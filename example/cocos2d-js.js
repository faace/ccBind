(function outer(modules, cache, entry) {
  function newRequire(name, jumped) {
    var module = cache[name];
    if (!module) {
      var moduleData = modules[name];
      if (!moduleData) return;
      var exports = {};
      module = cache[name] = {
        exports: exports
      };
      moduleData[0]((function(x) {
        return newRequire(moduleData[1][x] || x);
      }), module, exports);
    }
    return module.exports;
  }
  for (var i = 0; i < entry.length; i++) newRequire(entry[i]);
  return newRequire;
})({
  1: [ (function(require, module, exports) {
    module.exports = {
      1001: "cocos2d: removeAction: Target not found",
      1002: "cc.ActionManager.removeActionByTag(): an invalid tag",
      1003: "cc.ActionManager.removeActionByTag(): target must be non-null",
      1004: "cc.ActionManager.getActionByTag(): an invalid tag",
      1005: "cocos2d : getActionByTag(tag = %s): Action not found",
      1006: "[Action step]. override me",
      1007: "[Action update]. override me",
      1008: "cocos2d: FiniteTimeAction#reverse: Implement me",
      1009: "cc.EaseElastic.reverse(): it should be overridden in subclass.",
      1010: "cc.IntervalAction: reverse not implemented.",
      1011: "cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.",
      1012: "cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.",
      1013: "The speed parameter error",
      1014: "The repeat parameter error",
      1015: "parameters should not be ending with null in Javascript",
      1016: "cc.RotateTo.reverse(): it should be overridden in subclass.",
      1019: "Failed to construct, Sequence construction needs two or more actions.",
      1020: "Failed to construct, Spawn construction needs two or more actions.",
      1021: "cc.Speed.initWithAction(): action must be non nil",
      1022: "cc.Follow.initWithAction(): followedNode must be non nil",
      1023: "cc.ActionEase.initWithAction(): action must be non nil",
      1024: "Invalid configuration. It must at least have one control point",
      1025: "cc.Sequence.initWithTwoActions(): arguments must all be non nil",
      1026: "cc.RepeatForever.initWithAction(): action must be non null",
      1027: "cc.Spawn.initWithTwoActions(): arguments must all be non null",
      1028: "cc.ReverseTime.initWithAction(): action must be non null",
      1029: "cc.ReverseTime.initWithAction(): the action was already passed in.",
      1030: "cc.Animate.initWithAnimation(): animation must be non-NULL",
      1031: "Illegal parameter get passed in cc.tween: %s.",
      1100: "Expected 'data' dict, but not found. Config file: %s",
      1101: "Please load the resource first : %s",
      1200: "cocos2d: Director: Error in gettimeofday",
      1201: "cocos2d: Director: unrecognized projection",
      1203: "cocos2d: Director: Error in gettimeofday",
      1204: "running scene should not null",
      1205: "the scene should not null",
      1206: "loadScene: The scene index to load (%s) is out of range.",
      1207: "loadScene: Unknown name type to load: '%s'",
      1208: "loadScene: Failed to load scene '%s' because '%s' is already being loaded.",
      1209: "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
      1210: "Failed to preload '%s', %s",
      1211: "loadScene: The scene index to load (%s) is out of range.",
      1212: "loadScene: Unknown name type to load: '%s'",
      1213: "loadScene: Failed to load scene '%s' because '%s' is already loading",
      1214: "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
      1215: "Failed to preload '%s', %s",
      1216: "Director.runSceneImmediate: scene is not valid",
      1300: "element type is wrong!",
      1400: "'%s' is deprecated, please use '%s' instead.",
      1401: "The first argument should be the destination object",
      1402: "The 'visible' property of %s is deprecated, use 'enabled' instead please.",
      1403: "Sorry, cc.audioEngine.willPlayMusic is removed.",
      1404: "cc.spriteFrameCache is removed, please use cc.loader to load and cache sprite frames of atlas format.",
      1405: "The '%s' will be removed in v2.0, please use '%s' instead.",
      1406: "'%s.%s' is removed",
      1407: "cc.pool is being removed from v2.0, you are getting cc.js.Pool instead.",
      1408: "'%s' is not support in the '%s', please use '%s' instead.",
      1502: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
      1503: "cc.Scheduler.pauseTarget():target should be non-null",
      1504: "cc.Scheduler.resumeTarget():target should be non-null",
      1505: "cc.Scheduler.isTargetPaused():target should be non-null",
      1506: "warning: you CANNOT change update priority in scheduled function",
      1507: 'CCScheduler#scheduleSelector. Selector already scheduled. Updating interval from: %s to %s"',
      1508: "Argument callback must not be empty",
      1509: "Argument target must be non-nullptr",
      1510: "cc.Scheduler: Illegal target which doesn't have uuid or instanceId.",
      1511: "cc.Scheduler: pause state of the scheduled task doesn't match the element pause state in Scheduler, the given paused state will be ignored.",
      1512: "cc.Scheduler: updateFunc parameter is deprecated in scheduleUpdate function, and will be removed in v2.0",
      1513: "cc.Scheduler: scheduler stopped using `__instanceId` as id since v2.0, you should do scheduler.enableForTarget(target) before all scheduler API usage on target",
      1600: "getZOrder is deprecated. Please use getLocalZOrder instead.",
      1601: "setZOrder is deprecated. Please use setLocalZOrder instead.",
      1602: "RotationX != RotationY. Don't know which one to return",
      1603: "ScaleX != ScaleY. Don't know which one to return",
      1605: "child already added. It can't be added again",
      1606: "child must be non-null",
      1607: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
      1608: "boundingBox is deprecated. Use getBoundingBox instead",
      1609: "argument tag is an invalid tag",
      1610: "cocos2d: removeChildByTag(tag = %s): child not found!",
      1612: "cc.Node.stopActionBy(): argument tag an invalid tag",
      1613: "cc.Node.getActionByTag(): argument tag is an invalid tag",
      1614: "resumeSchedulerAndActions is deprecated, please use resume instead.",
      1615: "pauseSchedulerAndActions is deprecated, please use pause instead.",
      1617: "child must be non-null",
      1618: "cc.Node.runAction(): action must be non-null",
      1619: "callback function must be non-null",
      1620: "interval must be positive",
      1623: "Set '%s' to normal node (not persist root node).",
      1624: "Replacing with the same sgNode",
      1625: "The replacement sgNode should not contain any child.",
      1626: "Should not set alpha via 'color', set 'opacity' please.",
      1627: "Not support for asynchronous creating node in SG",
      1632: "Node name can not include '/'.",
      1633: "Internal error, should not remove unknown node from parent.",
      1634: "addChild: The child to add must be instance of cc.Node, not %s.",
      1635: "reorderChild: this child is not in children list.",
      1636: "Node's zIndex value can't be greater than cc.macro.MAX_ZINDEX, setting to the maximum value",
      1637: "Node's zIndex value can't be smaller than cc.macro.MIN_ZINDEX, setting to the minimum value",
      1638: "Private node's zIndex can't be set, it will keep cc.macro.MIN_ZINDEX as its value",
      1800: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
      1801: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
      1802: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
      1803: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
      1900: "Invalid parameter.",
      2000: "Don't call this method if the event is for touch.",
      2200: "Resolution not valid",
      2201: "should set resolutionPolicy",
      2300: "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
      2400: "WebGL error %s",
      2602: "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
      2603: "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
      2604: "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
      2606: "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
      2607: "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null",
      2608: "%s is null, please check.",
      2609: "cc.Sprite.initWithFile(): filename should be non-null",
      2610: "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
      2614: "cc.Sprite.addChild(): child should be non-null",
      2616: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
      2617: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
      2618: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
      2619: "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
      2623: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
      2625: "too many tiles, only 16384 tiles will be show",
      2626: "Unrecognized fill type in bar fill",
      2627: "Can not generate quad",
      2628: "%s does not exist",
      2710: "Sprite.initWithTexture(): Argument must be non-nil",
      2712: "Invalid spriteFrameName",
      3002: "textureForKey is deprecated. Please use getTextureForKey instead.",
      3005: "cocos2d: '%s' id=%s %s x %s",
      3006: "cocos2d: '%s' id= HTMLCanvasElement %s x %s",
      3007: "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
      3103: "cc.Texture.addImage(): path should be non-null",
      3112: "cc.Texture.addImage(): path should be non-null",
      3113: "NSInternalInconsistencyException",
      3116: "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures",
      3117: "Mimpap texture only works in POT textures",
      3118: "contentSize parameter is deprecated and ignored for cc.Texture2D initWithData function.",
      3119: "Lazy init texture with image element failed due to image loading failure: %s",
      3120: "Loading texture from '%s' with unsupported type: '%s'. Add '%s' into 'cc.macro.SUPPORT_TEXTURE_FORMATS' please.",
      3300: "Rect width exceeds maximum margin: %s",
      3400: "Rect height exceeds maximum margin: %s",
      3500: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
      3501: "Invalid listener type!",
      3502: "Can't set fixed priority with scene graph based listener.",
      3503: "Invalid parameters.",
      3504: "listener must be a cc.EventListener object when adding a fixed priority listener",
      3505: "The listener has been registered, please don't register it again.",
      3506: "Unsupported listener target.",
      3507: "Invalid scene graph priority!",
      3508: "If program goes here, there should be event in dispatch.",
      3509: "_inDispatch should be 1 here.",
      3510: "%s's scene graph node not contains in the parent's children",
      3511: "event is undefined",
      3600: "cc.Class will automatically call super constructor of %s, you should not call it manually.",
      3601: "The editor property 'playOnFocus' should be used with 'executeInEditMode' in class '%s'",
      3602: "Unknown editor property '%s' in class '%s'.",
      3603: "Use 'cc.Float' or 'cc.Integer' instead of 'cc.Number' please.",
      3604: "Can only indicate one type attribute for %s.",
      3605: "The default value of %s is not instance of %s.",
      3606: "No needs to indicate the '%s' attribute for %s, which its default value is type of %s.",
      3607: "The default value of %s must be an empty string.",
      3608: "The type of %s must be cc.String, not String.",
      3609: "The type of %s must be cc.Boolean, not Boolean.",
      3610: "The type of %s must be cc.Float or cc.Integer, not Number.",
      3611: "Can not indicate the '%s' attribute for %s, which its default value is type of %s.",
      3612: "%s Just set the default value to 'new %s()' and it will be handled properly.",
      3613: "'No need to use 'serializable: false' or 'editorOnly: true' for the getter of '%s.%s', every getter is actually non-serialized.",
      3614: "Should not define constructor for cc.Component %s.",
      3615: "Each script can have at most one Component.",
      3616: "Should not specify class name %s for Component which defines in project.",
      3617: "Can not instantiate CCClass '%s' with arguments.",
      3618: "ctor of '%s' can not be another CCClass",
      3619: "ctor of '%s' must be function type",
      3620: "this._super declared in '%s.%s' but no super method defined",
      3621: "Unknown type of %s.%s, maybe you want is '%s'.",
      3622: "Unknown type of %s.%s, property should be defined in 'properties' or 'ctor'",
      3623: "Can not use 'editor' attribute, '%s' not inherits from Components.",
      3624: "'%s' overrided '%s' but '%s' is defined as 'false' so the super method will not be called. You can set '%s' to null to disable this warning.",
      3625: "[isChildClassOf] superclass should be function type, not",
      3626: "Can't remove '%s' because '%s' depends on it.",
      3627: "Should not add renderer component (%s) to a Canvas node.",
      3628: "Should not add %s to a node which size is already used by its other component.",
      3629: "attribute must be type object",
      3633: "Properties function of '%s' should return an object!",
      3634: "Disallow to use '.' in property name",
      3635: "Default array must be empty, set default value of %s.%s to [], and initialize in 'onLoad' or 'ctor' please. (just like 'this.%s = [...];')",
      3636: "Do not set default value to non-empty object, unless the object defines its own 'clone' function. Set default value of %s.%s to null or {}, and initialize in 'onLoad' or 'ctor' please. (just like 'this.%s = {foo: bar};')",
      3637: "Can not declare %s.%s, it is already defined in the prototype of %s",
      3638: "'%s': the getter of '%s' is already defined!",
      3639: "Can not apply the specified attribute to the getter of '%s.%s', attribute index: %s",
      3640: "'%s': the setter of '%s' is already defined!",
      3641: "Can not construct %s because it contains object property.",
      3642: "Cannot define %s.%s because static member name can not be '%s'.",
      3643: "Can not define a member called 'constructor' in the class '%s', please use 'ctor' instead.",
      3644: "Please define 'type' parameter of %s.%s as the actual constructor.",
      3645: "Please define 'type' parameter of %s.%s as the constructor of %s.",
      3646: "Unknown 'type' parameter of %s.%s\uff1a%s",
      3647: "The length of range array must be equal or greater than 2",
      3648: "Can not declare %s.%s method, it is already defined in the properties of %s.",
      3649: "CCClass %s have conflict between its ctor and __ctor__.",
      3651: 'Can not call `_super` or `prototype.ctor` in ES6 Classes "%s", use `super` instead please.',
      3652: 'Failed to construct a dummy instance of the "%s" class using `new` behind the scenes. This is for getting default values declared in TypeScript. Please ensure the class will be able to construct during script\'s initialization. %s.',
      3653: 'Please do not specifiy "default" attribute in decorator of "%s" property in "%s" class.  \nDefault value must be initialized at their declaration:\n \n// Before:\n@property({\n  type: cc.Integer\n  default: 0  // <--\n})\nvalue;\n// After:\n@property({\n  type: cc.Integer\n})\nvalue = 0;    // <--',
      3654: 'Please specifiy a default value for "%s" property at its declaration:\n \n// Before:\n@property(...)\nvalue; \n// After:\n@property(...)\nvalue = 0',
      3655: 'Can not specifiy "get" or "set"  attribute in decorator for "%s" property in "%s" class.  \nPlease use:\n \n@property(...)\nget %s () {\n    ...\n}\n@property\nset %s (value) {\n    ...\n}',
      3656: "The default value of %s.%s must be an empty string. (changed since 1.8)",
      3657: "The value assigned to %s should be Texture2D object, not url string. Since 1.8,  \nyou can declare a texture object directly in properties by using:  \n \n{\n    default: null,\n    type: cc.Texture2D  // use 'type:' instead of 'url:'\n}",
      3658: "browser does not support getters",
      3700: "internal error: _prefab is undefined",
      3701: "Failed to load prefab asset for node '%s'",
      3800: "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
      3801: "The node can not be made persist because it's not under root node.",
      3802: "The node can not be made persist because it's not in current scene.",
      3803: "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
      3804: "getComponent: Type must be non-nil",
      3805: "Can't add component '%s' because %s already contains the same component.",
      3806: "Can't add component '%s' to %s because it conflicts with the existing '%s' derived component.",
      3807: "addComponent: Failed to get class '%s'",
      3808: "addComponent: Should not add component ('%s') when the scripts are still loading.",
      3809: "addComponent: The component to add must be a constructor",
      3810: "addComponent: The component to add must be child class of cc.Component",
      3811: "_addComponentAt: The component to add must be a constructor",
      3812: "_addComponentAt: Index out of range",
      3813: "removeComponent: Component must be non-nil",
      3814: "Argument must be non-nil",
      3815: "Component not owned by this entity",
      3816: "Node '%s' is already activating",
      3817: "Sorry, the component of '%s' which with an index of %s is corrupted! It has been removed.",
      3818: "Failed to read or parse project.json",
      3819: "Warning: target element is not a DIV or CANVAS",
      3820: "The renderer doesn't support the renderMode %s",
      3821: "Cannot change hierarchy while activating or deactivating the parent.",
      3900: "Invalid clip to add",
      3901: "Invalid clip to remove",
      3902: "clip is defaultClip, set force to true to force remove clip and animation state",
      3903: "animation state is playing, set force to true to force stop and remove clip and animation state",
      3904: "motion path of target [%s] in prop [%s] frame [%s] is not valid",
      3905: "sprite frames must be an Array.",
      3906: "Can't find easing type [%s]",
      3907: "animator not added or already removed",
      3908: "animation not added or already removed",
      3912: "already-playing",
      4000: "Sorry, the cc.Font has been modified from Raw Asset to Asset. Please load the font asset before using.",
      4003: "Label font size can't be shirnked less than 0!",
      4004: "force notify all fonts loaded!",
      4011: "Property spriteFrame of Font '%s' is invalid. Using system font instead.",
      4012: "The texture of Font '%s' must be already loaded on JSB. Using system font instead.",
      4013: "Sorry, lineHeight of system font not supported on JSB.",
      4100: "Property padding is deprecated, please use paddingLeft, paddingRight, paddingTop and paddingBottom instead",
      4200: "MaskType: IMAGE_STENCIL only support WebGL mode.",
      4201: "The alphaThreshold invalid in Canvas Mode.",
      4202: "The inverted invalid in Canvas Mode.",
      4300: "can not found the %s page.",
      4400: "Invalid RichText img tag! The sprite frame name can't be found in the ImageAtlas!",
      4600: "Script attached to '%s' is missing or invalid.",
      4700: "The dom control is not created!",
      4800: "unknown asset type",
      4901: "loadRes: should not specify the extname in %s %s",
      4902: "No need to release non-cached asset.",
      4903: "Can not get class '%s'",
      4914: "Resources url '%s' does not exist.",
      4915: "Pack indices and data do not match in size",
      4916: "Failed to download package for %s",
      4920: "Sorry, you shouldn't use id as item identity any more, please use url or uuid instead, the current id is being set as url: (%s)",
      4921: "Invalid pipe or invalid index provided!",
      4922: "The pipe to be inserted is already in the pipeline!",
      4923: "Uuid Loader: Parse asset [ %s ] failed : %s",
      4924: "JSON Loader: Input item doesn't contain string content",
      4925: "Uuid Loader: Deserialize asset [ %s ] failed : %s",
      4926: "Audio Downloader: no web audio context.",
      4927: "Audio Downloader: audio not supported on this browser!",
      4928: "Load %s failed!",
      4929: "Load Webp ( %s ) failed",
      4930: "Load image ( %s ) failed",
      4931: "Download Uuid: can not find type of raw asset[ %s ]: %s",
      4932: 'Since v1.10, for any atlas ("%s") in the "resources" directory, it is not possible to find the contained SpriteFrames via `loadRes`, `getRes` or `releaseRes`. Load the SpriteAtlas first and then use `spriteAtlas.getSpriteFrame(name)` instead please.',
      4933: "Download Font [ %s ] failed, using Arial or system default font instead",
      5000: "object already destroyed",
      5001: "object not yet destroyed",
      5100: "Not a plist file!",
      5200: "Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option",
      5201: "browser don't support web audio",
      5202: "This feature supports WebGL render mode only.",
      5300: "Type of target to deserialize not matched with data: target is %s, data is %s",
      5301: "Can not find script '%s'",
      5302: "Can not find class '%s'",
      5400: "'%s' is deprecated, use '%s' instead please.",
      5401: "'%s' is deprecated, use '%s' instead please.",
      5402: "cc.js.addon called on non-object:",
      5403: "cc.js.mixin: arguments must be type object:",
      5404: "The base class to extend from must be non-nil",
      5405: "The class to extend must be non-nil",
      5406: "Class should be extended before assigning any prototype members.",
      5500: "'notify' can't work with 'get/set' !",
      5501: "'notify' must work with 'default' !",
      5502: "Invalid url of %s.%s",
      5503: "The 'url' attribute of '%s.%s' is undefined when loading script.",
      5504: "The 'url' type of '%s.%s' must be child class of cc.RawAsset.",
      5505: "The 'url' type of '%s.%s' must not be child class of cc.Asset, otherwise you should use 'type: %s' instead.",
      5506: "Can not specify 'type' attribute for '%s.%s', because its 'url' is already defined.",
      5507: "The 'default' attribute of '%s.%s' must be an array",
      5508: "Invalid type of %s.%s",
      5510: "The 'type' attribute of '%s.%s' can not be 'Number', use 'Float' or 'Integer' instead please.",
      5511: "The 'type' attribute of '%s.%s' is undefined when loading script",
      5512: "Can not serialize '%s.%s' because the specified type is anonymous, please provide a class name or set the 'serializable' attribute of '%s.%s' to 'false'.",
      5513: "The 'default' value of '%s.%s' should not be used with a 'get' function.",
      5514: "The 'default' value of '%s.%s' should not be used with a 'set' function.",
      5515: "The 'default' value of '%s.%s' can not be an constructor. Set default to null please.",
      5516: "Property '%s.%s' must define at least one of 'default', 'get' or 'set'.",
      5517: "'%s.%s' hides inherited property '%s.%s'. To make the current property override that implementation, add the `override: true` attribute please.",
      5600: "Argument must be non-nil",
      5601: "Can not get current scene.",
      5602: "Scene is destroyed",
      5603: "reference node is destroyed",
      5700: "no %s or %s on %s",
      5800: "%s.lerp not yet implemented.",
      5801: "%s.clone not yet implemented.",
      5802: "%s.equals not yet implemented.",
      5900: "MotionStreak only support WebGL mode.",
      5901: "cc.MotionStreak.getOpacity has not been supported.",
      5902: "cc.MotionStreak.setOpacity has not been supported.",
      6000: "Custom should not be false if file is not specified.",
      6001: "The new %s must not be NaN",
      6017: "Incomplete or corrupt PNG file",
      6018: "Invalid filter algorithm: %s",
      6019: "Invalid byte order value.",
      6020: "You forgot your towel!",
      6021: "Unknown Field Tag: %s",
      6022: "Too many bits requested",
      6023: "No bits requested",
      6024: "Cannot recover from missing StripByteCounts",
      6025: "Cannot handle sub-byte bits per sample",
      6026: "Cannot handle sub-byte bits per pixel",
      6027: "Palette image missing color map",
      6028: "Unknown Photometric Interpretation: %s",
      6029: "Unkown error",
      6030: "cc.ParticleSystem: error decoding or ungzipping textureImageData",
      6031: "cc.ParticleSystem: unknown image format with Data",
      6032: "cc.ParticleSystem.initWithDictionary() : error loading the texture",
      6200: "Canvas doesn't support mesh slot!",
      6300: "only cc.DrawNode is accepted as stencil",
      6301: "Stencil buffer is not enabled.",
      6302: "Nesting more than %d stencils is not supported. Everything will be drawn without stencil for this node and its children.",
      6400: "asset.url is not usable in core process",
      6401: "asset.urls is not usable in core process",
      6402: "AssetLibrary has already been initialized!",
      6500: "Widget target must be one of the parent nodes of it",
      6600: "collider not added or already removed",
      6601: "Can't find testFunc for (%s, $s).",
      6700: "Can't init canvas '%s' because it conflicts with the existing '%s', the scene should only have one active canvas at the same time",
      6701: "Should not add Canvas to a node which already contains a renderer component (%s).",
      6702: "Should not add Canvas to a node which size is already used by its other component.",
      6703: "Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext",
      6704: "Polygon's point must greater than 2",
      6705: "Argument must be non-nil",
      6800: "Callback of event must be non-nil",
      6801: "The message must be provided",
      6900: "The thing you want to instantiate must be an object",
      6901: "The thing you want to instantiate is nil",
      6902: "The thing you want to instantiate is destroyed",
      6903: "The instantiate method for given asset do not implemented",
      6904: "Can not instantiate array",
      6905: "Can not instantiate DOM element",
      7000: "Failed to init asset's raw path.",
      7001: "Should not load '%s' from script dynamically, unless it is placed in the 'resources' folder.",
      7002: "Sorry can not load '%s' because it is not placed in the 'resources' folder.",
      7003: "Failed to init builtin asset's raw path.",
      7100: "%s already defined in Enum.",
      7101: "Sorry, 'cc.Enum' not available on this platform, please report this error here: https://github.com/cocos-creator/engine/issues/new",
      7200: "Method 'initWithTMXFile' is no effect now, please set property 'tmxAsset' instead.",
      7201: "Method 'initWithXML' is no effect now, please set property 'tmxAsset' instead.",
      7202: "Add component TiledLayer into node failed.",
      7203: "Property 'mapLoaded' is unused now. Please write the logic to the callback 'start'.",
      7210: "TMX Hexa zOrder not supported",
      7211: "TMX invalid value",
      7214: "propertiesForGID is deprecated. Please use getPropertiesForGID instead.",
      7215: "cocos2d: Warning: TMX Layer %s has no tiles",
      7216: "cocos2d: TMXFormat: Unsupported TMX version: %s",
      7217: "cocos2d: TMXFomat: Unsupported orientation: %s",
      7218: "cc.TMXMapInfo.parseXMLFile(): unsupported compression method",
      7219: "cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported",
      7221: "cc.TMXMapInfo.parseXMLFile(): Texture '%s' not found.",
      7222: "Parse %s failed.",
      7236: "cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released",
      7237: "cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released",
      7238: "cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released",
      7239: "cc.TMXLayer.setTileGID(): invalid gid: %s",
      7240: "cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released",
      7241: "cc.TiledMap.initWithXML(): Map not found. Please check the filename.",
      7401: "Failed to set _defaultArmatureIndex for '%s' because the index is out of range.",
      7402: "Failed to set _animationIndex for '%s' because the index is out of range.",
      7501: "Failed to set _defaultSkinIndex for '%s' because the index is out of range.",
      7502: "Failed to set _animationIndex for '%s' because its skeletonData is invalid.",
      7503: "Failed to set _animationIndex for '%s' because the index is out of range.",
      7504: "Can not render dynamic created SkeletonData",
      7505: "Invalid type of atlasFile, atlas should be registered as raw asset.",
      7506: "Failed to load spine atlas '$s'",
      7507: "Please re-import '%s' because its textures is not initialized! (This workflow will be improved in the future.)",
      7508: "The atlas asset of '%s' is not exists!",
      7509: "Spine: Animation not found: %s",
      7510: "Spine: Animation not found: %s",
      7600: "The context of RenderTexture is invalid.",
      7601: "cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;",
      7602: "Could not attach texture to the framebuffer",
      7603: "clearDepth isn't supported on Cocos2d-Html5",
      7604: "saveToFile isn't supported on Cocos2d-Html5",
      7605: "newCCImage isn't supported on Cocos2d-Html5",
      7700: "On the web is always keep the aspect ratio",
      7701: "Can't know status",
      7702: "Video player's duration is not ready to get now!",
      7800: "Web does not support loading",
      7801: "Web does not support query history",
      7802: "Web does not support query history",
      7803: "The current browser does not support the GoBack",
      7804: "The current browser does not support the GoForward",
      7805: "Web does not support zoom",
      7900: "cc.math.Matrix3.assign(): current matrix equals matIn",
      7901: "cc.math.mat4Assign(): pOut equals pIn",
      7902: "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
      7903: "cc.math.Matrix4 equal: pMat1 and pMat2 are same object.",
      7904: "cc.math.Matrix4.extractPlane: Invalid plane index",
      7905: "cc.math.mat4Assign(): pOut equals pIn",
      7906: "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
      7907: "cc.math.Matrix4 equals: pMat1 and pMat2 are same object.",
      7908: "Invalid matrix mode specified",
      7909: "current quaternion is an invalid value",
      8000: "Can't handle this field type or size",
      8001: "No bytes requested",
      8002: "Too many bytes requested",
      8003: "Missing StripByteCounts!",
      8103: "cc.GLProgram.link(): Cannot link invalid program",
      8104: "cocos2d: ERROR: Failed to link program: %s",
      8105: "cocos2d: cc.shaderCache._loadDefaultShader, error shader type",
      8106: "Please load the resource firset : %s",
      8107: "cc.GLProgram.getUniformLocationForName(): uniform name should be non-null",
      8108: "cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized",
      8109: "modelView matrix is undefined.",
      8200: "Please set node's active instead of rigidbody's enabled.",
      8300: "Should only one camera exists, please check your project.",
      8301: "Camera does not support Canvas Mode.",
      8400: "Wrong type arguments, 'filePath' must be a String.",
      8401: "Since 1.10, `%s` accept %s instance directly, not a URL string. Please directly reference the %s object in your script, or load %s by loader first. Don't use %s's URL anymore.",
      9000: "Stencil manager does not support level bigger than %d in this device.",
      9001: "Stencil manager is already empty, cannot pop any mask",
      "0100": "%s not yet implemented."
    };
  }), {} ],
  2: [ (function(require, module, exports) {
    "use strict";
    var _vmath = require("../vmath");
    var Node = require("../CCNode");
    var EventType = Node.EventType;
    var DirtyFlag = Node._LocalDirtyFlag;
    var RenderFlow = require("../renderer/render-flow");
    var ONE_DEGREE = Math.PI / 180;
    var POSITION_ON = 1;
    var SCALE_ON = 2;
    var ERR_INVALID_NUMBER = false;
    function _updateLocalMatrix3d() {
      if (this._localMatDirty) {
        var t = this._matrix;
        _vmath.mat4.fromRTS(t, this._quat, this._position, this._scale);
        if (this._skewX || this._skewY) {
          var a = t.m00, b = t.m01, c = t.m04, d = t.m05;
          var skx = Math.tan(this._skewX * ONE_DEGREE);
          var sky = Math.tan(this._skewY * ONE_DEGREE);
          Infinity === skx && (skx = 99999999);
          Infinity === sky && (sky = 99999999);
          t.m00 = a + c * sky;
          t.m01 = b + d * sky;
          t.m04 = c + a * skx;
          t.m05 = d + b * skx;
        }
        this._localMatDirty = 0;
        this._worldMatDirty = true;
      }
    }
    function _calculWorldMatrix3d() {
      this._localMatDirty && this._updateLocalMatrix();
      if (this._parent) {
        var parentMat = this._parent._worldMatrix;
        _vmath.mat4.mul(this._worldMatrix, parentMat, this._matrix);
      } else _vmath.mat4.copy(this._worldMatrix, this._matrix);
      this._worldMatDirty = false;
    }
    function setPosition(newPosOrX, y, z) {
      var x = void 0;
      if (void 0 === y) {
        x = newPosOrX.x;
        y = newPosOrX.y;
        z = newPosOrX.z || 0;
      } else {
        x = newPosOrX;
        z = z || 0;
      }
      var pos = this._position;
      if (pos.x === x && pos.y === y && pos.z === z) return;
      var oldPosition;
      false;
      pos.x = x;
      pos.y = y;
      pos.z = z;
      this.setLocalDirty(DirtyFlag.POSITION);
      this._renderFlag |= RenderFlow.FLAG_WORLD_TRANSFORM;
      if (this._eventMask & POSITION_ON) {
        false;
        this.emit(EventType.POSITION_CHANGED);
      }
    }
    function setScale(x, y, z) {
      if (x && "number" !== typeof x) {
        y = x.y;
        z = x.z || 1;
        x = x.x;
      } else if (void 0 !== x && void 0 === y) {
        y = x;
        z = x;
      } else void 0 === z && (z = 1);
      if (this._scale.x !== x || this._scale.y !== y || this._scale.z !== z) {
        this._scale.x = x;
        this._scale.y = y;
        this._scale.z = z;
        this.setLocalDirty(DirtyFlag.SCALE);
        this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
        this._eventMask & SCALE_ON && this.emit(EventType.SCALE_CHANGED);
      }
    }
    function _update3DFunction() {
      if (this._is3DNode) {
        this._updateLocalMatrix = _updateLocalMatrix3d;
        this._calculWorldMatrix = _calculWorldMatrix3d;
        this._mulMat = _vmath.mat4.mul;
      } else {
        this._updateLocalMatrix = _updateLocalMatrix2d;
        this._calculWorldMatrix = _calculWorldMatrix2d;
        this._mulMat = _mulMat2d;
      }
      this._renderComponent && this._renderComponent._on3DNodeChanged && this._renderComponent._on3DNodeChanged();
      this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
      this._localMatDirty = DirtyFlag.ALL;
    }
    function _upgrade_1x_to_2x() {
      this._is3DNode && this._update3DFunction();
      _upgrade_1x_to_2x_2d.call(this);
    }
    var proto = cc.Node.prototype;
    var _updateLocalMatrix2d = proto._updateLocalMatrix;
    var _calculWorldMatrix2d = proto._calculWorldMatrix;
    var _upgrade_1x_to_2x_2d = proto._upgrade_1x_to_2x;
    var _mulMat2d = proto._mulMat;
    proto.setPosition = setPosition;
    proto.setScale = setScale;
    proto._upgrade_1x_to_2x = _upgrade_1x_to_2x;
    proto._update3DFunction = _update3DFunction;
    cc.js.getset(proto, "position", proto.getPosition, setPosition, false, true);
    cc.js.getset(proto, "is3DNode", (function() {
      return this._is3DNode;
    }), (function(v) {
      if (this._is3DNode === v) return;
      this._is3DNode = v;
      this._update3DFunction();
    }));
    cc.js.getset(proto, "scaleZ", (function() {
      return this._scale.z;
    }), (function(v) {
      if (this._scale.z !== v) {
        this._scale.z = v;
        this.setLocalDirty(DirtyFlag.SCALE);
        this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
        this._eventMask & SCALE_ON && this.emit(EventType.SCALE_CHANGED);
      }
    }));
    cc.js.getset(proto, "z", (function() {
      return this._position.z;
    }), (function(value) {
      var localPosition = this._position;
      if (value !== localPosition.z) {
        true;
        localPosition.z = value;
        this.setLocalDirty(DirtyFlag.POSITION);
        this._renderFlag |= RenderFlow.FLAG_WORLD_TRANSFORM;
        this._eventMask & POSITION_ON && this.emit(EventType.POSITION_CHANGED);
      }
    }));
    cc.js.getset(proto, "eulerAngles", (function() {
      false;
      return this._quat.toEuler(this._eulerAngles);
    }), (function(v) {
      false;
      this._quat.fromEuler(v);
      this.setLocalDirty(DirtyFlag.ROTATION);
      this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
    }));
    cc.js.getset(proto, "quat", (function() {
      return this._quat;
    }), proto.setRotation);
  }), {
    "../CCNode": 6,
    "../renderer/render-flow": 148,
    "../vmath": 207
  } ],
  3: [ (function(require, module, exports) {
    "use strict";
    var debugInfos = require("../../DebugInfos") || {};
    var ERROR_MAP_URL = "https://github.com/cocos-creator/engine/blob/master/EngineErrorMap.md";
    var logList = void 0;
    cc.log = cc.warn = cc.error = cc.assert = console.log.bind ? console.log.bind(console) : console.log;
    var resetDebugSetting = function resetDebugSetting(mode) {
      cc.log = cc.warn = cc.error = cc.assert = function() {};
      if (mode === DebugMode.NONE) return;
      if (mode > DebugMode.ERROR) {
        var logToWebPage = function logToWebPage(msg) {
          if (!cc.game.canvas) return;
          if (!logList) {
            var logDiv = document.createElement("Div");
            logDiv.setAttribute("id", "logInfoDiv");
            logDiv.setAttribute("width", "200");
            logDiv.setAttribute("height", cc.game.canvas.height);
            var logDivStyle = logDiv.style;
            logDivStyle.zIndex = "99999";
            logDivStyle.position = "absolute";
            logDivStyle.top = logDivStyle.left = "0";
            logList = document.createElement("textarea");
            logList.setAttribute("rows", "20");
            logList.setAttribute("cols", "30");
            logList.setAttribute("disabled", "true");
            var logListStyle = logList.style;
            logListStyle.backgroundColor = "transparent";
            logListStyle.borderBottom = "1px solid #cccccc";
            logListStyle.borderTopWidth = logListStyle.borderLeftWidth = logListStyle.borderRightWidth = "0px";
            logListStyle.borderTopStyle = logListStyle.borderLeftStyle = logListStyle.borderRightStyle = "none";
            logListStyle.padding = "0px";
            logListStyle.margin = 0;
            logDiv.appendChild(logList);
            cc.game.canvas.parentNode.appendChild(logDiv);
          }
          logList.value = logList.value + msg + "\r\n";
          logList.scrollTop = logList.scrollHeight;
        };
        cc.error = function() {
          logToWebPage("ERROR :  " + cc.js.formatStr.apply(null, arguments));
        };
        cc.assert = function(cond, msg) {
          if (!cond && msg) {
            msg = cc.js.formatStr.apply(null, cc.js.shiftArguments.apply(null, arguments));
            logToWebPage("ASSERT: " + msg);
          }
        };
        mode !== DebugMode.ERROR_FOR_WEB_PAGE && (cc.warn = function() {
          logToWebPage("WARN :  " + cc.js.formatStr.apply(null, arguments));
        });
        mode === DebugMode.INFO_FOR_WEB_PAGE && (cc.log = function() {
          logToWebPage(cc.js.formatStr.apply(null, arguments));
        });
      } else if (console && console.log.apply) {
        console.error || (console.error = console.log);
        console.warn || (console.warn = console.log);
        false;
        console.error.bind ? cc.error = console.error.bind(console) : cc.error = (false, 
        function() {
          return console.error.apply(console, arguments);
        });
        cc.assert = function(cond, msg) {
          if (!cond) {
            msg && (msg = cc.js.formatStr.apply(null, cc.js.shiftArguments.apply(null, arguments)));
            false;
            false;
            throw new Error(msg);
          }
        };
      }
      if (mode !== DebugMode.ERROR) {
        false;
        console.warn.bind ? cc.warn = console.warn.bind(console) : cc.warn = (false, function() {
          return console.warn.apply(console, arguments);
        });
      }
      false;
      if (mode === DebugMode.INFO) {
        false, false;
        console.log.bind ? cc.log = console.log.bind(console) : cc.log = function() {
          return console.log.apply(console, arguments);
        };
      }
    };
    cc._throw = function(error) {
      var stack = error.stack;
      stack ? cc.error((false, stack)) : cc.error(error);
    };
    function getTypedFormatter(type) {
      return function() {
        var id = arguments[0];
        var msg = debugInfos[id] || "unknown id";
        if (1 === arguments.length) return msg;
        if (2 === arguments.length) return cc.js.formatStr(msg, arguments[1]);
        var argsArray = cc.js.shiftArguments.apply(null, arguments);
        return cc.js.formatStr.apply(null, [ msg ].concat(argsArray));
      };
    }
    var logFormatter = getTypedFormatter("Log");
    cc.logID = function() {
      cc.log(logFormatter.apply(null, arguments));
    };
    var warnFormatter = getTypedFormatter("Warning");
    cc.warnID = function() {
      cc.warn(warnFormatter.apply(null, arguments));
    };
    var errorFormatter = getTypedFormatter("Error");
    cc.errorID = function() {
      cc.error(errorFormatter.apply(null, arguments));
    };
    var assertFormatter = getTypedFormatter("Assert");
    cc.assertID = function(cond) {
      if (cond) return;
      cc.assert(false, assertFormatter.apply(null, cc.js.shiftArguments.apply(null, arguments)));
    };
    var DebugMode = cc.Enum({
      NONE: 0,
      INFO: 1,
      WARN: 2,
      ERROR: 3,
      INFO_FOR_WEB_PAGE: 4,
      WARN_FOR_WEB_PAGE: 5,
      ERROR_FOR_WEB_PAGE: 6
    });
    module.exports = cc.debug = {
      DebugMode: DebugMode,
      _resetDebugSetting: resetDebugSetting,
      getError: getTypedFormatter("ERROR"),
      isDisplayStats: function isDisplayStats() {
        return !!cc.profiler && cc.profiler.isShowingStats();
      },
      setDisplayStats: function setDisplayStats(displayStats) {
        if (cc.profiler) {
          displayStats ? cc.profiler.showStats() : cc.profiler.hideStats();
          cc.game.config.showFPS = !!displayStats;
        }
      }
    };
  }), {
    "../../DebugInfos": 1
  } ],
  4: [ (function(require, module, exports) {
    "use strict";
    var EventTarget = require("./event/event-target");
    var AutoReleaseUtils = require("./load-pipeline/auto-release-utils");
    var ComponentScheduler = require("./component-scheduler");
    var NodeActivator = require("./node-activator");
    var Obj = require("./platform/CCObject");
    var game = require("./CCGame");
    var renderer = require("./renderer");
    var eventManager = require("./event-manager");
    var Scheduler = require("./CCScheduler");
    cc.Director = function() {
      EventTarget.call(this);
      this._paused = false;
      this._purgeDirectorInNextLoop = false;
      this._winSizeInPoints = null;
      this._loadingScene = "";
      this._scene = null;
      this._totalFrames = 0;
      this._lastUpdate = 0;
      this._deltaTime = 0;
      this._scheduler = null;
      this._compScheduler = null;
      this._nodeActivator = null;
      this._actionManager = null;
      var self = this;
      game.on(game.EVENT_SHOW, (function() {
        self._lastUpdate = performance.now();
      }));
      game.once(game.EVENT_ENGINE_INITED, this.init, this);
    };
    cc.Director.prototype = {
      constructor: cc.Director,
      init: function init() {
        this._totalFrames = 0;
        this._lastUpdate = performance.now();
        this._paused = false;
        this._purgeDirectorInNextLoop = false;
        this._winSizeInPoints = cc.size(0, 0);
        this._scheduler = new Scheduler();
        if (cc.ActionManager) {
          this._actionManager = new cc.ActionManager();
          this._scheduler.scheduleUpdate(this._actionManager, Scheduler.PRIORITY_SYSTEM, false);
        } else this._actionManager = null;
        this.sharedInit();
        return true;
      },
      sharedInit: function sharedInit() {
        this._compScheduler = new ComponentScheduler();
        this._nodeActivator = new NodeActivator();
        eventManager && eventManager.setEnabled(true);
        if (cc.AnimationManager) {
          this._animationManager = new cc.AnimationManager();
          this._scheduler.scheduleUpdate(this._animationManager, Scheduler.PRIORITY_SYSTEM, false);
        } else this._animationManager = null;
        if (cc.CollisionManager) {
          this._collisionManager = new cc.CollisionManager();
          this._scheduler.scheduleUpdate(this._collisionManager, Scheduler.PRIORITY_SYSTEM, false);
        } else this._collisionManager = null;
        if (cc.PhysicsManager) {
          this._physicsManager = new cc.PhysicsManager();
          this._scheduler.scheduleUpdate(this._physicsManager, Scheduler.PRIORITY_SYSTEM, false);
        } else this._physicsManager = null;
        cc._widgetManager && cc._widgetManager.init(this);
        cc.loader.init(this);
      },
      calculateDeltaTime: function calculateDeltaTime(now) {
        now || (now = performance.now());
        this._deltaTime = (now - this._lastUpdate) / 1e3;
        (true, this._deltaTime > 1) && (this._deltaTime = 1 / 60);
        this._lastUpdate = now;
      },
      convertToGL: function convertToGL(uiPoint) {
        var container = game.container;
        var view = cc.view;
        var box = container.getBoundingClientRect();
        var left = box.left + window.pageXOffset - container.clientLeft;
        var top = box.top + window.pageYOffset - container.clientTop;
        var x = view._devicePixelRatio * (uiPoint.x - left);
        var y = view._devicePixelRatio * (top + box.height - uiPoint.y);
        return view._isRotated ? cc.v2(view._viewportRect.width - y, x) : cc.v2(x, y);
      },
      convertToUI: function convertToUI(glPoint) {
        var container = game.container;
        var view = cc.view;
        var box = container.getBoundingClientRect();
        var left = box.left + window.pageXOffset - container.clientLeft;
        var top = box.top + window.pageYOffset - container.clientTop;
        var uiPoint = cc.v2(0, 0);
        if (view._isRotated) {
          uiPoint.x = left + glPoint.y / view._devicePixelRatio;
          uiPoint.y = top + box.height - (view._viewportRect.width - glPoint.x) / view._devicePixelRatio;
        } else {
          uiPoint.x = left + glPoint.x * view._devicePixelRatio;
          uiPoint.y = top + box.height - glPoint.y * view._devicePixelRatio;
        }
        return uiPoint;
      },
      end: function end() {
        this._purgeDirectorInNextLoop = true;
      },
      getWinSize: function getWinSize() {
        return cc.size(cc.winSize);
      },
      getWinSizeInPixels: function getWinSizeInPixels() {
        return cc.size(cc.winSize);
      },
      pause: function pause() {
        if (this._paused) return;
        this._paused = true;
      },
      purgeCachedData: function purgeCachedData() {
        cc.loader.releaseAll();
      },
      purgeDirector: function purgeDirector() {
        this._scheduler.unscheduleAll();
        this._compScheduler.unscheduleAll();
        this._nodeActivator.reset();
        eventManager && eventManager.setEnabled(false);
        true;
        cc.isValid(this._scene) && this._scene.destroy();
        this._scene = null;
        cc.renderer.clear();
        cc.AssetLibrary.resetBuiltins();
        cc.game.pause();
        cc.loader.releaseAll();
      },
      reset: function reset() {
        this.purgeDirector();
        eventManager && eventManager.setEnabled(true);
        this._actionManager && this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        this._animationManager && this._scheduler.scheduleUpdate(this._animationManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        this._collisionManager && this._scheduler.scheduleUpdate(this._collisionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        this._physicsManager && this._scheduler.scheduleUpdate(this._physicsManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        cc.game.resume();
      },
      runSceneImmediate: function runSceneImmediate(scene, onBeforeLoadScene, onLaunched) {
        cc.assertID(scene instanceof cc.Scene, 1216);
        (true, true) && console.time("InitScene");
        scene._load();
        (true, true) && console.timeEnd("InitScene");
        (true, true) && console.time("AttachPersist");
        var persistNodeList = Object.keys(game._persistRootNodes).map((function(x) {
          return game._persistRootNodes[x];
        }));
        for (var i = 0; i < persistNodeList.length; i++) {
          var node = persistNodeList[i];
          var existNode = scene.getChildByUuid(node.uuid);
          if (existNode) {
            var index = existNode.getSiblingIndex();
            existNode._destroyImmediate();
            scene.insertChild(node, index);
          } else node.parent = scene;
        }
        (true, true) && console.timeEnd("AttachPersist");
        var oldScene = this._scene;
        true;
        (true, true) && console.time("AutoRelease");
        var autoReleaseAssets = oldScene && oldScene.autoReleaseAssets && oldScene.dependAssets;
        AutoReleaseUtils.autoRelease(autoReleaseAssets, scene.dependAssets, persistNodeList);
        (true, true) && console.timeEnd("AutoRelease");
        (true, true) && console.time("Destroy");
        cc.isValid(oldScene) && oldScene.destroy();
        this._scene = null;
        Obj._deferredDestroy();
        (true, true) && console.timeEnd("Destroy");
        onBeforeLoadScene && onBeforeLoadScene();
        this.emit(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, scene);
        this._scene = scene;
        (true, true) && console.time("Activate");
        scene._activate();
        (true, true) && console.timeEnd("Activate");
        cc.game.resume();
        onLaunched && onLaunched(null, scene);
        this.emit(cc.Director.EVENT_AFTER_SCENE_LAUNCH, scene);
      },
      runScene: function runScene(scene, onBeforeLoadScene, onLaunched) {
        cc.assertID(scene, 1205);
        cc.assertID(scene instanceof cc.Scene, 1216);
        scene._load();
        this.once(cc.Director.EVENT_AFTER_UPDATE, (function() {
          this.runSceneImmediate(scene, onBeforeLoadScene, onLaunched);
        }), this);
      },
      _getSceneUuid: function _getSceneUuid(key) {
        var scenes = game._sceneInfos;
        if ("string" === typeof key) {
          key.endsWith(".fire") || (key += ".fire");
          "/" === key[0] || key.startsWith("db://") || (key = "/" + key);
          for (var i = 0; i < scenes.length; i++) {
            var info = scenes[i];
            if (info.url.endsWith(key)) return info;
          }
        } else if ("number" === typeof key) {
          if (0 <= key && key < scenes.length) return scenes[key];
          cc.errorID(1206, key);
        } else cc.errorID(1207, key);
        return null;
      },
      loadScene: function loadScene(sceneName, onLaunched, _onUnloaded) {
        if (this._loadingScene) {
          cc.errorID(1208, sceneName, this._loadingScene);
          return false;
        }
        var info = this._getSceneUuid(sceneName);
        if (info) {
          var uuid = info.uuid;
          this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName);
          this._loadingScene = sceneName;
          this._loadSceneByUuid(uuid, onLaunched, _onUnloaded);
          return true;
        }
        cc.errorID(1209, sceneName);
        return false;
      },
      preloadScene: function preloadScene(sceneName, onProgress, onLoaded) {
        if (void 0 === onLoaded) {
          onLoaded = onProgress;
          onProgress = null;
        }
        var info = this._getSceneUuid(sceneName);
        if (info) {
          this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName);
          cc.loader.load({
            uuid: info.uuid,
            type: "uuid"
          }, onProgress, (function(error, asset) {
            error && cc.errorID(1210, sceneName, error.message);
            onLoaded && onLoaded(error, asset);
          }));
        } else {
          var error = 'Can not preload the scene "' + sceneName + '" because it is not in the build settings.';
          onLoaded(new Error(error));
          cc.error("preloadScene: " + error);
        }
      },
      _loadSceneByUuid: function _loadSceneByUuid(uuid, onLaunched, onUnloaded, dontRunScene) {
        false;
        console.time("LoadScene " + uuid);
        cc.AssetLibrary.loadAsset(uuid, (function(error, sceneAsset) {
          console.timeEnd("LoadScene " + uuid);
          var self = cc.director;
          self._loadingScene = "";
          if (error) {
            error = "Failed to load scene: " + error;
            cc.error(error);
          } else {
            if (sceneAsset instanceof cc.SceneAsset) {
              var scene = sceneAsset.scene;
              scene._id = sceneAsset._uuid;
              scene._name = sceneAsset._name;
              false;
              self.runSceneImmediate(scene, onUnloaded, onLaunched);
              return;
            }
            error = "The asset " + uuid + " is not a scene";
            cc.error(error);
          }
          onLaunched && onLaunched(error);
        }));
      },
      resume: function resume() {
        if (!this._paused) return;
        this._lastUpdate = performance.now();
        this._lastUpdate || cc.logID(1200);
        this._paused = false;
        this._deltaTime = 0;
      },
      setDepthTest: function setDepthTest(value) {
        if (!cc.Camera.main) return;
        cc.Camera.main.depth = !!value;
      },
      setClearColor: function setClearColor(clearColor) {
        if (!cc.Camera.main) return;
        cc.Camera.main.backgroundColor = clearColor;
      },
      getRunningScene: function getRunningScene() {
        return this._scene;
      },
      getScene: function getScene() {
        return this._scene;
      },
      getAnimationInterval: function getAnimationInterval() {
        return 1e3 / game.getFrameRate();
      },
      setAnimationInterval: function setAnimationInterval(value) {
        game.setFrameRate(Math.round(1e3 / value));
      },
      getDeltaTime: function getDeltaTime() {
        return this._deltaTime;
      },
      getTotalFrames: function getTotalFrames() {
        return this._totalFrames;
      },
      isPaused: function isPaused() {
        return this._paused;
      },
      getScheduler: function getScheduler() {
        return this._scheduler;
      },
      setScheduler: function setScheduler(scheduler) {
        this._scheduler !== scheduler && (this._scheduler = scheduler);
      },
      getActionManager: function getActionManager() {
        return this._actionManager;
      },
      setActionManager: function setActionManager(actionManager) {
        if (this._actionManager !== actionManager) {
          this._actionManager && this._scheduler.unscheduleUpdate(this._actionManager);
          this._actionManager = actionManager;
          this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        }
      },
      getAnimationManager: function getAnimationManager() {
        return this._animationManager;
      },
      getCollisionManager: function getCollisionManager() {
        return this._collisionManager;
      },
      getPhysicsManager: function getPhysicsManager() {
        return this._physicsManager;
      },
      startAnimation: function startAnimation() {
        cc.game.resume();
      },
      stopAnimation: function stopAnimation() {
        cc.game.pause();
      },
      _resetDeltaTime: function _resetDeltaTime() {
        this._lastUpdate = performance.now();
        this._deltaTime = 0;
      },
      mainLoop: function(now) {
        if (this._purgeDirectorInNextLoop) {
          this._purgeDirectorInNextLoop = false;
          this.purgeDirector();
        } else {
          this.calculateDeltaTime(now);
          if (!this._paused) {
            this.emit(cc.Director.EVENT_BEFORE_UPDATE);
            this._compScheduler.startPhase();
            this._compScheduler.updatePhase(this._deltaTime);
            this._scheduler.update(this._deltaTime);
            this._compScheduler.lateUpdatePhase(this._deltaTime);
            this.emit(cc.Director.EVENT_AFTER_UPDATE);
            Obj._deferredDestroy();
          }
          this.emit(cc.Director.EVENT_BEFORE_DRAW);
          renderer.render(this._scene);
          this.emit(cc.Director.EVENT_AFTER_DRAW);
          eventManager.frameUpdateListeners();
          this._totalFrames++;
        }
      },
      __fastOn: function __fastOn(type, callback, target) {
        this.add(type, callback, target);
      },
      __fastOff: function __fastOff(type, callback, target) {
        this.remove(type, callback, target);
      }
    };
    cc.js.addon(cc.Director.prototype, EventTarget.prototype);
    cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed";
    cc.Director.EVENT_BEFORE_SCENE_LOADING = "director_before_scene_loading";
    cc.Director.EVENT_BEFORE_SCENE_LAUNCH = "director_before_scene_launch";
    cc.Director.EVENT_AFTER_SCENE_LAUNCH = "director_after_scene_launch";
    cc.Director.EVENT_BEFORE_UPDATE = "director_before_update";
    cc.Director.EVENT_AFTER_UPDATE = "director_after_update";
    cc.Director.EVENT_BEFORE_VISIT = "director_before_draw";
    cc.Director.EVENT_AFTER_VISIT = "director_before_draw";
    cc.Director.EVENT_BEFORE_DRAW = "director_before_draw";
    cc.Director.EVENT_AFTER_DRAW = "director_after_draw";
    cc.Director.PROJECTION_2D = 0;
    cc.Director.PROJECTION_3D = 1;
    cc.Director.PROJECTION_CUSTOM = 3;
    cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_2D;
    cc.director = new cc.Director();
    module.exports = cc.director;
  }), {
    "./CCGame": 5,
    "./CCScheduler": 9,
    "./component-scheduler": 35,
    "./event-manager": 70,
    "./event/event-target": 72,
    "./load-pipeline/auto-release-utils": 85,
    "./node-activator": 101,
    "./platform/CCObject": 110,
    "./renderer": 147
  } ],
  5: [ (function(require, module, exports) {
    "use strict";
    var EventTarget = require("./event/event-target");
    require("../audio/CCAudioEngine");
    var debug = require("./CCDebug");
    var renderer = require("./renderer/index.js");
    var inputManager = require("./platform/CCInputManager");
    var dynamicAtlasManager = require("../core/renderer/utils/dynamic-atlas/manager");
    var game = {
      EVENT_HIDE: "game_on_hide",
      EVENT_SHOW: "game_on_show",
      EVENT_RESTART: "game_on_restart",
      EVENT_GAME_INITED: "game_inited",
      EVENT_ENGINE_INITED: "engine_inited",
      EVENT_RENDERER_INITED: "engine_inited",
      RENDER_TYPE_CANVAS: 0,
      RENDER_TYPE_WEBGL: 1,
      RENDER_TYPE_OPENGL: 2,
      _persistRootNodes: {},
      _paused: true,
      _configLoaded: false,
      _isCloning: false,
      _prepared: false,
      _rendererInitialized: false,
      _renderContext: null,
      _intervalId: null,
      _lastTime: null,
      _frameTime: null,
      _sceneInfos: [],
      frame: null,
      container: null,
      canvas: null,
      renderType: -1,
      config: null,
      onStart: null,
      setFrameRate: function setFrameRate(frameRate) {
        var config = this.config;
        config.frameRate = frameRate;
        this._intervalId && window.cancelAnimFrame(this._intervalId);
        this._intervalId = 0;
        this._paused = true;
        this._setAnimFrame();
        this._runMainLoop();
      },
      getFrameRate: function getFrameRate() {
        return this.config.frameRate;
      },
      step: function step() {
        cc.director.mainLoop();
      },
      pause: function pause() {
        if (this._paused) return;
        this._paused = true;
        cc.audioEngine && cc.audioEngine._break();
        this._intervalId && window.cancelAnimFrame(this._intervalId);
        this._intervalId = 0;
      },
      resume: function resume() {
        if (!this._paused) return;
        this._paused = false;
        cc.audioEngine && cc.audioEngine._restore();
        cc.director._resetDeltaTime();
        this._runMainLoop();
      },
      isPaused: function isPaused() {
        return this._paused;
      },
      restart: function restart() {
        cc.director.once(cc.Director.EVENT_AFTER_DRAW, (function() {
          for (var id in game._persistRootNodes) game.removePersistRootNode(game._persistRootNodes[id]);
          cc.director.getScene().destroy();
          cc.Object._deferredDestroy();
          cc.audioEngine && cc.audioEngine.uncacheAll();
          cc.director.reset();
          game.pause();
          cc.AssetLibrary._loadBuiltins((function() {
            game.onStart();
            game.emit(game.EVENT_RESTART);
          }));
        }));
      },
      end: function end() {
        close();
      },
      _initEngine: function _initEngine() {
        if (this._rendererInitialized) return;
        this._initRenderer();
        true;
        this._initEvents();
        this.emit(this.EVENT_ENGINE_INITED);
      },
      _prepareFinished: function _prepareFinished(cb) {
        var _this = this;
        false;
        this._prepared = true;
        this._initEngine();
        cc.AssetLibrary._loadBuiltins((function() {
          console.log("Cocos Creator v" + cc.ENGINE_VERSION);
          _this._setAnimFrame();
          _this._runMainLoop();
          _this.emit(_this.EVENT_GAME_INITED);
          cb && cb();
        }));
      },
      eventTargetOn: EventTarget.prototype.on,
      eventTargetOnce: EventTarget.prototype.once,
      on: function on(type, callback, target) {
        this._prepared && type === this.EVENT_ENGINE_INITED || !this._paused && type === this.EVENT_GAME_INITED ? callback.call(target) : this.eventTargetOn(type, callback, target);
      },
      once: function once(type, callback, target) {
        this._prepared && type === this.EVENT_ENGINE_INITED || !this._paused && type === this.EVENT_GAME_INITED ? callback.call(target) : this.eventTargetOnce(type, callback, target);
      },
      prepare: function prepare(cb) {
        if (this._prepared) {
          cb && cb();
          return;
        }
        var jsList = this.config.jsList;
        if (jsList && jsList.length > 0) {
          var self = this;
          cc.loader.load(jsList, (function(err) {
            if (err) throw new Error(JSON.stringify(err));
            self._prepareFinished(cb);
          }));
        } else this._prepareFinished(cb);
      },
      run: function run(config, onStart) {
        this._initConfig(config);
        this.onStart = onStart;
        this.prepare(game.onStart && game.onStart.bind(game));
      },
      addPersistRootNode: function addPersistRootNode(node) {
        if (!cc.Node.isNode(node) || !node.uuid) {
          cc.warnID(3800);
          return;
        }
        var id = node.uuid;
        if (!this._persistRootNodes[id]) {
          var scene = cc.director._scene;
          if (cc.isValid(scene)) if (node.parent) {
            if (!(node.parent instanceof cc.Scene)) {
              cc.warnID(3801);
              return;
            }
            if (node.parent !== scene) {
              cc.warnID(3802);
              return;
            }
          } else node.parent = scene;
          this._persistRootNodes[id] = node;
          node._persistNode = true;
        }
      },
      removePersistRootNode: function removePersistRootNode(node) {
        var id = node.uuid || "";
        if (node === this._persistRootNodes[id]) {
          delete this._persistRootNodes[id];
          node._persistNode = false;
        }
      },
      isPersistRootNode: function isPersistRootNode(node) {
        return node._persistNode;
      },
      _setAnimFrame: function _setAnimFrame() {
        this._lastTime = performance.now();
        var frameRate = game.config.frameRate;
        this._frameTime = 1e3 / frameRate;
        false, false;
        if (60 !== frameRate && 30 !== frameRate) {
          window.requestAnimFrame = this._stTime;
          window.cancelAnimFrame = this._ctTime;
        } else {
          window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || this._stTime;
          window.cancelAnimFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.oCancelAnimationFrame || this._ctTime;
        }
      },
      _stTime: function _stTime(callback) {
        var currTime = performance.now();
        var timeToCall = Math.max(0, game._frameTime - (currTime - game._lastTime));
        var id = window.setTimeout((function() {
          callback();
        }), timeToCall);
        game._lastTime = currTime + timeToCall;
        return id;
      },
      _ctTime: function _ctTime(id) {
        window.clearTimeout(id);
      },
      _runMainLoop: function _runMainLoop() {
        false;
        var self = this, _callback, config = self.config, director = cc.director, skip = true, frameRate = config.frameRate;
        debug.setDisplayStats(config.showFPS);
        _callback = function callback(now) {
          if (!self._paused) {
            self._intervalId = window.requestAnimFrame(_callback);
            if ((true, true) && 30 === frameRate && (skip = !skip)) return;
            director.mainLoop(now);
          }
        };
        self._intervalId = window.requestAnimFrame(_callback);
        self._paused = false;
      },
      _initConfig: function _initConfig(config) {
        "number" !== typeof config.debugMode && (config.debugMode = 0);
        config.exposeClassName = !!config.exposeClassName;
        "number" !== typeof config.frameRate && (config.frameRate = 60);
        var renderMode = config.renderMode;
        ("number" !== typeof renderMode || renderMode > 2 || renderMode < 0) && (config.renderMode = 0);
        "boolean" !== typeof config.registerSystemEvent && (config.registerSystemEvent = true);
        config.showFPS = !!config.showFPS;
        this._sceneInfos = config.scenes || [];
        this.collisionMatrix = config.collisionMatrix || [];
        this.groupList = config.groupList || [];
        debug._resetDebugSetting(config.debugMode);
        this.config = config;
        this._configLoaded = true;
      },
      _determineRenderType: function _determineRenderType() {
        var config = this.config, userRenderMode = parseInt(config.renderMode) || 0;
        this.renderType = this.RENDER_TYPE_CANVAS;
        var supportRender = false;
        if (0 === userRenderMode) {
          if (cc.sys.capabilities["opengl"]) {
            this.renderType = this.RENDER_TYPE_WEBGL;
            supportRender = true;
          } else if (cc.sys.capabilities["canvas"]) {
            this.renderType = this.RENDER_TYPE_CANVAS;
            supportRender = true;
          }
        } else if (1 === userRenderMode && cc.sys.capabilities["canvas"]) {
          this.renderType = this.RENDER_TYPE_CANVAS;
          supportRender = true;
        } else if (2 === userRenderMode && cc.sys.capabilities["opengl"]) {
          this.renderType = this.RENDER_TYPE_WEBGL;
          supportRender = true;
        }
        if (!supportRender) throw new Error(debug.getError(3820, userRenderMode));
      },
      _initRenderer: function _initRenderer() {
        if (this._rendererInitialized) return;
        var el = this.config.id, width = void 0, height = void 0, localCanvas = void 0, localContainer = void 0;
        if ((false, false) || false) {
          this.container = localContainer = document.createElement("DIV");
          this.frame = localContainer.parentNode === document.body ? document.documentElement : localContainer.parentNode;
          if (cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB) localCanvas = window.sharedCanvas || wx.getSharedCanvas(); else {
            false, false;
            localCanvas = canvas;
          }
          this.canvas = localCanvas;
        } else {
          false;
          var addClass = function addClass(element, name) {
            var hasClass = (" " + element.className + " ").indexOf(" " + name + " ") > -1;
            if (!hasClass) {
              element.className && (element.className += " ");
              element.className += name;
            }
          };
          var element = el instanceof HTMLElement ? el : document.querySelector(el) || document.querySelector("#" + el);
          if ("CANVAS" === element.tagName) {
            width = element.width;
            height = element.height;
            this.canvas = localCanvas = element;
            this.container = localContainer = document.createElement("DIV");
            localCanvas.parentNode && localCanvas.parentNode.insertBefore(localContainer, localCanvas);
          } else {
            "DIV" !== element.tagName && cc.warnID(3819);
            width = element.clientWidth;
            height = element.clientHeight;
            this.canvas = localCanvas = document.createElement("CANVAS");
            this.container = localContainer = document.createElement("DIV");
            element.appendChild(localContainer);
          }
          localContainer.setAttribute("id", "Cocos2dGameContainer");
          localContainer.appendChild(localCanvas);
          this.frame = localContainer.parentNode === document.body ? document.documentElement : localContainer.parentNode;
          addClass(localCanvas, "gameCanvas");
          localCanvas.setAttribute("width", width || 480);
          localCanvas.setAttribute("height", height || 320);
          localCanvas.setAttribute("tabindex", 99);
        }
        this._determineRenderType();
        if (this.renderType === this.RENDER_TYPE_WEBGL) {
          var opts = {
            stencil: true,
            antialias: cc.macro.ENABLE_WEBGL_ANTIALIAS,
            alpha: cc.macro.ENABLE_TRANSPARENT_CANVAS
          };
          false;
          renderer.initWebGL(localCanvas, opts);
          this._renderContext = renderer.device._gl;
          !cc.macro.CLEANUP_IMAGE_CACHE && dynamicAtlasManager && (dynamicAtlasManager.enabled = true);
        }
        if (!this._renderContext) {
          this.renderType = this.RENDER_TYPE_CANVAS;
          renderer.initCanvas(localCanvas);
          this._renderContext = renderer.device._ctx;
        }
        this.canvas.oncontextmenu = function() {
          if (!cc._isContextMenuEnable) return false;
        };
        this._rendererInitialized = true;
      },
      _initEvents: function _initEvents() {
        var win = window, hiddenPropName;
        this.config.registerSystemEvent && inputManager.registerSystemEvent(this.canvas);
        "undefined" !== typeof document.hidden ? hiddenPropName = "hidden" : "undefined" !== typeof document.mozHidden ? hiddenPropName = "mozHidden" : "undefined" !== typeof document.msHidden ? hiddenPropName = "msHidden" : "undefined" !== typeof document.webkitHidden && (hiddenPropName = "webkitHidden");
        var hidden = false;
        function onHidden() {
          if (!hidden) {
            hidden = true;
            game.emit(game.EVENT_HIDE);
          }
        }
        function onShown(arg0, arg1, arg2, arg3, arg4) {
          if (hidden) {
            hidden = false;
            game.emit(game.EVENT_SHOW, arg0, arg1, arg2, arg3, arg4);
          }
        }
        if (hiddenPropName) {
          var changeList = [ "visibilitychange", "mozvisibilitychange", "msvisibilitychange", "webkitvisibilitychange", "qbrowserVisibilityChange" ];
          for (var i = 0; i < changeList.length; i++) document.addEventListener(changeList[i], (function(event) {
            var visible = document[hiddenPropName];
            visible = visible || event["hidden"];
            visible ? onHidden() : onShown();
          }));
        } else {
          win.addEventListener("blur", onHidden);
          win.addEventListener("focus", onShown);
        }
        navigator.userAgent.indexOf("MicroMessenger") > -1 && (win.onfocus = onShown);
        false;
        if ("onpageshow" in window && "onpagehide" in window) {
          win.addEventListener("pagehide", onHidden);
          win.addEventListener("pageshow", onShown);
          document.addEventListener("pagehide", onHidden);
          document.addEventListener("pageshow", onShown);
        }
        this.on(game.EVENT_HIDE, (function() {
          game.pause();
        }));
        this.on(game.EVENT_SHOW, (function() {
          game.resume();
        }));
      }
    };
    EventTarget.call(game);
    cc.js.addon(game, EventTarget.prototype);
    cc.game = module.exports = game;
  }), {
    "../audio/CCAudioEngine": void 0,
    "../core/renderer/utils/dynamic-atlas/manager": 150,
    "./CCDebug": 3,
    "./event/event-target": 72,
    "./platform/BKInputManager": 102,
    "./platform/CCInputManager": 108,
    "./renderer/index.js": 147
  } ],
  6: [ (function(require, module, exports) {
    "use strict";
    var _vmath = require("./vmath");
    var BaseNode = require("./utils/base-node");
    var PrefabHelper = require("./utils/prefab-helper");
    var mathPools = require("./utils/math-pools");
    var AffineTrans = require("./utils/affine-transform");
    var eventManager = require("./event-manager");
    var macro = require("./platform/CCMacro");
    var js = require("./platform/js");
    var Event = require("./event/event");
    var EventTarget = require("./event/event-target");
    var RenderFlow = require("./renderer/render-flow");
    var Flags = cc.Object.Flags;
    var Destroying = Flags.Destroying;
    var ERR_INVALID_NUMBER = false;
    var ONE_DEGREE = Math.PI / 180;
    var ActionManagerExist = !!cc.ActionManager;
    var emptyFunc = function emptyFunc() {};
    var _vec2a = cc.v2();
    var _vec2b = cc.v2();
    var _mat4_temp = _vmath.mat4.create();
    var _vec3_temp = _vmath.vec3.create();
    var _quat_temp = _vmath.quat.create();
    var _globalOrderOfArrival = 1;
    var _cachedArray = new Array(16);
    _cachedArray.length = 0;
    var POSITION_ON = 1;
    var SCALE_ON = 2;
    var ROTATION_ON = 4;
    var SIZE_ON = 8;
    var ANCHOR_ON = 16;
    var COLOR_ON = 32;
    var BuiltinGroupIndex = cc.Enum({
      DEBUG: 31
    });
    var LocalDirtyFlag = cc.Enum({
      POSITION: 1,
      SCALE: 2,
      ROTATION: 4,
      SKEW: 8,
      RT: 7,
      ALL: 65535
    });
    var EventType = cc.Enum({
      TOUCH_START: "touchstart",
      TOUCH_MOVE: "touchmove",
      TOUCH_END: "touchend",
      TOUCH_CANCEL: "touchcancel",
      MOUSE_DOWN: "mousedown",
      MOUSE_MOVE: "mousemove",
      MOUSE_ENTER: "mouseenter",
      MOUSE_LEAVE: "mouseleave",
      MOUSE_UP: "mouseup",
      MOUSE_WHEEL: "mousewheel",
      POSITION_CHANGED: "position-changed",
      ROTATION_CHANGED: "rotation-changed",
      SCALE_CHANGED: "scale-changed",
      SIZE_CHANGED: "size-changed",
      ANCHOR_CHANGED: "anchor-changed",
      COLOR_CHANGED: "color-changed",
      CHILD_ADDED: "child-added",
      CHILD_REMOVED: "child-removed",
      CHILD_REORDER: "child-reorder",
      GROUP_CHANGED: "group-changed"
    });
    var _touchEvents = [ EventType.TOUCH_START, EventType.TOUCH_MOVE, EventType.TOUCH_END, EventType.TOUCH_CANCEL ];
    var _mouseEvents = [ EventType.MOUSE_DOWN, EventType.MOUSE_ENTER, EventType.MOUSE_MOVE, EventType.MOUSE_LEAVE, EventType.MOUSE_UP, EventType.MOUSE_WHEEL ];
    var _currentHovered = null;
    var _touchStartHandler = function _touchStartHandler(touch, event) {
      var pos = touch.getLocation();
      var node = this.owner;
      if (node._hitTest(pos, this)) {
        event.type = EventType.TOUCH_START;
        event.touch = touch;
        event.bubbles = true;
        node.dispatchEvent(event);
        return true;
      }
      return false;
    };
    var _touchMoveHandler = function _touchMoveHandler(touch, event) {
      var node = this.owner;
      event.type = EventType.TOUCH_MOVE;
      event.touch = touch;
      event.bubbles = true;
      node.dispatchEvent(event);
    };
    var _touchEndHandler = function _touchEndHandler(touch, event) {
      var pos = touch.getLocation();
      var node = this.owner;
      node._hitTest(pos, this) ? event.type = EventType.TOUCH_END : event.type = EventType.TOUCH_CANCEL;
      event.touch = touch;
      event.bubbles = true;
      node.dispatchEvent(event);
    };
    var _touchCancelHandler = function _touchCancelHandler(touch, event) {
      var pos = touch.getLocation();
      var node = this.owner;
      event.type = EventType.TOUCH_CANCEL;
      event.touch = touch;
      event.bubbles = true;
      node.dispatchEvent(event);
    };
    var _mouseDownHandler = function _mouseDownHandler(event) {
      var pos = event.getLocation();
      var node = this.owner;
      if (node._hitTest(pos, this)) {
        event.type = EventType.MOUSE_DOWN;
        event.bubbles = true;
        node.dispatchEvent(event);
      }
    };
    var _mouseMoveHandler = function _mouseMoveHandler(event) {
      var pos = event.getLocation();
      var node = this.owner;
      var hit = node._hitTest(pos, this);
      if (hit) {
        if (!this._previousIn) {
          if (_currentHovered && _currentHovered._mouseListener) {
            event.type = EventType.MOUSE_LEAVE;
            _currentHovered.dispatchEvent(event);
            _currentHovered._mouseListener._previousIn = false;
          }
          _currentHovered = this.owner;
          event.type = EventType.MOUSE_ENTER;
          node.dispatchEvent(event);
          this._previousIn = true;
        }
        event.type = EventType.MOUSE_MOVE;
        event.bubbles = true;
        node.dispatchEvent(event);
      } else {
        if (!this._previousIn) return;
        event.type = EventType.MOUSE_LEAVE;
        node.dispatchEvent(event);
        this._previousIn = false;
        _currentHovered = null;
      }
      event.stopPropagation();
    };
    var _mouseUpHandler = function _mouseUpHandler(event) {
      var pos = event.getLocation();
      var node = this.owner;
      if (node._hitTest(pos, this)) {
        event.type = EventType.MOUSE_UP;
        event.bubbles = true;
        node.dispatchEvent(event);
        event.stopPropagation();
      }
    };
    var _mouseWheelHandler = function _mouseWheelHandler(event) {
      var pos = event.getLocation();
      var node = this.owner;
      if (node._hitTest(pos, this)) {
        event.type = EventType.MOUSE_WHEEL;
        event.bubbles = true;
        node.dispatchEvent(event);
        event.stopPropagation();
      }
    };
    function _searchMaskInParent(node) {
      var Mask = cc.Mask;
      if (Mask) {
        var index = 0;
        for (var curr = node; curr && cc.Node.isNode(curr); curr = curr._parent, ++index) if (curr.getComponent(Mask)) return {
          index: index,
          node: curr
        };
      }
      return null;
    }
    function _checkListeners(node, events) {
      if (!(node._objFlags & Destroying)) {
        var i = 0;
        if (node._bubblingListeners) for (;i < events.length; ++i) if (node._bubblingListeners.hasEventListener(events[i])) return true;
        if (node._capturingListeners) for (;i < events.length; ++i) if (node._capturingListeners.hasEventListener(events[i])) return true;
        return false;
      }
      return true;
    }
    function _doDispatchEvent(owner, event) {
      var target, i;
      event.target = owner;
      _cachedArray.length = 0;
      owner._getCapturingTargets(event.type, _cachedArray);
      event.eventPhase = 1;
      for (i = _cachedArray.length - 1; i >= 0; --i) {
        target = _cachedArray[i];
        if (target._capturingListeners) {
          event.currentTarget = target;
          target._capturingListeners.emit(event.type, event, _cachedArray);
          if (event._propagationStopped) {
            _cachedArray.length = 0;
            return;
          }
        }
      }
      _cachedArray.length = 0;
      event.eventPhase = 2;
      event.currentTarget = owner;
      owner._capturingListeners && owner._capturingListeners.emit(event.type, event);
      !event._propagationImmediateStopped && owner._bubblingListeners && owner._bubblingListeners.emit(event.type, event);
      if (!event._propagationStopped && event.bubbles) {
        owner._getBubblingTargets(event.type, _cachedArray);
        event.eventPhase = 3;
        for (i = 0; i < _cachedArray.length; ++i) {
          target = _cachedArray[i];
          if (target._bubblingListeners) {
            event.currentTarget = target;
            target._bubblingListeners.emit(event.type, event);
            if (event._propagationStopped) {
              _cachedArray.length = 0;
              return;
            }
          }
        }
      }
      _cachedArray.length = 0;
    }
    function _getActualGroupIndex(node) {
      var groupIndex = node.groupIndex;
      0 === groupIndex && node.parent && (groupIndex = _getActualGroupIndex(node.parent));
      return groupIndex;
    }
    function _updateCullingMask(node) {
      var index = _getActualGroupIndex(node);
      node._cullingMask = 1 << index;
      for (var i = 0; i < node._children.length; i++) _updateCullingMask(node._children[i]);
    }
    var NodeDefines = {
      name: "cc.Node",
      extends: BaseNode,
      properties: {
        _opacity: 255,
        _color: cc.Color.WHITE,
        _contentSize: cc.Size,
        _anchorPoint: cc.v2(.5, .5),
        _position: cc.Vec3,
        _scale: cc.Vec3.ONE,
        _eulerAngles: cc.Vec3,
        _skewX: 0,
        _skewY: 0,
        _zIndex: {
          default: void 0,
          type: cc.Integer
        },
        _localZOrder: {
          default: 0,
          serializable: false
        },
        _is3DNode: false,
        groupIndex: {
          default: 0,
          type: cc.Integer
        },
        group: {
          get: function get() {
            return cc.game.groupList[this.groupIndex] || "";
          },
          set: function set(value) {
            this.groupIndex = cc.game.groupList.indexOf(value);
            _updateCullingMask(this);
            this.emit(EventType.GROUP_CHANGED, this);
          }
        },
        x: {
          get: function get() {
            return this._position.x;
          },
          set: function set(value) {
            var localPosition = this._position;
            if (value !== localPosition.x) {
              true;
              var oldValue;
              false;
              localPosition.x = value;
              this.setLocalDirty(LocalDirtyFlag.POSITION);
              this._renderFlag |= RenderFlow.FLAG_WORLD_TRANSFORM;
              if (this._eventMask & POSITION_ON) {
                false;
                this.emit(EventType.POSITION_CHANGED);
              }
            }
          }
        },
        y: {
          get: function get() {
            return this._position.y;
          },
          set: function set(value) {
            var localPosition = this._position;
            if (value !== localPosition.y) {
              true;
              var oldValue;
              false;
              localPosition.y = value;
              this.setLocalDirty(LocalDirtyFlag.POSITION);
              this._renderFlag |= RenderFlow.FLAG_WORLD_TRANSFORM;
              if (this._eventMask & POSITION_ON) {
                false;
                this.emit(EventType.POSITION_CHANGED);
              }
            }
          }
        },
        rotation: {
          get: function get() {
            true;
            cc.warn("`cc.Node.rotation` is deprecated since v2.1.0, please use `-angle` instead. (`this.node.rotation` -> `-this.node.angle`)");
            return -this.angle;
          },
          set: function set(value) {
            true;
            cc.warn("`cc.Node.rotation` is deprecated since v2.1.0, please set `-angle` instead. (`this.node.rotation = x` -> `this.node.angle = -x`)");
            this.angle = -value;
          }
        },
        angle: {
          get: function get() {
            return this._eulerAngles.z;
          },
          set: function set(value) {
            _vmath.vec3.set(this._eulerAngles, 0, 0, value);
            _vmath.quat.fromAngleZ(this._quat, value);
            this.setLocalDirty(LocalDirtyFlag.ROTATION);
            this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
            this._eventMask & ROTATION_ON && this.emit(EventType.ROTATION_CHANGED);
          }
        },
        rotationX: {
          get: function get() {
            true;
            cc.warn("`cc.Node.rotationX` is deprecated since v2.1.0, please use `eulerAngles.x` instead. (`this.node.rotationX` -> `this.node.eulerAngles.x`)");
            return this._eulerAngles.x;
          },
          set: function set(value) {
            true;
            cc.warn("`cc.Node.rotationX` is deprecated since v2.1.0, please set `eulerAngles` instead. (`this.node.rotationX = x` -> `this.node.is3DNode = true; this.node.eulerAngles = cc.v3(x, 0, 0)`");
            if (this._eulerAngles.x !== value) {
              this._eulerAngles.x = value;
              this._eulerAngles.x === this._eulerAngles.y ? _vmath.quat.fromAngleZ(this._quat, -value) : _vmath.quat.fromEuler(this._quat, value, this._eulerAngles.y, 0);
              this.setLocalDirty(LocalDirtyFlag.ROTATION);
              this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
              this._eventMask & ROTATION_ON && this.emit(EventType.ROTATION_CHANGED);
            }
          }
        },
        rotationY: {
          get: function get() {
            true;
            cc.warn("`cc.Node.rotationY` is deprecated since v2.1.0, please use `eulerAngles.y` instead. (`this.node.rotationY` -> `this.node.eulerAngles.y`)");
            return this._eulerAngles.y;
          },
          set: function set(value) {
            true;
            cc.warn("`cc.Node.rotationY` is deprecated since v2.1.0, please set `eulerAngles` instead. (`this.node.rotationY = y` -> `this.node.is3DNode = true; this.node.eulerAngles = cc.v3(0, y, 0)`");
            if (this._eulerAngles.y !== value) {
              this._eulerAngles.y = value;
              this._eulerAngles.x === this._eulerAngles.y ? _vmath.quat.fromAngleZ(this._quat, -value) : _vmath.quat.fromEuler(this._quat, this._eulerAngles.x, value, 0);
              this.setLocalDirty(LocalDirtyFlag.ROTATION);
              this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
              this._eventMask & ROTATION_ON && this.emit(EventType.ROTATION_CHANGED);
            }
          }
        },
        scale: {
          get: function get() {
            return this._scale.x;
          },
          set: function set(v) {
            this.setScale(v);
          }
        },
        scaleX: {
          get: function get() {
            return this._scale.x;
          },
          set: function set(value) {
            if (this._scale.x !== value) {
              this._scale.x = value;
              this.setLocalDirty(LocalDirtyFlag.SCALE);
              this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
              this._eventMask & SCALE_ON && this.emit(EventType.SCALE_CHANGED);
            }
          }
        },
        scaleY: {
          get: function get() {
            return this._scale.y;
          },
          set: function set(value) {
            if (this._scale.y !== value) {
              this._scale.y = value;
              this.setLocalDirty(LocalDirtyFlag.SCALE);
              this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
              this._eventMask & SCALE_ON && this.emit(EventType.SCALE_CHANGED);
            }
          }
        },
        skewX: {
          get: function get() {
            return this._skewX;
          },
          set: function set(value) {
            this._skewX = value;
            this.setLocalDirty(LocalDirtyFlag.SKEW);
            this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
          }
        },
        skewY: {
          get: function get() {
            return this._skewY;
          },
          set: function set(value) {
            this._skewY = value;
            this.setLocalDirty(LocalDirtyFlag.SKEW);
            this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
          }
        },
        opacity: {
          get: function get() {
            return this._opacity;
          },
          set: function set(value) {
            value = cc.misc.clampf(value, 0, 255);
            if (this._opacity !== value) {
              this._opacity = value;
              this._renderFlag |= RenderFlow.FLAG_OPACITY;
            }
          },
          range: [ 0, 255 ]
        },
        color: {
          get: function get() {
            return this._color.clone();
          },
          set: function set(value) {
            if (!this._color.equals(value)) {
              this._color.set(value);
              false;
              this._eventMask & COLOR_ON && this.emit(EventType.COLOR_CHANGED, value);
            }
          }
        },
        anchorX: {
          get: function get() {
            return this._anchorPoint.x;
          },
          set: function set(value) {
            var anchorPoint = this._anchorPoint;
            if (anchorPoint.x !== value) {
              anchorPoint.x = value;
              this._eventMask & ANCHOR_ON && this.emit(EventType.ANCHOR_CHANGED);
            }
          }
        },
        anchorY: {
          get: function get() {
            return this._anchorPoint.y;
          },
          set: function set(value) {
            var anchorPoint = this._anchorPoint;
            if (anchorPoint.y !== value) {
              anchorPoint.y = value;
              this._eventMask & ANCHOR_ON && this.emit(EventType.ANCHOR_CHANGED);
            }
          }
        },
        width: {
          get: function get() {
            return this._contentSize.width;
          },
          set: function set(value) {
            if (value !== this._contentSize.width) {
              var clone;
              false;
              this._contentSize.width = value;
              if (this._eventMask & SIZE_ON) {
                false;
                this.emit(EventType.SIZE_CHANGED);
              }
            }
          }
        },
        height: {
          get: function get() {
            return this._contentSize.height;
          },
          set: function set(value) {
            if (value !== this._contentSize.height) {
              var clone;
              false;
              this._contentSize.height = value;
              if (this._eventMask & SIZE_ON) {
                false;
                this.emit(EventType.SIZE_CHANGED);
              }
            }
          }
        },
        zIndex: {
          get: function get() {
            return this._localZOrder >> 16;
          },
          set: function set(value) {
            if (value > macro.MAX_ZINDEX) {
              cc.warnID(1636);
              value = macro.MAX_ZINDEX;
            } else if (value < macro.MIN_ZINDEX) {
              cc.warnID(1637);
              value = macro.MIN_ZINDEX;
            }
            if (this.zIndex !== value) {
              this._localZOrder = 65535 & this._localZOrder | value << 16;
              this._parent && this._onSiblingIndexChanged();
            }
          }
        }
      },
      ctor: function ctor() {
        this._reorderChildDirty = false;
        this._widget = null;
        this._renderComponent = null;
        this._capturingListeners = null;
        this._bubblingListeners = null;
        this._touchListener = null;
        this._mouseListener = null;
        this._matrix = mathPools.mat4.get();
        this._worldMatrix = mathPools.mat4.get();
        this._localMatDirty = LocalDirtyFlag.ALL;
        this._worldMatDirty = true;
        this._eventMask = 0;
        this._cullingMask = 1;
        this._childArrivalOrder = 1;
        this._quat = cc.quat();
      },
      statics: {
        EventType: EventType,
        _LocalDirtyFlag: LocalDirtyFlag,
        isNode: function isNode(obj) {
          return obj instanceof Node && (obj.constructor === Node || !(obj instanceof cc.Scene));
        },
        BuiltinGroupIndex: BuiltinGroupIndex
      },
      _onSiblingIndexChanged: function _onSiblingIndexChanged() {
        var parent = this._parent;
        var siblings = parent._children;
        var i = 0, len = siblings.length, sibling;
        for (;i < len; i++) {
          sibling = siblings[i];
          sibling._updateOrderOfArrival();
        }
        parent._delaySort();
      },
      _onPreDestroy: function _onPreDestroy() {
        var destroyByParent = this._onPreDestroyBase();
        ActionManagerExist && cc.director.getActionManager().removeAllActionsFromTarget(this);
        _currentHovered === this && (_currentHovered = null);
        if (this._touchListener || this._mouseListener) {
          eventManager.removeListeners(this);
          if (this._touchListener) {
            this._touchListener.owner = null;
            this._touchListener.mask = null;
            this._touchListener = null;
          }
          if (this._mouseListener) {
            this._mouseListener.owner = null;
            this._mouseListener.mask = null;
            this._mouseListener = null;
          }
        }
        mathPools.mat4.put(this._matrix);
        mathPools.mat4.put(this._worldMatrix);
        this._matrix = this._worldMatrix = null;
        this._reorderChildDirty && cc.director.__fastOff(cc.Director.EVENT_AFTER_UPDATE, this.sortAllChildren, this);
        destroyByParent || false;
      },
      _onPostActivated: function _onPostActivated(active) {
        var actionManager = ActionManagerExist ? cc.director.getActionManager() : null;
        if (active) {
          this._renderFlag |= RenderFlow.FLAG_WORLD_TRANSFORM;
          actionManager && actionManager.resumeTarget(this);
          eventManager.resumeTarget(this);
          if (this._touchListener) {
            var mask = this._touchListener.mask = _searchMaskInParent(this);
            this._mouseListener && (this._mouseListener.mask = mask);
          } else this._mouseListener && (this._mouseListener.mask = _searchMaskInParent(this));
        } else {
          actionManager && actionManager.pauseTarget(this);
          eventManager.pauseTarget(this);
        }
      },
      _onHierarchyChanged: function _onHierarchyChanged(oldParent) {
        this._updateOrderOfArrival();
        _updateCullingMask(this);
        this._parent && this._parent._delaySort();
        this._renderFlag |= RenderFlow.FLAG_WORLD_TRANSFORM;
        this._onHierarchyChangedBase(oldParent);
        cc._widgetManager && (cc._widgetManager._nodesOrderDirty = true);
      },
      _toEuler: function _toEuler() {
        if (this.is3DNode) this._quat.toEuler(this._eulerAngles); else {
          var z = Math.asin(this._quat.z) / ONE_DEGREE * 2;
          _vmath.vec3.set(this._eulerAngles, 0, 0, z);
        }
      },
      _fromEuler: function _fromEuler() {
        this.is3DNode ? this._quat.fromEuler(this._eulerAngles) : _vmath.quat.fromAngleZ(this._quat, this._eulerAngles.z);
      },
      _upgrade_1x_to_2x: function _upgrade_1x_to_2x() {
        if (void 0 !== this._scaleX) {
          this._scale.x = this._scaleX;
          this._scaleX = void 0;
        }
        if (void 0 !== this._scaleY) {
          this._scale.y = this._scaleY;
          this._scaleY = void 0;
        }
        if (void 0 !== this._zIndex) {
          this._localZOrder = this._zIndex << 16;
          this._zIndex = void 0;
        }
        var eulerAngles = this._eulerAngles;
        if ((this._rotationX || this._rotationY) && 0 === eulerAngles.x && 0 === eulerAngles.y && 0 === eulerAngles.z) {
          if (this._rotationX === this._rotationY) eulerAngles.z = -this._rotationX; else {
            eulerAngles.x = this._rotationX;
            eulerAngles.y = this._rotationY;
          }
          this._rotationX = this._rotationY = void 0;
        }
        this._fromEuler();
        if (this._color.a < 255 && 255 === this._opacity) {
          this._opacity = this._color.a;
          this._color.a = 255;
        }
      },
      _onBatchCreated: function _onBatchCreated() {
        var prefabInfo = this._prefab;
        if (prefabInfo && prefabInfo.sync && prefabInfo.root === this) {
          false;
          PrefabHelper.syncWithPrefab(this);
        }
        this._upgrade_1x_to_2x();
        this._updateOrderOfArrival();
        this._cullingMask = 1 << _getActualGroupIndex(this);
        if (!this._activeInHierarchy) {
          ActionManagerExist && cc.director.getActionManager().pauseTarget(this);
          eventManager.pauseTarget(this);
        }
        var children = this._children;
        for (var i = 0, len = children.length; i < len; i++) children[i]._onBatchCreated();
        children.length > 0 && (this._renderFlag |= RenderFlow.FLAG_CHILDREN);
      },
      _onBatchRestored: function _onBatchRestored() {
        this._upgrade_1x_to_2x();
        this._cullingMask = 1 << _getActualGroupIndex(this);
        if (!this._activeInHierarchy) {
          var manager = cc.director.getActionManager();
          manager && manager.pauseTarget(this);
          eventManager.pauseTarget(this);
        }
        var children = this._children;
        for (var i = 0, len = children.length; i < len; i++) children[i]._onBatchRestored();
        children.length > 0 && (this._renderFlag |= RenderFlow.FLAG_CHILDREN);
      },
      _checknSetupSysEvent: function _checknSetupSysEvent(type) {
        var newAdded = false;
        var forDispatch = false;
        if (-1 !== _touchEvents.indexOf(type)) {
          if (!this._touchListener) {
            this._touchListener = cc.EventListener.create({
              event: cc.EventListener.TOUCH_ONE_BY_ONE,
              swallowTouches: true,
              owner: this,
              mask: _searchMaskInParent(this),
              onTouchBegan: _touchStartHandler,
              onTouchMoved: _touchMoveHandler,
              onTouchEnded: _touchEndHandler,
              onTouchCancelled: _touchCancelHandler
            });
            eventManager.addListener(this._touchListener, this);
            newAdded = true;
          }
          forDispatch = true;
        } else if (-1 !== _mouseEvents.indexOf(type)) {
          if (!this._mouseListener) {
            this._mouseListener = cc.EventListener.create({
              event: cc.EventListener.MOUSE,
              _previousIn: false,
              owner: this,
              mask: _searchMaskInParent(this),
              onMouseDown: _mouseDownHandler,
              onMouseMove: _mouseMoveHandler,
              onMouseUp: _mouseUpHandler,
              onMouseScroll: _mouseWheelHandler
            });
            eventManager.addListener(this._mouseListener, this);
            newAdded = true;
          }
          forDispatch = true;
        }
        newAdded && !this._activeInHierarchy && cc.director.getScheduler().schedule((function() {
          this._activeInHierarchy || eventManager.pauseTarget(this);
        }), this, 0, 0, 0, false);
        return forDispatch;
      },
      on: function on(type, callback, target, useCapture) {
        var forDispatch = this._checknSetupSysEvent(type);
        if (forDispatch) return this._onDispatch(type, callback, target, useCapture);
        switch (type) {
         case EventType.POSITION_CHANGED:
          this._eventMask |= POSITION_ON;
          break;

         case EventType.SCALE_CHANGED:
          this._eventMask |= SCALE_ON;
          break;

         case EventType.ROTATION_CHANGED:
          this._eventMask |= ROTATION_ON;
          break;

         case EventType.SIZE_CHANGED:
          this._eventMask |= SIZE_ON;
          break;

         case EventType.ANCHOR_CHANGED:
          this._eventMask |= ANCHOR_ON;
          break;

         case EventType.COLOR_CHANGED:
          this._eventMask |= COLOR_ON;
        }
        this._bubblingListeners || (this._bubblingListeners = new EventTarget());
        return this._bubblingListeners.on(type, callback, target);
      },
      once: function once(type, callback, target, useCapture) {
        var forDispatch = this._checknSetupSysEvent(type);
        var eventType_hasOnceListener = "__ONCE_FLAG:" + type;
        var listeners = null;
        listeners = forDispatch && useCapture ? this._capturingListeners = this._capturingListeners || new EventTarget() : this._bubblingListeners = this._bubblingListeners || new EventTarget();
        var hasOnceListener = listeners.hasEventListener(eventType_hasOnceListener, callback, target);
        if (!hasOnceListener) {
          var self = this;
          var onceWrapper = function onceWrapper(arg1, arg2, arg3, arg4, arg5) {
            self.off(type, onceWrapper, target);
            listeners.remove(eventType_hasOnceListener, callback, target);
            callback.call(this, arg1, arg2, arg3, arg4, arg5);
          };
          this.on(type, onceWrapper, target);
          listeners.add(eventType_hasOnceListener, callback, target);
        }
      },
      _onDispatch: function _onDispatch(type, callback, target, useCapture) {
        if ("boolean" === typeof target) {
          useCapture = target;
          target = void 0;
        } else useCapture = !!useCapture;
        if (!callback) {
          cc.errorID(6800);
          return;
        }
        var listeners = null;
        listeners = useCapture ? this._capturingListeners = this._capturingListeners || new EventTarget() : this._bubblingListeners = this._bubblingListeners || new EventTarget();
        if (!listeners.hasEventListener(type, callback, target)) {
          listeners.add(type, callback, target);
          target && target.__eventTargets && target.__eventTargets.push(this);
        }
        return callback;
      },
      off: function off(type, callback, target, useCapture) {
        var touchEvent = -1 !== _touchEvents.indexOf(type);
        var mouseEvent = !touchEvent && -1 !== _mouseEvents.indexOf(type);
        if (touchEvent || mouseEvent) {
          this._offDispatch(type, callback, target, useCapture);
          if (touchEvent) {
            if (this._touchListener && !_checkListeners(this, _touchEvents)) {
              eventManager.removeListener(this._touchListener);
              this._touchListener = null;
            }
          } else if (mouseEvent && this._mouseListener && !_checkListeners(this, _mouseEvents)) {
            eventManager.removeListener(this._mouseListener);
            this._mouseListener = null;
          }
        } else if (this._bubblingListeners) {
          this._bubblingListeners.off(type, callback, target);
          var hasListeners = this._bubblingListeners.hasEventListener(type);
          if (!hasListeners) switch (type) {
           case EventType.POSITION_CHANGED:
            this._eventMask &= ~POSITION_ON;
            break;

           case EventType.SCALE_CHANGED:
            this._eventMask &= ~SCALE_ON;
            break;

           case EventType.ROTATION_CHANGED:
            this._eventMask &= ~ROTATION_ON;
            break;

           case EventType.SIZE_CHANGED:
            this._eventMask &= ~SIZE_ON;
            break;

           case EventType.ANCHOR_CHANGED:
            this._eventMask &= ~ANCHOR_ON;
            break;

           case EventType.COLOR_CHANGED:
            this._eventMask &= ~COLOR_ON;
          }
        }
      },
      _offDispatch: function _offDispatch(type, callback, target, useCapture) {
        if ("boolean" === typeof target) {
          useCapture = target;
          target = void 0;
        } else useCapture = !!useCapture;
        if (callback) {
          var listeners = useCapture ? this._capturingListeners : this._bubblingListeners;
          if (listeners) {
            listeners.remove(type, callback, target);
            target && target.__eventTargets && js.array.fastRemove(target.__eventTargets, this);
          }
        } else {
          this._capturingListeners && this._capturingListeners.removeAll(type);
          this._bubblingListeners && this._bubblingListeners.removeAll(type);
        }
      },
      targetOff: function targetOff(target) {
        var listeners = this._bubblingListeners;
        if (listeners) {
          listeners.targetOff(target);
          this._eventMask & POSITION_ON && !listeners.hasEventListener(EventType.POSITION_CHANGED) && (this._eventMask &= ~POSITION_ON);
          this._eventMask & SCALE_ON && !listeners.hasEventListener(EventType.SCALE_CHANGED) && (this._eventMask &= ~SCALE_ON);
          this._eventMask & ROTATION_ON && !listeners.hasEventListener(EventType.ROTATION_CHANGED) && (this._eventMask &= ~ROTATION_ON);
          this._eventMask & SIZE_ON && !listeners.hasEventListener(EventType.SIZE_CHANGED) && (this._eventMask &= ~SIZE_ON);
          this._eventMask & ANCHOR_ON && !listeners.hasEventListener(EventType.ANCHOR_CHANGED) && (this._eventMask &= ~ANCHOR_ON);
          this._eventMask & COLOR_ON && !listeners.hasEventListener(EventType.COLOR_CHANGED) && (this._eventMask &= ~COLOR_ON);
        }
        this._capturingListeners && this._capturingListeners.targetOff(target);
        if (this._touchListener && !_checkListeners(this, _touchEvents)) {
          eventManager.removeListener(this._touchListener);
          this._touchListener = null;
        }
        if (this._mouseListener && !_checkListeners(this, _mouseEvents)) {
          eventManager.removeListener(this._mouseListener);
          this._mouseListener = null;
        }
      },
      hasEventListener: function hasEventListener(type) {
        var has = false;
        this._bubblingListeners && (has = this._bubblingListeners.hasEventListener(type));
        !has && this._capturingListeners && (has = this._capturingListeners.hasEventListener(type));
        return has;
      },
      emit: function emit(type, arg1, arg2, arg3, arg4, arg5) {
        this._bubblingListeners && this._bubblingListeners.emit(type, arg1, arg2, arg3, arg4, arg5);
      },
      dispatchEvent: function dispatchEvent(event) {
        _doDispatchEvent(this, event);
        _cachedArray.length = 0;
      },
      pauseSystemEvents: function pauseSystemEvents(recursive) {
        eventManager.pauseTarget(this, recursive);
      },
      resumeSystemEvents: function resumeSystemEvents(recursive) {
        eventManager.resumeTarget(this, recursive);
      },
      _hitTest: function _hitTest(point, listener) {
        var w = this._contentSize.width, h = this._contentSize.height, cameraPt = _vec2a, testPt = _vec2b;
        var camera = cc.Camera.findCamera(this);
        camera ? camera.getCameraToWorldPoint(point, cameraPt) : cameraPt.set(point);
        this._updateWorldMatrix();
        if (!_vmath.mat4.invert(_mat4_temp, this._worldMatrix)) return false;
        _vmath.vec2.transformMat4(testPt, cameraPt, _mat4_temp);
        testPt.x += this._anchorPoint.x * w;
        testPt.y += this._anchorPoint.y * h;
        if (testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
          if (listener && listener.mask) {
            var mask = listener.mask;
            var parent = this;
            for (var i = 0; parent && i < mask.index; ++i, parent = parent.parent) ;
            if (parent === mask.node) {
              var comp = parent.getComponent(cc.Mask);
              return !comp || !comp.enabledInHierarchy || comp._hitTest(cameraPt);
            }
            listener.mask = null;
            return true;
          }
          return true;
        }
        return false;
      },
      _getCapturingTargets: function _getCapturingTargets(type, array) {
        var parent = this.parent;
        while (parent) {
          parent._capturingListeners && parent._capturingListeners.hasEventListener(type) && array.push(parent);
          parent = parent.parent;
        }
      },
      _getBubblingTargets: function _getBubblingTargets(type, array) {
        var parent = this.parent;
        while (parent) {
          parent._bubblingListeners && parent._bubblingListeners.hasEventListener(type) && array.push(parent);
          parent = parent.parent;
        }
      },
      runAction: ActionManagerExist ? function(action) {
        if (!this.active) return;
        cc.assertID(action, 1618);
        cc.director.getActionManager().addAction(action, this, false);
        return action;
      } : emptyFunc,
      pauseAllActions: ActionManagerExist ? function() {
        cc.director.getActionManager().pauseTarget(this);
      } : emptyFunc,
      resumeAllActions: ActionManagerExist ? function() {
        cc.director.getActionManager().resumeTarget(this);
      } : emptyFunc,
      stopAllActions: ActionManagerExist ? function() {
        cc.director.getActionManager().removeAllActionsFromTarget(this);
      } : emptyFunc,
      stopAction: ActionManagerExist ? function(action) {
        cc.director.getActionManager().removeAction(action);
      } : emptyFunc,
      stopActionByTag: ActionManagerExist ? function(tag) {
        if (tag === cc.Action.TAG_INVALID) {
          cc.logID(1612);
          return;
        }
        cc.director.getActionManager().removeActionByTag(tag, this);
      } : emptyFunc,
      getActionByTag: ActionManagerExist ? function(tag) {
        if (tag === cc.Action.TAG_INVALID) {
          cc.logID(1613);
          return null;
        }
        return cc.director.getActionManager().getActionByTag(tag, this);
      } : function() {
        return null;
      },
      getNumberOfRunningActions: ActionManagerExist ? function() {
        return cc.director.getActionManager().getNumberOfRunningActionsInTarget(this);
      } : function() {
        return 0;
      },
      getPosition: function getPosition(out) {
        out = out || cc.v3();
        return out.set(this._position);
      },
      setPosition: function setPosition(newPosOrX, y) {
        var x;
        if (void 0 === y) {
          x = newPosOrX.x;
          y = newPosOrX.y;
        } else x = newPosOrX;
        var locPosition = this._position;
        if (locPosition.x === x && locPosition.y === y) return;
        var oldPosition;
        false;
        true;
        locPosition.x = x;
        true;
        locPosition.y = y;
        this.setLocalDirty(LocalDirtyFlag.POSITION);
        this._renderFlag |= RenderFlow.FLAG_WORLD_TRANSFORM;
        if (this._eventMask & POSITION_ON) {
          false;
          this.emit(EventType.POSITION_CHANGED);
        }
      },
      getScale: function getScale(out) {
        if (out) return out.set(this._scale);
        true;
        cc.warn("`cc.Node.getScale()` is deprecated since v2.1.0, please use `cc.Node.scale` instead. (`this.node.getScale()` -> `this.node.scale`)");
        return this._scale.x;
      },
      setScale: function setScale(x, y) {
        if (x && "number" !== typeof x) {
          y = x.y;
          x = x.x;
        } else void 0 === y && (y = x);
        if (this._scale.x !== x || this._scale.y !== y) {
          this._scale.x = x;
          this._scale.y = y;
          this.setLocalDirty(LocalDirtyFlag.SCALE);
          this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
          this._eventMask & SCALE_ON && this.emit(EventType.SCALE_CHANGED);
        }
      },
      getRotation: function getRotation(out) {
        if (out instanceof cc.Quat) return out.set(this._quat);
        true;
        cc.warn("`cc.Node.getRotation()` is deprecated since v2.1.0, please use `-cc.Node.angle` instead. (`this.node.getRotation()` -> `-this.node.angle`)");
        return -this.angle;
      },
      setRotation: function setRotation(quat, y, z, w) {
        if ("number" === typeof quat && void 0 === y) {
          true;
          cc.warn("`cc.Node.setRotation(degree)` is deprecated since v2.1.0, please set `-cc.Node.angle` instead. (`this.node.setRotation(x)` -> `this.node.angle = -x`)");
          this.angle = -quat;
        } else {
          var x = quat;
          if (void 0 === y) {
            x = quat.x;
            y = quat.y;
            z = quat.z;
            w = quat.w;
          }
          var old = this._quat;
          if (old.x !== x || old.y !== y || old.z !== z || old.w !== w) {
            old.x = x;
            old.y = y;
            old.z = z;
            old.w = w;
            this.setLocalDirty(LocalDirtyFlag.ROTATION);
            this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
            this._eventMask & ROTATION_ON && this.emit(EventType.ROTATION_CHANGED);
            false;
          }
        }
      },
      getContentSize: function getContentSize() {
        return cc.size(this._contentSize.width, this._contentSize.height);
      },
      setContentSize: function setContentSize(size, height) {
        var locContentSize = this._contentSize;
        var clone;
        if (void 0 === height) {
          if (size.width === locContentSize.width && size.height === locContentSize.height) return;
          false;
          locContentSize.width = size.width;
          locContentSize.height = size.height;
        } else {
          if (size === locContentSize.width && height === locContentSize.height) return;
          false;
          locContentSize.width = size;
          locContentSize.height = height;
        }
        if (this._eventMask & SIZE_ON) {
          false;
          this.emit(EventType.SIZE_CHANGED);
        }
      },
      getAnchorPoint: function getAnchorPoint() {
        return cc.v2(this._anchorPoint);
      },
      setAnchorPoint: function setAnchorPoint(point, y) {
        var locAnchorPoint = this._anchorPoint;
        if (void 0 === y) {
          if (point.x === locAnchorPoint.x && point.y === locAnchorPoint.y) return;
          locAnchorPoint.x = point.x;
          locAnchorPoint.y = point.y;
        } else {
          if (point === locAnchorPoint.x && y === locAnchorPoint.y) return;
          locAnchorPoint.x = point;
          locAnchorPoint.y = y;
        }
        this.setLocalDirty(LocalDirtyFlag.POSITION);
        this._eventMask & ANCHOR_ON && this.emit(EventType.ANCHOR_CHANGED);
      },
      _invTransformPoint: function _invTransformPoint(out, pos) {
        this._parent ? this._parent._invTransformPoint(out, pos) : _vmath.vec3.copy(out, pos);
        _vmath.vec3.sub(out, out, this._position);
        _vmath.quat.conjugate(_quat_temp, this._quat);
        _vmath.vec3.transformQuat(out, out, _quat_temp);
        _vmath.vec3.inverseSafe(_vec3_temp, this._scale);
        _vmath.vec3.mul(out, out, _vec3_temp);
        return out;
      },
      getWorldPosition: function getWorldPosition(out) {
        _vmath.vec3.copy(out, this._position);
        var curr = this._parent;
        while (curr) {
          _vmath.vec3.mul(out, out, curr._scale);
          _vmath.vec3.transformQuat(out, out, curr._quat);
          _vmath.vec3.add(out, out, curr._position);
          curr = curr._parent;
        }
        return out;
      },
      setWorldPosition: function setWorldPosition(pos) {
        var oldPosition;
        false;
        this._parent ? this._parent._invTransformPoint(this._position, pos) : _vmath.vec3.copy(this._position, pos);
        this.setLocalDirty(LocalDirtyFlag.POSITION);
        if (this._eventMask & POSITION_ON) {
          false;
          this.emit(EventType.POSITION_CHANGED);
        }
      },
      getWorldRotation: function getWorldRotation(out) {
        _vmath.quat.copy(out, this._quat);
        var curr = this._parent;
        while (curr) {
          _vmath.quat.mul(out, curr._quat, out);
          curr = curr._parent;
        }
        return out;
      },
      setWorldRotation: function setWorldRotation(val) {
        if (this._parent) {
          this._parent.getWorldRotation(this._quat);
          _vmath.quat.conjugate(this._quat, this._quat);
          _vmath.quat.mul(this._quat, this._quat, val);
        } else _vmath.quat.copy(this._quat, _vmath.quat);
        this._toEuler();
        this.setLocalDirty(LocalDirtyFlag.ROTATION);
      },
      getWorldScale: function getWorldScale(out) {
        _vmath.vec3.copy(out, this._scale);
        var curr = this._parent;
        while (curr) {
          _vmath.vec3.mul(out, out, curr._scale);
          curr = curr._parent;
        }
        return out;
      },
      setWorldScale: function setWorldScale(scale) {
        if (this._parent) {
          this._parent.getWorldScale(this._scale);
          _vmath.vec3.div(this._scale, scale, this._scale);
        } else _vmath.vec3.copy(this._scale, scale);
        this.setLocalDirty(LocalDirtyFlag.SCALE);
      },
      getWorldRT: function getWorldRT(out) {
        var opos = _vec3_temp;
        var orot = _quat_temp;
        _vmath.vec3.copy(opos, this._position);
        _vmath.quat.copy(orot, this._quat);
        var curr = this._parent;
        while (curr) {
          _vmath.vec3.mul(opos, opos, curr._scale);
          _vmath.vec3.transformQuat(opos, opos, curr._quat);
          _vmath.vec3.add(opos, opos, curr._position);
          _vmath.quat.mul(orot, curr._quat, orot);
          curr = curr._parent;
        }
        _vmath.mat4.fromRT(out, orot, opos);
        return out;
      },
      lookAt: function lookAt(pos, up) {
        this.getWorldPosition(_vec3_temp);
        _vmath.vec3.sub(_vec3_temp, _vec3_temp, pos);
        _vmath.vec3.normalize(_vec3_temp, _vec3_temp);
        _vmath.quat.fromViewUp(_quat_temp, _vec3_temp, up);
        this.setWorldRotation(_quat_temp);
      },
      _updateLocalMatrix: function _updateLocalMatrix() {
        var dirtyFlag = this._localMatDirty;
        if (!dirtyFlag) return;
        var t = this._matrix;
        if (dirtyFlag & (LocalDirtyFlag.RT | LocalDirtyFlag.SKEW)) {
          var rotation = -this._eulerAngles.z;
          var hasSkew = this._skewX || this._skewY;
          var sx = this._scale.x, sy = this._scale.y;
          if (rotation || hasSkew) {
            var a = 1, b = 0, c = 0, d = 1;
            if (rotation) {
              var rotationRadians = rotation * ONE_DEGREE;
              c = Math.sin(rotationRadians);
              d = Math.cos(rotationRadians);
              a = d;
              b = -c;
            }
            t.m00 = a *= sx;
            t.m01 = b *= sx;
            t.m04 = c *= sy;
            t.m05 = d *= sy;
            if (hasSkew) {
              var _a = t.m00, _b = t.m01, _c = t.m04, _d = t.m05;
              var skx = Math.tan(this._skewX * ONE_DEGREE);
              var sky = Math.tan(this._skewY * ONE_DEGREE);
              Infinity === skx && (skx = 99999999);
              Infinity === sky && (sky = 99999999);
              t.m00 = _a + _c * sky;
              t.m01 = _b + _d * sky;
              t.m04 = _c + _a * skx;
              t.m05 = _d + _b * skx;
            }
          } else {
            t.m00 = sx;
            t.m01 = 0;
            t.m04 = 0;
            t.m05 = sy;
          }
        }
        t.m12 = this._position.x;
        t.m13 = this._position.y;
        this._localMatDirty = 0;
        this._worldMatDirty = true;
      },
      _calculWorldMatrix: function _calculWorldMatrix() {
        this._localMatDirty && this._updateLocalMatrix();
        var parent = this._parent;
        parent ? this._mulMat(this._worldMatrix, parent._worldMatrix, this._matrix) : _vmath.mat4.copy(this._worldMatrix, this._matrix);
        this._worldMatDirty = false;
      },
      _mulMat: function _mulMat(out, a, b) {
        var aa = a.m00, ab = a.m01, ac = a.m04, ad = a.m05, atx = a.m12, aty = a.m13;
        var ba = b.m00, bb = b.m01, bc = b.m04, bd = b.m05, btx = b.m12, bty = b.m13;
        if (0 !== ab || 0 !== ac) {
          out.m00 = ba * aa + bb * ac;
          out.m01 = ba * ab + bb * ad;
          out.m04 = bc * aa + bd * ac;
          out.m05 = bc * ab + bd * ad;
          out.m12 = aa * btx + ac * bty + atx;
          out.m13 = ab * btx + ad * bty + aty;
        } else {
          out.m00 = ba * aa;
          out.m01 = bb * ad;
          out.m04 = bc * aa;
          out.m05 = bd * ad;
          out.m12 = aa * btx + atx;
          out.m13 = ad * bty + aty;
        }
      },
      _updateWorldMatrix: function _updateWorldMatrix() {
        this._parent && this._parent._updateWorldMatrix();
        if (this._worldMatDirty) {
          this._calculWorldMatrix();
          var children = this._children;
          for (var i = 0, l = children.length; i < l; i++) children[i]._worldMatDirty = true;
        }
      },
      setLocalDirty: function setLocalDirty(flag) {
        this._localMatDirty = this._localMatDirty | flag;
        this._worldMatDirty = true;
      },
      setWorldDirty: function setWorldDirty() {
        this._worldMatDirty = true;
      },
      getLocalMatrix: function getLocalMatrix(out) {
        this._updateLocalMatrix();
        return _vmath.mat4.copy(out, this._matrix);
      },
      getWorldMatrix: function getWorldMatrix(out) {
        this._updateWorldMatrix();
        return _vmath.mat4.copy(out, this._worldMatrix);
      },
      convertToNodeSpace: function convertToNodeSpace(worldPoint) {
        this._updateWorldMatrix();
        _vmath.mat4.invert(_mat4_temp, this._worldMatrix);
        var out = new cc.Vec2();
        _vmath.vec2.transformMat4(out, worldPoint, _mat4_temp);
        out.x += this._anchorPoint.x * this._contentSize.width;
        out.y += this._anchorPoint.y * this._contentSize.height;
        return out;
      },
      convertToWorldSpace: function convertToWorldSpace(nodePoint) {
        this._updateWorldMatrix();
        var out = new cc.Vec2(nodePoint.x - this._anchorPoint.x * this._contentSize.width, nodePoint.y - this._anchorPoint.y * this._contentSize.height);
        return _vmath.vec2.transformMat4(out, out, this._worldMatrix);
      },
      convertToNodeSpaceAR: function convertToNodeSpaceAR(worldPoint) {
        this._updateWorldMatrix();
        _vmath.mat4.invert(_mat4_temp, this._worldMatrix);
        var out = new cc.Vec2();
        return _vmath.vec2.transformMat4(out, worldPoint, _mat4_temp);
      },
      convertToWorldSpaceAR: function convertToWorldSpaceAR(nodePoint) {
        this._updateWorldMatrix();
        var out = new cc.Vec2();
        return _vmath.vec2.transformMat4(out, nodePoint, this._worldMatrix);
      },
      getNodeToParentTransform: function getNodeToParentTransform(out) {
        out || (out = AffineTrans.identity());
        this._updateLocalMatrix();
        var contentSize = this._contentSize;
        _vec3_temp.x = -this._anchorPoint.x * contentSize.width;
        _vec3_temp.y = -this._anchorPoint.y * contentSize.height;
        _vmath.mat4.copy(_mat4_temp, this._matrix);
        _vmath.mat4.translate(_mat4_temp, _mat4_temp, _vec3_temp);
        return AffineTrans.fromMat4(out, _mat4_temp);
      },
      getNodeToParentTransformAR: function getNodeToParentTransformAR(out) {
        out || (out = AffineTrans.identity());
        this._updateLocalMatrix();
        return AffineTrans.fromMat4(out, this._matrix);
      },
      getNodeToWorldTransform: function getNodeToWorldTransform(out) {
        out || (out = AffineTrans.identity());
        this._updateWorldMatrix();
        var contentSize = this._contentSize;
        _vec3_temp.x = -this._anchorPoint.x * contentSize.width;
        _vec3_temp.y = -this._anchorPoint.y * contentSize.height;
        _vmath.mat4.copy(_mat4_temp, this._worldMatrix);
        _vmath.mat4.translate(_mat4_temp, _mat4_temp, _vec3_temp);
        return AffineTrans.fromMat4(out, _mat4_temp);
      },
      getNodeToWorldTransformAR: function getNodeToWorldTransformAR(out) {
        out || (out = AffineTrans.identity());
        this._updateWorldMatrix();
        return AffineTrans.fromMat4(out, this._worldMatrix);
      },
      getParentToNodeTransform: function getParentToNodeTransform(out) {
        out || (out = AffineTrans.identity());
        this._updateLocalMatrix();
        _vmath.mat4.invert(_mat4_temp, this._matrix);
        return AffineTrans.fromMat4(out, _mat4_temp);
      },
      getWorldToNodeTransform: function getWorldToNodeTransform(out) {
        out || (out = AffineTrans.identity());
        this._updateWorldMatrix();
        _vmath.mat4.invert(_mat4_temp, this._worldMatrix);
        return AffineTrans.fromMat4(out, _mat4_temp);
      },
      convertTouchToNodeSpace: function convertTouchToNodeSpace(touch) {
        return this.convertToNodeSpace(touch.getLocation());
      },
      convertTouchToNodeSpaceAR: function convertTouchToNodeSpaceAR(touch) {
        return this.convertToNodeSpaceAR(touch.getLocation());
      },
      getBoundingBox: function getBoundingBox() {
        this._updateLocalMatrix();
        var width = this._contentSize.width;
        var height = this._contentSize.height;
        var rect = cc.rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
        return rect.transformMat4(rect, this._matrix);
      },
      getBoundingBoxToWorld: function getBoundingBoxToWorld() {
        if (this._parent) {
          this._parent._updateWorldMatrix();
          return this._getBoundingBoxTo(this._parent._worldMatrix);
        }
        return this.getBoundingBox();
      },
      _getBoundingBoxTo: function _getBoundingBoxTo(parentMat) {
        this._updateLocalMatrix();
        var width = this._contentSize.width;
        var height = this._contentSize.height;
        var rect = cc.rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
        var parentMat = _vmath.mat4.mul(this._worldMatrix, parentMat, this._matrix);
        rect.transformMat4(rect, parentMat);
        if (!this._children) return rect;
        var locChildren = this._children;
        for (var i = 0; i < locChildren.length; i++) {
          var child = locChildren[i];
          if (child && child.active) {
            var childRect = child._getBoundingBoxTo(parentMat);
            childRect && rect.union(rect, childRect);
          }
        }
        return rect;
      },
      _updateOrderOfArrival: function _updateOrderOfArrival() {
        var arrivalOrder = this._parent ? ++this._parent._childArrivalOrder : 0;
        this._localZOrder = 4294901760 & this._localZOrder | arrivalOrder;
        if (65535 === arrivalOrder) {
          var siblings = this._parent._children;
          siblings.forEach((function(node, index) {
            node._localZOrder = 4294901760 & node._localZOrder | index + 1;
          }));
          this._parent._childArrivalOrder = siblings.length;
        }
      },
      addChild: function addChild(child, zIndex, name) {
        false;
        cc.assertID(child, 1606);
        cc.assertID(null === child._parent, 1605);
        child.parent = this;
        void 0 !== zIndex && (child.zIndex = zIndex);
        void 0 !== name && (child.name = name);
      },
      cleanup: function cleanup() {
        ActionManagerExist && cc.director.getActionManager().removeAllActionsFromTarget(this);
        eventManager.removeListeners(this);
        var i, len = this._children.length, node;
        for (i = 0; i < len; ++i) {
          node = this._children[i];
          node && node.cleanup();
        }
      },
      sortAllChildren: function sortAllChildren() {
        if (this._reorderChildDirty) {
          eventManager._setDirtyForNode(this);
          this._reorderChildDirty = false;
          var _children = this._children;
          if (_children.length > 1) {
            var len = _children.length, i, j, child;
            for (i = 1; i < len; i++) {
              child = _children[i];
              j = i - 1;
              while (j >= 0) {
                if (!(child._localZOrder < _children[j]._localZOrder)) break;
                _children[j + 1] = _children[j];
                j--;
              }
              _children[j + 1] = child;
            }
            this.emit(EventType.CHILD_REORDER, this);
          }
          cc.director.__fastOff(cc.Director.EVENT_AFTER_UPDATE, this.sortAllChildren, this);
        }
      },
      _delaySort: function _delaySort() {
        if (!this._reorderChildDirty) {
          this._reorderChildDirty = true;
          cc.director.__fastOn(cc.Director.EVENT_AFTER_UPDATE, this.sortAllChildren, this);
        }
      },
      _restoreProperties: false,
      onRestore: false
    };
    false;
    var Node = cc.Class(NodeDefines);
    var _p = Node.prototype;
    js.getset(_p, "position", _p.getPosition, _p.setPosition, false, true);
    cc.Node = module.exports = Node;
  }), {
    "./event-manager": 70,
    "./event/event": 73,
    "./event/event-target": 72,
    "./platform/CCMacro": 109,
    "./platform/js": 124,
    "./renderer/render-flow": 148,
    "./utils/affine-transform": 179,
    "./utils/base-node": 180,
    "./utils/math-pools": 186,
    "./utils/prefab-helper": 189,
    "./vmath": 207
  } ],
  7: [ (function(require, module, exports) {
    "use strict";
    var Node = require("./CCNode");
    var RenderFlow = require("./renderer/render-flow");
    var HideInHierarchy = cc.Object.Flags.HideInHierarchy;
    var LocalDirtyFlag = Node._LocalDirtyFlag;
    var POSITION_ON = 1;
    var PrivateNode = cc.Class({
      name: "cc.PrivateNode",
      extends: Node,
      properties: {
        x: {
          get: function get() {
            return this._originPos.x;
          },
          set: function set(value) {
            var localPosition = this._originPos;
            if (value !== localPosition.x) {
              localPosition.x = value;
              this._posDirty(true);
            }
          },
          override: true
        },
        y: {
          get: function get() {
            return this._originPos.y;
          },
          set: function set(value) {
            var localPosition = this._originPos;
            if (value !== localPosition.y) {
              localPosition.y = value;
              this._posDirty(true);
            }
          },
          override: true
        },
        zIndex: {
          get: function get() {
            return cc.macro.MIN_ZINDEX;
          },
          set: function set() {
            cc.warnID(1638);
          },
          override: true
        },
        showInEditor: {
          default: false,
          editorOnly: true,
          override: true
        }
      },
      ctor: function ctor(name) {
        this._localZOrder = cc.macro.MIN_ZINDEX << 16;
        this._originPos = cc.v2();
        false;
      },
      _posDirty: function _posDirty(sendEvent) {
        this.setLocalDirty(LocalDirtyFlag.POSITION);
        this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
        true === sendEvent && this._eventMask & POSITION_ON && this.emit(Node.EventType.POSITION_CHANGED);
      },
      _updateLocalMatrix: function _updateLocalMatrix() {
        if (!this._localMatDirty) return;
        var parent = this.parent;
        if (parent) {
          this._position.x = this._originPos.x - (parent._anchorPoint.x - .5) * parent._contentSize.width;
          this._position.y = this._originPos.y - (parent._anchorPoint.y - .5) * parent._contentSize.height;
        }
        this._super();
      },
      getPosition: function getPosition() {
        return new cc.Vec2(this._originPos);
      },
      setPosition: function setPosition(x, y) {
        if (void 0 === y) {
          x = x.x;
          y = x.y;
        }
        var pos = this._originPos;
        if (pos.x === x && pos.y === y) return;
        pos.x = x;
        pos.y = y;
        this._posDirty(true);
      },
      setParent: function setParent(value) {
        var oldParent = this._parent;
        this._super(value);
        if (oldParent !== value) {
          oldParent && oldParent.off(Node.EventType.ANCHOR_CHANGED, this._posDirty, this);
          value && value.on(Node.EventType.ANCHOR_CHANGED, this._posDirty, this);
        }
      },
      _updateOrderOfArrival: function _updateOrderOfArrival() {}
    });
    cc.js.getset(PrivateNode.prototype, "parent", PrivateNode.prototype.getParent, PrivateNode.prototype.setParent);
    cc.js.getset(PrivateNode.prototype, "position", PrivateNode.prototype.getPosition, PrivateNode.prototype.setPosition);
    cc.PrivateNode = module.exports = PrivateNode;
  }), {
    "./CCNode": 6,
    "./renderer/render-flow": 148
  } ],
  8: [ (function(require, module, exports) {
    "use strict";
    var NIL = function NIL() {};
    cc.Scene = cc.Class({
      name: "cc.Scene",
      extends: require("./CCNode"),
      properties: {
        _is3DNode: {
          default: true,
          override: true
        },
        autoReleaseAssets: {
          default: void 0,
          type: cc.Boolean
        }
      },
      ctor: function ctor() {
        this._anchorPoint.x = 0;
        this._anchorPoint.y = 0;
        this._activeInHierarchy = false;
        this._inited = !cc.game._isCloning;
        false;
        this.dependAssets = null;
      },
      destroy: function destroy() {
        if (cc.Object.prototype.destroy.call(this)) {
          var children = this._children;
          for (var i = 0; i < children.length; ++i) children[i].active = false;
        }
        this._active = false;
        this._activeInHierarchy = false;
      },
      _onHierarchyChanged: NIL,
      _instantiate: null,
      _load: function _load() {
        if (!this._inited) {
          false;
          false;
          this._onBatchCreated();
          this._inited = true;
        }
      },
      _activate: function _activate(active) {
        active = false !== active;
        false, false;
        cc.director._nodeActivator.activateNode(this, active);
      }
    });
    module.exports = cc.Scene;
  }), {
    "./CCNode": 6
  } ],
  9: [ (function(require, module, exports) {
    "use strict";
    var js = require("./platform/js");
    var IdGenerater = require("./platform/id-generater");
    var MAX_POOL_SIZE = 20;
    var idGenerater = new IdGenerater("Scheduler");
    var ListEntry = function ListEntry(target, priority, paused, markedForDeletion) {
      this.target = target;
      this.priority = priority;
      this.paused = paused;
      this.markedForDeletion = markedForDeletion;
    };
    var _listEntries = [];
    ListEntry.get = function(target, priority, paused, markedForDeletion) {
      var result = _listEntries.pop();
      if (result) {
        result.target = target;
        result.priority = priority;
        result.paused = paused;
        result.markedForDeletion = markedForDeletion;
      } else result = new ListEntry(target, priority, paused, markedForDeletion);
      return result;
    };
    ListEntry.put = function(entry) {
      if (_listEntries.length < MAX_POOL_SIZE) {
        entry.target = null;
        _listEntries.push(entry);
      }
    };
    var HashUpdateEntry = function HashUpdateEntry(list, entry, target, callback) {
      this.list = list;
      this.entry = entry;
      this.target = target;
      this.callback = callback;
    };
    var _hashUpdateEntries = [];
    HashUpdateEntry.get = function(list, entry, target, callback) {
      var result = _hashUpdateEntries.pop();
      if (result) {
        result.list = list;
        result.entry = entry;
        result.target = target;
        result.callback = callback;
      } else result = new HashUpdateEntry(list, entry, target, callback);
      return result;
    };
    HashUpdateEntry.put = function(entry) {
      if (_hashUpdateEntries.length < MAX_POOL_SIZE) {
        entry.list = entry.entry = entry.target = entry.callback = null;
        _hashUpdateEntries.push(entry);
      }
    };
    var HashTimerEntry = function HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
      var _t = this;
      _t.timers = timers;
      _t.target = target;
      _t.timerIndex = timerIndex;
      _t.currentTimer = currentTimer;
      _t.currentTimerSalvaged = currentTimerSalvaged;
      _t.paused = paused;
    };
    var _hashTimerEntries = [];
    HashTimerEntry.get = function(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
      var result = _hashTimerEntries.pop();
      if (result) {
        result.timers = timers;
        result.target = target;
        result.timerIndex = timerIndex;
        result.currentTimer = currentTimer;
        result.currentTimerSalvaged = currentTimerSalvaged;
        result.paused = paused;
      } else result = new HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused);
      return result;
    };
    HashTimerEntry.put = function(entry) {
      if (_hashTimerEntries.length < MAX_POOL_SIZE) {
        entry.timers = entry.target = entry.currentTimer = null;
        _hashTimerEntries.push(entry);
      }
    };
    function CallbackTimer() {
      this._lock = false;
      this._scheduler = null;
      this._elapsed = -1;
      this._runForever = false;
      this._useDelay = false;
      this._timesExecuted = 0;
      this._repeat = 0;
      this._delay = 0;
      this._interval = 0;
      this._target = null;
      this._callback = null;
    }
    var proto = CallbackTimer.prototype;
    proto.initWithCallback = function(scheduler, callback, target, seconds, repeat, delay) {
      this._lock = false;
      this._scheduler = scheduler;
      this._target = target;
      this._callback = callback;
      this._elapsed = -1;
      this._interval = seconds;
      this._delay = delay;
      this._useDelay = this._delay > 0;
      this._repeat = repeat;
      this._runForever = this._repeat === cc.macro.REPEAT_FOREVER;
      return true;
    };
    proto.getInterval = function() {
      return this._interval;
    };
    proto.setInterval = function(interval) {
      this._interval = interval;
    };
    proto.update = function(dt) {
      if (-1 === this._elapsed) {
        this._elapsed = 0;
        this._timesExecuted = 0;
      } else {
        this._elapsed += dt;
        if (this._runForever && !this._useDelay) {
          if (this._elapsed >= this._interval) {
            this.trigger();
            this._elapsed = 0;
          }
        } else {
          if (this._useDelay) {
            if (this._elapsed >= this._delay) {
              this.trigger();
              this._elapsed -= this._delay;
              this._timesExecuted += 1;
              this._useDelay = false;
            }
          } else if (this._elapsed >= this._interval) {
            this.trigger();
            this._elapsed = 0;
            this._timesExecuted += 1;
          }
          this._callback && !this._runForever && this._timesExecuted > this._repeat && this.cancel();
        }
      }
    };
    proto.getCallback = function() {
      return this._callback;
    };
    proto.trigger = function() {
      if (this._target && this._callback) {
        this._lock = true;
        this._callback.call(this._target, this._elapsed);
        this._lock = false;
      }
    };
    proto.cancel = function() {
      this._scheduler.unschedule(this._callback, this._target);
    };
    var _timers = [];
    CallbackTimer.get = function() {
      return _timers.pop() || new CallbackTimer();
    };
    CallbackTimer.put = function(timer) {
      if (_timers.length < MAX_POOL_SIZE && !timer._lock) {
        timer._scheduler = timer._target = timer._callback = null;
        _timers.push(timer);
      }
    };
    cc.Scheduler = function() {
      this._timeScale = 1;
      this._updatesNegList = [];
      this._updates0List = [];
      this._updatesPosList = [];
      this._hashForUpdates = js.createMap(true);
      this._hashForTimers = js.createMap(true);
      this._currentTarget = null;
      this._currentTargetSalvaged = false;
      this._updateHashLocked = false;
      this._arrayForTimers = [];
    };
    cc.Scheduler.prototype = {
      constructor: cc.Scheduler,
      _removeHashElement: function _removeHashElement(element) {
        delete this._hashForTimers[element.target._id];
        var arr = this._arrayForTimers;
        for (var i = 0, l = arr.length; i < l; i++) if (arr[i] === element) {
          arr.splice(i, 1);
          break;
        }
        HashTimerEntry.put(element);
      },
      _removeUpdateFromHash: function _removeUpdateFromHash(entry) {
        var targetId = entry.target._id;
        var self = this, element = self._hashForUpdates[targetId];
        if (element) {
          var list = element.list, listEntry = element.entry;
          for (var i = 0, l = list.length; i < l; i++) if (list[i] === listEntry) {
            list.splice(i, 1);
            break;
          }
          delete self._hashForUpdates[targetId];
          ListEntry.put(listEntry);
          HashUpdateEntry.put(element);
        }
      },
      _priorityIn: function _priorityIn(ppList, listElement, priority) {
        for (var i = 0; i < ppList.length; i++) if (priority < ppList[i].priority) {
          ppList.splice(i, 0, listElement);
          return;
        }
        ppList.push(listElement);
      },
      _appendIn: function _appendIn(ppList, listElement) {
        ppList.push(listElement);
      },
      enableForTarget: function enableForTarget(target) {
        target._id || (target.__instanceId ? cc.warnID(1513) : target._id = idGenerater.getNewId());
      },
      setTimeScale: function setTimeScale(timeScale) {
        this._timeScale = timeScale;
      },
      getTimeScale: function getTimeScale() {
        return this._timeScale;
      },
      update: function update(dt) {
        this._updateHashLocked = true;
        1 !== this._timeScale && (dt *= this._timeScale);
        var i, list, len, entry;
        for (i = 0, list = this._updatesNegList, len = list.length; i < len; i++) {
          entry = list[i];
          entry.paused || entry.markedForDeletion || entry.target.update(dt);
        }
        for (i = 0, list = this._updates0List, len = list.length; i < len; i++) {
          entry = list[i];
          entry.paused || entry.markedForDeletion || entry.target.update(dt);
        }
        for (i = 0, list = this._updatesPosList, len = list.length; i < len; i++) {
          entry = list[i];
          entry.paused || entry.markedForDeletion || entry.target.update(dt);
        }
        var elt, arr = this._arrayForTimers;
        for (i = 0; i < arr.length; i++) {
          elt = arr[i];
          this._currentTarget = elt;
          this._currentTargetSalvaged = false;
          if (!elt.paused) for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; ++elt.timerIndex) {
            elt.currentTimer = elt.timers[elt.timerIndex];
            elt.currentTimerSalvaged = false;
            elt.currentTimer.update(dt);
            elt.currentTimer = null;
          }
          if (this._currentTargetSalvaged && 0 === this._currentTarget.timers.length) {
            this._removeHashElement(this._currentTarget);
            --i;
          }
        }
        for (i = 0, list = this._updatesNegList; i < list.length; ) {
          entry = list[i];
          entry.markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
        }
        for (i = 0, list = this._updates0List; i < list.length; ) {
          entry = list[i];
          entry.markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
        }
        for (i = 0, list = this._updatesPosList; i < list.length; ) {
          entry = list[i];
          entry.markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
        }
        this._updateHashLocked = false;
        this._currentTarget = null;
      },
      schedule: function schedule(callback, target, interval, repeat, delay, paused) {
        if ("function" !== typeof callback) {
          var tmp = callback;
          callback = target;
          target = tmp;
        }
        if (4 === arguments.length || 5 === arguments.length) {
          paused = !!repeat;
          repeat = cc.macro.REPEAT_FOREVER;
          delay = 0;
        }
        cc.assertID(target, 1502);
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var element = this._hashForTimers[targetId];
        if (element) element.paused !== paused && cc.warnID(1511); else {
          element = HashTimerEntry.get(null, target, 0, null, null, paused);
          this._arrayForTimers.push(element);
          this._hashForTimers[targetId] = element;
        }
        var timer, i;
        if (null == element.timers) element.timers = []; else for (i = 0; i < element.timers.length; ++i) {
          timer = element.timers[i];
          if (timer && callback === timer._callback) {
            cc.logID(1507, timer.getInterval(), interval);
            timer._interval = interval;
            return;
          }
        }
        timer = CallbackTimer.get();
        timer.initWithCallback(this, callback, target, interval, repeat, delay);
        element.timers.push(timer);
        this._currentTarget === element && this._currentTargetSalvaged && (this._currentTargetSalvaged = false);
      },
      scheduleUpdate: function scheduleUpdate(target, priority, paused) {
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var hashElement = this._hashForUpdates[targetId];
        if (hashElement && hashElement.entry) {
          if (hashElement.entry.priority === priority) {
            hashElement.entry.markedForDeletion = false;
            hashElement.entry.paused = paused;
            return;
          }
          if (this._updateHashLocked) {
            cc.logID(1506);
            hashElement.entry.markedForDeletion = false;
            hashElement.entry.paused = paused;
            return;
          }
          this.unscheduleUpdate(target);
        }
        var listElement = ListEntry.get(target, priority, paused, false);
        var ppList;
        if (0 === priority) {
          ppList = this._updates0List;
          this._appendIn(ppList, listElement);
        } else {
          ppList = priority < 0 ? this._updatesNegList : this._updatesPosList;
          this._priorityIn(ppList, listElement, priority);
        }
        this._hashForUpdates[targetId] = HashUpdateEntry.get(ppList, listElement, target, null);
      },
      unschedule: function unschedule(callback, target) {
        if (!target || !callback) return;
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var self = this, element = self._hashForTimers[targetId];
        if (element) {
          var timers = element.timers;
          for (var i = 0, li = timers.length; i < li; i++) {
            var timer = timers[i];
            if (callback === timer._callback) {
              timer !== element.currentTimer || element.currentTimerSalvaged || (element.currentTimerSalvaged = true);
              timers.splice(i, 1);
              CallbackTimer.put(timer);
              element.timerIndex >= i && element.timerIndex--;
              0 === timers.length && (self._currentTarget === element ? self._currentTargetSalvaged = true : self._removeHashElement(element));
              return;
            }
          }
        }
      },
      unscheduleUpdate: function unscheduleUpdate(target) {
        if (!target) return;
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var element = this._hashForUpdates[targetId];
        element && (this._updateHashLocked ? element.entry.markedForDeletion = true : this._removeUpdateFromHash(element.entry));
      },
      unscheduleAllForTarget: function unscheduleAllForTarget(target) {
        if (!target) return;
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var element = this._hashForTimers[targetId];
        if (element) {
          var timers = element.timers;
          timers.indexOf(element.currentTimer) > -1 && !element.currentTimerSalvaged && (element.currentTimerSalvaged = true);
          for (var i = 0, l = timers.length; i < l; i++) CallbackTimer.put(timers[i]);
          timers.length = 0;
          this._currentTarget === element ? this._currentTargetSalvaged = true : this._removeHashElement(element);
        }
        this.unscheduleUpdate(target);
      },
      unscheduleAll: function unscheduleAll() {
        this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
      },
      unscheduleAllWithMinPriority: function unscheduleAllWithMinPriority(minPriority) {
        var i, element, arr = this._arrayForTimers;
        for (i = arr.length - 1; i >= 0; i--) {
          element = arr[i];
          this.unscheduleAllForTarget(element.target);
        }
        var entry;
        var temp_length = 0;
        if (minPriority < 0) for (i = 0; i < this._updatesNegList.length; ) {
          temp_length = this._updatesNegList.length;
          entry = this._updatesNegList[i];
          entry && entry.priority >= minPriority && this.unscheduleUpdate(entry.target);
          temp_length == this._updatesNegList.length && i++;
        }
        if (minPriority <= 0) for (i = 0; i < this._updates0List.length; ) {
          temp_length = this._updates0List.length;
          entry = this._updates0List[i];
          entry && this.unscheduleUpdate(entry.target);
          temp_length == this._updates0List.length && i++;
        }
        for (i = 0; i < this._updatesPosList.length; ) {
          temp_length = this._updatesPosList.length;
          entry = this._updatesPosList[i];
          entry && entry.priority >= minPriority && this.unscheduleUpdate(entry.target);
          temp_length == this._updatesPosList.length && i++;
        }
      },
      isScheduled: function isScheduled(callback, target) {
        cc.assertID(callback, 1508);
        cc.assertID(target, 1509);
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var element = this._hashForTimers[targetId];
        if (!element) return false;
        if (null == element.timers) return false;
        var timers = element.timers;
        for (var i = 0; i < timers.length; ++i) {
          var timer = timers[i];
          if (callback === timer._callback) return true;
        }
        return false;
      },
      pauseAllTargets: function pauseAllTargets() {
        return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
      },
      pauseAllTargetsWithMinPriority: function pauseAllTargetsWithMinPriority(minPriority) {
        var idsWithSelectors = [];
        var self = this, element, locArrayForTimers = self._arrayForTimers;
        var i, li;
        for (i = 0, li = locArrayForTimers.length; i < li; i++) {
          element = locArrayForTimers[i];
          if (element) {
            element.paused = true;
            idsWithSelectors.push(element.target);
          }
        }
        var entry;
        if (minPriority < 0) for (i = 0; i < this._updatesNegList.length; i++) {
          entry = this._updatesNegList[i];
          if (entry && entry.priority >= minPriority) {
            entry.paused = true;
            idsWithSelectors.push(entry.target);
          }
        }
        if (minPriority <= 0) for (i = 0; i < this._updates0List.length; i++) {
          entry = this._updates0List[i];
          if (entry) {
            entry.paused = true;
            idsWithSelectors.push(entry.target);
          }
        }
        for (i = 0; i < this._updatesPosList.length; i++) {
          entry = this._updatesPosList[i];
          if (entry && entry.priority >= minPriority) {
            entry.paused = true;
            idsWithSelectors.push(entry.target);
          }
        }
        return idsWithSelectors;
      },
      resumeTargets: function resumeTargets(targetsToResume) {
        if (!targetsToResume) return;
        for (var i = 0; i < targetsToResume.length; i++) this.resumeTarget(targetsToResume[i]);
      },
      pauseTarget: function pauseTarget(target) {
        cc.assertID(target, 1503);
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var self = this, element = self._hashForTimers[targetId];
        element && (element.paused = true);
        var elementUpdate = self._hashForUpdates[targetId];
        elementUpdate && (elementUpdate.entry.paused = true);
      },
      resumeTarget: function resumeTarget(target) {
        cc.assertID(target, 1504);
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var self = this, element = self._hashForTimers[targetId];
        element && (element.paused = false);
        var elementUpdate = self._hashForUpdates[targetId];
        elementUpdate && (elementUpdate.entry.paused = false);
      },
      isTargetPaused: function isTargetPaused(target) {
        cc.assertID(target, 1505);
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var element = this._hashForTimers[targetId];
        if (element) return element.paused;
        var elementUpdate = this._hashForUpdates[targetId];
        if (elementUpdate) return elementUpdate.entry.paused;
        return false;
      }
    };
    cc.Scheduler.PRIORITY_SYSTEM = 1 << 31;
    cc.Scheduler.PRIORITY_NON_SYSTEM = cc.Scheduler.PRIORITY_SYSTEM + 1;
    module.exports = cc.Scheduler;
  }), {
    "./platform/id-generater": 120,
    "./platform/js": 124
  } ],
  10: [ (function(require, module, exports) {
    "use strict";
    var RawAsset = require("./CCRawAsset");
    cc.Asset = cc.Class({
      name: "cc.Asset",
      extends: RawAsset,
      ctor: function ctor() {
        this.loaded = true;
        this.url = "";
      },
      properties: {
        nativeUrl: {
          get: function get() {
            if (this._native) {
              var name = this._native;
              if (47 === name.charCodeAt(0)) return name.slice(1);
              if (cc.AssetLibrary) {
                var base = cc.AssetLibrary.getLibUrlNoExt(this._uuid, true);
                return 46 === name.charCodeAt(0) ? base + name : base + "/" + name;
              }
              cc.errorID(6400);
            }
            return "";
          },
          visible: false
        },
        _native: "",
        _nativeAsset: {
          get: function get() {
            return this._$nativeAsset;
          },
          set: function set(obj) {
            this._$nativeAsset = obj;
          }
        }
      },
      statics: {
        deserialize: false,
        preventDeferredLoadDependents: false,
        preventPreloadNativeObject: false
      },
      toString: function toString() {
        return this.nativeUrl;
      },
      serialize: false,
      createNode: null,
      _setRawAsset: function _setRawAsset(filename, inLibrary) {
        this._native = false !== inLibrary ? filename || void 0 : "/" + filename;
      }
    });
    module.exports = cc.Asset;
  }), {
    "./CCRawAsset": 19
  } ],
  11: [ (function(require, module, exports) {
    "use strict";
    var Asset = require("./CCAsset");
    var EventTarget = require("../event/event-target");
    var LoadMode = cc.Enum({
      WEB_AUDIO: 0,
      DOM_AUDIO: 1
    });
    var AudioClip = cc.Class({
      name: "cc.AudioClip",
      extends: Asset,
      mixins: [ EventTarget ],
      ctor: function ctor() {
        this.loaded = false;
        this._audio = null;
      },
      properties: {
        loadMode: {
          default: LoadMode.WEB_AUDIO,
          type: LoadMode
        },
        _nativeAsset: {
          get: function get() {
            return this._audio;
          },
          set: function set(value) {
            value instanceof cc.AudioClip ? this._audio = value._nativeAsset : this._audio = value;
            if (this._audio) {
              this.loaded = true;
              this.emit("load");
            }
          },
          override: true
        }
      },
      statics: {
        LoadMode: LoadMode,
        _loadByUrl: function _loadByUrl(url, callback) {
          var item = cc.loader.getItem(url) || cc.loader.getItem(url + "?useDom=1");
          item && item.complete ? item._owner instanceof AudioClip ? callback(null, item._owner) : callback(null, item.content) : cc.loader.load(url, (function(error, downloadUrl) {
            if (error) return callback(error);
            item = cc.loader.getItem(url) || cc.loader.getItem(url + "?useDom=1");
            callback(null, item.content);
          }));
        }
      },
      destroy: function destroy() {
        cc.audioEngine.uncache(this);
        this._super();
      }
    });
    cc.AudioClip = AudioClip;
    module.exports = AudioClip;
  }), {
    "../event/event-target": 72,
    "./CCAsset": 10
  } ],
  12: [ (function(require, module, exports) {
    "use strict";
    var BitmapFont = cc.Class({
      name: "cc.BitmapFont",
      extends: cc.Font,
      properties: {
        fntDataStr: {
          default: ""
        },
        spriteFrame: {
          default: null,
          type: cc.SpriteFrame
        },
        fontSize: {
          default: -1
        },
        _fntConfig: null
      }
    });
    cc.BitmapFont = BitmapFont;
    module.exports = BitmapFont;
  }), {} ],
  13: [ (function(require, module, exports) {
    "use strict";
    var BufferAsset = cc.Class({
      name: "cc.BufferAsset",
      extends: cc.Asset,
      ctor: function ctor() {
        this._buffer = null;
      },
      properties: {
        _nativeAsset: {
          get: function get() {
            return this._buffer;
          },
          set: function set(bin) {
            this._buffer = bin.buffer || bin;
          },
          override: true
        },
        buffer: function buffer() {
          return this._buffer;
        }
      }
    });
    cc.BufferAsset = module.exports = BufferAsset;
  }), {} ],
  14: [ (function(require, module, exports) {
    "use strict";
    var Asset = require("./CCAsset");
    var EffectAsset = cc.Class({
      name: "cc.EffectAsset",
      extends: Asset,
      properties: {
        properties: Object,
        techniques: [],
        shaders: []
      },
      onLoad: function onLoad() {
        if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) return;
        var lib = cc.renderer._forward._programLib;
        for (var i = 0; i < this.shaders.length; i++) lib.define(this.shaders[i]);
      }
    });
    module.exports = cc.EffectAsset = EffectAsset;
  }), {
    "./CCAsset": 10
  } ],
  15: [ (function(require, module, exports) {
    "use strict";
    var Font = cc.Class({
      name: "cc.Font",
      extends: cc.Asset
    });
    cc.Font = module.exports = Font;
  }), {} ],
  16: [ (function(require, module, exports) {
    "use strict";
    var JsonAsset = cc.Class({
      name: "cc.JsonAsset",
      extends: cc.Asset,
      properties: {
        json: null
      }
    });
    module.exports = cc.JsonAsset = JsonAsset;
  }), {} ],
  17: [ (function(require, module, exports) {
    "use strict";
    var LabelAtlas = cc.Class({
      name: "cc.LabelAtlas",
      extends: cc.BitmapFont
    });
    cc.LabelAtlas = LabelAtlas;
    module.exports = LabelAtlas;
  }), {} ],
  18: [ (function(require, module, exports) {
    "use strict";
    var OptimizationPolicy = cc.Enum({
      AUTO: 0,
      SINGLE_INSTANCE: 1,
      MULTI_INSTANCE: 2
    });
    var Prefab = cc.Class({
      name: "cc.Prefab",
      extends: cc.Asset,
      ctor: function ctor() {
        this._createFunction = null;
        this._instantiatedTimes = 0;
      },
      properties: {
        data: null,
        optimizationPolicy: OptimizationPolicy.AUTO,
        asyncLoadAssets: false,
        readonly: {
          default: false,
          editorOnly: true
        }
      },
      statics: {
        OptimizationPolicy: OptimizationPolicy,
        OptimizationPolicyThreshold: 3
      },
      createNode: false,
      compileCreateFunction: function compileCreateFunction() {
        var jit = require("../platform/instantiate-jit");
        this._createFunction = jit.compile(this.data);
      },
      _doInstantiate: function _doInstantiate(rootToRedirect) {
        this.data._prefab ? this.data._prefab._synced = true : cc.warnID(3700);
        this._createFunction || this.compileCreateFunction();
        return this._createFunction(rootToRedirect);
      },
      _instantiate: function _instantiate() {
        var node, useJit = false;
        true;
        useJit = this.optimizationPolicy !== OptimizationPolicy.SINGLE_INSTANCE && (this.optimizationPolicy === OptimizationPolicy.MULTI_INSTANCE || this._instantiatedTimes + 1 >= Prefab.OptimizationPolicyThreshold);
        if (useJit) {
          node = this._doInstantiate();
          this.data._instantiate(node);
        } else {
          this.data._prefab._synced = true;
          node = this.data._instantiate();
        }
        ++this._instantiatedTimes;
        var PrefabUtils;
        false, false;
        return node;
      }
    });
    cc.Prefab = module.exports = Prefab;
    cc.js.obsolete(cc, "cc._Prefab", "Prefab");
  }), {
    "../platform/instantiate-jit": 122
  } ],
  19: [ (function(require, module, exports) {
    "use strict";
    var CCObject = require("../platform/CCObject");
    var js = require("../platform/js");
    cc.RawAsset = cc.Class({
      name: "cc.RawAsset",
      extends: CCObject,
      ctor: function ctor() {
        Object.defineProperty(this, "_uuid", {
          value: "",
          writable: true
        });
      }
    });
    js.value(cc.RawAsset, "isRawAssetType", (function(ctor) {
      return js.isChildClassOf(ctor, cc.RawAsset) && !js.isChildClassOf(ctor, cc.Asset);
    }));
    js.value(cc.RawAsset, "wasRawAssetType", (function(ctor) {
      return ctor === cc.Texture2D || ctor === cc.AudioClip || ctor === cc.ParticleAsset || ctor === cc.Asset;
    }));
    module.exports = cc.RawAsset;
  }), {
    "../platform/CCObject": 110,
    "../platform/js": 124
  } ],
  20: [ (function(require, module, exports) {
    "use strict";
    var _gfx = require("../../renderer/gfx");
    var _gfx2 = _interopRequireDefault(_gfx);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var renderer = require("../renderer");
    var Texture2D = require("./CCTexture2D");
    var RenderTexture = cc.Class({
      name: "cc.RenderTexture",
      extends: Texture2D,
      ctor: function ctor() {
        this._framebuffer = null;
      },
      initWithSize: function initWithSize(width, height, depthStencilFormat) {
        this.width = Math.floor(width || cc.visibleRect.width);
        this.height = Math.floor(height || cc.visibleRect.height);
        this._resetUnderlyingMipmaps();
        var opts = {
          colors: [ this._texture ]
        };
        this._depthStencilBuffer && this._depthStencilBuffer.destroy();
        var depthStencilBuffer = void 0;
        if (depthStencilFormat) {
          depthStencilBuffer = new _gfx2.default.RenderBuffer(renderer.device, depthStencilFormat, width, height);
          depthStencilFormat === _gfx2.default.RB_FMT_D24S8 ? opts.depthStencil = depthStencilBuffer : depthStencilFormat === _gfx2.default.RB_FMT_S8 ? opts.stencil = depthStencilBuffer : depthStencilFormat === _gfx2.default.RB_FMT_D16 && (opts.depth = depthStencilBuffer);
        }
        this._depthStencilBuffer = depthStencilBuffer;
        this._framebuffer && this._framebuffer.destroy();
        this._framebuffer = new _gfx2.default.FrameBuffer(renderer.device, width, height, opts);
        this.loaded = true;
        this.emit("load");
      },
      updateSize: function updateSize(width, height) {
        this.width = Math.floor(width || cc.visibleRect.width);
        this.height = Math.floor(height || cc.visibleRect.height);
        this._resetUnderlyingMipmaps();
        var rbo = this._depthStencilBuffer;
        rbo && rbo.update(this.width, this.height);
        this._framebuffer._width = width;
        this._framebuffer._height = height;
      },
      drawTextureAt: function drawTextureAt(texture, x, y) {
        if (!texture._image) return;
        this._texture.updateSubImage({
          x: x,
          y: y,
          image: texture._image,
          width: texture.width,
          height: texture.height,
          level: 0,
          flipY: false,
          premultiplyAlpha: texture._premultiplyAlpha
        });
      },
      readPixels: function readPixels(data, x, y, w, h) {
        if (!this._framebuffer || !this._texture) return data;
        x = x || 0;
        y = y || 0;
        var width = w || this.width;
        var height = h || this.height;
        data = data || new Uint8Array(width * height * 4);
        var gl = renderer._forward._device._gl;
        var oldFBO = gl.getParameter(gl.FRAMEBUFFER_BINDING);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer._glID);
        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);
        gl.bindFramebuffer(gl.FRAMEBUFFER, oldFBO);
        return data;
      },
      destroy: function destroy() {
        this._super();
        this._framebuffer && this._framebuffer.destroy();
      }
    });
    cc.RenderTexture = module.exports = RenderTexture;
  }), {
    "../../renderer/gfx": 233,
    "../renderer": 147,
    "./CCTexture2D": 27
  } ],
  21: [ (function(require, module, exports) {
    "use strict";
    var Scene = cc.Class({
      name: "cc.SceneAsset",
      extends: cc.Asset,
      properties: {
        scene: null,
        asyncLoadAssets: void 0
      }
    });
    cc.SceneAsset = Scene;
    module.exports = Scene;
  }), {} ],
  22: [ (function(require, module, exports) {
    "use strict";
    var Script = cc.Class({
      name: "cc.Script",
      extends: cc.Asset
    });
    cc._Script = Script;
    var JavaScript = cc.Class({
      name: "cc.JavaScript",
      extends: Script
    });
    cc._JavaScript = JavaScript;
    var CoffeeScript = cc.Class({
      name: "cc.CoffeeScript",
      extends: Script
    });
    cc._CoffeeScript = CoffeeScript;
    var TypeScript = cc.Class({
      name: "cc.TypeScript",
      extends: Script
    });
    cc._TypeScript = TypeScript;
  }), {} ],
  23: [ (function(require, module, exports) {
    "use strict";
    var SpriteAtlas = cc.Class({
      name: "cc.SpriteAtlas",
      extends: cc.Asset,
      properties: {
        _spriteFrames: {
          default: {}
        }
      },
      getTexture: function getTexture() {
        var keys = Object.keys(this._spriteFrames);
        if (keys.length > 0) {
          var spriteFrame = this._spriteFrames[keys[0]];
          return spriteFrame ? spriteFrame.getTexture() : null;
        }
        return null;
      },
      getSpriteFrame: function getSpriteFrame(key) {
        var sf = this._spriteFrames[key];
        if (!sf) return null;
        sf.name || (sf.name = key);
        return sf;
      },
      getSpriteFrames: function getSpriteFrames() {
        var frames = [];
        var spriteFrames = this._spriteFrames;
        for (var key in spriteFrames) frames.push(this.getSpriteFrame(key));
        return frames;
      }
    });
    cc.SpriteAtlas = SpriteAtlas;
    module.exports = SpriteAtlas;
  }), {} ],
  24: [ (function(require, module, exports) {
    "use strict";
    var EventTarget = require("../event/event-target");
    var textureUtil = require("../utils/texture-util");
    var INSET_LEFT = 0;
    var INSET_TOP = 1;
    var INSET_RIGHT = 2;
    var INSET_BOTTOM = 3;
    var temp_uvs = [ {
      u: 0,
      v: 0
    }, {
      u: 0,
      v: 0
    }, {
      u: 0,
      v: 0
    }, {
      u: 0,
      v: 0
    } ];
    var SpriteFrame = cc.Class({
      name: "cc.SpriteFrame",
      extends: require("../assets/CCAsset"),
      mixins: [ EventTarget ],
      properties: {
        _textureSetter: {
          set: function set(texture) {
            if (texture) {
              false;
              this._texture !== texture && this._refreshTexture(texture);
              this._textureFilename = texture.url;
            }
          }
        },
        insetTop: {
          get: function get() {
            return this._capInsets[INSET_TOP];
          },
          set: function set(value) {
            this._capInsets[INSET_TOP] = value;
            this._texture && this._calculateSlicedUV();
          }
        },
        insetBottom: {
          get: function get() {
            return this._capInsets[INSET_BOTTOM];
          },
          set: function set(value) {
            this._capInsets[INSET_BOTTOM] = value;
            this._texture && this._calculateSlicedUV();
          }
        },
        insetLeft: {
          get: function get() {
            return this._capInsets[INSET_LEFT];
          },
          set: function set(value) {
            this._capInsets[INSET_LEFT] = value;
            this._texture && this._calculateSlicedUV();
          }
        },
        insetRight: {
          get: function get() {
            return this._capInsets[INSET_RIGHT];
          },
          set: function set(value) {
            this._capInsets[INSET_RIGHT] = value;
            this._texture && this._calculateSlicedUV();
          }
        }
      },
      ctor: function ctor() {
        EventTarget.call(this);
        var filename = arguments[0];
        var rect = arguments[1];
        var rotated = arguments[2];
        var offset = arguments[3];
        var originalSize = arguments[4];
        this._rect = null;
        this.uv = [];
        this._texture = null;
        this._original = null;
        this._offset = null;
        this._originalSize = null;
        this._rotated = false;
        this.vertices = null;
        this._capInsets = [ 0, 0, 0, 0 ];
        this.uvSliced = [];
        this._textureFilename = "";
        false;
        void 0 !== filename && this.setTexture(filename, rect, rotated, offset, originalSize);
      },
      textureLoaded: function textureLoaded() {
        return this._texture && this._texture.loaded;
      },
      isRotated: function isRotated() {
        return this._rotated;
      },
      setRotated: function setRotated(bRotated) {
        this._rotated = bRotated;
        this._texture && this._calculateUV();
      },
      getRect: function getRect() {
        return cc.rect(this._rect);
      },
      setRect: function setRect(rect) {
        this._rect = rect;
        this._texture && this._calculateUV();
      },
      getOriginalSize: function getOriginalSize() {
        return cc.size(this._originalSize);
      },
      setOriginalSize: function setOriginalSize(size) {
        if (this._originalSize) {
          this._originalSize.width = size.width;
          this._originalSize.height = size.height;
        } else this._originalSize = cc.size(size);
      },
      getTexture: function getTexture() {
        return this._texture;
      },
      _textureLoadedCallback: function _textureLoadedCallback() {
        var self = this;
        var texture = this._texture;
        if (!texture) return;
        var w = texture.width, h = texture.height;
        if (self._rotated && cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) {
          self._rotated = false;
          w = self._texture.width;
          h = self._texture.height;
          self._rect = cc.rect(0, 0, w, h);
        }
        self._rect ? self._checkRect(self._texture) : self._rect = cc.rect(0, 0, w, h);
        self._originalSize || self.setOriginalSize(cc.size(w, h));
        self._offset || self.setOffset(cc.v2(0, 0));
        self._calculateUV();
        self.emit("load");
      },
      _refreshTexture: function _refreshTexture(texture) {
        this._texture = texture;
        texture.loaded ? this._textureLoadedCallback() : texture.once("load", this._textureLoadedCallback, this);
      },
      getOffset: function getOffset() {
        return cc.v2(this._offset);
      },
      setOffset: function setOffset(offsets) {
        this._offset = cc.v2(offsets);
      },
      clone: function clone() {
        return new SpriteFrame(this._texture || this._textureFilename, this._rect, this._rotated, this._offset, this._originalSize);
      },
      setTexture: function setTexture(textureOrTextureFile, rect, rotated, offset, originalSize) {
        this._rect = rect || null;
        offset ? this.setOffset(offset) : this._offset = null;
        originalSize ? this.setOriginalSize(originalSize) : this._originalSize = null;
        this._rotated = rotated || false;
        var texture = textureOrTextureFile;
        if ("string" === typeof texture && texture) {
          this._textureFilename = texture;
          this._loadTexture();
        }
        texture instanceof cc.Texture2D && this._texture !== texture && this._refreshTexture(texture);
        return true;
      },
      _loadTexture: function _loadTexture() {
        if (this._textureFilename) {
          var texture = textureUtil.loadImage(this._textureFilename);
          this._refreshTexture(texture);
        }
      },
      ensureLoadTexture: function ensureLoadTexture() {
        if (this._texture) {
          if (!this._texture.loaded) {
            this._refreshTexture(this._texture);
            textureUtil.postLoadTexture(this._texture);
          }
        } else this._textureFilename && this._loadTexture();
      },
      clearTexture: function clearTexture() {
        this._texture = null;
      },
      _checkRect: function _checkRect(texture) {
        var rect = this._rect;
        var maxX = rect.x, maxY = rect.y;
        if (this._rotated) {
          maxX += rect.height;
          maxY += rect.width;
        } else {
          maxX += rect.width;
          maxY += rect.height;
        }
        maxX > texture.width && cc.errorID(3300, texture.url + "/" + this.name, maxX, texture.width);
        maxY > texture.height && cc.errorID(3400, texture.url + "/" + this.name, maxY, texture.height);
      },
      _calculateSlicedUV: function _calculateSlicedUV() {
        var rect = this._rect;
        var atlasWidth = this._texture.width;
        var atlasHeight = this._texture.height;
        var leftWidth = this._capInsets[INSET_LEFT];
        var rightWidth = this._capInsets[INSET_RIGHT];
        var centerWidth = rect.width - leftWidth - rightWidth;
        var topHeight = this._capInsets[INSET_TOP];
        var bottomHeight = this._capInsets[INSET_BOTTOM];
        var centerHeight = rect.height - topHeight - bottomHeight;
        var uvSliced = this.uvSliced;
        uvSliced.length = 0;
        if (this._rotated) {
          temp_uvs[0].u = rect.x / atlasWidth;
          temp_uvs[1].u = (rect.x + bottomHeight) / atlasWidth;
          temp_uvs[2].u = (rect.x + bottomHeight + centerHeight) / atlasWidth;
          temp_uvs[3].u = (rect.x + rect.height) / atlasWidth;
          temp_uvs[3].v = rect.y / atlasHeight;
          temp_uvs[2].v = (rect.y + leftWidth) / atlasHeight;
          temp_uvs[1].v = (rect.y + leftWidth + centerWidth) / atlasHeight;
          temp_uvs[0].v = (rect.y + rect.width) / atlasHeight;
          for (var row = 0; row < 4; ++row) {
            var rowD = temp_uvs[row];
            for (var col = 0; col < 4; ++col) {
              var colD = temp_uvs[3 - col];
              uvSliced.push({
                u: rowD.u,
                v: colD.v
              });
            }
          }
        } else {
          temp_uvs[0].u = rect.x / atlasWidth;
          temp_uvs[1].u = (rect.x + leftWidth) / atlasWidth;
          temp_uvs[2].u = (rect.x + leftWidth + centerWidth) / atlasWidth;
          temp_uvs[3].u = (rect.x + rect.width) / atlasWidth;
          temp_uvs[3].v = rect.y / atlasHeight;
          temp_uvs[2].v = (rect.y + topHeight) / atlasHeight;
          temp_uvs[1].v = (rect.y + topHeight + centerHeight) / atlasHeight;
          temp_uvs[0].v = (rect.y + rect.height) / atlasHeight;
          for (var _row = 0; _row < 4; ++_row) {
            var _rowD = temp_uvs[_row];
            for (var _col = 0; _col < 4; ++_col) {
              var _colD = temp_uvs[_col];
              uvSliced.push({
                u: _colD.u,
                v: _rowD.v
              });
            }
          }
        }
      },
      _setDynamicAtlasFrame: function _setDynamicAtlasFrame(frame) {
        if (!frame) return;
        this._original = {
          _texture: this._texture,
          _x: this._rect.x,
          _y: this._rect.y
        };
        this._texture = frame.texture;
        this._rect.x = frame.x;
        this._rect.y = frame.y;
        this._calculateUV();
      },
      _resetDynamicAtlasFrame: function _resetDynamicAtlasFrame() {
        if (!this._original) return;
        this._rect.x = this._original._x;
        this._rect.y = this._original._y;
        this._texture = this._original._texture;
        this._original = null;
        this._calculateUV();
      },
      _calculateUV: function _calculateUV() {
        var rect = this._rect, texture = this._texture, uv = this.uv, texw = texture.width, texh = texture.height;
        if (this._rotated) {
          var l = 0 === texw ? 0 : rect.x / texw;
          var r = 0 === texw ? 0 : (rect.x + rect.height) / texw;
          var b = 0 === texh ? 0 : (rect.y + rect.width) / texh;
          var t = 0 === texh ? 0 : rect.y / texh;
          uv[0] = l;
          uv[1] = t;
          uv[2] = l;
          uv[3] = b;
          uv[4] = r;
          uv[5] = t;
          uv[6] = r;
          uv[7] = b;
        } else {
          var _l = 0 === texw ? 0 : rect.x / texw;
          var _r = 0 === texw ? 0 : (rect.x + rect.width) / texw;
          var _b = 0 === texh ? 0 : (rect.y + rect.height) / texh;
          var _t = 0 === texh ? 0 : rect.y / texh;
          uv[0] = _l;
          uv[1] = _b;
          uv[2] = _r;
          uv[3] = _b;
          uv[4] = _l;
          uv[5] = _t;
          uv[6] = _r;
          uv[7] = _t;
        }
        var vertices = this.vertices;
        if (vertices) {
          vertices.nu.length = 0;
          vertices.nv.length = 0;
          for (var i = 0; i < vertices.u.length; i++) {
            vertices.nu[i] = vertices.u[i] / texw;
            vertices.nv[i] = vertices.v[i] / texh;
          }
        }
        this._calculateSlicedUV();
      },
      _serialize: false,
      _deserialize: function _deserialize(data, handle) {
        var rect = data.rect;
        rect && (this._rect = new cc.Rect(rect[0], rect[1], rect[2], rect[3]));
        data.offset && this.setOffset(new cc.Vec2(data.offset[0], data.offset[1]));
        data.originalSize && this.setOriginalSize(new cc.Size(data.originalSize[0], data.originalSize[1]));
        this._rotated = 1 === data.rotated;
        this._name = data.name;
        var capInsets = data.capInsets;
        if (capInsets) {
          this._capInsets[INSET_LEFT] = capInsets[INSET_LEFT];
          this._capInsets[INSET_TOP] = capInsets[INSET_TOP];
          this._capInsets[INSET_RIGHT] = capInsets[INSET_RIGHT];
          this._capInsets[INSET_BOTTOM] = capInsets[INSET_BOTTOM];
        }
        false;
        this.vertices = data.vertices;
        if (this.vertices) {
          this.vertices.nu = [];
          this.vertices.nv = [];
        }
        var textureUuid = data.texture;
        textureUuid && handle.result.push(this, "_textureSetter", textureUuid);
      }
    });
    var proto = SpriteFrame.prototype;
    proto.copyWithZone = proto.clone;
    proto.copy = proto.clone;
    proto.initWithTexture = proto.setTexture;
    cc.SpriteFrame = SpriteFrame;
    module.exports = SpriteFrame;
  }), {
    "../assets/CCAsset": 10,
    "../event/event-target": 72,
    "../utils/texture-util": 194
  } ],
  25: [ (function(require, module, exports) {
    "use strict";
    var Font = require("./CCFont");
    var TTFFont = cc.Class({
      name: "cc.TTFFont",
      extends: Font,
      properties: {
        _fontFamily: null,
        _nativeAsset: {
          type: cc.String,
          get: function get() {
            return this._fontFamily;
          },
          set: function set(value) {
            this._fontFamily = value || "Arial";
          },
          override: true
        }
      }
    });
    cc.TTFFont = module.exports = TTFFont;
  }), {
    "./CCFont": 15
  } ],
  26: [ (function(require, module, exports) {
    "use strict";
    var TextAsset = cc.Class({
      name: "cc.TextAsset",
      extends: cc.Asset,
      properties: {
        text: ""
      },
      toString: function toString() {
        return this.text;
      }
    });
    module.exports = cc.TextAsset = TextAsset;
  }), {} ],
  27: [ (function(require, module, exports) {
    "use strict";
    var _gfx = require("../../renderer/gfx");
    var _gfx2 = _interopRequireDefault(_gfx);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var EventTarget = require("../event/event-target");
    var renderer = require("../renderer");
    require("../platform/CCClass");
    var GL_NEAREST = 9728;
    var GL_LINEAR = 9729;
    var GL_REPEAT = 10497;
    var GL_CLAMP_TO_EDGE = 33071;
    var GL_MIRRORED_REPEAT = 33648;
    var GL_RGBA = 6408;
    var CHAR_CODE_0 = 48;
    var CHAR_CODE_1 = 49;
    var idGenerater = new (require("../platform/id-generater"))("Tex");
    var PixelFormat = cc.Enum({
      RGB565: _gfx2.default.TEXTURE_FMT_R5_G6_B5,
      RGB5A1: _gfx2.default.TEXTURE_FMT_R5_G5_B5_A1,
      RGBA4444: _gfx2.default.TEXTURE_FMT_R4_G4_B4_A4,
      RGB888: _gfx2.default.TEXTURE_FMT_RGB8,
      RGBA8888: _gfx2.default.TEXTURE_FMT_RGBA8,
      RGBA32F: _gfx2.default.TEXTURE_FMT_RGBA32F,
      A8: _gfx2.default.TEXTURE_FMT_A8,
      I8: _gfx2.default.TEXTURE_FMT_L8,
      AI8: _gfx2.default.TEXTURE_FMT_L8_A8,
      RGB_PVRTC_2BPPV1: _gfx2.default.TEXTURE_FMT_RGB_PVRTC_2BPPV1,
      RGBA_PVRTC_2BPPV1: _gfx2.default.TEXTURE_FMT_RGBA_PVRTC_2BPPV1,
      RGB_PVRTC_4BPPV1: _gfx2.default.TEXTURE_FMT_RGB_PVRTC_4BPPV1,
      RGBA_PVRTC_4BPPV1: _gfx2.default.TEXTURE_FMT_RGBA_PVRTC_4BPPV1,
      RGB_ETC1: _gfx2.default.TEXTURE_FMT_RGB_ETC1,
      RGBA_ETC1: 1024,
      RGB_ETC2: _gfx2.default.TEXTURE_FMT_RGB_ETC2,
      RGBA_ETC2: _gfx2.default.TEXTURE_FMT_RGBA_ETC2
    });
    var WrapMode = cc.Enum({
      REPEAT: GL_REPEAT,
      CLAMP_TO_EDGE: GL_CLAMP_TO_EDGE,
      MIRRORED_REPEAT: GL_MIRRORED_REPEAT
    });
    var Filter = cc.Enum({
      LINEAR: GL_LINEAR,
      NEAREST: GL_NEAREST
    });
    var FilterIndex = {
      9728: 0,
      9729: 1
    };
    var _images = [];
    var _sharedOpts = {
      width: void 0,
      height: void 0,
      minFilter: void 0,
      magFilter: void 0,
      wrapS: void 0,
      wrapT: void 0,
      format: void 0,
      mipmap: void 0,
      images: void 0,
      image: void 0,
      flipY: void 0,
      premultiplyAlpha: void 0
    };
    function _getSharedOptions() {
      for (var key in _sharedOpts) _sharedOpts[key] = void 0;
      _images.length = 0;
      _sharedOpts.images = _images;
      _sharedOpts.flipY = false;
      return _sharedOpts;
    }
    var Texture2D = cc.Class({
      name: "cc.Texture2D",
      extends: require("../assets/CCAsset"),
      mixins: [ EventTarget ],
      properties: {
        _nativeAsset: {
          get: function get() {
            return this._image;
          },
          set: function set(data) {
            data._compressed && data._data ? this.initWithData(data._data, this._format, data.width, data.height) : this.initWithElement(data);
          },
          override: true
        },
        _hasMipmap: false,
        _format: PixelFormat.RGBA8888,
        _premultiplyAlpha: false,
        _flipY: false,
        _minFilter: Filter.LINEAR,
        _magFilter: Filter.LINEAR,
        _mipFilter: Filter.LINEAR,
        _wrapS: WrapMode.CLAMP_TO_EDGE,
        _wrapT: WrapMode.CLAMP_TO_EDGE
      },
      statics: {
        PixelFormat: PixelFormat,
        WrapMode: WrapMode,
        Filter: Filter,
        _FilterIndex: FilterIndex,
        extnames: [ ".png", ".jpg", ".jpeg", ".bmp", ".webp", ".pvr", ".pkm" ]
      },
      ctor: function ctor() {
        this._id = idGenerater.getNewId();
        this.loaded = false;
        this.width = 0;
        this.height = 0;
        this._hashDirty = true;
        this._hash = 0;
        this._texture = null;
        false;
      },
      getImpl: function getImpl() {
        return this._texture;
      },
      getId: function getId() {
        return this._id;
      },
      toString: function toString() {
        return this.url || "";
      },
      update: function update(options) {
        if (options) {
          var updateImg = false;
          void 0 !== options.width && (this.width = options.width);
          void 0 !== options.height && (this.height = options.height);
          if (void 0 !== options.minFilter) {
            this._minFilter = options.minFilter;
            options.minFilter = FilterIndex[options.minFilter];
          }
          if (void 0 !== options.magFilter) {
            this._magFilter = options.magFilter;
            options.magFilter = FilterIndex[options.magFilter];
          }
          if (void 0 !== options.mipFilter) {
            this._mipFilter = options.mipFilter;
            options.mipFilter = FilterIndex[options.mipFilter];
          }
          void 0 !== options.wrapS && (this._wrapS = options.wrapS);
          void 0 !== options.wrapT && (this._wrapT = options.wrapT);
          void 0 !== options.format && (this._format = options.format);
          if (void 0 !== options.flipY) {
            this._flipY = options.flipY;
            updateImg = true;
          }
          if (void 0 !== options.premultiplyAlpha) {
            this._premultiplyAlpha = options.premultiplyAlpha;
            updateImg = true;
          }
          void 0 !== options.mipmap && (this._hasMipmap = options.mipmap);
          updateImg && this._image && (options.image = this._image);
          if (options.images && options.images.length > 0) this._image = options.images[0]; else if (void 0 !== options.image) {
            this._image = options.image;
            if (!options.images) {
              _images.length = 0;
              options.images = _images;
            }
            options.images.push(options.image);
          }
          options.images && options.images.length > 0 && this._texture.update(options);
          this._hashDirty = true;
        }
      },
      initWithElement: function initWithElement(element) {
        if (!element) return;
        this._image = element;
        if ((false, false) || element.complete || element instanceof HTMLCanvasElement) this.handleLoadedTexture(); else {
          var self = this;
          element.addEventListener("load", (function() {
            self.handleLoadedTexture();
          }));
          element.addEventListener("error", (function(err) {
            cc.warnID(3119, err.message);
          }));
        }
      },
      initWithData: function initWithData(data, pixelFormat, pixelsWidth, pixelsHeight) {
        var opts = _getSharedOptions();
        opts.image = data;
        opts.images = [ opts.image ];
        opts.hasMipmap = this._hasMipmap;
        opts.premultiplyAlpha = this._premultiplyAlpha;
        opts.flipY = this._flipY;
        opts.minFilter = FilterIndex[this._minFilter];
        opts.magFilter = FilterIndex[this._magFilter];
        opts.wrapS = this._wrapS;
        opts.wrapT = this._wrapT;
        opts.format = pixelFormat;
        pixelFormat === PixelFormat.RGBA_ETC1 && (opts.format = PixelFormat.RGB_ETC1);
        opts.width = pixelsWidth;
        opts.height = pixelsHeight;
        this._texture ? this._texture.update(opts) : this._texture = new renderer.Texture2D(renderer.device, opts);
        this.width = pixelsWidth;
        this.height = pixelsHeight;
        this.loaded = true;
        this.emit("load");
        return true;
      },
      getHtmlElementObj: function getHtmlElementObj() {
        return this._image;
      },
      destroy: function destroy() {
        this._image = null;
        this._texture && this._texture.destroy();
        this._super();
      },
      getPixelFormat: function getPixelFormat() {
        return this._format;
      },
      hasPremultipliedAlpha: function hasPremultipliedAlpha() {
        return this._premultiplyAlpha || false;
      },
      hasMipmap: function hasMipmap() {
        return this._hasMipmap || false;
      },
      handleLoadedTexture: function handleLoadedTexture() {
        if (!this._image || !this._image.width || !this._image.height) return;
        this.width = this._image.width;
        this.height = this._image.height;
        var opts = _getSharedOptions();
        opts.image = this._image;
        opts.images = [ opts.image ];
        opts.width = this.width;
        opts.height = this.height;
        opts.hasMipmap = this._hasMipmap;
        opts.format = this._format;
        this._format === PixelFormat.RGBA_ETC1 && (opts.format = PixelFormat.RGB_ETC1);
        opts.premultiplyAlpha = this._premultiplyAlpha;
        opts.flipY = this._flipY;
        opts.minFilter = FilterIndex[this._minFilter];
        opts.magFilter = FilterIndex[this._magFilter];
        opts.wrapS = this._wrapS;
        opts.wrapT = this._wrapT;
        this._texture ? this._texture.update(opts) : this._texture = new renderer.Texture2D(renderer.device, opts);
        this.loaded = true;
        this.emit("load");
        cc.macro.CLEANUP_IMAGE_CACHE && this._image instanceof HTMLImageElement && this._clearImage();
      },
      description: function description() {
        return "<cc.Texture2D | Name = " + this.url + " | Dimensions = " + this.width + " x " + this.height + ">";
      },
      releaseTexture: function releaseTexture() {
        this._image = null;
        this._texture && this._texture.destroy();
      },
      setWrapMode: function setWrapMode(wrapS, wrapT) {
        if (this._wrapS !== wrapS || this._wrapT !== wrapT) {
          var opts = _getSharedOptions();
          opts.wrapS = wrapS;
          opts.wrapT = wrapT;
          this.update(opts);
        }
      },
      setFilters: function setFilters(minFilter, magFilter) {
        if (this._minFilter !== minFilter || this._magFilter !== magFilter) {
          var opts = _getSharedOptions();
          opts.minFilter = minFilter;
          opts.magFilter = magFilter;
          this.update(opts);
        }
      },
      setFlipY: function setFlipY(flipY) {
        if (this._flipY !== flipY) {
          var opts = _getSharedOptions();
          opts.flipY = flipY;
          this.update(opts);
        }
      },
      setPremultiplyAlpha: function setPremultiplyAlpha(premultiply) {
        if (this._premultiplyAlpha !== premultiply) {
          var opts = _getSharedOptions();
          opts.premultiplyAlpha = premultiply;
          this.update(opts);
        }
      },
      setMipmap: function setMipmap(mipmap) {
        if (this._hasMipmap !== mipmap) {
          var opts = _getSharedOptions();
          opts.mipmap = mipmap;
          this.update(opts);
        }
      },
      _getOpts: function _getOpts() {
        var opts = _getSharedOptions();
        opts.width = this.width;
        opts.height = this.height;
        opts.mipmap = this._genMipmap;
        opts.format = this._format;
        opts.premultiplyAlpha = this._premultiplyAlpha;
        opts.anisotropy = this._anisotropy;
        opts.flipY = this._flipY;
        opts.minFilter = FilterIndex[this._minFilter];
        opts.magFilter = FilterIndex[this._magFilter];
        opts.mipFilter = FilterIndex[this._mipFilter];
        opts.wrapS = this._wrapS;
        opts.wrapT = this._wrapT;
        return opts;
      },
      _resetUnderlyingMipmaps: function _resetUnderlyingMipmaps(mipmapSources) {
        var opts = this._getOpts();
        opts.images = mipmapSources || [ null ];
        this._texture ? this._texture.update(opts) : this._texture = new renderer.Texture2D(renderer.device, opts);
      },
      _serialize: (false, false) && function() {
        var extId = "";
        var exportedExts = this._exportedExts;
        !exportedExts && this._native && (exportedExts = [ this._native ]);
        if (exportedExts) {
          var exts = [];
          for (var i = 0; i < exportedExts.length; i++) {
            var _extId = "";
            var ext = exportedExts[i];
            if (ext) {
              var extFormat = ext.split("@");
              _extId = Texture2D.extnames.indexOf(extFormat[0]);
              _extId < 0 && (_extId = ext);
              extFormat[1] && (_extId += "@" + extFormat[1]);
            }
            exts.push(_extId);
          }
          extId = exts.join("_");
        }
        var asset = extId + "," + this._minFilter + "," + this._magFilter + "," + this._wrapS + "," + this._wrapT + "," + (this._premultiplyAlpha ? 1 : 0);
        return asset;
      },
      _deserialize: function _deserialize(data, handle) {
        var device = cc.renderer.device;
        var fields = data.split(",");
        var extIdStr = fields[0];
        if (extIdStr) {
          var extIds = extIdStr.split("_");
          var defaultExt = "";
          var bestExt = "";
          var bestIndex = 999;
          var bestFormat = this._format;
          var SupportTextureFormats = cc.macro.SUPPORT_TEXTURE_FORMATS;
          for (var i = 0; i < extIds.length; i++) {
            var extFormat = extIds[i].split("@");
            var tmpExt = extFormat[0];
            tmpExt = Texture2D.extnames[tmpExt.charCodeAt(0) - CHAR_CODE_0] || tmpExt;
            var index = SupportTextureFormats.indexOf(tmpExt);
            if (-1 !== index && index < bestIndex) {
              var tmpFormat = extFormat[1] ? parseInt(extFormat[1]) : this._format;
              if (".pvr" === tmpExt && !device.ext("WEBGL_compressed_texture_pvrtc")) continue;
              if (!(tmpFormat !== PixelFormat.RGB_ETC1 && tmpFormat !== PixelFormat.RGBA_ETC1 || device.ext("WEBGL_compressed_texture_etc1"))) continue;
              if ((tmpFormat === PixelFormat.RGB_ETC2 || tmpFormat === PixelFormat.RGBA_ETC2) && !device.ext("WEBGL_compressed_texture_etc")) continue;
              bestIndex = index;
              bestExt = tmpExt;
              bestFormat = tmpFormat;
            } else defaultExt || (defaultExt = tmpExt);
          }
          if (bestExt) {
            this._setRawAsset(bestExt);
            this._format = bestFormat;
          } else {
            this._setRawAsset(defaultExt);
            cc.warnID(3120, handle.customEnv.url, defaultExt, defaultExt);
          }
        }
        if (6 === fields.length) {
          this._minFilter = parseInt(fields[1]);
          this._magFilter = parseInt(fields[2]);
          this._wrapS = parseInt(fields[3]);
          this._wrapT = parseInt(fields[4]);
          this._premultiplyAlpha = fields[5].charCodeAt(0) === CHAR_CODE_1;
        }
      },
      _getHash: function _getHash() {
        if (!this._hashDirty) return this._hash;
        var hasMipmap = this._hasMipmap ? 1 : 0;
        var premultiplyAlpha = this._premultiplyAlpha ? 1 : 0;
        var flipY = this._flipY ? 1 : 0;
        var minFilter = this._minFilter === Filter.LINEAR ? 1 : 2;
        var magFilter = this._magFilter === Filter.LINEAR ? 1 : 2;
        var wrapS = this._wrapS === WrapMode.REPEAT ? 1 : this._wrapS === WrapMode.CLAMP_TO_EDGE ? 2 : 3;
        var wrapT = this._wrapT === WrapMode.REPEAT ? 1 : this._wrapT === WrapMode.CLAMP_TO_EDGE ? 2 : 3;
        var pixelFormat = this._format;
        var image = this._image;
        false;
        this._hash = Number("" + minFilter + magFilter + pixelFormat + wrapS + wrapT + hasMipmap + premultiplyAlpha + flipY);
        this._hashDirty = false;
        return this._hash;
      },
      _isCompressed: function _isCompressed() {
        return this._texture && this._texture._compressed;
      },
      _clearImage: function _clearImage() {
        cc.loader.removeItem(this._image.id || this._image.src);
        this._image.src = "";
      }
    });
    cc.Texture2D = module.exports = Texture2D;
  }), {
    "../../renderer/gfx": 233,
    "../assets/CCAsset": 10,
    "../event/event-target": 72,
    "../platform/CCClass": 104,
    "../platform/id-generater": 120,
    "../renderer": 147
  } ],
  28: [ (function(require, module, exports) {
    "use strict";
    require("./CCRawAsset");
    require("./CCAsset");
    require("./CCFont");
    require("./CCPrefab");
    require("./CCAudioClip");
    require("./CCScripts");
    require("./CCSceneAsset");
    require("./CCSpriteFrame");
    require("./CCTexture2D");
    require("./CCRenderTexture");
    require("./CCTTFFont");
    require("./CCSpriteAtlas");
    require("./CCBitmapFont");
    require("./CCLabelAtlas");
    require("./CCTextAsset");
    require("./CCJsonAsset");
    require("./CCBufferAsset");
    require("./CCEffectAsset");
    require("./material/CCMaterial");
  }), {
    "./CCAsset": 10,
    "./CCAudioClip": 11,
    "./CCBitmapFont": 12,
    "./CCBufferAsset": 13,
    "./CCEffectAsset": 14,
    "./CCFont": 15,
    "./CCJsonAsset": 16,
    "./CCLabelAtlas": 17,
    "./CCPrefab": 18,
    "./CCRawAsset": 19,
    "./CCRenderTexture": 20,
    "./CCSceneAsset": 21,
    "./CCScripts": 22,
    "./CCSpriteAtlas": 23,
    "./CCSpriteFrame": 24,
    "./CCTTFFont": 25,
    "./CCTextAsset": 26,
    "./CCTexture2D": 27,
    "./material/CCMaterial": 29
  } ],
  29: [ (function(require, module, exports) {
    "use strict";
    var _effect = require("../../../renderer/core/effect");
    var _effect2 = _interopRequireDefault(_effect);
    var _murmurhash2_gc = require("./murmurhash2_gc");
    var _murmurhash2_gc2 = _interopRequireDefault(_murmurhash2_gc);
    var _utils = require("./utils");
    var _utils2 = _interopRequireDefault(_utils);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Asset = require("../CCAsset");
    var Texture = require("../CCTexture2D");
    var PixelFormat = Texture.PixelFormat;
    var EffectAsset = require("../CCEffectAsset");
    var Material = cc.Class({
      name: "cc.Material",
      extends: Asset,
      ctor: function ctor() {
        this._dirty = true;
        this._effect = null;
        this._owner = null;
      },
      properties: {
        _effectAsset: {
          type: EffectAsset,
          default: null
        },
        _defines: {
          default: {},
          type: Object
        },
        _props: {
          default: {},
          type: Object
        },
        effectName: void 0,
        effectAsset: {
          get: function get() {
            return this._effectAsset;
          },
          set: function set(asset) {
            if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) return;
            this._effectAsset = asset;
            if (!asset) {
              cc.error("Can not set an empty effect asset.");
              return;
            }
            this._effect = _effect2.default.parseEffect(asset);
          }
        },
        effect: {
          get: function get() {
            return this._effect;
          }
        },
        owner: {
          get: function get() {
            return this._owner;
          }
        }
      },
      statics: {
        getBuiltinMaterial: function getBuiltinMaterial(name) {
          return cc.AssetLibrary.getBuiltin("material", "builtin-" + name);
        },
        getInstantiatedBuiltinMaterial: function getInstantiatedBuiltinMaterial(name, renderComponent) {
          var builtinMaterial = this.getBuiltinMaterial(name);
          return Material.getInstantiatedMaterial(builtinMaterial, renderComponent);
        },
        getInstantiatedMaterial: function getInstantiatedMaterial(mat, renderComponent) {
          if (mat._owner === renderComponent) return mat;
          var instance = new Material();
          instance.copy(mat);
          instance._name = mat._name + " (Instance)";
          instance._uuid = mat._uuid;
          instance._owner = renderComponent;
          return instance;
        }
      },
      copy: function copy(mat) {
        this.effectAsset = mat.effectAsset;
        for (var name in mat._defines) this.define(name, mat._defines[name]);
        for (var _name in mat._props) this.setProperty(_name, mat._props[_name]);
      },
      setProperty: function setProperty(name, val, force) {
        if (this._props[name] === val && !force) return;
        this._props[name] = val;
        this._dirty = true;
        if (this._effect) if (val instanceof Texture) {
          this._effect.setProperty(name, val.getImpl());
          val.getPixelFormat() === PixelFormat.RGBA_ETC1 && this.define("_USE_ETC1_" + name.toUpperCase(), true);
        } else this._effect.setProperty(name, val);
      },
      getProperty: function getProperty(name) {
        return this._props[name];
      },
      define: function define(name, val, force) {
        if (this._defines[name] === val && !force) return;
        this._defines[name] = val;
        this._dirty = true;
        this._effect && this._effect.define(name, val);
      },
      getDefine: function getDefine(name) {
        return this._defines[name];
      },
      setDirty: function setDirty(dirty) {
        this._dirty = dirty;
      },
      updateHash: function updateHash(hash) {
        this._dirty = false;
        this._hash = hash;
      },
      getHash: function getHash() {
        if (!this._dirty) return this._hash;
        this._dirty = false;
        var effect = this._effect;
        var hashStr = "";
        if (effect) {
          hashStr += _utils2.default.serializeDefines(effect._defines);
          hashStr += _utils2.default.serializeTechniques(effect._techniques);
          hashStr += _utils2.default.serializeUniforms(effect._properties);
        }
        return this._hash = (0, _murmurhash2_gc2.default)(hashStr, 666);
      },
      onLoad: function onLoad() {
        this.effectAsset = this._effectAsset;
        if (!this._effect) return;
        for (var def in this._defines) this.define(def, this._defines[def], true);
        for (var prop in this._props) this.setProperty(prop, this._props[prop], true);
      }
    });
    module.exports = cc.Material = Material;
  }), {
    "../../../renderer/core/effect": 222,
    "../CCAsset": 10,
    "../CCEffectAsset": 14,
    "../CCTexture2D": 27,
    "./murmurhash2_gc": 30,
    "./utils": 31
  } ],
  30: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = murmurhash2_32_gc;
    function murmurhash2_32_gc(str, seed) {
      var l = str.length, h = seed ^ l, i = 0, k;
      while (l >= 4) {
        k = 255 & str.charCodeAt(i) | (255 & str.charCodeAt(++i)) << 8 | (255 & str.charCodeAt(++i)) << 16 | (255 & str.charCodeAt(++i)) << 24;
        k = 1540483477 * (65535 & k) + ((1540483477 * (k >>> 16) & 65535) << 16);
        k ^= k >>> 24;
        k = 1540483477 * (65535 & k) + ((1540483477 * (k >>> 16) & 65535) << 16);
        h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16) ^ k;
        l -= 4;
        ++i;
      }
      switch (l) {
       case 3:
        h ^= (255 & str.charCodeAt(i + 2)) << 16;

       case 2:
        h ^= (255 & str.charCodeAt(i + 1)) << 8;

       case 1:
        h ^= 255 & str.charCodeAt(i);
        h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16);
      }
      h ^= h >>> 13;
      h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16);
      h ^= h >>> 15;
      return h >>> 0;
    }
    module.exports = exports["default"];
  }), {} ],
  31: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _enums = require("../../../renderer/enums");
    var _enums2 = _interopRequireDefault(_enums);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function serializeDefines(defines) {
      var str = "";
      for (var name in defines) str += name + defines[name];
      return str;
    }
    function serializePass(pass) {
      var str = pass._programName + pass._cullMode;
      pass._blend && (str += pass._blendEq + pass._blendAlphaEq + pass._blendSrc + pass._blendDst + pass._blendSrcAlpha + pass._blendDstAlpha + pass._blendColor);
      pass._depthTest && (str += pass._depthWrite + pass._depthFunc);
      pass._stencilTest && (str += pass._stencilFuncFront + pass._stencilRefFront + pass._stencilMaskFront + pass._stencilFailOpFront + pass._stencilZFailOpFront + pass._stencilZPassOpFront + pass._stencilWriteMaskFront + pass._stencilFuncBack + pass._stencilRefBack + pass._stencilMaskBack + pass._stencilFailOpBack + pass._stencilZFailOpBack + pass._stencilZPassOpBack + pass._stencilWriteMaskBack);
      return str;
    }
    function serializeTechniques(techniques) {
      var hashData = "";
      for (var i = 0; i < techniques.length; i++) {
        var techData = techniques[i];
        hashData += techData.stageIDs;
        for (var j = 0; j < techData.passes.length; j++) hashData += serializePass(techData.passes[j]);
      }
      return hashData;
    }
    function serializeUniforms(uniforms) {
      var hashData = "";
      for (var name in uniforms) {
        var param = uniforms[name];
        var prop = param.value;
        if (!prop) continue;
        switch (param.type) {
         case _enums2.default.PARAM_INT:
         case _enums2.default.PARAM_FLOAT:
          hashData += prop + ";";
          break;

         case _enums2.default.PARAM_INT2:
         case _enums2.default.PARAM_FLOAT2:
          hashData += prop.x + "," + prop.y + ";";
          break;

         case _enums2.default.PARAM_INT4:
         case _enums2.default.PARAM_FLOAT4:
          hashData += prop.x + "," + prop.y + "," + prop.z + "," + prop.w + ";";
          break;

         case _enums2.default.PARAM_COLOR4:
          hashData += prop.r + "," + prop.g + "," + prop.b + "," + prop.a + ";";
          break;

         case _enums2.default.PARAM_MAT2:
          hashData += prop.m00 + "," + prop.m01 + "," + prop.m02 + "," + prop.m03 + ";";
          break;

         case _enums2.default.PARAM_TEXTURE_2D:
         case _enums2.default.PARAM_TEXTURE_CUBE:
          hashData += prop._id + ";";
          break;

         case _enums2.default.PARAM_INT3:
         case _enums2.default.PARAM_FLOAT3:
         case _enums2.default.PARAM_COLOR3:
         case _enums2.default.PARAM_MAT3:
         case _enums2.default.PARAM_MAT4:
          hashData += JSON.stringify(prop) + ";";
        }
      }
      return hashData;
    }
    exports.default = {
      serializeDefines: serializeDefines,
      serializeTechniques: serializeTechniques,
      serializeUniforms: serializeUniforms
    };
    module.exports = exports["default"];
  }), {
    "../../../renderer/enums": 228
  } ],
  32: [ (function(require, module, exports) {
    "use strict";
    var Event = require("../CCNode").EventType;
    var TOP = 1;
    var MID = 2;
    var BOT = 4;
    var LEFT = 8;
    var CENTER = 16;
    var RIGHT = 32;
    var HORIZONTAL = LEFT | CENTER | RIGHT;
    var VERTICAL = TOP | MID | BOT;
    var AlignMode = cc.Enum({
      ONCE: 0,
      ON_WINDOW_RESIZE: 1,
      ALWAYS: 2
    });
    function getReadonlyNodeSize(parent) {
      return parent instanceof cc.Scene ? cc.visibleRect : parent._contentSize;
    }
    function computeInverseTransForTarget(widgetNode, target, out_inverseTranslate, out_inverseScale) {
      var scaleX = widgetNode._parent._scale.x;
      var scaleY = widgetNode._parent._scale.y;
      var translateX = 0;
      var translateY = 0;
      for (var node = widgetNode._parent; ;) {
        var pos = node._position;
        translateX += pos.x;
        translateY += pos.y;
        node = node._parent;
        if (!node) {
          out_inverseTranslate.x = out_inverseTranslate.y = 0;
          out_inverseScale.x = out_inverseScale.y = 1;
          return;
        }
        if (node === target) break;
        var sx = node._scale.x;
        var sy = node._scale.y;
        translateX *= sx;
        translateY *= sy;
        scaleX *= sx;
        scaleY *= sy;
      }
      out_inverseScale.x = 0 !== scaleX ? 1 / scaleX : 1;
      out_inverseScale.y = 0 !== scaleY ? 1 / scaleY : 1;
      out_inverseTranslate.x = -translateX;
      out_inverseTranslate.y = -translateY;
    }
    var tInverseTranslate = cc.Vec2.ZERO;
    var tInverseScale = cc.Vec2.ONE;
    function align(node, widget) {
      var hasTarget = widget._target;
      var target;
      var inverseTranslate, inverseScale;
      if (hasTarget) {
        target = hasTarget;
        inverseTranslate = tInverseTranslate;
        inverseScale = tInverseScale;
        computeInverseTransForTarget(node, target, inverseTranslate, inverseScale);
      } else target = node._parent;
      var targetSize = getReadonlyNodeSize(target);
      var targetAnchor = target._anchorPoint;
      var isRoot = (true, target instanceof cc.Scene);
      var x = node._position.x, y = node._position.y;
      var anchor = node._anchorPoint;
      if (widget._alignFlags & HORIZONTAL) {
        var localLeft, localRight, targetWidth = targetSize.width;
        if (isRoot) {
          localLeft = cc.visibleRect.left.x;
          localRight = cc.visibleRect.right.x;
        } else {
          localLeft = -targetAnchor.x * targetWidth;
          localRight = localLeft + targetWidth;
        }
        localLeft += widget._isAbsLeft ? widget._left : widget._left * targetWidth;
        localRight -= widget._isAbsRight ? widget._right : widget._right * targetWidth;
        if (hasTarget) {
          localLeft += inverseTranslate.x;
          localLeft *= inverseScale.x;
          localRight += inverseTranslate.x;
          localRight *= inverseScale.x;
        }
        var width, anchorX = anchor.x, scaleX = node._scale.x;
        if (scaleX < 0) {
          anchorX = 1 - anchorX;
          scaleX = -scaleX;
        }
        if (widget.isStretchWidth) {
          width = localRight - localLeft;
          0 !== scaleX && (node.width = width / scaleX);
          x = localLeft + anchorX * width;
        } else {
          width = node.width * scaleX;
          if (widget.isAlignHorizontalCenter) {
            var localHorizontalCenter = widget._isAbsHorizontalCenter ? widget._horizontalCenter : widget._horizontalCenter * targetWidth;
            var targetCenter = (.5 - targetAnchor.x) * targetSize.width;
            if (hasTarget) {
              localHorizontalCenter *= inverseScale.x;
              targetCenter += inverseTranslate.x;
              targetCenter *= inverseScale.x;
            }
            x = targetCenter + (anchorX - .5) * width + localHorizontalCenter;
          } else x = widget.isAlignLeft ? localLeft + anchorX * width : localRight + (anchorX - 1) * width;
        }
      }
      if (widget._alignFlags & VERTICAL) {
        var localTop, localBottom, targetHeight = targetSize.height;
        if (isRoot) {
          localBottom = cc.visibleRect.bottom.y;
          localTop = cc.visibleRect.top.y;
        } else {
          localBottom = -targetAnchor.y * targetHeight;
          localTop = localBottom + targetHeight;
        }
        localBottom += widget._isAbsBottom ? widget._bottom : widget._bottom * targetHeight;
        localTop -= widget._isAbsTop ? widget._top : widget._top * targetHeight;
        if (hasTarget) {
          localBottom += inverseTranslate.y;
          localBottom *= inverseScale.y;
          localTop += inverseTranslate.y;
          localTop *= inverseScale.y;
        }
        var height, anchorY = anchor.y, scaleY = node._scale.y;
        if (scaleY < 0) {
          anchorY = 1 - anchorY;
          scaleY = -scaleY;
        }
        if (widget.isStretchHeight) {
          height = localTop - localBottom;
          0 !== scaleY && (node.height = height / scaleY);
          y = localBottom + anchorY * height;
        } else {
          height = node.height * scaleY;
          if (widget.isAlignVerticalCenter) {
            var localVerticalCenter = widget._isAbsVerticalCenter ? widget._verticalCenter : widget._verticalCenter * targetHeight;
            var targetMiddle = (.5 - targetAnchor.y) * targetSize.height;
            if (hasTarget) {
              localVerticalCenter *= inverseScale.y;
              targetMiddle += inverseTranslate.y;
              targetMiddle *= inverseScale.y;
            }
            y = targetMiddle + (anchorY - .5) * height + localVerticalCenter;
          } else y = widget.isAlignBottom ? localBottom + anchorY * height : localTop + (anchorY - 1) * height;
        }
      }
      node.setPosition(x, y);
    }
    function visitNode(node) {
      var widget = node._widget;
      if (widget) {
        false;
        align(node, widget);
        true, widget.alignMode !== AlignMode.ALWAYS ? widget.enabled = false : activeWidgets.push(widget);
      }
      var children = node._children;
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        child._active && visitNode(child);
      }
    }
    var animationState;
    false;
    function refreshScene() {
      var AnimUtils;
      var EditMode;
      var nowPreviewing;
      var component;
      var animation;
      var _component;
      var _animation;
      false;
      var scene = cc.director.getScene();
      if (scene) {
        widgetManager.isAligning = true;
        if (widgetManager._nodesOrderDirty) {
          activeWidgets.length = 0;
          visitNode(scene);
          widgetManager._nodesOrderDirty = false;
        } else {
          var i, widget, iterator = widgetManager._activeWidgetsIterator;
          var AnimUtils;
          var editingNode;
          var node;
          false;
          for (iterator.i = 0; iterator.i < activeWidgets.length; ++iterator.i) {
            widget = activeWidgets[iterator.i];
            align(widget.node, widget);
          }
        }
        widgetManager.isAligning = false;
      }
      false;
    }
    var adjustWidgetToAllowMovingInEditor = false;
    var adjustWidgetToAllowResizingInEditor = false;
    var activeWidgets = [];
    function updateAlignment(node) {
      var parent = node._parent;
      cc.Node.isNode(parent) && updateAlignment(parent);
      var widget = node._widget || node.getComponent(cc.Widget);
      widget && parent && align(node, widget);
    }
    var widgetManager = cc._widgetManager = module.exports = {
      _AlignFlags: {
        TOP: TOP,
        MID: MID,
        BOT: BOT,
        LEFT: LEFT,
        CENTER: CENTER,
        RIGHT: RIGHT
      },
      isAligning: false,
      _nodesOrderDirty: false,
      _activeWidgetsIterator: new cc.js.array.MutableForwardIterator(activeWidgets),
      init: function init(director) {
        director.on(cc.Director.EVENT_AFTER_UPDATE, refreshScene);
        false;
        cc.sys.isMobile ? window.addEventListener("resize", this.onResized.bind(this)) : cc.view.on("canvas-resize", this.onResized, this);
      },
      add: function add(widget) {
        widget.node._widget = widget;
        this._nodesOrderDirty = true;
        false;
      },
      remove: function remove(widget) {
        widget.node._widget = null;
        this._activeWidgetsIterator.remove(widget);
        false;
      },
      onResized: function onResized() {
        var scene = cc.director.getScene();
        scene && this.refreshWidgetOnResized(scene);
      },
      refreshWidgetOnResized: function refreshWidgetOnResized(node) {
        var widget = cc.Node.isNode(node) && node.getComponent(cc.Widget);
        widget && widget.alignMode === AlignMode.ON_WINDOW_RESIZE && (widget.enabled = true);
        var children = node._children;
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          this.refreshWidgetOnResized(child);
        }
      },
      updateAlignment: updateAlignment,
      AlignMode: AlignMode
    };
    false;
  }), {
    "../CCNode": 6
  } ],
  33: [ (function(require, module, exports) {
    "use strict";
    var _geomUtils = require("../geom-utils");
    var _geomUtils2 = _interopRequireDefault(_geomUtils);
    var _camera = require("../../renderer/scene/camera");
    var _camera2 = _interopRequireDefault(_camera);
    var _view = require("../../renderer/core/view");
    var _view2 = _interopRequireDefault(_view);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var AffineTrans = require("../utils/affine-transform");
    var renderer = require("../renderer/index");
    var RenderFlow = require("../renderer/render-flow");
    var game = require("../CCGame");
    var mat4 = cc.vmath.mat4;
    var vec2 = cc.vmath.vec2;
    var vec3 = cc.vmath.vec3;
    var _mat4_temp_1 = mat4.create();
    var _mat4_temp_2 = mat4.create();
    var _v3_temp_1 = vec3.create();
    var _v3_temp_2 = vec3.create();
    var _v3_temp_3 = vec3.create();
    var _cameras = [];
    var _debugCamera = null;
    function repositionDebugCamera() {
      if (!_debugCamera) return;
      var node = _debugCamera.getNode();
      var canvas = cc.game.canvas;
      node.z = canvas.height / 1.1566;
      node.x = canvas.width / 2;
      node.y = canvas.height / 2;
    }
    var ClearFlags = cc.Enum({
      COLOR: 1,
      DEPTH: 2,
      STENCIL: 4
    });
    var StageFlags = cc.Enum({
      OPAQUE: 1,
      TRANSPARENT: 2
    });
    var Camera = cc.Class({
      name: "cc.Camera",
      extends: cc.Component,
      ctor: function ctor() {
        if (game.renderType !== game.RENDER_TYPE_CANVAS) {
          var camera = new _camera2.default();
          camera.setStages([ "opaque" ]);
          camera.dirty = true;
          this._inited = false;
          this._camera = camera;
        } else this._inited = true;
      },
      editor: false,
      properties: {
        _cullingMask: 4294967295,
        _clearFlags: ClearFlags.DEPTH | ClearFlags.STENCIL,
        _backgroundColor: cc.color(0, 0, 0, 255),
        _depth: 0,
        _zoomRatio: 1,
        _targetTexture: null,
        _fov: 60,
        _orthoSize: 10,
        _nearClip: 1,
        _farClip: 4096,
        _ortho: true,
        _rect: cc.rect(0, 0, 1, 1),
        _renderStages: 1,
        zoomRatio: {
          get: function get() {
            return this._zoomRatio;
          },
          set: function set(value) {
            this._zoomRatio = value;
          }
        },
        fov: {
          get: function get() {
            return this._fov;
          },
          set: function set(v) {
            this._fov = v;
          }
        },
        orthoSize: {
          get: function get() {
            return this._orthoSize;
          },
          set: function set(v) {
            this._orthoSize = v;
          }
        },
        nearClip: {
          get: function get() {
            return this._nearClip;
          },
          set: function set(v) {
            this._nearClip = v;
            this._updateClippingpPlanes();
          }
        },
        farClip: {
          get: function get() {
            return this._farClip;
          },
          set: function set(v) {
            this._farClip = v;
            this._updateClippingpPlanes();
          }
        },
        ortho: {
          get: function get() {
            return this._ortho;
          },
          set: function set(v) {
            this._ortho = v;
            this._updateProjection();
          }
        },
        rect: {
          get: function get() {
            return this._rect;
          },
          set: function set(v) {
            this._rect = v;
            this._updateRect();
          }
        },
        cullingMask: {
          get: function get() {
            return this._cullingMask;
          },
          set: function set(value) {
            this._cullingMask = value;
            this._updateCameraMask();
          }
        },
        clearFlags: {
          get: function get() {
            return this._clearFlags;
          },
          set: function set(value) {
            this._clearFlags = value;
            this._camera && this._camera.setClearFlags(value);
          }
        },
        backgroundColor: {
          get: function get() {
            return this._backgroundColor;
          },
          set: function set(value) {
            this._backgroundColor = value;
            this._updateBackgroundColor();
          }
        },
        depth: {
          get: function get() {
            return this._depth;
          },
          set: function set(value) {
            this._depth = value;
            this._camera && (this._camera._priority = value);
          }
        },
        targetTexture: {
          get: function get() {
            return this._targetTexture;
          },
          set: function set(value) {
            this._targetTexture = value;
            this._updateTargetTexture();
          }
        },
        renderStages: {
          get: function get() {
            return this._renderStages;
          },
          set: function set(val) {
            this._renderStages = val;
            this._updateStages();
          }
        },
        _is3D: {
          get: function get() {
            return this.node && this.node._is3DNode;
          }
        }
      },
      statics: {
        main: null,
        cameras: _cameras,
        ClearFlags: ClearFlags,
        findCamera: function findCamera(node) {
          for (var i = 0, l = _cameras.length; i < l; i++) {
            var camera = _cameras[i];
            if (camera.containsNode(node)) return camera;
          }
          return null;
        },
        _findRendererCamera: function _findRendererCamera(node) {
          var cameras = renderer.scene._cameras;
          for (var i = 0; i < cameras._count; i++) if (cameras._data[i]._cullingMask & node._cullingMask) return cameras._data[i];
          return null;
        },
        _setupDebugCamera: function _setupDebugCamera() {
          if (_debugCamera) return;
          if (game.renderType === game.RENDER_TYPE_CANVAS) return;
          var camera = new _camera2.default();
          _debugCamera = camera;
          camera.setStages([ "opaque" ]);
          camera.setFov(60 * Math.PI / 180);
          camera.setNear(.1);
          camera.setFar(4096);
          camera.dirty = true;
          camera._cullingMask = 1 << cc.Node.BuiltinGroupIndex.DEBUG;
          camera._priority = cc.macro.MAX_ZINDEX;
          camera.setClearFlags(0);
          camera.setColor(0, 0, 0, 0);
          var node = new cc.Node();
          camera.setNode(node);
          repositionDebugCamera();
          cc.view.on("design-resolution-changed", repositionDebugCamera);
          renderer.scene.addCamera(camera);
        }
      },
      _updateCameraMask: function _updateCameraMask() {
        if (this._camera) {
          var mask = this._cullingMask & ~(1 << cc.Node.BuiltinGroupIndex.DEBUG);
          this._camera._cullingMask = mask;
        }
      },
      _updateBackgroundColor: function _updateBackgroundColor() {
        if (!this._camera) return;
        var color = this._backgroundColor;
        this._camera.setColor(color.r / 255, color.g / 255, color.b / 255, color.a / 255);
      },
      _updateTargetTexture: function _updateTargetTexture() {
        if (!this._camera) return;
        var texture = this._targetTexture;
        this._camera._framebuffer = texture ? texture._framebuffer : null;
      },
      _updateClippingpPlanes: function _updateClippingpPlanes() {
        if (!this._camera) return;
        this._camera.setNear(this._nearClip);
        this._camera.setFar(this._farClip);
      },
      _updateProjection: function _updateProjection() {
        if (!this._camera) return;
        var type = this._ortho ? 1 : 0;
        this._camera.setType(type);
      },
      _updateRect: function _updateRect() {
        if (!this._camera) return;
        this._camera.setRect(this._rect);
      },
      _updateStages: function _updateStages() {
        var flags = this._renderStages;
        var stages = this._camera._stages;
        stages.length = 0;
        flags & StageFlags.OPAQUE && stages.push("opaque");
        flags & StageFlags.TRANSPARENT && stages.push("transparent");
      },
      _init: function _init() {
        if (this._inited) return;
        this._inited = true;
        var camera = this._camera;
        if (!camera) return;
        camera.setNode(this.node);
        camera.setClearFlags(this._clearFlags);
        camera._priority = this._depth;
        this._updateBackgroundColor();
        this._updateCameraMask();
        this._updateTargetTexture();
        this._updateClippingpPlanes();
        this._updateProjection();
        this._updateStages();
      },
      onLoad: function onLoad() {
        this._init();
      },
      onEnable: function onEnable() {
        if (true, game.renderType !== game.RENDER_TYPE_CANVAS) {
          cc.director.on(cc.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this);
          renderer.scene.addCamera(this._camera);
        }
        _cameras.push(this);
      },
      onDisable: function onDisable() {
        if (true, game.renderType !== game.RENDER_TYPE_CANVAS) {
          cc.director.off(cc.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this);
          renderer.scene.removeCamera(this._camera);
        }
        cc.js.array.remove(_cameras, this);
      },
      getNodeToCameraTransform: function getNodeToCameraTransform(node) {
        var out = AffineTrans.identity();
        node.getWorldMatrix(_mat4_temp_2);
        if (this.containsNode(node)) {
          this.getWorldToCameraMatrix(_mat4_temp_1);
          mat4.mul(_mat4_temp_2, _mat4_temp_2, _mat4_temp_1);
        }
        AffineTrans.fromMat4(out, _mat4_temp_2);
        return out;
      },
      getCameraToWorldPoint: function getCameraToWorldPoint(point, out) {
        out = out || cc.v2();
        this.getCameraToWorldMatrix(_mat4_temp_1);
        vec2.transformMat4(out, point, _mat4_temp_1);
        return out;
      },
      getWorldToCameraPoint: function getWorldToCameraPoint(point, out) {
        out = out || cc.v2();
        this.getWorldToCameraMatrix(_mat4_temp_1);
        vec2.transformMat4(out, point, _mat4_temp_1);
        return out;
      },
      getCameraToWorldMatrix: function getCameraToWorldMatrix(out) {
        this.getWorldToCameraMatrix(out);
        mat4.invert(out, out);
        return out;
      },
      getWorldToCameraMatrix: function getWorldToCameraMatrix(out) {
        this.node.getWorldRT(_mat4_temp_1);
        var zoomRatio = this.zoomRatio;
        _mat4_temp_1.m00 *= zoomRatio;
        _mat4_temp_1.m01 *= zoomRatio;
        _mat4_temp_1.m04 *= zoomRatio;
        _mat4_temp_1.m05 *= zoomRatio;
        var m12 = _mat4_temp_1.m12;
        var m13 = _mat4_temp_1.m13;
        var center = cc.visibleRect.center;
        _mat4_temp_1.m12 = center.x - (_mat4_temp_1.m00 * m12 + _mat4_temp_1.m04 * m13);
        _mat4_temp_1.m13 = center.y - (_mat4_temp_1.m01 * m12 + _mat4_temp_1.m05 * m13);
        out !== _mat4_temp_1 && mat4.copy(out, _mat4_temp_1);
        return out;
      },
      getRay: function getRay(screenPos) {
        if (!_geomUtils2.default) return screenPos;
        vec3.set(_v3_temp_3, screenPos.x, screenPos.y, 1);
        this._camera.screenToWorld(_v3_temp_2, _v3_temp_3, cc.visibleRect.width, cc.visibleRect.height);
        if (this.ortho) {
          vec3.set(_v3_temp_3, screenPos.x, screenPos.y, -1);
          this._camera.screenToWorld(_v3_temp_1, _v3_temp_3, cc.visibleRect.width, cc.visibleRect.height);
        } else this.node.getWorldPosition(_v3_temp_1);
        return _geomUtils2.default.Ray.fromPoints(_geomUtils2.default.Ray.create(), _v3_temp_1, _v3_temp_2);
      },
      containsNode: function containsNode(node) {
        return node._cullingMask & this.cullingMask;
      },
      render: function render(root) {
        root = root || cc.director.getScene();
        if (!root) return null;
        this.node.getWorldMatrix(_mat4_temp_1);
        this.beforeDraw();
        RenderFlow.visit(root);
        renderer._forward.renderCamera(this._camera, renderer.scene);
      },
      _layout: function _layout() {
        var height = cc.game.canvas.height / cc.view._scaleY;
        var targetTexture = this._targetTexture;
        targetTexture && (height = targetTexture.height);
        var fov = this._fov * cc.macro.RAD;
        this.node.z = height / (2 * Math.tan(fov / 2));
        fov = 2 * Math.atan(Math.tan(fov / 2) / this.zoomRatio);
        this._camera.setFov(fov);
        this._camera.setOrthoHeight(height / 2 / this.zoomRatio);
      },
      beforeDraw: function beforeDraw() {
        if (!this._camera) return;
        if (this.node._is3DNode) {
          this._camera.setFov(this._fov * cc.macro.RAD);
          this._camera.setOrthoHeight(this._orthoSize);
        } else this._layout();
        this._camera.dirty = true;
      }
    });
    module.exports = cc.Camera = Camera;
  }), {
    "../../renderer/core/view": 227,
    "../../renderer/scene/camera": 255,
    "../CCGame": 5,
    "../geom-utils": void 0,
    "../renderer/index": 147,
    "../renderer/render-flow": 148,
    "../utils/affine-transform": 179
  } ],
  34: [ (function(require, module, exports) {
    "use strict";
    var Intersection = {};
    function lineLine(a1, a2, b1, b2) {
      var ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
      var ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
      var u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
      if (0 !== u_b) {
        var ua = ua_t / u_b;
        var ub = ub_t / u_b;
        if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) return true;
      }
      return false;
    }
    Intersection.lineLine = lineLine;
    function lineRect(a1, a2, b) {
      var r0 = new cc.Vec2(b.x, b.y);
      var r1 = new cc.Vec2(b.x, b.yMax);
      var r2 = new cc.Vec2(b.xMax, b.yMax);
      var r3 = new cc.Vec2(b.xMax, b.y);
      if (lineLine(a1, a2, r0, r1)) return true;
      if (lineLine(a1, a2, r1, r2)) return true;
      if (lineLine(a1, a2, r2, r3)) return true;
      if (lineLine(a1, a2, r3, r0)) return true;
      return false;
    }
    Intersection.lineRect = lineRect;
    function linePolygon(a1, a2, b) {
      var length = b.length;
      for (var i = 0; i < length; ++i) {
        var b1 = b[i];
        var b2 = b[(i + 1) % length];
        if (lineLine(a1, a2, b1, b2)) return true;
      }
      return false;
    }
    Intersection.linePolygon = linePolygon;
    function rectRect(a, b) {
      var a_min_x = a.x;
      var a_min_y = a.y;
      var a_max_x = a.x + a.width;
      var a_max_y = a.y + a.height;
      var b_min_x = b.x;
      var b_min_y = b.y;
      var b_max_x = b.x + b.width;
      var b_max_y = b.y + b.height;
      return a_min_x <= b_max_x && a_max_x >= b_min_x && a_min_y <= b_max_y && a_max_y >= b_min_y;
    }
    Intersection.rectRect = rectRect;
    function rectPolygon(a, b) {
      var i, l;
      var r0 = new cc.Vec2(a.x, a.y);
      var r1 = new cc.Vec2(a.x, a.yMax);
      var r2 = new cc.Vec2(a.xMax, a.yMax);
      var r3 = new cc.Vec2(a.xMax, a.y);
      if (linePolygon(r0, r1, b)) return true;
      if (linePolygon(r1, r2, b)) return true;
      if (linePolygon(r2, r3, b)) return true;
      if (linePolygon(r3, r0, b)) return true;
      for (i = 0, l = b.length; i < l; ++i) if (pointInPolygon(b[i], a)) return true;
      if (pointInPolygon(r0, b)) return true;
      if (pointInPolygon(r1, b)) return true;
      if (pointInPolygon(r2, b)) return true;
      if (pointInPolygon(r3, b)) return true;
      return false;
    }
    Intersection.rectPolygon = rectPolygon;
    function polygonPolygon(a, b) {
      var i, l;
      for (i = 0, l = a.length; i < l; ++i) {
        var a1 = a[i];
        var a2 = a[(i + 1) % l];
        if (linePolygon(a1, a2, b)) return true;
      }
      for (i = 0, l = b.length; i < l; ++i) if (pointInPolygon(b[i], a)) return true;
      for (i = 0, l = a.length; i < l; ++i) if (pointInPolygon(a[i], b)) return true;
      return false;
    }
    Intersection.polygonPolygon = polygonPolygon;
    function circleCircle(a, b) {
      var distance = a.position.sub(b.position).mag();
      return distance < a.radius + b.radius;
    }
    Intersection.circleCircle = circleCircle;
    function polygonCircle(polygon, circle) {
      var position = circle.position;
      if (pointInPolygon(position, polygon)) return true;
      for (var i = 0, l = polygon.length; i < l; i++) {
        var start = 0 === i ? polygon[polygon.length - 1] : polygon[i - 1];
        var end = polygon[i];
        if (pointLineDistance(position, start, end, true) < circle.radius) return true;
      }
      return false;
    }
    Intersection.polygonCircle = polygonCircle;
    function pointInPolygon(point, polygon) {
      var inside = false;
      var x = point.x;
      var y = point.y;
      var length = polygon.length;
      for (var i = 0, j = length - 1; i < length; j = i++) {
        var xi = polygon[i].x, yi = polygon[i].y, xj = polygon[j].x, yj = polygon[j].y, intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        intersect && (inside = !inside);
      }
      return inside;
    }
    Intersection.pointInPolygon = pointInPolygon;
    function pointLineDistance(point, start, end, isSegment) {
      var dx = end.x - start.x;
      var dy = end.y - start.y;
      var d = dx * dx + dy * dy;
      var t = ((point.x - start.x) * dx + (point.y - start.y) * dy) / d;
      var p;
      p = isSegment ? d ? t < 0 ? start : t > 1 ? end : cc.v2(start.x + t * dx, start.y + t * dy) : start : cc.v2(start.x + t * dx, start.y + t * dy);
      dx = point.x - p.x;
      dy = point.y - p.y;
      return Math.sqrt(dx * dx + dy * dy);
    }
    Intersection.pointLineDistance = pointLineDistance;
    cc.Intersection = module.exports = Intersection;
  }), {} ],
  35: [ (function(require, module, exports) {
    "use strict";
    require("./platform/CCClass");
    var Flags = require("./platform/CCObject").Flags;
    var jsArray = require("./platform/js").array;
    var IsStartCalled = Flags.IsStartCalled;
    var IsOnEnableCalled = Flags.IsOnEnableCalled;
    var IsEditorOnEnableCalled = Flags.IsEditorOnEnableCalled;
    var callerFunctor = false;
    var callOnEnableInTryCatch = false;
    var callStartInTryCatch = false;
    var callUpdateInTryCatch = false;
    var callLateUpdateInTryCatch = false;
    var callOnDisableInTryCatch = false;
    var callStart = "c.start();c._objFlags|=" + IsStartCalled;
    var callUpdate = "c.update(dt)";
    var callLateUpdate = "c.lateUpdate(dt)";
    function sortedIndex(array, comp) {
      var order = comp.constructor._executionOrder;
      var id = comp._id;
      for (var l = 0, h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
        var test = array[m];
        var testOrder = test.constructor._executionOrder;
        if (testOrder > order) h = m - 1; else if (testOrder < order) l = m + 1; else {
          var testId = test._id;
          if (testId > id) h = m - 1; else {
            if (!(testId < id)) return m;
            l = m + 1;
          }
        }
      }
      return ~l;
    }
    function stableRemoveInactive(iterator, flagToClear) {
      var array = iterator.array;
      var next = iterator.i + 1;
      while (next < array.length) {
        var comp = array[next];
        if (comp._enabled && comp.node._activeInHierarchy) ++next; else {
          iterator.removeAt(next);
          flagToClear && (comp._objFlags &= ~flagToClear);
        }
      }
    }
    var LifeCycleInvoker = cc.Class({
      __ctor__: function __ctor__(invokeFunc) {
        var Iterator = jsArray.MutableForwardIterator;
        this._zero = new Iterator([]);
        this._neg = new Iterator([]);
        this._pos = new Iterator([]);
        false;
        this._invoke = invokeFunc;
      },
      statics: {
        stableRemoveInactive: stableRemoveInactive
      },
      add: null,
      remove: null,
      invoke: null
    });
    function compareOrder(a, b) {
      return a.constructor._executionOrder - b.constructor._executionOrder;
    }
    var OneOffInvoker = cc.Class({
      extends: LifeCycleInvoker,
      add: function add(comp) {
        var order = comp.constructor._executionOrder;
        (0 === order ? this._zero : order < 0 ? this._neg : this._pos).array.push(comp);
      },
      remove: function remove(comp) {
        var order = comp.constructor._executionOrder;
        (0 === order ? this._zero : order < 0 ? this._neg : this._pos).fastRemove(comp);
      },
      cancelInactive: function cancelInactive(flagToClear) {
        stableRemoveInactive(this._zero, flagToClear);
        stableRemoveInactive(this._neg, flagToClear);
        stableRemoveInactive(this._pos, flagToClear);
      },
      invoke: function invoke() {
        var compsNeg = this._neg;
        if (compsNeg.array.length > 0) {
          compsNeg.array.sort(compareOrder);
          this._invoke(compsNeg);
          compsNeg.array.length = 0;
        }
        this._invoke(this._zero);
        this._zero.array.length = 0;
        var compsPos = this._pos;
        if (compsPos.array.length > 0) {
          compsPos.array.sort(compareOrder);
          this._invoke(compsPos);
          compsPos.array.length = 0;
        }
      }
    });
    var ReusableInvoker = cc.Class({
      extends: LifeCycleInvoker,
      add: function add(comp) {
        var order = comp.constructor._executionOrder;
        if (0 === order) this._zero.array.push(comp); else {
          var array = order < 0 ? this._neg.array : this._pos.array;
          var i = sortedIndex(array, comp);
          i < 0 && array.splice(~i, 0, comp);
        }
      },
      remove: function remove(comp) {
        var order = comp.constructor._executionOrder;
        if (0 === order) this._zero.fastRemove(comp); else {
          var iterator = order < 0 ? this._neg : this._pos;
          var i = sortedIndex(iterator.array, comp);
          i >= 0 && iterator.removeAt(i);
        }
      },
      invoke: function invoke(dt) {
        this._neg.array.length > 0 && this._invoke(this._neg, dt);
        this._invoke(this._zero, dt);
        this._pos.array.length > 0 && this._invoke(this._pos, dt);
      }
    });
    function enableInEditor(comp) {
      if (!(comp._objFlags & IsEditorOnEnableCalled)) {
        cc.engine.emit("component-enabled", comp.uuid);
        comp._objFlags |= IsEditorOnEnableCalled;
      }
    }
    function createInvokeImpl(funcOrCode, useDt) {
      if ("function" === typeof funcOrCode) return useDt ? function(iterator, dt) {
        var array = iterator.array;
        for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
          var comp = array[iterator.i];
          funcOrCode(comp, dt);
        }
      } : function(iterator) {
        var array = iterator.array;
        for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
          var comp = array[iterator.i];
          funcOrCode(comp);
        }
      };
      var body = "var a=it.array;for(it.i=0;it.i<a.length;++it.i){var c=a[it.i];" + funcOrCode + "}";
      return useDt ? Function("it", "dt", body) : Function("it", body);
    }
    function ctor() {
      this.startInvoker = new OneOffInvoker(createInvokeImpl(callStart));
      this.updateInvoker = new ReusableInvoker(createInvokeImpl(callUpdate, true));
      this.lateUpdateInvoker = new ReusableInvoker(createInvokeImpl(callLateUpdate, true));
      this.scheduleInNextFrame = [];
      this._updating = false;
    }
    var ComponentScheduler = cc.Class({
      ctor: ctor,
      unscheduleAll: ctor,
      statics: {
        LifeCycleInvoker: LifeCycleInvoker,
        OneOffInvoker: OneOffInvoker,
        createInvokeImpl: createInvokeImpl,
        invokeOnEnable: function(iterator) {
          var compScheduler = cc.director._compScheduler;
          var array = iterator.array;
          for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
            var comp = array[iterator.i];
            if (comp._enabled) {
              comp.onEnable();
              var deactivatedDuringOnEnable = !comp.node._activeInHierarchy;
              deactivatedDuringOnEnable || compScheduler._onEnabled(comp);
            }
          }
        }
      },
      _onEnabled: function _onEnabled(comp) {
        cc.director.getScheduler().resumeTarget(comp);
        comp._objFlags |= IsOnEnableCalled;
        this._updating ? this.scheduleInNextFrame.push(comp) : this._scheduleImmediate(comp);
      },
      _onDisabled: function _onDisabled(comp) {
        cc.director.getScheduler().pauseTarget(comp);
        comp._objFlags &= ~IsOnEnableCalled;
        var index = this.scheduleInNextFrame.indexOf(comp);
        if (index >= 0) {
          jsArray.fastRemoveAt(this.scheduleInNextFrame, index);
          return;
        }
        !comp.start || comp._objFlags & IsStartCalled || this.startInvoker.remove(comp);
        comp.update && this.updateInvoker.remove(comp);
        comp.lateUpdate && this.lateUpdateInvoker.remove(comp);
      },
      enableComp: function(comp, invoker) {
        if (!(comp._objFlags & IsOnEnableCalled)) {
          if (comp.onEnable) {
            if (invoker) {
              invoker.add(comp);
              return;
            }
            comp.onEnable();
            var deactivatedDuringOnEnable = !comp.node._activeInHierarchy;
            if (deactivatedDuringOnEnable) return;
          }
          this._onEnabled(comp);
        }
      },
      disableComp: function(comp) {
        if (comp._objFlags & IsOnEnableCalled) {
          comp.onDisable && comp.onDisable();
          this._onDisabled(comp);
        }
      },
      _scheduleImmediate: function _scheduleImmediate(comp) {
        !comp.start || comp._objFlags & IsStartCalled || this.startInvoker.add(comp);
        comp.update && this.updateInvoker.add(comp);
        comp.lateUpdate && this.lateUpdateInvoker.add(comp);
      },
      _deferredSchedule: function _deferredSchedule() {
        var comps = this.scheduleInNextFrame;
        for (var i = 0, len = comps.length; i < len; i++) {
          var comp = comps[i];
          this._scheduleImmediate(comp);
        }
        comps.length = 0;
      },
      startPhase: function startPhase() {
        this._updating = true;
        this.scheduleInNextFrame.length > 0 && this._deferredSchedule();
        this.startInvoker.invoke();
      },
      updatePhase: function updatePhase(dt) {
        this.updateInvoker.invoke(dt);
      },
      lateUpdatePhase: function lateUpdatePhase(dt) {
        this.lateUpdateInvoker.invoke(dt);
        this._updating = false;
      }
    });
    module.exports = ComponentScheduler;
  }), {
    "./platform/CCClass": 104,
    "./platform/CCObject": 110,
    "./platform/js": 124,
    "./utils/misc": 187
  } ],
  36: [ (function(require, module, exports) {
    "use strict";
    var BlockEvents = [ "touchstart", "touchmove", "touchend", "mousedown", "mousemove", "mouseup", "mouseenter", "mouseleave", "mousewheel" ];
    function stopPropagation(event) {
      event.stopPropagation();
    }
    var BlockInputEvents = cc.Class({
      name: "cc.BlockInputEvents",
      extends: require("./CCComponent"),
      editor: {
        menu: "i18n:MAIN_MENU.component.ui/Block Input Events",
        inspector: "packages://inspector/inspectors/comps/block-input-events.js",
        help: "i18n:COMPONENT.help_url.block_input_events"
      },
      onEnable: function onEnable() {
        for (var i = 0; i < BlockEvents.length; i++) this.node.on(BlockEvents[i], stopPropagation, this);
      },
      onDisable: function onDisable() {
        for (var i = 0; i < BlockEvents.length; i++) this.node.off(BlockEvents[i], stopPropagation, this);
      }
    });
    cc.BlockInputEvents = module.exports = BlockInputEvents;
  }), {
    "./CCComponent": 39
  } ],
  37: [ (function(require, module, exports) {
    "use strict";
    var Component = require("./CCComponent");
    var GraySpriteState = require("../utils/gray-sprite-state");
    var Transition = cc.Enum({
      NONE: 0,
      COLOR: 1,
      SPRITE: 2,
      SCALE: 3
    });
    var State = cc.Enum({
      NORMAL: 0,
      HOVER: 1,
      PRESSED: 2,
      DISABLED: 3
    });
    var Button = cc.Class({
      name: "cc.Button",
      extends: Component,
      mixins: [ GraySpriteState ],
      ctor: function ctor() {
        this._pressed = false;
        this._hovered = false;
        this._fromColor = null;
        this._toColor = null;
        this._time = 0;
        this._transitionFinished = true;
        this._fromScale = cc.Vec2.ZERO;
        this._toScale = cc.Vec2.ZERO;
        this._originalScale = null;
        this._graySpriteMaterial = null;
        this._spriteMaterial = null;
        this._sprite = null;
      },
      editor: false,
      properties: {
        interactable: {
          default: true,
          tooltip: false,
          notify: function notify() {
            this._updateState();
            this.interactable || this._resetState();
          },
          animatable: false
        },
        _resizeToTarget: {
          animatable: false,
          set: function set(value) {
            value && this._resizeNodeToTargetNode();
          }
        },
        enableAutoGrayEffect: {
          default: false,
          tooltip: false,
          notify: function notify() {
            this._updateDisabledState();
          }
        },
        transition: {
          default: Transition.NONE,
          tooltip: false,
          type: Transition,
          animatable: false,
          notify: function notify(oldValue) {
            this._updateTransition(oldValue);
          },
          formerlySerializedAs: "transition"
        },
        normalColor: {
          default: cc.color(214, 214, 214),
          displayName: "Normal",
          tooltip: false,
          notify: function notify() {
            this.transition === Transition.Color && this._getButtonState() === State.NORMAL && (this._getTarget().opacity = this.normalColor.a);
            this._updateState();
          }
        },
        pressedColor: {
          default: cc.color(211, 211, 211),
          displayName: "Pressed",
          tooltip: false,
          notify: function notify() {
            this.transition === Transition.Color && this._getButtonState() === State.PRESSED && (this._getTarget().opacity = this.pressedColor.a);
            this._updateState();
          },
          formerlySerializedAs: "pressedColor"
        },
        hoverColor: {
          default: cc.Color.WHITE,
          displayName: "Hover",
          tooltip: false,
          notify: function notify() {
            this.transition === Transition.Color && this._getButtonState() === State.HOVER && (this._getTarget().opacity = this.hoverColor.a);
            this._updateState();
          },
          formerlySerializedAs: "hoverColor"
        },
        disabledColor: {
          default: cc.color(124, 124, 124),
          displayName: "Disabled",
          tooltip: false,
          notify: function notify() {
            this.transition === Transition.Color && this._getButtonState() === State.DISABLED && (this._getTarget().opacity = this.disabledColor.a);
            this._updateState();
          }
        },
        duration: {
          default: .1,
          range: [ 0, 10 ],
          tooltip: false
        },
        zoomScale: {
          default: 1.2,
          tooltip: false
        },
        normalSprite: {
          default: null,
          type: cc.SpriteFrame,
          displayName: "Normal",
          tooltip: false,
          notify: function notify() {
            this._updateState();
          }
        },
        pressedSprite: {
          default: null,
          type: cc.SpriteFrame,
          displayName: "Pressed",
          tooltip: false,
          formerlySerializedAs: "pressedSprite",
          notify: function notify() {
            this._updateState();
          }
        },
        hoverSprite: {
          default: null,
          type: cc.SpriteFrame,
          displayName: "Hover",
          tooltip: false,
          formerlySerializedAs: "hoverSprite",
          notify: function notify() {
            this._updateState();
          }
        },
        disabledSprite: {
          default: null,
          type: cc.SpriteFrame,
          displayName: "Disabled",
          tooltip: false,
          notify: function notify() {
            this._updateState();
          }
        },
        target: {
          default: null,
          type: cc.Node,
          tooltip: false,
          notify: function notify(oldValue) {
            this._applyTarget();
            oldValue && this.target !== oldValue && this._unregisterTargetEvent(oldValue);
          }
        },
        clickEvents: {
          default: [],
          type: cc.Component.EventHandler,
          tooltip: false
        }
      },
      statics: {
        Transition: Transition
      },
      __preload: function __preload() {
        this._applyTarget();
        this._updateState();
      },
      _resetState: function _resetState() {
        this._pressed = false;
        this._hovered = false;
        var target = this._getTarget();
        var transition = this.transition;
        var originalScale = this._originalScale;
        transition === Transition.COLOR && this.interactable ? this._setTargetColor(this.normalColor) : transition === Transition.SCALE && originalScale && target.setScale(originalScale.x, originalScale.y);
        this._transitionFinished = true;
      },
      onEnable: function onEnable() {
        this.normalSprite && this.normalSprite.ensureLoadTexture();
        this.hoverSprite && this.hoverSprite.ensureLoadTexture();
        this.pressedSprite && this.pressedSprite.ensureLoadTexture();
        this.disabledSprite && this.disabledSprite.ensureLoadTexture();
        true;
        this._registerNodeEvent();
      },
      onDisable: function onDisable() {
        this._resetState();
        true;
        this._unregisterNodeEvent();
      },
      _getTarget: function _getTarget() {
        return this.target ? this.target : this.node;
      },
      _onTargetSpriteFrameChanged: function _onTargetSpriteFrameChanged(comp) {
        this.transition === Transition.SPRITE && this._setCurrentStateSprite(comp.spriteFrame);
      },
      _onTargetColorChanged: function _onTargetColorChanged(color) {
        this.transition === Transition.COLOR && this._setCurrentStateColor(color);
      },
      _onTargetScaleChanged: function _onTargetScaleChanged() {
        var target = this._getTarget();
        if (this._originalScale && (this.transition !== Transition.SCALE || this._transitionFinished)) {
          this._originalScale.x = target.scaleX;
          this._originalScale.y = target.scaleY;
        }
      },
      _setTargetColor: function _setTargetColor(color) {
        var target = this._getTarget();
        target.color = color;
        target.opacity = color.a;
      },
      _getStateColor: function _getStateColor(state) {
        switch (state) {
         case State.NORMAL:
          return this.normalColor;

         case State.HOVER:
          return this.hoverColor;

         case State.PRESSED:
          return this.pressedColor;

         case State.DISABLED:
          return this.disabledColor;
        }
      },
      _getStateSprite: function _getStateSprite(state) {
        switch (state) {
         case State.NORMAL:
          return this.normalSprite;

         case State.HOVER:
          return this.hoverSprite;

         case State.PRESSED:
          return this.pressedSprite;

         case State.DISABLED:
          return this.disabledSprite;
        }
      },
      _setCurrentStateColor: function _setCurrentStateColor(color) {
        switch (this._getButtonState()) {
         case State.NORMAL:
          this.normalColor = color;
          break;

         case State.HOVER:
          this.hoverColor = color;
          break;

         case State.PRESSED:
          this.pressedColor = color;
          break;

         case State.DISABLED:
          this.disabledColor = color;
        }
      },
      _setCurrentStateSprite: function _setCurrentStateSprite(spriteFrame) {
        switch (this._getButtonState()) {
         case State.NORMAL:
          this.normalSprite = spriteFrame;
          break;

         case State.HOVER:
          this.hoverSprite = spriteFrame;
          break;

         case State.PRESSED:
          this.pressedSprite = spriteFrame;
          break;

         case State.DISABLED:
          this.disabledSprite = spriteFrame;
        }
      },
      update: function update(dt) {
        var target = this._getTarget();
        if (this._transitionFinished) return;
        if (this.transition !== Transition.COLOR && this.transition !== Transition.SCALE) return;
        this.time += dt;
        var ratio = 1;
        this.duration > 0 && (ratio = this.time / this.duration);
        ratio >= 1 && (ratio = 1);
        if (this.transition === Transition.COLOR) {
          var color = this._fromColor.lerp(this._toColor, ratio);
          this._setTargetColor(color);
        } else this.transition === Transition.SCALE && this._originalScale && (target.scale = this._fromScale.lerp(this._toScale, ratio));
        1 === ratio && (this._transitionFinished = true);
      },
      _registerNodeEvent: function _registerNodeEvent() {
        this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMove, this);
        this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancel, this);
        this.node.on(cc.Node.EventType.MOUSE_ENTER, this._onMouseMoveIn, this);
        this.node.on(cc.Node.EventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
      },
      _unregisterNodeEvent: function _unregisterNodeEvent() {
        this.node.off(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        this.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMove, this);
        this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        this.node.off(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancel, this);
        this.node.off(cc.Node.EventType.MOUSE_ENTER, this._onMouseMoveIn, this);
        this.node.off(cc.Node.EventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
      },
      _registerTargetEvent: function _registerTargetEvent(target) {
        false;
        target.on(cc.Node.EventType.SCALE_CHANGED, this._onTargetScaleChanged, this);
      },
      _unregisterTargetEvent: function _unregisterTargetEvent(target) {
        false;
        target.off(cc.Node.EventType.SCALE_CHANGED, this._onTargetScaleChanged, this);
      },
      _getTargetSprite: function _getTargetSprite(target) {
        var sprite = null;
        target && (sprite = target.getComponent(cc.Sprite));
        return sprite;
      },
      _applyTarget: function _applyTarget() {
        var target = this._getTarget();
        this._sprite = this._getTargetSprite(target);
        this._originalScale || (this._originalScale = cc.Vec2.ZERO);
        this._originalScale.x = target.scaleX;
        this._originalScale.y = target.scaleY;
        this._registerTargetEvent(target);
      },
      _onTouchBegan: function _onTouchBegan(event) {
        if (!this.interactable || !this.enabledInHierarchy) return;
        this._pressed = true;
        this._updateState();
        event.stopPropagation();
      },
      _onTouchMove: function _onTouchMove(event) {
        if (!this.interactable || !this.enabledInHierarchy || !this._pressed) return;
        var touch = event.touch;
        var hit = this.node._hitTest(touch.getLocation());
        var target = this._getTarget();
        var originalScale = this._originalScale;
        if (this.transition === Transition.SCALE && originalScale) if (hit) {
          this._fromScale.x = originalScale.x;
          this._fromScale.y = originalScale.y;
          this._toScale.x = originalScale.x * this.zoomScale;
          this._toScale.y = originalScale.y * this.zoomScale;
          this._transitionFinished = false;
        } else {
          this.time = 0;
          this._transitionFinished = true;
          target.setScale(originalScale.x, originalScale.y);
        } else {
          var state = void 0;
          state = hit ? State.PRESSED : State.NORMAL;
          this._applyTransition(state);
        }
        event.stopPropagation();
      },
      _onTouchEnded: function _onTouchEnded(event) {
        if (!this.interactable || !this.enabledInHierarchy) return;
        if (this._pressed) {
          cc.Component.EventHandler.emitEvents(this.clickEvents, event);
          this.node.emit("click", this);
        }
        this._pressed = false;
        this._updateState();
        event.stopPropagation();
      },
      _onTouchCancel: function _onTouchCancel() {
        if (!this.interactable || !this.enabledInHierarchy) return;
        this._pressed = false;
        this._updateState();
      },
      _onMouseMoveIn: function _onMouseMoveIn() {
        if (this._pressed || !this.interactable || !this.enabledInHierarchy) return;
        if (this.transition === Transition.SPRITE && !this.hoverSprite) return;
        if (!this._hovered) {
          this._hovered = true;
          this._updateState();
        }
      },
      _onMouseMoveOut: function _onMouseMoveOut() {
        if (this._hovered) {
          this._hovered = false;
          this._updateState();
        }
      },
      _updateState: function _updateState() {
        var state = this._getButtonState();
        this._applyTransition(state);
        this._updateDisabledState();
      },
      _getButtonState: function _getButtonState() {
        var state = void 0;
        state = this.interactable ? this._pressed ? State.PRESSED : this._hovered ? State.HOVER : State.NORMAL : State.DISABLED;
        return state;
      },
      _updateColorTransitionImmediately: function _updateColorTransitionImmediately(state) {
        var color = this._getStateColor(state);
        this._setTargetColor(color);
      },
      _updateColorTransition: function _updateColorTransition(state) {
        if (false, state === State.DISABLED) this._updateColorTransitionImmediately(state); else {
          var target = this._getTarget();
          var color = this._getStateColor(state);
          this._fromColor = target.color.clone();
          this._toColor = color;
          this.time = 0;
          this._transitionFinished = false;
        }
      },
      _updateSpriteTransition: function _updateSpriteTransition(state) {
        var sprite = this._getStateSprite(state);
        this._sprite && sprite && (this._sprite.spriteFrame = sprite);
      },
      _updateScaleTransition: function _updateScaleTransition(state) {
        state === State.PRESSED ? this._zoomUp() : this._zoomBack();
      },
      _zoomUp: function _zoomUp() {
        if (!this._originalScale) return;
        this._fromScale.x = this._originalScale.x;
        this._fromScale.y = this._originalScale.y;
        this._toScale.x = this._originalScale.x * this.zoomScale;
        this._toScale.y = this._originalScale.y * this.zoomScale;
        this.time = 0;
        this._transitionFinished = false;
      },
      _zoomBack: function _zoomBack() {
        if (!this._originalScale) return;
        var target = this._getTarget();
        this._fromScale.x = target.scaleX;
        this._fromScale.y = target.scaleY;
        this._toScale.x = this._originalScale.x;
        this._toScale.y = this._originalScale.y;
        this.time = 0;
        this._transitionFinished = false;
      },
      _updateTransition: function _updateTransition(oldTransition) {
        oldTransition === Transition.COLOR ? this._updateColorTransitionImmediately(State.NORMAL) : oldTransition === Transition.SPRITE && this._updateSpriteTransition(State.NORMAL);
        this._updateState();
      },
      _applyTransition: function _applyTransition(state) {
        var transition = this.transition;
        transition === Transition.COLOR ? this._updateColorTransition(state) : transition === Transition.SPRITE ? this._updateSpriteTransition(state) : transition === Transition.SCALE && this._updateScaleTransition(state);
      },
      _resizeNodeToTargetNode: false,
      _updateDisabledState: function _updateDisabledState() {
        if (this._sprite) {
          var useGrayMaterial = false;
          this.enableAutoGrayEffect && (this.transition === Transition.SPRITE && this.disabledSprite || this.interactable || (useGrayMaterial = true));
          this._switchGrayMaterial(useGrayMaterial, this._sprite);
        }
      }
    });
    cc.Button = module.exports = Button;
  }), {
    "../utils/gray-sprite-state": 184,
    "./CCComponent": 39
  } ],
  38: [ (function(require, module, exports) {
    "use strict";
    var Camera = require("../camera/CCCamera");
    var Component = require("./CCComponent");
    var Canvas = cc.Class({
      name: "cc.Canvas",
      extends: Component,
      editor: false,
      resetInEditor: false,
      statics: {
        instance: null
      },
      properties: {
        _designResolution: cc.size(960, 640),
        designResolution: {
          get: function get() {
            return cc.size(this._designResolution);
          },
          set: function set(value) {
            this._designResolution.width = value.width;
            this._designResolution.height = value.height;
            this.applySettings();
            this.alignWithScreen();
          },
          tooltip: false
        },
        _fitWidth: false,
        _fitHeight: true,
        fitHeight: {
          get: function get() {
            return this._fitHeight;
          },
          set: function set(value) {
            if (this._fitHeight !== value) {
              this._fitHeight = value;
              this.applySettings();
              this.alignWithScreen();
            }
          },
          tooltip: false
        },
        fitWidth: {
          get: function get() {
            return this._fitWidth;
          },
          set: function set(value) {
            if (this._fitWidth !== value) {
              this._fitWidth = value;
              this.applySettings();
              this.alignWithScreen();
            }
          },
          tooltip: false
        }
      },
      ctor: function ctor() {
        this._thisOnResized = this.alignWithScreen.bind(this);
      },
      __preload: function __preload() {
        var Flags;
        false;
        if (Canvas.instance) return cc.errorID(6700, this.node.name, Canvas.instance.node.name);
        Canvas.instance = this;
        false;
        cc.sys.isMobile ? window.addEventListener("resize", this._thisOnResized) : cc.view.on("canvas-resize", this._thisOnResized);
        this.applySettings();
        this.alignWithScreen();
        var cameraNode = cc.find("Main Camera", this.node);
        if (!cameraNode) {
          cameraNode = new cc.Node("Main Camera");
          cameraNode.parent = this.node;
          cameraNode.setSiblingIndex(0);
        }
        var camera = cameraNode.getComponent(Camera);
        if (!camera) {
          camera = cameraNode.addComponent(Camera);
          var ClearFlags = Camera.ClearFlags;
          camera.clearFlags = ClearFlags.COLOR | ClearFlags.DEPTH | ClearFlags.STENCIL;
          camera.depth = -1;
        }
        Camera.main = camera;
      },
      onDestroy: function onDestroy() {
        false;
        cc.sys.isMobile ? window.removeEventListener("resize", this._thisOnResized) : cc.view.off("canvas-resize", this._thisOnResized);
        Canvas.instance === this && (Canvas.instance = null);
      },
      alignWithScreen: function alignWithScreen() {
        var designSize, nodeSize;
        false;
        var canvasSize = nodeSize = cc.visibleRect;
        designSize = cc.view.getDesignResolutionSize();
        var clipTopRight = !this.fitHeight && !this.fitWidth;
        var offsetX = 0;
        var offsetY = 0;
        if (clipTopRight) {
          offsetX = .5 * (designSize.width - canvasSize.width);
          offsetY = .5 * (designSize.height - canvasSize.height);
        }
        this.node.setPosition(.5 * canvasSize.width + offsetX, .5 * canvasSize.height + offsetY);
        this.node.width = nodeSize.width;
        this.node.height = nodeSize.height;
      },
      applySettings: function applySettings() {
        var ResolutionPolicy = cc.ResolutionPolicy;
        var policy;
        policy = this.fitHeight && this.fitWidth ? ResolutionPolicy.SHOW_ALL : this.fitHeight || this.fitWidth ? this.fitWidth ? ResolutionPolicy.FIXED_WIDTH : ResolutionPolicy.FIXED_HEIGHT : ResolutionPolicy.NO_BORDER;
        var designRes = this._designResolution;
        false;
        cc.view.setDesignResolutionSize(designRes.width, designRes.height, policy);
      }
    });
    cc.Canvas = module.exports = Canvas;
  }), {
    "../camera/CCCamera": 33,
    "./CCComponent": 39
  } ],
  39: [ (function(require, module, exports) {
    "use strict";
    var CCObject = require("../platform/CCObject");
    var js = require("../platform/js");
    var idGenerater = new (require("../platform/id-generater"))("Comp");
    var IsOnEnableCalled = CCObject.Flags.IsOnEnableCalled;
    var IsOnLoadCalled = CCObject.Flags.IsOnLoadCalled;
    var Component = cc.Class({
      name: "cc.Component",
      extends: CCObject,
      ctor: function() {
        this._id = idGenerater.getNewId();
        this.__eventTargets = [];
      },
      properties: {
        node: {
          default: null,
          visible: false
        },
        name: {
          get: function get() {
            if (this._name) return this._name;
            var className = cc.js.getClassName(this);
            var trimLeft = className.lastIndexOf(".");
            trimLeft >= 0 && (className = className.slice(trimLeft + 1));
            return this.node.name + "<" + className + ">";
          },
          set: function set(value) {
            this._name = value;
          },
          visible: false
        },
        uuid: {
          get: function get() {
            return this._id;
          },
          visible: false
        },
        __scriptAsset: false,
        _enabled: true,
        enabled: {
          get: function get() {
            return this._enabled;
          },
          set: function set(value) {
            if (this._enabled !== value) {
              this._enabled = value;
              if (this.node._activeInHierarchy) {
                var compScheduler = cc.director._compScheduler;
                value ? compScheduler.enableComp(this) : compScheduler.disableComp(this);
              }
            }
          },
          visible: false,
          animatable: true
        },
        enabledInHierarchy: {
          get: function get() {
            return this._enabled && this.node._activeInHierarchy;
          },
          visible: false
        },
        _isOnLoadCalled: {
          get: function get() {
            return this._objFlags & IsOnLoadCalled;
          }
        }
      },
      update: null,
      lateUpdate: null,
      __preload: null,
      onLoad: null,
      start: null,
      onEnable: null,
      onDisable: null,
      onDestroy: null,
      onFocusInEditor: null,
      onLostFocusInEditor: null,
      resetInEditor: null,
      addComponent: function addComponent(typeOrClassName) {
        return this.node.addComponent(typeOrClassName);
      },
      getComponent: function getComponent(typeOrClassName) {
        return this.node.getComponent(typeOrClassName);
      },
      getComponents: function getComponents(typeOrClassName) {
        return this.node.getComponents(typeOrClassName);
      },
      getComponentInChildren: function getComponentInChildren(typeOrClassName) {
        return this.node.getComponentInChildren(typeOrClassName);
      },
      getComponentsInChildren: function getComponentsInChildren(typeOrClassName) {
        return this.node.getComponentsInChildren(typeOrClassName);
      },
      _getLocalBounds: null,
      onRestore: null,
      destroy: function destroy() {
        var depend;
        false;
        this._super() && this._enabled && this.node._activeInHierarchy && cc.director._compScheduler.disableComp(this);
      },
      _onPreDestroy: function _onPreDestroy() {
        this.unscheduleAllCallbacks();
        var eventTargets = this.__eventTargets;
        for (var i = 0, l = eventTargets.length; i < l; ++i) {
          var target = eventTargets[i];
          target && target.targetOff(this);
        }
        eventTargets.length = 0;
        false;
        cc.director._nodeActivator.destroyComp(this);
        this.node._removeComponent(this);
      },
      _instantiate: function _instantiate(cloned) {
        cloned || (cloned = cc.instantiate._clone(this, this));
        cloned.node = null;
        return cloned;
      },
      schedule: function schedule(callback, interval, repeat, delay) {
        cc.assertID(callback, 1619);
        cc.assertID(interval >= 0, 1620);
        interval = interval || 0;
        repeat = isNaN(repeat) ? cc.macro.REPEAT_FOREVER : repeat;
        delay = delay || 0;
        var scheduler = cc.director.getScheduler();
        var paused = scheduler.isTargetPaused(this);
        scheduler.schedule(callback, this, interval, repeat, delay, paused);
      },
      scheduleOnce: function scheduleOnce(callback, delay) {
        this.schedule(callback, 0, 0, delay);
      },
      unschedule: function unschedule(callback_fn) {
        if (!callback_fn) return;
        cc.director.getScheduler().unschedule(callback_fn, this);
      },
      unscheduleAllCallbacks: function unscheduleAllCallbacks() {
        cc.director.getScheduler().unscheduleAllForTarget(this);
      }
    });
    Component._requireComponent = null;
    Component._executionOrder = 0;
    false, false;
    js.value(Component, "_registerEditorProps", (function(cls, props) {
      var reqComp = props.requireComponent;
      reqComp && (cls._requireComponent = reqComp);
      var order = props.executionOrder;
      order && "number" === typeof order && (cls._executionOrder = order);
      var name;
      var key;
      var val;
      var willExecuteInEditMode;
      false, false;
    }));
    Component.prototype.__scriptUuid = "";
    cc.Component = module.exports = Component;
  }), {
    "../platform/CCObject": 110,
    "../platform/id-generater": 120,
    "../platform/js": 124
  } ],
  40: [ (function(require, module, exports) {
    "use strict";
    cc.Component.EventHandler = cc.Class({
      name: "cc.ClickEvent",
      properties: {
        target: {
          default: null,
          type: cc.Node
        },
        component: "",
        _componentId: "",
        _componentName: {
          get: function get() {
            this._genCompIdIfNeeded();
            return this._compId2Name(this._componentId);
          },
          set: function set(value) {
            this._componentId = this._compName2Id(value);
          }
        },
        handler: {
          default: ""
        },
        customEventData: {
          default: ""
        }
      },
      statics: {
        emitEvents: function emitEvents(events) {
          var args = void 0;
          if (arguments.length > 0) {
            args = new Array(arguments.length - 1);
            for (var i = 0, l = args.length; i < l; i++) args[i] = arguments[i + 1];
          }
          for (var _i = 0, _l = events.length; _i < _l; _i++) {
            var event = events[_i];
            if (!(event instanceof cc.Component.EventHandler)) continue;
            event.emit(args);
          }
        }
      },
      emit: function emit(params) {
        var target = this.target;
        if (!cc.isValid(target)) return;
        this._genCompIdIfNeeded();
        var compType = cc.js._getClassById(this._componentId);
        var comp = target.getComponent(compType);
        if (!cc.isValid(comp)) return;
        var handler = comp[this.handler];
        if ("function" !== typeof handler) return;
        if (null != this.customEventData && "" !== this.customEventData) {
          params = params.slice();
          params.push(this.customEventData);
        }
        handler.apply(comp, params);
      },
      _compName2Id: function _compName2Id(compName) {
        var comp = cc.js.getClassByName(compName);
        return cc.js._getClassId(comp);
      },
      _compId2Name: function _compId2Name(compId) {
        var comp = cc.js._getClassById(compId);
        return cc.js.getClassName(comp);
      },
      _genCompIdIfNeeded: function _genCompIdIfNeeded() {
        if (!this._componentId) {
          this._componentName = this.component;
          this.component = "";
        }
      }
    });
  }), {} ],
  41: [ (function(require, module, exports) {
    "use strict";
    var macro = require("../platform/CCMacro");
    var RenderComponent = require("./CCRenderComponent");
    var Material = require("../assets/material/CCMaterial");
    var LabelFrame = require("../renderer/utils/label/label-frame");
    var RenderFlow = require("../renderer/render-flow");
    var opacityFlag = RenderFlow.FLAG_COLOR | RenderFlow.FLAG_OPACITY;
    var HorizontalAlign = macro.TextAlignment;
    var VerticalAlign = macro.VerticalTextAlignment;
    var Overflow = cc.Enum({
      NONE: 0,
      CLAMP: 1,
      SHRINK: 2,
      RESIZE_HEIGHT: 3
    });
    var CacheMode = cc.Enum({
      NONE: 0,
      BITMAP: 1,
      CHAR: 2
    });
    var Label = cc.Class({
      name: "cc.Label",
      extends: RenderComponent,
      ctor: function ctor() {
        false;
        this._actualFontSize = 0;
        this._assemblerData = null;
        this._frame = null;
        this._ttfTexture = null;
        this._letterTexture = null;
      },
      editor: false,
      properties: {
        _useOriginalSize: true,
        _string: {
          default: "",
          formerlySerializedAs: "_N$string"
        },
        string: {
          get: function get() {
            return this._string;
          },
          set: function set(value) {
            var oldValue = this._string;
            this._string = "" + value;
            this.string !== oldValue && this._updateRenderData();
            this._checkStringEmpty();
          },
          multiline: true,
          tooltip: false
        },
        horizontalAlign: {
          default: HorizontalAlign.LEFT,
          type: HorizontalAlign,
          tooltip: false,
          notify: function notify(oldValue) {
            if (this.horizontalAlign === oldValue) return;
            this._updateRenderData();
          },
          animatable: false
        },
        verticalAlign: {
          default: VerticalAlign.TOP,
          type: VerticalAlign,
          tooltip: false,
          notify: function notify(oldValue) {
            if (this.verticalAlign === oldValue) return;
            this._updateRenderData();
          },
          animatable: false
        },
        actualFontSize: {
          displayName: "Actual Font Size",
          animatable: false,
          readonly: true,
          get: function get() {
            return this._actualFontSize;
          },
          tooltip: false
        },
        _fontSize: 40,
        fontSize: {
          get: function get() {
            return this._fontSize;
          },
          set: function set(value) {
            if (this._fontSize === value) return;
            this._fontSize = value;
            this._updateRenderData();
          },
          range: [ 0, 512 ],
          tooltip: false
        },
        fontFamily: {
          default: "Arial",
          tooltip: false,
          notify: function notify(oldValue) {
            if (this.fontFamily === oldValue) return;
            this._updateRenderData();
          },
          animatable: false
        },
        _lineHeight: 40,
        lineHeight: {
          get: function get() {
            return this._lineHeight;
          },
          set: function set(value) {
            if (this._lineHeight === value) return;
            this._lineHeight = value;
            this._updateRenderData();
          },
          tooltip: false
        },
        overflow: {
          default: Overflow.NONE,
          type: Overflow,
          tooltip: false,
          notify: function notify(oldValue) {
            if (this.overflow === oldValue) return;
            this._updateRenderData();
          },
          animatable: false
        },
        _enableWrapText: true,
        enableWrapText: {
          get: function get() {
            return this._enableWrapText;
          },
          set: function set(value) {
            if (this._enableWrapText === value) return;
            this._enableWrapText = value;
            this._updateRenderData();
          },
          animatable: false,
          tooltip: false
        },
        _N$file: null,
        font: {
          get: function get() {
            return this._N$file;
          },
          set: function set(value) {
            if (this.font === value) return;
            value || (this._isSystemFontUsed = true);
            false;
            cc.Label.FontAtlasManager.releaseFontAtlas(this.font, this.node._id);
            this._N$file = value;
            value && this._isSystemFontUsed && (this._isSystemFontUsed = false);
            "string" === typeof value && cc.warnID(4e3);
            if (this._renderData) {
              this.destroyRenderData(this._renderData);
              this._renderData = null;
            }
            this._updateAssembler();
            this._applyFontTexture(true);
            this._updateRenderData();
          },
          type: cc.Font,
          tooltip: false,
          animatable: false
        },
        _isSystemFontUsed: true,
        useSystemFont: {
          get: function get() {
            return this._isSystemFontUsed;
          },
          set: function set(value) {
            if (this._isSystemFontUsed === value) return;
            this.destroyRenderData(this._renderData);
            this._renderData = null;
            false;
            this._isSystemFontUsed = !!value;
            if (value) {
              this.font = null;
              this._updateAssembler();
              this._updateRenderData();
              this._checkStringEmpty();
            } else this._userDefinedFont || this.disableRender();
          },
          animatable: false,
          tooltip: false
        },
        _bmFontOriginalSize: {
          displayName: "BMFont Original Size",
          get: function get() {
            return this._N$file instanceof cc.BitmapFont ? this._N$file.fontSize : -1;
          },
          visible: true,
          animatable: false
        },
        _spacingX: 0,
        spacingX: {
          get: function get() {
            return this._spacingX;
          },
          set: function set(value) {
            this._spacingX = value;
            this._updateRenderData();
          },
          tooltip: false
        },
        _batchAsBitmap: false,
        cacheMode: {
          default: CacheMode.NONE,
          type: CacheMode,
          tooltip: false,
          notify: function notify(oldValue) {
            if (this.cacheMode === oldValue) return;
            oldValue !== CacheMode.BITMAP || this.font instanceof cc.BitmapFont || this._frame._resetDynamicAtlasFrame();
            oldValue === CacheMode.CHAR && (this._ttfTexture = null);
            this._updateRenderData(true);
          },
          animatable: false
        },
        _isBold: {
          default: false,
          serializable: false
        },
        _isItalic: {
          default: false,
          serializable: false
        },
        _isUnderline: {
          default: false,
          serializable: false
        }
      },
      statics: {
        HorizontalAlign: HorizontalAlign,
        VerticalAlign: VerticalAlign,
        Overflow: Overflow,
        CacheMode: CacheMode
      },
      onLoad: function onLoad() {
        if (this._batchAsBitmap && this.cacheMode === CacheMode.NONE) {
          this.cacheMode = CacheMode.BITMAP;
          this._batchAsBitmap = false;
        }
      },
      onEnable: function onEnable() {
        this._super();
        this.font || this._isSystemFontUsed || (this.useSystemFont = true);
        this.useSystemFont && !this.fontFamily && (this.fontFamily = "Arial");
        this.node.on(cc.Node.EventType.SIZE_CHANGED, this._updateRenderData, this);
        this.node.on(cc.Node.EventType.ANCHOR_CHANGED, this._updateRenderData, this);
        this.node.on(cc.Node.EventType.COLOR_CHANGED, this._updateColor, this);
        this._checkStringEmpty();
        this._updateRenderData(true);
      },
      onDisable: function onDisable() {
        this._super();
        this.node.off(cc.Node.EventType.SIZE_CHANGED, this._updateRenderData, this);
        this.node.off(cc.Node.EventType.ANCHOR_CHANGED, this._updateRenderData, this);
        this.node.off(cc.Node.EventType.COLOR_CHANGED, this._updateColor, this);
      },
      onDestroy: function onDestroy() {
        this._assembler && this._assembler._resetAssemblerData && this._assembler._resetAssemblerData(this._assemblerData);
        this._assemblerData = null;
        this._letterTexture = null;
        if (this._ttfTexture) {
          this._ttfTexture.destroy();
          this._ttfTexture = null;
        }
        cc.Label.FontAtlasManager.releaseFontAtlas(this.font, this.node._id);
        this._super();
      },
      _canRender: function _canRender() {
        var result = this._super();
        var font = this.font;
        if (font instanceof cc.BitmapFont) {
          var spriteFrame = font.spriteFrame;
          spriteFrame && spriteFrame.textureLoaded() || (result = false);
        }
        return result;
      },
      _checkStringEmpty: function _checkStringEmpty() {
        this.markForRender(!!this.string);
      },
      _on3DNodeChanged: function _on3DNodeChanged() {
        this._updateAssembler();
        this._applyFontTexture(true);
      },
      _updateAssembler: function _updateAssembler() {
        var assembler = Label._assembler.getAssembler(this);
        if (this._assembler !== assembler) {
          this._assembler = assembler;
          this._renderData = null;
          this._frame = null;
        }
        if (!this._renderData) {
          this._renderData = this._assembler.createData(this);
          this.markForUpdateRenderData(true);
        }
      },
      _applyFontTexture: function _applyFontTexture(force) {
        var font = this.font;
        if (font instanceof cc.BitmapFont) {
          var spriteFrame = font.spriteFrame;
          this._frame = spriteFrame;
          var self = this;
          var onBMFontTextureLoaded = function onBMFontTextureLoaded() {
            self._frame._texture = spriteFrame._texture;
            self._activateMaterial(force);
            force && self._assembler && self._assembler.updateRenderData(self);
          };
          if (spriteFrame && spriteFrame.textureLoaded()) onBMFontTextureLoaded(); else {
            this.disableRender();
            if (spriteFrame) {
              spriteFrame.once("load", onBMFontTextureLoaded, this);
              spriteFrame.ensureLoadTexture();
            }
          }
        } else {
          this._frame || (this._frame = new LabelFrame());
          if (this.cacheMode === CacheMode.CHAR && cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB) {
            this._letterTexture = this._assembler._getAssemblerData();
            this._frame._refreshTexture(this._letterTexture);
          } else if (!this._ttfTexture) {
            this._ttfTexture = new cc.Texture2D();
            this._assemblerData = this._assembler._getAssemblerData();
            this._ttfTexture.initWithElement(this._assemblerData.canvas);
          }
          if (this.cacheMode !== CacheMode.CHAR) {
            this._frame._resetDynamicAtlasFrame();
            this._frame._refreshTexture(this._ttfTexture);
          }
          this._activateMaterial(force);
          force && this._assembler && this._assembler.updateRenderData(this);
        }
      },
      _updateColor: function _updateColor() {
        var font = this.font;
        if (!(font instanceof cc.BitmapFont)) {
          this._updateRenderData();
          this.node._renderFlag &= ~RenderFlow.FLAG_COLOR;
        }
      },
      _activateMaterial: function _activateMaterial(force) {
        if (!force) return;
        if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) this._frame._texture.url = this.uuid + "_texture"; else {
          var material = this.sharedMaterials[0];
          material = material ? Material.getInstantiatedMaterial(material, this) : Material.getInstantiatedBuiltinMaterial("2d-sprite", this);
          material.setProperty("texture", this._frame._texture);
          this.setMaterial(0, material);
        }
        this.markForUpdateRenderData(true);
        this.markForRender(true);
      },
      _updateRenderData: function _updateRenderData(force) {
        var renderData = this._renderData;
        if (renderData) {
          renderData.vertDirty = true;
          renderData.uvDirty = true;
          this.markForUpdateRenderData(true);
        }
        if (true === force) {
          this._updateAssembler();
          this._applyFontTexture(force);
        }
      },
      _enableBold: function _enableBold(enabled) {
        this._isBold = !!enabled;
      },
      _enableItalics: function _enableItalics(enabled) {
        this._isItalic = !!enabled;
      },
      _enableUnderline: function _enableUnderline(enabled) {
        this._isUnderline = !!enabled;
      }
    });
    cc.Label = module.exports = Label;
  }), {
    "../assets/material/CCMaterial": 29,
    "../platform/CCMacro": 109,
    "../renderer/render-flow": 148,
    "../renderer/utils/label/label-frame": 152,
    "./CCRenderComponent": 47
  } ],
  42: [ (function(require, module, exports) {
    "use strict";
    var LabelOutline = cc.Class({
      name: "cc.LabelOutline",
      extends: require("./CCComponent"),
      editor: false,
      properties: {
        _color: cc.Color.WHITE,
        _width: 1,
        color: {
          tooltip: false,
          get: function get() {
            return this._color;
          },
          set: function set(value) {
            this._color = value;
            this._updateRenderData();
          }
        },
        width: {
          tooltip: false,
          get: function get() {
            return this._width;
          },
          set: function set(value) {
            this._width = value;
            this._updateRenderData();
          },
          range: [ 0, 512 ]
        }
      },
      onEnable: function onEnable() {
        this._updateRenderData();
      },
      onDisable: function onDisable() {
        this._updateRenderData();
      },
      _updateRenderData: function _updateRenderData() {
        var label = this.node.getComponent(cc.Label);
        label && label._updateRenderData();
      }
    });
    cc.LabelOutline = module.exports = LabelOutline;
  }), {
    "./CCComponent": 39
  } ],
  43: [ (function(require, module, exports) {
    "use strict";
    var LabelShadow = cc.Class({
      name: "cc.LabelShadow",
      extends: require("./CCComponent"),
      editor: false,
      properties: {
        _color: cc.Color.WHITE,
        _offset: cc.v2(2, 2),
        _blur: 2,
        color: {
          tooltip: false,
          get: function get() {
            return this._color;
          },
          set: function set(value) {
            this._color = value;
            this._updateRenderData();
          }
        },
        offset: {
          tooltip: false,
          get: function get() {
            return this._offset;
          },
          set: function set(value) {
            this._offset = value;
            this._updateRenderData();
          }
        },
        blur: {
          tooltip: false,
          get: function get() {
            return this._blur;
          },
          set: function set(value) {
            this._blur = value;
            this._updateRenderData();
          },
          range: [ 0, 1024 ]
        }
      },
      onEnable: function onEnable() {
        this._updateRenderData();
      },
      onDisable: function onDisable() {
        this._updateRenderData();
      },
      _updateRenderData: function _updateRenderData() {
        var label = this.node.getComponent(cc.Label);
        label && label._updateRenderData();
      }
    });
    cc.LabelShadow = module.exports = LabelShadow;
  }), {
    "./CCComponent": 39
  } ],
  44: [ (function(require, module, exports) {
    "use strict";
    var NodeEvent = require("../CCNode").EventType;
    var Type = cc.Enum({
      NONE: 0,
      HORIZONTAL: 1,
      VERTICAL: 2,
      GRID: 3
    });
    var ResizeMode = cc.Enum({
      NONE: 0,
      CONTAINER: 1,
      CHILDREN: 2
    });
    var AxisDirection = cc.Enum({
      HORIZONTAL: 0,
      VERTICAL: 1
    });
    var VerticalDirection = cc.Enum({
      BOTTOM_TO_TOP: 0,
      TOP_TO_BOTTOM: 1
    });
    var HorizontalDirection = cc.Enum({
      LEFT_TO_RIGHT: 0,
      RIGHT_TO_LEFT: 1
    });
    var Layout = cc.Class({
      name: "cc.Layout",
      extends: require("./CCComponent"),
      editor: false,
      properties: {
        _layoutSize: cc.size(300, 200),
        _layoutDirty: {
          default: true,
          serializable: false
        },
        _resize: ResizeMode.NONE,
        _N$layoutType: Type.NONE,
        type: {
          type: Type,
          get: function get() {
            return this._N$layoutType;
          },
          set: function set(value) {
            this._N$layoutType = value;
            var reLayouted;
            false;
            this._doLayoutDirty();
          },
          tooltip: false,
          animatable: false
        },
        resizeMode: {
          type: ResizeMode,
          tooltip: false,
          animatable: false,
          get: function get() {
            return this._resize;
          },
          set: function set(value) {
            if (this.type === Type.NONE && value === ResizeMode.CHILDREN) return;
            this._resize = value;
            var reLayouted;
            false;
            this._doLayoutDirty();
          }
        },
        cellSize: {
          default: cc.size(40, 40),
          tooltip: false,
          type: cc.Size,
          notify: function notify() {
            this._doLayoutDirty();
          }
        },
        startAxis: {
          default: AxisDirection.HORIZONTAL,
          tooltip: false,
          type: AxisDirection,
          notify: function notify() {
            var reLayouted;
            false;
            this._doLayoutDirty();
          },
          animatable: false
        },
        _N$padding: {
          default: 0
        },
        paddingLeft: {
          default: 0,
          tooltip: false,
          notify: function notify() {
            this._doLayoutDirty();
          }
        },
        paddingRight: {
          default: 0,
          tooltip: false,
          notify: function notify() {
            this._doLayoutDirty();
          }
        },
        paddingTop: {
          default: 0,
          tooltip: false,
          notify: function notify() {
            this._doLayoutDirty();
          }
        },
        paddingBottom: {
          default: 0,
          tooltip: false,
          notify: function notify() {
            this._doLayoutDirty();
          }
        },
        spacingX: {
          default: 0,
          notify: function notify() {
            this._doLayoutDirty();
          },
          tooltip: false
        },
        spacingY: {
          default: 0,
          notify: function notify() {
            this._doLayoutDirty();
          },
          tooltip: false
        },
        verticalDirection: {
          default: VerticalDirection.TOP_TO_BOTTOM,
          type: VerticalDirection,
          notify: function notify() {
            this._doLayoutDirty();
          },
          tooltip: false,
          animatable: false
        },
        horizontalDirection: {
          default: HorizontalDirection.LEFT_TO_RIGHT,
          type: HorizontalDirection,
          notify: function notify() {
            this._doLayoutDirty();
          },
          tooltip: false,
          animatable: false
        },
        affectedByScale: {
          default: false,
          notify: function notify() {
            this._doLayoutDirty();
          },
          animatable: false,
          tooltip: false
        }
      },
      statics: {
        Type: Type,
        VerticalDirection: VerticalDirection,
        HorizontalDirection: HorizontalDirection,
        ResizeMode: ResizeMode,
        AxisDirection: AxisDirection
      },
      _migratePaddingData: function _migratePaddingData() {
        this.paddingLeft = this._N$padding;
        this.paddingRight = this._N$padding;
        this.paddingTop = this._N$padding;
        this.paddingBottom = this._N$padding;
        this._N$padding = 0;
      },
      onEnable: function onEnable() {
        this._addEventListeners();
        this.node.getContentSize().equals(cc.size(0, 0)) && this.node.setContentSize(this._layoutSize);
        0 !== this._N$padding && this._migratePaddingData();
        this._doLayoutDirty();
      },
      onDisable: function onDisable() {
        this._removeEventListeners();
      },
      _doLayoutDirty: function _doLayoutDirty() {
        this._layoutDirty = true;
      },
      _doScaleDirty: function _doScaleDirty() {
        this._layoutDirty = this._layoutDirty || this.affectedByScale;
      },
      _addEventListeners: function _addEventListeners() {
        cc.director.on(cc.Director.EVENT_AFTER_UPDATE, this.updateLayout, this);
        this.node.on(NodeEvent.SIZE_CHANGED, this._resized, this);
        this.node.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
        this.node.on(NodeEvent.CHILD_ADDED, this._childAdded, this);
        this.node.on(NodeEvent.CHILD_REMOVED, this._childRemoved, this);
        this.node.on(NodeEvent.CHILD_REORDER, this._doLayoutDirty, this);
        this._addChildrenEventListeners();
      },
      _removeEventListeners: function _removeEventListeners() {
        cc.director.off(cc.Director.EVENT_AFTER_UPDATE, this.updateLayout, this);
        this.node.off(NodeEvent.SIZE_CHANGED, this._resized, this);
        this.node.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
        this.node.off(NodeEvent.CHILD_ADDED, this._childAdded, this);
        this.node.off(NodeEvent.CHILD_REMOVED, this._childRemoved, this);
        this.node.off(NodeEvent.CHILD_REORDER, this._doLayoutDirty, this);
        this._removeChildrenEventListeners();
      },
      _addChildrenEventListeners: function _addChildrenEventListeners() {
        var children = this.node.children;
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          child.on(NodeEvent.SCALE_CHANGED, this._doScaleDirty, this);
          child.on(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this);
          child.on(NodeEvent.POSITION_CHANGED, this._doLayoutDirty, this);
          child.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
          child.on("active-in-hierarchy-changed", this._doLayoutDirty, this);
        }
      },
      _removeChildrenEventListeners: function _removeChildrenEventListeners() {
        var children = this.node.children;
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          child.off(NodeEvent.SCALE_CHANGED, this._doScaleDirty, this);
          child.off(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this);
          child.off(NodeEvent.POSITION_CHANGED, this._doLayoutDirty, this);
          child.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
          child.off("active-in-hierarchy-changed", this._doLayoutDirty, this);
        }
      },
      _childAdded: function _childAdded(child) {
        child.on(NodeEvent.SCALE_CHANGED, this._doScaleDirty, this);
        child.on(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this);
        child.on(NodeEvent.POSITION_CHANGED, this._doLayoutDirty, this);
        child.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
        child.on("active-in-hierarchy-changed", this._doLayoutDirty, this);
        this._doLayoutDirty();
      },
      _childRemoved: function _childRemoved(child) {
        child.off(NodeEvent.SCALE_CHANGED, this._doScaleDirty, this);
        child.off(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this);
        child.off(NodeEvent.POSITION_CHANGED, this._doLayoutDirty, this);
        child.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
        child.off("active-in-hierarchy-changed", this._doLayoutDirty, this);
        this._doLayoutDirty();
      },
      _resized: function _resized() {
        this._layoutSize = this.node.getContentSize();
        this._doLayoutDirty();
      },
      _doLayoutHorizontally: function _doLayoutHorizontally(baseWidth, rowBreak, fnPositionY, applyChildren) {
        var layoutAnchor = this.node.getAnchorPoint();
        var children = this.node.children;
        var sign = 1;
        var paddingX = this.paddingLeft;
        var leftBoundaryOfLayout = -layoutAnchor.x * baseWidth;
        if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
          sign = -1;
          leftBoundaryOfLayout = (1 - layoutAnchor.x) * baseWidth;
          paddingX = this.paddingRight;
        }
        var nextX = leftBoundaryOfLayout + sign * paddingX - sign * this.spacingX;
        var rowMaxHeight = 0;
        var tempMaxHeight = 0;
        var secondMaxHeight = 0;
        var row = 0;
        var containerResizeBoundary = 0;
        var maxHeightChildAnchorY = 0;
        var activeChildCount = 0;
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          child.activeInHierarchy && activeChildCount++;
        }
        var newChildWidth = this.cellSize.width;
        this.type !== Type.GRID && this.resizeMode === ResizeMode.CHILDREN && (newChildWidth = (baseWidth - (this.paddingLeft + this.paddingRight) - (activeChildCount - 1) * this.spacingX) / activeChildCount);
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          var childScaleX = this._getUsedScaleValue(child.scaleX);
          var childScaleY = this._getUsedScaleValue(child.scaleY);
          if (!child.activeInHierarchy) continue;
          if (this._resize === ResizeMode.CHILDREN) {
            child.width = newChildWidth / childScaleX;
            this.type === Type.GRID && (child.height = this.cellSize.height / childScaleY);
          }
          var anchorX = child.anchorX;
          var childBoundingBoxWidth = child.width * childScaleX;
          var childBoundingBoxHeight = child.height * childScaleY;
          secondMaxHeight > tempMaxHeight && (tempMaxHeight = secondMaxHeight);
          if (childBoundingBoxHeight >= tempMaxHeight) {
            secondMaxHeight = tempMaxHeight;
            tempMaxHeight = childBoundingBoxHeight;
            maxHeightChildAnchorY = child.getAnchorPoint().y;
          }
          this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (anchorX = 1 - child.anchorX);
          nextX = nextX + sign * anchorX * childBoundingBoxWidth + sign * this.spacingX;
          var rightBoundaryOfChild = sign * (1 - anchorX) * childBoundingBoxWidth;
          if (rowBreak) {
            var rowBreakBoundary = nextX + rightBoundaryOfChild + sign * (sign > 0 ? this.paddingRight : this.paddingLeft);
            var leftToRightRowBreak = this.horizontalDirection === HorizontalDirection.LEFT_TO_RIGHT && rowBreakBoundary > (1 - layoutAnchor.x) * baseWidth;
            var rightToLeftRowBreak = this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && rowBreakBoundary < -layoutAnchor.x * baseWidth;
            if (leftToRightRowBreak || rightToLeftRowBreak) {
              if (childBoundingBoxHeight >= tempMaxHeight) {
                0 === secondMaxHeight && (secondMaxHeight = tempMaxHeight);
                rowMaxHeight += secondMaxHeight;
                secondMaxHeight = tempMaxHeight;
              } else {
                rowMaxHeight += tempMaxHeight;
                secondMaxHeight = childBoundingBoxHeight;
                tempMaxHeight = 0;
              }
              nextX = leftBoundaryOfLayout + sign * (paddingX + anchorX * childBoundingBoxWidth);
              row++;
            }
          }
          var finalPositionY = fnPositionY(child, rowMaxHeight, row);
          baseWidth >= childBoundingBoxWidth + this.paddingLeft + this.paddingRight && applyChildren && child.setPosition(cc.v2(nextX, finalPositionY));
          var signX = 1;
          var tempFinalPositionY;
          var topMarign = 0 === tempMaxHeight ? childBoundingBoxHeight : tempMaxHeight;
          if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
            containerResizeBoundary = containerResizeBoundary || this.node._contentSize.height;
            signX = -1;
            tempFinalPositionY = finalPositionY + signX * (topMarign * maxHeightChildAnchorY + this.paddingBottom);
            tempFinalPositionY < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionY);
          } else {
            containerResizeBoundary = containerResizeBoundary || -this.node._contentSize.height;
            tempFinalPositionY = finalPositionY + signX * (topMarign * maxHeightChildAnchorY + this.paddingTop);
            tempFinalPositionY > containerResizeBoundary && (containerResizeBoundary = tempFinalPositionY);
          }
          nextX += rightBoundaryOfChild;
        }
        return containerResizeBoundary;
      },
      _getVerticalBaseHeight: function _getVerticalBaseHeight(children) {
        var newHeight = 0;
        var activeChildCount = 0;
        if (this.resizeMode === ResizeMode.CONTAINER) {
          for (var i = 0; i < children.length; ++i) {
            var child = children[i];
            if (child.activeInHierarchy) {
              activeChildCount++;
              newHeight += child.height * this._getUsedScaleValue(child.scaleY);
            }
          }
          newHeight += (activeChildCount - 1) * this.spacingY + this.paddingBottom + this.paddingTop;
        } else newHeight = this.node.getContentSize().height;
        return newHeight;
      },
      _doLayoutVertically: function _doLayoutVertically(baseHeight, columnBreak, fnPositionX, applyChildren) {
        var layoutAnchor = this.node.getAnchorPoint();
        var children = this.node.children;
        var sign = 1;
        var paddingY = this.paddingBottom;
        var bottomBoundaryOfLayout = -layoutAnchor.y * baseHeight;
        if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
          sign = -1;
          bottomBoundaryOfLayout = (1 - layoutAnchor.y) * baseHeight;
          paddingY = this.paddingTop;
        }
        var nextY = bottomBoundaryOfLayout + sign * paddingY - sign * this.spacingY;
        var columnMaxWidth = 0;
        var tempMaxWidth = 0;
        var secondMaxWidth = 0;
        var column = 0;
        var containerResizeBoundary = 0;
        var maxWidthChildAnchorX = 0;
        var activeChildCount = 0;
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          child.activeInHierarchy && activeChildCount++;
        }
        var newChildHeight = this.cellSize.height;
        this.type !== Type.GRID && this.resizeMode === ResizeMode.CHILDREN && (newChildHeight = (baseHeight - (this.paddingTop + this.paddingBottom) - (activeChildCount - 1) * this.spacingY) / activeChildCount);
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          var childScaleX = this._getUsedScaleValue(child.scaleX);
          var childScaleY = this._getUsedScaleValue(child.scaleY);
          if (!child.activeInHierarchy) continue;
          if (this.resizeMode === ResizeMode.CHILDREN) {
            child.height = newChildHeight / childScaleY;
            this.type === Type.GRID && (child.width = this.cellSize.width / childScaleX);
          }
          var anchorY = child.anchorY;
          var childBoundingBoxWidth = child.width * childScaleX;
          var childBoundingBoxHeight = child.height * childScaleY;
          secondMaxWidth > tempMaxWidth && (tempMaxWidth = secondMaxWidth);
          if (childBoundingBoxWidth >= tempMaxWidth) {
            secondMaxWidth = tempMaxWidth;
            tempMaxWidth = childBoundingBoxWidth;
            maxWidthChildAnchorX = child.getAnchorPoint().x;
          }
          this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (anchorY = 1 - child.anchorY);
          nextY = nextY + sign * anchorY * childBoundingBoxHeight + sign * this.spacingY;
          var topBoundaryOfChild = sign * (1 - anchorY) * childBoundingBoxHeight;
          if (columnBreak) {
            var columnBreakBoundary = nextY + topBoundaryOfChild + sign * (sign > 0 ? this.paddingTop : this.paddingBottom);
            var bottomToTopColumnBreak = this.verticalDirection === VerticalDirection.BOTTOM_TO_TOP && columnBreakBoundary > (1 - layoutAnchor.y) * baseHeight;
            var topToBottomColumnBreak = this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM && columnBreakBoundary < -layoutAnchor.y * baseHeight;
            if (bottomToTopColumnBreak || topToBottomColumnBreak) {
              if (childBoundingBoxWidth >= tempMaxWidth) {
                0 === secondMaxWidth && (secondMaxWidth = tempMaxWidth);
                columnMaxWidth += secondMaxWidth;
                secondMaxWidth = tempMaxWidth;
              } else {
                columnMaxWidth += tempMaxWidth;
                secondMaxWidth = childBoundingBoxWidth;
                tempMaxWidth = 0;
              }
              nextY = bottomBoundaryOfLayout + sign * (paddingY + anchorY * childBoundingBoxHeight);
              column++;
            }
          }
          var finalPositionX = fnPositionX(child, columnMaxWidth, column);
          baseHeight >= childBoundingBoxHeight + (this.paddingTop + this.paddingBottom) && applyChildren && child.setPosition(cc.v2(finalPositionX, nextY));
          var signX = 1;
          var tempFinalPositionX;
          var rightMarign = 0 === tempMaxWidth ? childBoundingBoxWidth : tempMaxWidth;
          if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
            signX = -1;
            containerResizeBoundary = containerResizeBoundary || this.node._contentSize.width;
            tempFinalPositionX = finalPositionX + signX * (rightMarign * maxWidthChildAnchorX + this.paddingLeft);
            tempFinalPositionX < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionX);
          } else {
            containerResizeBoundary = containerResizeBoundary || -this.node._contentSize.width;
            tempFinalPositionX = finalPositionX + signX * (rightMarign * maxWidthChildAnchorX + this.paddingRight);
            tempFinalPositionX > containerResizeBoundary && (containerResizeBoundary = tempFinalPositionX);
          }
          nextY += topBoundaryOfChild;
        }
        return containerResizeBoundary;
      },
      _doLayoutBasic: function _doLayoutBasic() {
        var children = this.node.children;
        var allChildrenBoundingBox = null;
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          child.activeInHierarchy && (allChildrenBoundingBox ? allChildrenBoundingBox.union(allChildrenBoundingBox, child.getBoundingBoxToWorld()) : allChildrenBoundingBox = child.getBoundingBoxToWorld());
        }
        if (allChildrenBoundingBox) {
          var leftBottomInParentSpace = this.node.parent.convertToNodeSpaceAR(cc.v2(allChildrenBoundingBox.x, allChildrenBoundingBox.y));
          leftBottomInParentSpace = cc.v2(leftBottomInParentSpace.x - this.paddingLeft, leftBottomInParentSpace.y - this.paddingBottom);
          var rightTopInParentSpace = this.node.parent.convertToNodeSpaceAR(cc.v2(allChildrenBoundingBox.x + allChildrenBoundingBox.width, allChildrenBoundingBox.y + allChildrenBoundingBox.height));
          rightTopInParentSpace = cc.v2(rightTopInParentSpace.x + this.paddingRight, rightTopInParentSpace.y + this.paddingTop);
          var newSize = cc.size(parseFloat((rightTopInParentSpace.x - leftBottomInParentSpace.x).toFixed(2)), parseFloat((rightTopInParentSpace.y - leftBottomInParentSpace.y).toFixed(2)));
          var layoutPosition = this.node.getPosition();
          if (0 !== newSize.width) {
            var newAnchorX = (layoutPosition.x - leftBottomInParentSpace.x) / newSize.width;
            this.node.anchorX = parseFloat(newAnchorX.toFixed(2));
          }
          if (0 !== newSize.height) {
            var newAnchorY = (layoutPosition.y - leftBottomInParentSpace.y) / newSize.height;
            this.node.anchorY = parseFloat(newAnchorY.toFixed(2));
          }
          this.node.setContentSize(newSize);
        }
      },
      _doLayoutGridAxisHorizontal: function _doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) {
        var baseWidth = layoutSize.width;
        var sign = 1;
        var bottomBoundaryOfLayout = -layoutAnchor.y * layoutSize.height;
        var paddingY = this.paddingBottom;
        if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
          sign = -1;
          bottomBoundaryOfLayout = (1 - layoutAnchor.y) * layoutSize.height;
          paddingY = this.paddingTop;
        }
        var fnPositionY = function(child, topOffset, row) {
          return bottomBoundaryOfLayout + sign * (topOffset + child.anchorY * child.height * this._getUsedScaleValue(child.scaleY) + paddingY + row * this.spacingY);
        }.bind(this);
        var newHeight = 0;
        if (this.resizeMode === ResizeMode.CONTAINER) {
          var boundary = this._doLayoutHorizontally(baseWidth, true, fnPositionY, false);
          newHeight = bottomBoundaryOfLayout - boundary;
          newHeight < 0 && (newHeight *= -1);
          bottomBoundaryOfLayout = -layoutAnchor.y * newHeight;
          if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
            sign = -1;
            bottomBoundaryOfLayout = (1 - layoutAnchor.y) * newHeight;
          }
        }
        this._doLayoutHorizontally(baseWidth, true, fnPositionY, true);
        this.resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(baseWidth, newHeight);
      },
      _doLayoutGridAxisVertical: function _doLayoutGridAxisVertical(layoutAnchor, layoutSize) {
        var baseHeight = layoutSize.height;
        var sign = 1;
        var leftBoundaryOfLayout = -layoutAnchor.x * layoutSize.width;
        var paddingX = this.paddingLeft;
        if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
          sign = -1;
          leftBoundaryOfLayout = (1 - layoutAnchor.x) * layoutSize.width;
          paddingX = this.paddingRight;
        }
        var fnPositionX = function(child, leftOffset, column) {
          return leftBoundaryOfLayout + sign * (leftOffset + child.anchorX * child.width * this._getUsedScaleValue(child.scaleX) + paddingX + column * this.spacingX);
        }.bind(this);
        var newWidth = 0;
        if (this.resizeMode === ResizeMode.CONTAINER) {
          var boundary = this._doLayoutVertically(baseHeight, true, fnPositionX, false);
          newWidth = leftBoundaryOfLayout - boundary;
          newWidth < 0 && (newWidth *= -1);
          leftBoundaryOfLayout = -layoutAnchor.x * newWidth;
          if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
            sign = -1;
            leftBoundaryOfLayout = (1 - layoutAnchor.x) * newWidth;
          }
        }
        this._doLayoutVertically(baseHeight, true, fnPositionX, true);
        this.resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(newWidth, baseHeight);
      },
      _doLayoutGrid: function _doLayoutGrid() {
        var layoutAnchor = this.node.getAnchorPoint();
        var layoutSize = this.node.getContentSize();
        this.startAxis === AxisDirection.HORIZONTAL ? this._doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) : this.startAxis === AxisDirection.VERTICAL && this._doLayoutGridAxisVertical(layoutAnchor, layoutSize);
      },
      _getHorizontalBaseWidth: function _getHorizontalBaseWidth(children) {
        var newWidth = 0;
        var activeChildCount = 0;
        if (this.resizeMode === ResizeMode.CONTAINER) {
          for (var i = 0; i < children.length; ++i) {
            var child = children[i];
            if (child.activeInHierarchy) {
              activeChildCount++;
              newWidth += child.width * this._getUsedScaleValue(child.scaleX);
            }
          }
          newWidth += (activeChildCount - 1) * this.spacingX + this.paddingLeft + this.paddingRight;
        } else newWidth = this.node.getContentSize().width;
        return newWidth;
      },
      _doLayout: function _doLayout() {
        if (this.type === Type.HORIZONTAL) {
          var newWidth = this._getHorizontalBaseWidth(this.node.children);
          var fnPositionY = function fnPositionY(child) {
            return child.y;
          };
          this._doLayoutHorizontally(newWidth, false, fnPositionY, true);
          this.node.width = newWidth;
        } else if (this.type === Type.VERTICAL) {
          var newHeight = this._getVerticalBaseHeight(this.node.children);
          var fnPositionX = function fnPositionX(child) {
            return child.x;
          };
          this._doLayoutVertically(newHeight, false, fnPositionX, true);
          this.node.height = newHeight;
        } else this.type === Type.NONE ? this.resizeMode === ResizeMode.CONTAINER && this._doLayoutBasic() : this.type === Type.GRID && this._doLayoutGrid();
      },
      _getUsedScaleValue: function _getUsedScaleValue(value) {
        return this.affectedByScale ? Math.abs(value) : 1;
      },
      updateLayout: function updateLayout() {
        if (this._layoutDirty && this.node.children.length > 0) {
          this._doLayout();
          this._layoutDirty = false;
        }
      }
    });
    Object.defineProperty(Layout.prototype, "padding", {
      get: function get() {
        cc.warnID(4100);
        return this.paddingLeft;
      },
      set: function set(value) {
        this._N$padding = value;
        this._migratePaddingData();
        this._doLayoutDirty();
      }
    });
    cc.Layout = module.exports = Layout;
  }), {
    "../CCNode": 6,
    "./CCComponent": 39
  } ],
  45: [ (function(require, module, exports) {
    "use strict";
    var _gfx = require("../../renderer/gfx");
    var _gfx2 = _interopRequireDefault(_gfx);
    var _vmath = require("../vmath");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var misc = require("../utils/misc");
    var Material = require("../assets/material/CCMaterial");
    var RenderComponent = require("./CCRenderComponent");
    var RenderFlow = require("../renderer/render-flow");
    var Graphics = require("../graphics/graphics");
    var Node = require("../CCNode");
    var _vec2_temp = cc.v2();
    var _mat4_temp = _vmath.mat4.create();
    var _circlepoints = [];
    function _calculateCircle(center, radius, segements) {
      _circlepoints.length = 0;
      var anglePerStep = 2 * Math.PI / segements;
      for (var step = 0; step < segements; ++step) _circlepoints.push(cc.v2(radius.x * Math.cos(anglePerStep * step) + center.x, radius.y * Math.sin(anglePerStep * step) + center.y));
      return _circlepoints;
    }
    var MaskType = cc.Enum({
      RECT: 0,
      ELLIPSE: 1,
      IMAGE_STENCIL: 2
    });
    var SEGEMENTS_MIN = 3;
    var SEGEMENTS_MAX = 1e4;
    var Mask = cc.Class({
      name: "cc.Mask",
      extends: RenderComponent,
      editor: false,
      ctor: function ctor() {
        this._graphics = null;
        this._enableMaterial = null;
        this._exitMaterial = null;
        this._clearMaterial = null;
      },
      properties: {
        _spriteFrame: {
          default: null,
          type: cc.SpriteFrame
        },
        _type: MaskType.RECT,
        type: {
          get: function get() {
            return this._type;
          },
          set: function set(value) {
            this._type = value;
            if (this._type !== MaskType.IMAGE_STENCIL) {
              this.spriteFrame = null;
              this.alphaThreshold = 0;
              this._updateGraphics();
            }
            if (this._renderData) {
              this.destroyRenderData(this._renderData);
              this._renderData = null;
            }
            this._activateMaterial();
          },
          type: MaskType,
          tooltip: false
        },
        spriteFrame: {
          type: cc.SpriteFrame,
          tooltip: false,
          get: function get() {
            return this._spriteFrame;
          },
          set: function set(value) {
            var lastSprite = this._spriteFrame;
            false;
            if (lastSprite === value) return;
            this._spriteFrame = value;
            this._applySpriteFrame(lastSprite);
          }
        },
        alphaThreshold: {
          default: 0,
          type: cc.Float,
          range: [ 0, 1, .1 ],
          slide: true,
          tooltip: false,
          notify: function notify() {
            if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) {
              cc.warnID(4201);
              return;
            }
            var material = this.sharedMaterials[0];
            material && material.setProperty("alphaThreshold", this.alphaThreshold);
          }
        },
        inverted: {
          default: false,
          type: cc.Boolean,
          tooltip: false,
          notify: function notify() {
            if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) {
              cc.warnID(4202);
              return;
            }
          }
        },
        _segments: 64,
        segements: {
          get: function get() {
            return this._segments;
          },
          set: function set(value) {
            this._segments = misc.clampf(value, SEGEMENTS_MIN, SEGEMENTS_MAX);
            this._updateGraphics();
          },
          type: cc.Integer,
          tooltip: false
        },
        _resizeToTarget: {
          animatable: false,
          set: function set(value) {
            value && this._resizeNodeToTargetNode();
          }
        }
      },
      statics: {
        Type: MaskType
      },
      onLoad: function onLoad() {
        this._createGraphics();
      },
      onRestore: function onRestore() {
        this._createGraphics();
        this._type !== MaskType.IMAGE_STENCIL ? this._updateGraphics() : this._applySpriteFrame();
      },
      onEnable: function onEnable() {
        this._super();
        if (this._type === MaskType.IMAGE_STENCIL) {
          if (!this._spriteFrame || !this._spriteFrame.textureLoaded()) {
            this.markForRender(false);
            if (this._spriteFrame) {
              this.markForUpdateRenderData(false);
              this._spriteFrame.once("load", this._onTextureLoaded, this);
              this._spriteFrame.ensureLoadTexture();
            }
          }
        } else this._updateGraphics();
        this.node.on(cc.Node.EventType.POSITION_CHANGED, this._updateGraphics, this);
        this.node.on(cc.Node.EventType.ROTATION_CHANGED, this._updateGraphics, this);
        this.node.on(cc.Node.EventType.SCALE_CHANGED, this._updateGraphics, this);
        this.node.on(cc.Node.EventType.SIZE_CHANGED, this._updateGraphics, this);
        this.node.on(cc.Node.EventType.ANCHOR_CHANGED, this._updateGraphics, this);
        this.node._renderFlag |= RenderFlow.FLAG_POST_RENDER;
        this._activateMaterial();
      },
      onDisable: function onDisable() {
        this._super();
        this.node.off(cc.Node.EventType.POSITION_CHANGED, this._updateGraphics, this);
        this.node.off(cc.Node.EventType.ROTATION_CHANGED, this._updateGraphics, this);
        this.node.off(cc.Node.EventType.SCALE_CHANGED, this._updateGraphics, this);
        this.node.off(cc.Node.EventType.SIZE_CHANGED, this._updateGraphics, this);
        this.node.off(cc.Node.EventType.ANCHOR_CHANGED, this._updateGraphics, this);
        this.node._renderFlag &= ~RenderFlow.FLAG_POST_RENDER;
      },
      onDestroy: function onDestroy() {
        this._super();
        this._removeGraphics();
      },
      _resizeNodeToTargetNode: false,
      _onTextureLoaded: function _onTextureLoaded() {
        if (this._renderData) {
          this._renderData.uvDirty = true;
          this._renderData.vertDirty = true;
          this.markForUpdateRenderData(true);
        }
        this.enabledInHierarchy && this._activateMaterial();
      },
      _applySpriteFrame: function _applySpriteFrame(oldFrame) {
        oldFrame && oldFrame.off && oldFrame.off("load", this._onTextureLoaded, this);
        var spriteFrame = this._spriteFrame;
        if (spriteFrame) if (spriteFrame.textureLoaded()) this._onTextureLoaded(null); else {
          spriteFrame.once("load", this._onTextureLoaded, this);
          spriteFrame.ensureLoadTexture();
        } else this.disableRender();
      },
      _activateMaterial: function _activateMaterial() {
        if (this._type === MaskType.IMAGE_STENCIL && (!this.spriteFrame || !this.spriteFrame.textureLoaded())) {
          this.markForRender(false);
          return;
        }
        if (cc.game.renderType !== cc.game.RENDER_TYPE_CANVAS) {
          var material = this.sharedMaterials[0];
          material = material ? Material.getInstantiatedMaterial(material, this) : Material.getInstantiatedBuiltinMaterial("2d-sprite", this);
          material.define("USE_ALPHA_TEST", true);
          if (this._type === MaskType.IMAGE_STENCIL) {
            var texture = this.spriteFrame.getTexture();
            material.define("_USE_MODEL", false);
            material.define("USE_TEXTURE", true);
            material.setProperty("texture", texture);
            material.setProperty("alphaThreshold", this.alphaThreshold);
          } else {
            material.define("_USE_MODEL", true);
            material.define("USE_TEXTURE", false);
          }
          this._enableMaterial || (this._enableMaterial = Material.getInstantiatedBuiltinMaterial("2d-sprite", this));
          if (!this._exitMaterial) {
            this._exitMaterial = Material.getInstantiatedBuiltinMaterial("2d-sprite", this);
            var passes = this._exitMaterial.effect.getDefaultTechnique().passes;
            for (var i = 0; i < passes.length; i++) passes[i].setStencilEnabled(_gfx2.default.STENCIL_DISABLE);
          }
          this._clearMaterial || (this._clearMaterial = Material.getInstantiatedBuiltinMaterial("clear-stencil", this));
          this.setMaterial(0, material);
        }
        this.markForRender(true);
      },
      _createGraphics: function _createGraphics() {
        if (!this._graphics) {
          this._graphics = new Graphics();
          this._graphics.node = this.node;
          this._graphics.lineWidth = 0;
          this._graphics.strokeColor = cc.color(0, 0, 0, 0);
        }
      },
      _updateGraphics: function _updateGraphics() {
        var node = this.node;
        var graphics = this._graphics;
        graphics.clear(false);
        var width = node._contentSize.width;
        var height = node._contentSize.height;
        var x = -width * node._anchorPoint.x;
        var y = -height * node._anchorPoint.y;
        if (this._type === MaskType.RECT) graphics.rect(x, y, width, height); else if (this._type === MaskType.ELLIPSE) {
          var center = cc.v2(x + width / 2, y + height / 2);
          var radius = {
            x: width / 2,
            y: height / 2
          };
          var points = _calculateCircle(center, radius, this._segments);
          for (var i = 0; i < points.length; ++i) {
            var point = points[i];
            0 === i ? graphics.moveTo(point.x, point.y) : graphics.lineTo(point.x, point.y);
          }
          graphics.close();
        }
        cc.game.renderType === cc.game.RENDER_TYPE_CANVAS ? graphics.stroke() : graphics.fill();
      },
      _removeGraphics: function _removeGraphics() {
        if (this._graphics) {
          this._graphics.destroy();
          this._graphics = null;
        }
        if (this._clearGraphics) {
          this._clearGraphics.destroy();
          this._clearGraphics = null;
        }
      },
      _hitTest: function _hitTest(cameraPt) {
        var node = this.node;
        var size = node.getContentSize(), w = size.width, h = size.height, testPt = _vec2_temp;
        node._updateWorldMatrix();
        if (!_vmath.mat4.invert(_mat4_temp, node._worldMatrix)) return false;
        _vmath.vec2.transformMat4(testPt, cameraPt, _mat4_temp);
        testPt.x += node._anchorPoint.x * w;
        testPt.y += node._anchorPoint.y * h;
        var result = false;
        if (this.type === MaskType.RECT || this.type === MaskType.IMAGE_STENCIL) result = testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h; else if (this.type === MaskType.ELLIPSE) {
          var rx = w / 2, ry = h / 2;
          var px = testPt.x - .5 * w, py = testPt.y - .5 * h;
          result = px * px / (rx * rx) + py * py / (ry * ry) < 1;
        }
        this.inverted && (result = !result);
        return result;
      },
      markForUpdateRenderData: function markForUpdateRenderData(enable) {
        enable && this.enabledInHierarchy ? this.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA : enable || (this.node._renderFlag &= ~RenderFlow.FLAG_UPDATE_RENDER_DATA);
      },
      markForRender: function markForRender(enable) {
        enable && this.enabledInHierarchy ? this.node._renderFlag |= RenderFlow.FLAG_RENDER | RenderFlow.FLAG_UPDATE_RENDER_DATA | RenderFlow.FLAG_POST_RENDER : enable || (this.node._renderFlag &= ~(RenderFlow.FLAG_RENDER | RenderFlow.FLAG_POST_RENDER));
      },
      disableRender: function disableRender() {
        this.node._renderFlag &= ~(RenderFlow.FLAG_RENDER | RenderFlow.FLAG_UPDATE_RENDER_DATA | RenderFlow.FLAG_POST_RENDER);
      }
    });
    cc.Mask = module.exports = Mask;
  }), {
    "../../renderer/gfx": 233,
    "../CCNode": 6,
    "../assets/material/CCMaterial": 29,
    "../graphics/graphics": 76,
    "../renderer/render-flow": 148,
    "../utils/misc": 187,
    "../vmath": 207,
    "./CCRenderComponent": 47
  } ],
  46: [ (function(require, module, exports) {
    "use strict";
    var misc = require("../utils/misc");
    var Component = require("./CCComponent");
    var Mode = cc.Enum({
      HORIZONTAL: 0,
      VERTICAL: 1,
      FILLED: 2
    });
    var ProgressBar = cc.Class({
      name: "cc.ProgressBar",
      extends: Component,
      editor: false,
      _initBarSprite: function _initBarSprite() {
        if (this.barSprite) {
          var entity = this.barSprite.node;
          if (!entity) return;
          var nodeSize = this.node.getContentSize();
          var nodeAnchor = this.node.getAnchorPoint();
          var entitySize = entity.getContentSize();
          entity.parent === this.node && this.node.setContentSize(entitySize);
          this.barSprite.fillType === cc.Sprite.FillType.RADIAL && (this.mode = Mode.FILLED);
          var barSpriteSize = entity.getContentSize();
          this.mode === Mode.HORIZONTAL ? this.totalLength = barSpriteSize.width : this.mode === Mode.VERTICAL ? this.totalLength = barSpriteSize.height : this.totalLength = this.barSprite.fillRange;
          if (entity.parent === this.node) {
            var x = -nodeSize.width * nodeAnchor.x;
            var y = 0;
            entity.setPosition(cc.v2(x, y));
          }
        }
      },
      _updateBarStatus: function _updateBarStatus() {
        if (this.barSprite) {
          var entity = this.barSprite.node;
          if (!entity) return;
          var entityAnchorPoint = entity.getAnchorPoint();
          var entitySize = entity.getContentSize();
          var entityPosition = entity.getPosition();
          var anchorPoint = cc.v2(0, .5);
          var progress = misc.clamp01(this.progress);
          var actualLenth = this.totalLength * progress;
          var finalContentSize;
          var totalWidth;
          var totalHeight;
          switch (this.mode) {
           case Mode.HORIZONTAL:
            this.reverse && (anchorPoint = cc.v2(1, .5));
            finalContentSize = cc.size(actualLenth, entitySize.height);
            totalWidth = this.totalLength;
            totalHeight = entitySize.height;
            break;

           case Mode.VERTICAL:
            anchorPoint = this.reverse ? cc.v2(.5, 1) : cc.v2(.5, 0);
            finalContentSize = cc.size(entitySize.width, actualLenth);
            totalWidth = entitySize.width;
            totalHeight = this.totalLength;
          }
          if (this.mode === Mode.FILLED) if (this.barSprite.type !== cc.Sprite.Type.FILLED) cc.warn("ProgressBar FILLED mode only works when barSprite's Type is FILLED!"); else {
            this.reverse && (actualLenth *= -1);
            this.barSprite.fillRange = actualLenth;
          } else if (this.barSprite.type !== cc.Sprite.Type.FILLED) {
            var anchorOffsetX = anchorPoint.x - entityAnchorPoint.x;
            var anchorOffsetY = anchorPoint.y - entityAnchorPoint.y;
            var finalPosition = cc.v2(totalWidth * anchorOffsetX, totalHeight * anchorOffsetY);
            entity.setPosition(entityPosition.x + finalPosition.x, entityPosition.y + finalPosition.y);
            entity.setAnchorPoint(anchorPoint);
            entity.setContentSize(finalContentSize);
          } else cc.warn("ProgressBar non-FILLED mode only works when barSprite's Type is non-FILLED!");
        }
      },
      properties: {
        barSprite: {
          default: null,
          type: cc.Sprite,
          tooltip: false,
          notify: function notify() {
            this._initBarSprite();
          },
          animatable: false
        },
        mode: {
          default: Mode.HORIZONTAL,
          type: Mode,
          tooltip: false,
          notify: function notify() {
            if (this.barSprite) {
              var entity = this.barSprite.node;
              if (!entity) return;
              var entitySize = entity.getContentSize();
              this.mode === Mode.HORIZONTAL ? this.totalLength = entitySize.width : this.mode === Mode.VERTICAL ? this.totalLength = entitySize.height : this.mode === Mode.FILLED && (this.totalLength = this.barSprite.fillRange);
            }
          },
          animatable: false
        },
        _N$totalLength: 1,
        totalLength: {
          range: [ 0, Number.MAX_VALUE ],
          tooltip: false,
          get: function get() {
            return this._N$totalLength;
          },
          set: function set(value) {
            this.mode === Mode.FILLED && (value = misc.clamp01(value));
            this._N$totalLength = value;
            this._updateBarStatus();
          }
        },
        progress: {
          default: 1,
          type: "Float",
          range: [ 0, 1, .1 ],
          slide: true,
          tooltip: false,
          notify: function notify() {
            this._updateBarStatus();
          }
        },
        reverse: {
          default: false,
          tooltip: false,
          notify: function notify() {
            this.barSprite && (this.barSprite.fillStart = 1 - this.barSprite.fillStart);
            this._updateBarStatus();
          },
          animatable: false
        }
      },
      statics: {
        Mode: Mode
      }
    });
    cc.ProgressBar = module.exports = ProgressBar;
  }), {
    "../utils/misc": 187,
    "./CCComponent": 39
  } ],
  47: [ (function(require, module, exports) {
    "use strict";
    var _gfx = require("../../renderer/gfx");
    var _gfx2 = _interopRequireDefault(_gfx);
    var _renderData = require("../../renderer/render-data/render-data");
    var _renderData2 = _interopRequireDefault(_renderData);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Component = require("./CCComponent");
    var RenderFlow = require("../renderer/render-flow");
    var BlendFactor = require("../platform/CCMacro").BlendFactor;
    var Material = require("../assets/material/CCMaterial");
    var RenderComponent = cc.Class({
      name: "RenderComponent",
      extends: Component,
      editor: false,
      properties: {
        _materials: {
          default: [],
          type: Material
        },
        sharedMaterials: {
          get: function get() {
            return this._materials;
          },
          set: function set(val) {
            this._materials = val;
            this._activateMaterial(true);
          },
          type: [ Material ],
          displayName: "Materials"
        }
      },
      ctor: function ctor() {
        this._renderData = null;
        this.__allocedDatas = [];
        this._vertexFormat = null;
        this._toPostHandle = false;
        this._assembler = this.constructor._assembler;
        this._postAssembler = this.constructor._postAssembler;
      },
      onEnable: function onEnable() {
        this.node._renderComponent && (this.node._renderComponent.enabled = false);
        this.node._renderComponent = this;
        this.node._renderFlag |= RenderFlow.FLAG_RENDER | RenderFlow.FLAG_UPDATE_RENDER_DATA;
      },
      onDisable: function onDisable() {
        this.node._renderComponent = null;
        this.disableRender();
      },
      onDestroy: function onDestroy() {
        for (var i = 0, l = this.__allocedDatas.length; i < l; i++) _renderData2.default.free(this.__allocedDatas[i]);
        this.__allocedDatas.length = 0;
        this._materials.length = 0;
        this._renderData = null;
        var uniforms = this._uniforms;
        for (var name in uniforms) _uniformPool.remove(_uniformPool._data.indexOf(uniforms[name]));
        this._uniforms = null;
        this._defines = null;
      },
      _canRender: function _canRender() {
        return this._enabled && this.node._activeInHierarchy;
      },
      markForUpdateRenderData: function markForUpdateRenderData(enable) {
        enable && this._canRender() ? this.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA : enable || (this.node._renderFlag &= ~RenderFlow.FLAG_UPDATE_RENDER_DATA);
      },
      markForRender: function markForRender(enable) {
        enable && this._canRender() ? this.node._renderFlag |= RenderFlow.FLAG_RENDER : enable || (this.node._renderFlag &= ~RenderFlow.FLAG_RENDER);
      },
      markForCustomIARender: function markForCustomIARender(enable) {
        enable && this._canRender() ? this.node._renderFlag |= RenderFlow.FLAG_CUSTOM_IA_RENDER : enable || (this.node._renderFlag &= ~RenderFlow.FLAG_CUSTOM_IA_RENDER);
      },
      disableRender: function disableRender() {
        this.node._renderFlag &= ~(RenderFlow.FLAG_RENDER | RenderFlow.FLAG_CUSTOM_IA_RENDER | RenderFlow.FLAG_UPDATE_RENDER_DATA);
      },
      requestRenderData: function requestRenderData() {
        var data = _renderData2.default.alloc();
        this.__allocedDatas.push(data);
        return data;
      },
      destroyRenderData: function destroyRenderData(data) {
        var index = this.__allocedDatas.indexOf(data);
        if (-1 !== index) {
          this.__allocedDatas.splice(index, 1);
          _renderData2.default.free(data);
        }
      },
      getMaterial: function getMaterial(index) {
        if (index < 0 || index >= this._materials.length) return null;
        var material = this._materials[index];
        if (!material) return null;
        var instantiated = Material.getInstantiatedMaterial(material, this);
        instantiated !== material && this.setMaterial(index, instantiated);
        return this._materials[index];
      },
      setMaterial: function setMaterial(index, material) {
        this._materials[index] = material;
        material && this.markForUpdateRenderData(true);
      },
      _activateMaterial: function _activateMaterial(force) {}
    });
    RenderComponent._assembler = null;
    RenderComponent._postAssembler = null;
    cc.RenderComponent = module.exports = RenderComponent;
  }), {
    "../../renderer/gfx": 233,
    "../../renderer/render-data/render-data": 253,
    "../assets/material/CCMaterial": 29,
    "../platform/CCMacro": 109,
    "../renderer/render-flow": 148,
    "./CCComponent": 39
  } ],
  48: [ (function(require, module, exports) {
    "use strict";
    var misc = require("../utils/misc");
    var Component = require("./CCComponent");
    var GETTINGSHORTERFACTOR = 20;
    var Direction = cc.Enum({
      HORIZONTAL: 0,
      VERTICAL: 1
    });
    var Scrollbar = cc.Class({
      name: "cc.Scrollbar",
      extends: require("./CCComponent"),
      editor: false,
      properties: {
        _scrollView: null,
        _touching: false,
        _autoHideRemainingTime: {
          default: 0,
          serializable: false
        },
        _opacity: 255,
        handle: {
          default: null,
          type: cc.Sprite,
          tooltip: false,
          notify: function notify() {
            this._onScroll(cc.v2(0, 0));
          },
          animatable: false
        },
        direction: {
          default: Direction.HORIZONTAL,
          type: Direction,
          tooltip: false,
          notify: function notify() {
            this._onScroll(cc.v2(0, 0));
          },
          animatable: false
        },
        enableAutoHide: {
          default: true,
          animatable: false,
          tooltip: false
        },
        autoHideTime: {
          default: 1,
          animatable: false,
          tooltip: false
        }
      },
      statics: {
        Direction: Direction
      },
      setTargetScrollView: function setTargetScrollView(scrollView) {
        this._scrollView = scrollView;
      },
      _convertToScrollViewSpace: function _convertToScrollViewSpace(content) {
        var worldSpacePos = content.convertToWorldSpace(cc.v2(0, 0));
        var scrollViewSpacePos = this._scrollView.node.convertToNodeSpace(worldSpacePos);
        return scrollViewSpacePos;
      },
      _setOpacity: function _setOpacity(opacity) {
        if (this.handle) {
          this.node.opacity = opacity;
          this.handle.node.opacity = opacity;
        }
      },
      _onScroll: function _onScroll(outOfBoundary) {
        if (this._scrollView) {
          var content = this._scrollView.content;
          if (content) {
            var contentSize = content.getContentSize();
            var scrollViewSize = this._scrollView.node.getContentSize();
            var handleNodeSize = this.node.getContentSize();
            if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) return;
            if (this.enableAutoHide) {
              this._autoHideRemainingTime = this.autoHideTime;
              this._setOpacity(this._opacity);
            }
            var contentMeasure = 0;
            var scrollViewMeasure = 0;
            var outOfBoundaryValue = 0;
            var contentPosition = 0;
            var handleNodeMeasure = 0;
            if (this.direction === Direction.HORIZONTAL) {
              contentMeasure = contentSize.width;
              scrollViewMeasure = scrollViewSize.width;
              handleNodeMeasure = handleNodeSize.width;
              outOfBoundaryValue = outOfBoundary.x;
              contentPosition = -this._convertToScrollViewSpace(content).x;
            } else if (this.direction === Direction.VERTICAL) {
              contentMeasure = contentSize.height;
              scrollViewMeasure = scrollViewSize.height;
              handleNodeMeasure = handleNodeSize.height;
              outOfBoundaryValue = outOfBoundary.y;
              contentPosition = -this._convertToScrollViewSpace(content).y;
            }
            var length = this._calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundaryValue);
            var position = this._calculatePosition(contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundaryValue, length);
            this._updateLength(length);
            this._updateHanlderPosition(position);
          }
        }
      },
      _updateHanlderPosition: function _updateHanlderPosition(position) {
        if (this.handle) {
          var oldPosition = this._fixupHandlerPosition();
          this.handle.node.setPosition(position.x + oldPosition.x, position.y + oldPosition.y);
        }
      },
      _fixupHandlerPosition: function _fixupHandlerPosition() {
        var barSize = this.node.getContentSize();
        var barAnchor = this.node.getAnchorPoint();
        var handleSize = this.handle.node.getContentSize();
        var handleParent = this.handle.node.parent;
        var leftBottomWorldPosition = this.node.convertToWorldSpaceAR(cc.v2(-barSize.width * barAnchor.x, -barSize.height * barAnchor.y));
        var fixupPosition = handleParent.convertToNodeSpaceAR(leftBottomWorldPosition);
        this.direction === Direction.HORIZONTAL ? fixupPosition = cc.v2(fixupPosition.x, fixupPosition.y + (barSize.height - handleSize.height) / 2) : this.direction === Direction.VERTICAL && (fixupPosition = cc.v2(fixupPosition.x + (barSize.width - handleSize.width) / 2, fixupPosition.y));
        this.handle.node.setPosition(fixupPosition);
        return fixupPosition;
      },
      _onTouchBegan: function _onTouchBegan() {
        if (!this.enableAutoHide) return;
        this._touching = true;
      },
      _conditionalDisableScrollBar: function _conditionalDisableScrollBar(contentSize, scrollViewSize) {
        if (contentSize.width <= scrollViewSize.width && this.direction === Direction.HORIZONTAL) return true;
        if (contentSize.height <= scrollViewSize.height && this.direction === Direction.VERTICAL) return true;
        return false;
      },
      _onTouchEnded: function _onTouchEnded() {
        if (!this.enableAutoHide) return;
        this._touching = false;
        if (this.autoHideTime <= 0) return;
        if (this._scrollView) {
          var content = this._scrollView.content;
          if (content) {
            var contentSize = content.getContentSize();
            var scrollViewSize = this._scrollView.node.getContentSize();
            if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) return;
          }
        }
        this._autoHideRemainingTime = this.autoHideTime;
      },
      _calculateLength: function _calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundary) {
        var denominatorValue = contentMeasure;
        outOfBoundary && (denominatorValue += (outOfBoundary > 0 ? outOfBoundary : -outOfBoundary) * GETTINGSHORTERFACTOR);
        var lengthRation = scrollViewMeasure / denominatorValue;
        return handleNodeMeasure * lengthRation;
      },
      _calculatePosition: function _calculatePosition(contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundary, actualLenth) {
        var denominatorValue = contentMeasure - scrollViewMeasure;
        outOfBoundary && (denominatorValue += Math.abs(outOfBoundary));
        var positionRatio = 0;
        if (denominatorValue) {
          positionRatio = contentPosition / denominatorValue;
          positionRatio = misc.clamp01(positionRatio);
        }
        var position = (handleNodeMeasure - actualLenth) * positionRatio;
        return this.direction === Direction.VERTICAL ? cc.v2(0, position) : cc.v2(position, 0);
      },
      _updateLength: function _updateLength(length) {
        if (this.handle) {
          var handleNode = this.handle.node;
          var handleNodeSize = handleNode.getContentSize();
          handleNode.setAnchorPoint(cc.v2(0, 0));
          this.direction === Direction.HORIZONTAL ? handleNode.setContentSize(length, handleNodeSize.height) : handleNode.setContentSize(handleNodeSize.width, length);
        }
      },
      _processAutoHide: function _processAutoHide(deltaTime) {
        if (!this.enableAutoHide || this._autoHideRemainingTime <= 0) return;
        if (this._touching) return;
        this._autoHideRemainingTime -= deltaTime;
        if (this._autoHideRemainingTime <= this.autoHideTime) {
          this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime);
          var opacity = this._opacity * (this._autoHideRemainingTime / this.autoHideTime);
          this._setOpacity(opacity);
        }
      },
      start: function start() {
        this.enableAutoHide && this._setOpacity(0);
      },
      hide: function hide() {
        this._autoHideRemainingTime = 0;
        this._setOpacity(0);
      },
      show: function show() {
        this._autoHideRemainingTime = this.autoHideTime;
        this._setOpacity(this._opacity);
      },
      update: function update(dt) {
        this._processAutoHide(dt);
      }
    });
    cc.Scrollbar = module.exports = Scrollbar;
  }), {
    "../utils/misc": 187,
    "./CCComponent": 39
  } ],
  49: [ (function(require, module, exports) {
    "use strict";
    var NodeEvent = require("../CCNode").EventType;
    var NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED = 5;
    var OUT_OF_BOUNDARY_BREAKING_FACTOR = .05;
    var EPSILON = 1e-4;
    var MOVEMENT_FACTOR = .7;
    var quintEaseOut = function quintEaseOut(time) {
      time -= 1;
      return time * time * time * time * time + 1;
    };
    var getTimeInMilliseconds = function getTimeInMilliseconds() {
      var currentTime = new Date();
      return currentTime.getMilliseconds();
    };
    var EventType = cc.Enum({
      SCROLL_TO_TOP: 0,
      SCROLL_TO_BOTTOM: 1,
      SCROLL_TO_LEFT: 2,
      SCROLL_TO_RIGHT: 3,
      SCROLLING: 4,
      BOUNCE_TOP: 5,
      BOUNCE_BOTTOM: 6,
      BOUNCE_LEFT: 7,
      BOUNCE_RIGHT: 8,
      SCROLL_ENDED: 9,
      TOUCH_UP: 10,
      AUTOSCROLL_ENDED_WITH_THRESHOLD: 11,
      SCROLL_BEGAN: 12
    });
    var eventMap = {
      "scroll-to-top": EventType.SCROLL_TO_TOP,
      "scroll-to-bottom": EventType.SCROLL_TO_BOTTOM,
      "scroll-to-left": EventType.SCROLL_TO_LEFT,
      "scroll-to-right": EventType.SCROLL_TO_RIGHT,
      scrolling: EventType.SCROLLING,
      "bounce-bottom": EventType.BOUNCE_BOTTOM,
      "bounce-left": EventType.BOUNCE_LEFT,
      "bounce-right": EventType.BOUNCE_RIGHT,
      "bounce-top": EventType.BOUNCE_TOP,
      "scroll-ended": EventType.SCROLL_ENDED,
      "touch-up": EventType.TOUCH_UP,
      "scroll-ended-with-threshold": EventType.AUTOSCROLL_ENDED_WITH_THRESHOLD,
      "scroll-began": EventType.SCROLL_BEGAN
    };
    var ScrollView = cc.Class({
      name: "cc.ScrollView",
      extends: require("./CCViewGroup"),
      editor: false,
      ctor: function ctor() {
        this._topBoundary = 0;
        this._bottomBoundary = 0;
        this._leftBoundary = 0;
        this._rightBoundary = 0;
        this._touchMoveDisplacements = [];
        this._touchMoveTimeDeltas = [];
        this._touchMovePreviousTimestamp = 0;
        this._touchMoved = false;
        this._autoScrolling = false;
        this._autoScrollAttenuate = false;
        this._autoScrollStartPosition = cc.v2(0, 0);
        this._autoScrollTargetDelta = cc.v2(0, 0);
        this._autoScrollTotalTime = 0;
        this._autoScrollAccumulatedTime = 0;
        this._autoScrollCurrentlyOutOfBoundary = false;
        this._autoScrollBraking = false;
        this._autoScrollBrakingStartPosition = cc.v2(0, 0);
        this._outOfBoundaryAmount = cc.v2(0, 0);
        this._outOfBoundaryAmountDirty = true;
        this._stopMouseWheel = false;
        this._mouseWheelEventElapsedTime = 0;
        this._isScrollEndedWithThresholdEventFired = false;
        this._scrollEventEmitMask = 0;
        this._isBouncing = false;
        this._scrolling = false;
      },
      properties: {
        content: {
          default: void 0,
          type: cc.Node,
          tooltip: false,
          formerlySerializedAs: "content",
          notify: function notify(oldValue) {
            this._calculateBoundary();
          }
        },
        horizontal: {
          default: true,
          animatable: false,
          tooltip: false
        },
        vertical: {
          default: true,
          animatable: false,
          tooltip: false
        },
        inertia: {
          default: true,
          tooltip: false
        },
        brake: {
          default: .5,
          type: "Float",
          range: [ 0, 1, .1 ],
          tooltip: false
        },
        elastic: {
          default: true,
          animatable: false,
          tooltip: false
        },
        bounceDuration: {
          default: 1,
          range: [ 0, 10 ],
          tooltip: false
        },
        horizontalScrollBar: {
          default: void 0,
          type: cc.Scrollbar,
          tooltip: false,
          notify: function notify() {
            if (this.horizontalScrollBar) {
              this.horizontalScrollBar.setTargetScrollView(this);
              this._updateScrollBar(0);
            }
          },
          animatable: false
        },
        verticalScrollBar: {
          default: void 0,
          type: cc.Scrollbar,
          tooltip: false,
          notify: function notify() {
            if (this.verticalScrollBar) {
              this.verticalScrollBar.setTargetScrollView(this);
              this._updateScrollBar(0);
            }
          },
          animatable: false
        },
        scrollEvents: {
          default: [],
          type: cc.Component.EventHandler,
          tooltip: false
        },
        cancelInnerEvents: {
          default: true,
          animatable: false,
          tooltip: false
        },
        _view: {
          get: function get() {
            if (this.content) return this.content.parent;
          }
        }
      },
      statics: {
        EventType: EventType
      },
      scrollToBottom: function scrollToBottom(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(0, 0),
          applyToHorizontal: false,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta, true);
      },
      scrollToTop: function scrollToTop(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(0, 1),
          applyToHorizontal: false,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToLeft: function scrollToLeft(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(0, 0),
          applyToHorizontal: true,
          applyToVertical: false
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToRight: function scrollToRight(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(1, 0),
          applyToHorizontal: true,
          applyToVertical: false
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToTopLeft: function scrollToTopLeft(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(0, 1),
          applyToHorizontal: true,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToTopRight: function scrollToTopRight(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(1, 1),
          applyToHorizontal: true,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToBottomLeft: function scrollToBottomLeft(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(0, 0),
          applyToHorizontal: true,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToBottomRight: function scrollToBottomRight(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(1, 0),
          applyToHorizontal: true,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToOffset: function scrollToOffset(offset, timeInSecond, attenuated) {
        var maxScrollOffset = this.getMaxScrollOffset();
        var anchor = cc.v2(0, 0);
        0 === maxScrollOffset.x ? anchor.x = 0 : anchor.x = offset.x / maxScrollOffset.x;
        0 === maxScrollOffset.y ? anchor.y = 1 : anchor.y = (maxScrollOffset.y - offset.y) / maxScrollOffset.y;
        this.scrollTo(anchor, timeInSecond, attenuated);
      },
      getScrollOffset: function getScrollOffset() {
        var topDelta = this._getContentTopBoundary() - this._topBoundary;
        var leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
        return cc.v2(leftDeta, topDelta);
      },
      getMaxScrollOffset: function getMaxScrollOffset() {
        var viewSize = this._view.getContentSize();
        var contentSize = this.content.getContentSize();
        var horizontalMaximizeOffset = contentSize.width - viewSize.width;
        var verticalMaximizeOffset = contentSize.height - viewSize.height;
        horizontalMaximizeOffset = horizontalMaximizeOffset >= 0 ? horizontalMaximizeOffset : 0;
        verticalMaximizeOffset = verticalMaximizeOffset >= 0 ? verticalMaximizeOffset : 0;
        return cc.v2(horizontalMaximizeOffset, verticalMaximizeOffset);
      },
      scrollToPercentHorizontal: function scrollToPercentHorizontal(percent, timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(percent, 0),
          applyToHorizontal: true,
          applyToVertical: false
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollTo: function scrollTo(anchor, timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(anchor),
          applyToHorizontal: true,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToPercentVertical: function scrollToPercentVertical(percent, timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(0, percent),
          applyToHorizontal: false,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      stopAutoScroll: function stopAutoScroll() {
        this._autoScrolling = false;
        this._autoScrollAccumulatedTime = this._autoScrollTotalTime;
      },
      setContentPosition: function setContentPosition(position) {
        if (position.fuzzyEquals(this.getContentPosition(), EPSILON)) return;
        this.content.setPosition(position);
        this._outOfBoundaryAmountDirty = true;
      },
      getContentPosition: function getContentPosition() {
        return this.content.getPosition();
      },
      isScrolling: function isScrolling() {
        return this._scrolling;
      },
      isAutoScrolling: function isAutoScrolling() {
        return this._autoScrolling;
      },
      _registerEvent: function _registerEvent() {
        this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this, true);
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this, true);
        this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this, true);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
        this.node.on(cc.Node.EventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
      },
      _unregisterEvent: function _unregisterEvent() {
        this.node.off(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this, true);
        this.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this, true);
        this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this, true);
        this.node.off(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
        this.node.off(cc.Node.EventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
      },
      _onMouseWheel: function _onMouseWheel(event, captureListeners) {
        if (!this.enabledInHierarchy) return;
        if (this._hasNestedViewGroup(event, captureListeners)) return;
        var deltaMove = cc.v2(0, 0);
        var wheelPrecision = -.1;
        false, false;
        this.vertical ? deltaMove = cc.v2(0, event.getScrollY() * wheelPrecision) : this.horizontal && (deltaMove = cc.v2(event.getScrollY() * wheelPrecision, 0));
        this._mouseWheelEventElapsedTime = 0;
        this._processDeltaMove(deltaMove);
        if (!this._stopMouseWheel) {
          this._handlePressLogic();
          this.schedule(this._checkMouseWheel, 1 / 60);
          this._stopMouseWheel = true;
        }
        this._stopPropagationIfTargetIsMe(event);
      },
      _checkMouseWheel: function _checkMouseWheel(dt) {
        var currentOutOfBoundary = this._getHowMuchOutOfBoundary();
        var maxElapsedTime = .1;
        if (!currentOutOfBoundary.fuzzyEquals(cc.v2(0, 0), EPSILON)) {
          this._processInertiaScroll();
          this.unschedule(this._checkMouseWheel);
          this._stopMouseWheel = false;
          return;
        }
        this._mouseWheelEventElapsedTime += dt;
        if (this._mouseWheelEventElapsedTime > maxElapsedTime) {
          this._onScrollBarTouchEnded();
          this.unschedule(this._checkMouseWheel);
          this._stopMouseWheel = false;
        }
      },
      _calculateMovePercentDelta: function _calculateMovePercentDelta(options) {
        var anchor = options.anchor;
        var applyToHorizontal = options.applyToHorizontal;
        var applyToVertical = options.applyToVertical;
        this._calculateBoundary();
        anchor = anchor.clampf(cc.v2(0, 0), cc.v2(1, 1));
        var scrollSize = this._view.getContentSize();
        var contentSize = this.content.getContentSize();
        var bottomDeta = this._getContentBottomBoundary() - this._bottomBoundary;
        bottomDeta = -bottomDeta;
        var leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
        leftDeta = -leftDeta;
        var moveDelta = cc.v2(0, 0);
        var totalScrollDelta = 0;
        if (applyToHorizontal) {
          totalScrollDelta = contentSize.width - scrollSize.width;
          moveDelta.x = leftDeta - totalScrollDelta * anchor.x;
        }
        if (applyToVertical) {
          totalScrollDelta = contentSize.height - scrollSize.height;
          moveDelta.y = bottomDeta - totalScrollDelta * anchor.y;
        }
        return moveDelta;
      },
      _moveContentToTopLeft: function _moveContentToTopLeft(scrollViewSize) {
        var contentSize = this.content.getContentSize();
        var bottomDeta = this._getContentBottomBoundary() - this._bottomBoundary;
        bottomDeta = -bottomDeta;
        var moveDelta = cc.v2(0, 0);
        var totalScrollDelta = 0;
        var leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
        leftDeta = -leftDeta;
        if (contentSize.height < scrollViewSize.height) {
          totalScrollDelta = contentSize.height - scrollViewSize.height;
          moveDelta.y = bottomDeta - totalScrollDelta;
          this.verticalScrollBar && this.verticalScrollBar.hide();
        } else this.verticalScrollBar && this.verticalScrollBar.show();
        if (contentSize.width < scrollViewSize.width) {
          totalScrollDelta = contentSize.width - scrollViewSize.width;
          moveDelta.x = leftDeta;
          this.horizontalScrollBar && this.horizontalScrollBar.hide();
        } else this.horizontalScrollBar && this.horizontalScrollBar.show();
        this._moveContent(moveDelta);
        this._adjustContentOutOfBoundary();
      },
      _calculateBoundary: function _calculateBoundary() {
        if (this.content) {
          var layout = this.content.getComponent(cc.Layout);
          layout && layout.enabledInHierarchy && layout.updateLayout();
          var viewSize = this._view.getContentSize();
          var anchorX = viewSize.width * this._view.anchorX;
          var anchorY = viewSize.height * this._view.anchorY;
          this._leftBoundary = -anchorX;
          this._bottomBoundary = -anchorY;
          this._rightBoundary = this._leftBoundary + viewSize.width;
          this._topBoundary = this._bottomBoundary + viewSize.height;
          this._moveContentToTopLeft(viewSize);
        }
      },
      _hasNestedViewGroup: function _hasNestedViewGroup(event, captureListeners) {
        if (event.eventPhase !== cc.Event.CAPTURING_PHASE) return;
        if (captureListeners) for (var i = 0; i < captureListeners.length; ++i) {
          var item = captureListeners[i];
          if (this.node === item) {
            if (event.target.getComponent(cc.ViewGroup)) return true;
            return false;
          }
          if (item.getComponent(cc.ViewGroup)) return true;
        }
        return false;
      },
      _stopPropagationIfTargetIsMe: function _stopPropagationIfTargetIsMe(event) {
        event.eventPhase === cc.Event.AT_TARGET && event.target === this.node && event.stopPropagation();
      },
      _onTouchBegan: function _onTouchBegan(event, captureListeners) {
        if (!this.enabledInHierarchy) return;
        if (this._hasNestedViewGroup(event, captureListeners)) return;
        var touch = event.touch;
        this.content && this._handlePressLogic(touch);
        this._touchMoved = false;
        this._stopPropagationIfTargetIsMe(event);
      },
      _onTouchMoved: function _onTouchMoved(event, captureListeners) {
        if (!this.enabledInHierarchy) return;
        if (this._hasNestedViewGroup(event, captureListeners)) return;
        var touch = event.touch;
        this.content && this._handleMoveLogic(touch);
        if (!this.cancelInnerEvents) return;
        var deltaMove = touch.getLocation().sub(touch.getStartLocation());
        if (deltaMove.mag() > 7 && !this._touchMoved && event.target !== this.node) {
          var cancelEvent = new cc.Event.EventTouch(event.getTouches(), event.bubbles);
          cancelEvent.type = cc.Node.EventType.TOUCH_CANCEL;
          cancelEvent.touch = event.touch;
          cancelEvent.simulate = true;
          event.target.dispatchEvent(cancelEvent);
          this._touchMoved = true;
        }
        this._stopPropagationIfTargetIsMe(event);
      },
      _onTouchEnded: function _onTouchEnded(event, captureListeners) {
        if (!this.enabledInHierarchy) return;
        if (this._hasNestedViewGroup(event, captureListeners)) return;
        this._dispatchEvent("touch-up");
        var touch = event.touch;
        this.content && this._handleReleaseLogic(touch);
        this._touchMoved ? event.stopPropagation() : this._stopPropagationIfTargetIsMe(event);
      },
      _onTouchCancelled: function _onTouchCancelled(event, captureListeners) {
        if (!this.enabledInHierarchy) return;
        if (this._hasNestedViewGroup(event, captureListeners)) return;
        if (!event.simulate) {
          var touch = event.touch;
          this.content && this._handleReleaseLogic(touch);
        }
        this._stopPropagationIfTargetIsMe(event);
      },
      _processDeltaMove: function _processDeltaMove(deltaMove) {
        this._scrollChildren(deltaMove);
        this._gatherTouchMove(deltaMove);
      },
      _handleMoveLogic: function _handleMoveLogic(touch) {
        var deltaMove = touch.getDelta();
        this._processDeltaMove(deltaMove);
      },
      _scrollChildren: function _scrollChildren(deltaMove) {
        deltaMove = this._clampDelta(deltaMove);
        var realMove = deltaMove;
        var outOfBoundary = void 0;
        if (this.elastic) {
          outOfBoundary = this._getHowMuchOutOfBoundary();
          realMove.x *= 0 === outOfBoundary.x ? 1 : .5;
          realMove.y *= 0 === outOfBoundary.y ? 1 : .5;
        }
        if (!this.elastic) {
          outOfBoundary = this._getHowMuchOutOfBoundary(realMove);
          realMove = realMove.add(outOfBoundary);
        }
        var scrollEventType = -1;
        if (realMove.y > 0) {
          var icBottomPos = this.content.y - this.content.anchorY * this.content.height;
          icBottomPos + realMove.y > this._bottomBoundary && (scrollEventType = "scroll-to-bottom");
        } else if (realMove.y < 0) {
          var icTopPos = this.content.y - this.content.anchorY * this.content.height + this.content.height;
          icTopPos + realMove.y <= this._topBoundary && (scrollEventType = "scroll-to-top");
        }
        if (realMove.x < 0) {
          var icRightPos = this.content.x - this.content.anchorX * this.content.width + this.content.width;
          icRightPos + realMove.x <= this._rightBoundary && (scrollEventType = "scroll-to-right");
        } else if (realMove.x > 0) {
          var icLeftPos = this.content.x - this.content.anchorX * this.content.width;
          icLeftPos + realMove.x >= this._leftBoundary && (scrollEventType = "scroll-to-left");
        }
        this._moveContent(realMove, false);
        if (0 !== realMove.x || 0 !== realMove.y) {
          if (!this._scrolling) {
            this._scrolling = true;
            this._dispatchEvent("scroll-began");
          }
          this._dispatchEvent("scrolling");
        }
        -1 !== scrollEventType && this._dispatchEvent(scrollEventType);
      },
      _handlePressLogic: function _handlePressLogic() {
        this._autoScrolling && this._dispatchEvent("scroll-ended");
        this._autoScrolling = false;
        this._isBouncing = false;
        this._touchMovePreviousTimestamp = getTimeInMilliseconds();
        this._touchMoveDisplacements.length = 0;
        this._touchMoveTimeDeltas.length = 0;
        this._onScrollBarTouchBegan();
      },
      _clampDelta: function _clampDelta(delta) {
        var contentSize = this.content.getContentSize();
        var scrollViewSize = this._view.getContentSize();
        contentSize.width < scrollViewSize.width && (delta.x = 0);
        contentSize.height < scrollViewSize.height && (delta.y = 0);
        return delta;
      },
      _gatherTouchMove: function _gatherTouchMove(delta) {
        delta = this._clampDelta(delta);
        while (this._touchMoveDisplacements.length >= NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED) {
          this._touchMoveDisplacements.shift();
          this._touchMoveTimeDeltas.shift();
        }
        this._touchMoveDisplacements.push(delta);
        var timeStamp = getTimeInMilliseconds();
        this._touchMoveTimeDeltas.push((timeStamp - this._touchMovePreviousTimestamp) / 1e3);
        this._touchMovePreviousTimestamp = timeStamp;
      },
      _startBounceBackIfNeeded: function _startBounceBackIfNeeded() {
        if (!this.elastic) return false;
        var bounceBackAmount = this._getHowMuchOutOfBoundary();
        bounceBackAmount = this._clampDelta(bounceBackAmount);
        if (bounceBackAmount.fuzzyEquals(cc.v2(0, 0), EPSILON)) return false;
        var bounceBackTime = Math.max(this.bounceDuration, 0);
        this._startAutoScroll(bounceBackAmount, bounceBackTime, true);
        if (!this._isBouncing) {
          bounceBackAmount.y > 0 && this._dispatchEvent("bounce-top");
          bounceBackAmount.y < 0 && this._dispatchEvent("bounce-bottom");
          bounceBackAmount.x > 0 && this._dispatchEvent("bounce-right");
          bounceBackAmount.x < 0 && this._dispatchEvent("bounce-left");
          this._isBouncing = true;
        }
        return true;
      },
      _processInertiaScroll: function _processInertiaScroll() {
        var bounceBackStarted = this._startBounceBackIfNeeded();
        if (!bounceBackStarted && this.inertia) {
          var touchMoveVelocity = this._calculateTouchMoveVelocity();
          !touchMoveVelocity.fuzzyEquals(cc.v2(0, 0), EPSILON) && this.brake < 1 && this._startInertiaScroll(touchMoveVelocity);
        }
        this._onScrollBarTouchEnded();
      },
      _handleReleaseLogic: function _handleReleaseLogic(touch) {
        var delta = touch.getDelta();
        this._gatherTouchMove(delta);
        this._processInertiaScroll();
        if (this._scrolling) {
          this._scrolling = false;
          this._autoScrolling || this._dispatchEvent("scroll-ended");
        }
      },
      _isOutOfBoundary: function _isOutOfBoundary() {
        var outOfBoundary = this._getHowMuchOutOfBoundary();
        return !outOfBoundary.fuzzyEquals(cc.v2(0, 0), EPSILON);
      },
      _isNecessaryAutoScrollBrake: function _isNecessaryAutoScrollBrake() {
        if (this._autoScrollBraking) return true;
        if (this._isOutOfBoundary()) {
          if (!this._autoScrollCurrentlyOutOfBoundary) {
            this._autoScrollCurrentlyOutOfBoundary = true;
            this._autoScrollBraking = true;
            this._autoScrollBrakingStartPosition = this.getContentPosition();
            return true;
          }
        } else this._autoScrollCurrentlyOutOfBoundary = false;
        return false;
      },
      getScrollEndedEventTiming: function getScrollEndedEventTiming() {
        return EPSILON;
      },
      _processAutoScrolling: function _processAutoScrolling(dt) {
        var isAutoScrollBrake = this._isNecessaryAutoScrollBrake();
        var brakingFactor = isAutoScrollBrake ? OUT_OF_BOUNDARY_BREAKING_FACTOR : 1;
        this._autoScrollAccumulatedTime += dt * (1 / brakingFactor);
        var percentage = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);
        this._autoScrollAttenuate && (percentage = quintEaseOut(percentage));
        var newPosition = this._autoScrollStartPosition.add(this._autoScrollTargetDelta.mul(percentage));
        var reachedEnd = Math.abs(percentage - 1) <= EPSILON;
        var fireEvent = Math.abs(percentage - 1) <= this.getScrollEndedEventTiming();
        if (fireEvent && !this._isScrollEndedWithThresholdEventFired) {
          this._dispatchEvent("scroll-ended-with-threshold");
          this._isScrollEndedWithThresholdEventFired = true;
        }
        if (this.elastic) {
          var brakeOffsetPosition = newPosition.sub(this._autoScrollBrakingStartPosition);
          isAutoScrollBrake && (brakeOffsetPosition = brakeOffsetPosition.mul(brakingFactor));
          newPosition = this._autoScrollBrakingStartPosition.add(brakeOffsetPosition);
        } else {
          var moveDelta = newPosition.sub(this.getContentPosition());
          var outOfBoundary = this._getHowMuchOutOfBoundary(moveDelta);
          if (!outOfBoundary.fuzzyEquals(cc.v2(0, 0), EPSILON)) {
            newPosition = newPosition.add(outOfBoundary);
            reachedEnd = true;
          }
        }
        reachedEnd && (this._autoScrolling = false);
        var deltaMove = newPosition.sub(this.getContentPosition());
        this._moveContent(this._clampDelta(deltaMove), reachedEnd);
        this._dispatchEvent("scrolling");
        if (!this._autoScrolling) {
          this._isBouncing = false;
          this._scrolling = false;
          this._dispatchEvent("scroll-ended");
        }
      },
      _startInertiaScroll: function _startInertiaScroll(touchMoveVelocity) {
        var inertiaTotalMovement = touchMoveVelocity.mul(MOVEMENT_FACTOR);
        this._startAttenuatingAutoScroll(inertiaTotalMovement, touchMoveVelocity);
      },
      _calculateAttenuatedFactor: function _calculateAttenuatedFactor(distance) {
        if (this.brake <= 0) return 1 - this.brake;
        return (1 - this.brake) * (1 / (1 + 14e-6 * distance + distance * distance * 8e-9));
      },
      _startAttenuatingAutoScroll: function _startAttenuatingAutoScroll(deltaMove, initialVelocity) {
        var time = this._calculateAutoScrollTimeByInitalSpeed(initialVelocity.mag());
        var targetDelta = deltaMove.normalize();
        var contentSize = this.content.getContentSize();
        var scrollviewSize = this._view.getContentSize();
        var totalMoveWidth = contentSize.width - scrollviewSize.width;
        var totalMoveHeight = contentSize.height - scrollviewSize.height;
        var attenuatedFactorX = this._calculateAttenuatedFactor(totalMoveWidth);
        var attenuatedFactorY = this._calculateAttenuatedFactor(totalMoveHeight);
        targetDelta = cc.v2(targetDelta.x * totalMoveWidth * (1 - this.brake) * attenuatedFactorX, targetDelta.y * totalMoveHeight * attenuatedFactorY * (1 - this.brake));
        var originalMoveLength = deltaMove.mag();
        var factor = targetDelta.mag() / originalMoveLength;
        targetDelta = targetDelta.add(deltaMove);
        if (this.brake > 0 && factor > 7) {
          factor = Math.sqrt(factor);
          targetDelta = deltaMove.mul(factor).add(deltaMove);
        }
        if (this.brake > 0 && factor > 3) {
          factor = 3;
          time *= factor;
        }
        0 === this.brake && factor > 1 && (time *= factor);
        this._startAutoScroll(targetDelta, time, true);
      },
      _calculateAutoScrollTimeByInitalSpeed: function _calculateAutoScrollTimeByInitalSpeed(initalSpeed) {
        return Math.sqrt(Math.sqrt(initalSpeed / 5));
      },
      _startAutoScroll: function _startAutoScroll(deltaMove, timeInSecond, attenuated) {
        var adjustedDeltaMove = this._flattenVectorByDirection(deltaMove);
        this._autoScrolling = true;
        this._autoScrollTargetDelta = adjustedDeltaMove;
        this._autoScrollAttenuate = attenuated;
        this._autoScrollStartPosition = this.getContentPosition();
        this._autoScrollTotalTime = timeInSecond;
        this._autoScrollAccumulatedTime = 0;
        this._autoScrollBraking = false;
        this._isScrollEndedWithThresholdEventFired = false;
        this._autoScrollBrakingStartPosition = cc.v2(0, 0);
        var currentOutOfBoundary = this._getHowMuchOutOfBoundary();
        currentOutOfBoundary.fuzzyEquals(cc.v2(0, 0), EPSILON) || (this._autoScrollCurrentlyOutOfBoundary = true);
      },
      _calculateTouchMoveVelocity: function _calculateTouchMoveVelocity() {
        var totalTime = 0;
        totalTime = this._touchMoveTimeDeltas.reduce((function(a, b) {
          return a + b;
        }), totalTime);
        if (totalTime <= 0 || totalTime >= .5) return cc.v2(0, 0);
        var totalMovement = cc.v2(0, 0);
        totalMovement = this._touchMoveDisplacements.reduce((function(a, b) {
          return a.add(b);
        }), totalMovement);
        return cc.v2(totalMovement.x * (1 - this.brake) / totalTime, totalMovement.y * (1 - this.brake) / totalTime);
      },
      _flattenVectorByDirection: function _flattenVectorByDirection(vector) {
        var result = vector;
        result.x = this.horizontal ? result.x : 0;
        result.y = this.vertical ? result.y : 0;
        return result;
      },
      _moveContent: function _moveContent(deltaMove, canStartBounceBack) {
        var adjustedMove = this._flattenVectorByDirection(deltaMove);
        var newPosition = this.getContentPosition().add(adjustedMove);
        this.setContentPosition(newPosition);
        var outOfBoundary = this._getHowMuchOutOfBoundary();
        this._updateScrollBar(outOfBoundary);
        this.elastic && canStartBounceBack && this._startBounceBackIfNeeded();
      },
      _getContentLeftBoundary: function _getContentLeftBoundary() {
        var contentPos = this.getContentPosition();
        return contentPos.x - this.content.getAnchorPoint().x * this.content.getContentSize().width;
      },
      _getContentRightBoundary: function _getContentRightBoundary() {
        var contentSize = this.content.getContentSize();
        return this._getContentLeftBoundary() + contentSize.width;
      },
      _getContentTopBoundary: function _getContentTopBoundary() {
        var contentSize = this.content.getContentSize();
        return this._getContentBottomBoundary() + contentSize.height;
      },
      _getContentBottomBoundary: function _getContentBottomBoundary() {
        var contentPos = this.getContentPosition();
        return contentPos.y - this.content.getAnchorPoint().y * this.content.getContentSize().height;
      },
      _getHowMuchOutOfBoundary: function _getHowMuchOutOfBoundary(addition) {
        addition = addition || cc.v2(0, 0);
        if (addition.fuzzyEquals(cc.v2(0, 0), EPSILON) && !this._outOfBoundaryAmountDirty) return this._outOfBoundaryAmount;
        var outOfBoundaryAmount = cc.v2(0, 0);
        this._getContentLeftBoundary() + addition.x > this._leftBoundary ? outOfBoundaryAmount.x = this._leftBoundary - (this._getContentLeftBoundary() + addition.x) : this._getContentRightBoundary() + addition.x < this._rightBoundary && (outOfBoundaryAmount.x = this._rightBoundary - (this._getContentRightBoundary() + addition.x));
        this._getContentTopBoundary() + addition.y < this._topBoundary ? outOfBoundaryAmount.y = this._topBoundary - (this._getContentTopBoundary() + addition.y) : this._getContentBottomBoundary() + addition.y > this._bottomBoundary && (outOfBoundaryAmount.y = this._bottomBoundary - (this._getContentBottomBoundary() + addition.y));
        if (addition.fuzzyEquals(cc.v2(0, 0), EPSILON)) {
          this._outOfBoundaryAmount = outOfBoundaryAmount;
          this._outOfBoundaryAmountDirty = false;
        }
        outOfBoundaryAmount = this._clampDelta(outOfBoundaryAmount);
        return outOfBoundaryAmount;
      },
      _updateScrollBar: function _updateScrollBar(outOfBoundary) {
        this.horizontalScrollBar && this.horizontalScrollBar._onScroll(outOfBoundary);
        this.verticalScrollBar && this.verticalScrollBar._onScroll(outOfBoundary);
      },
      _onScrollBarTouchBegan: function _onScrollBarTouchBegan() {
        this.horizontalScrollBar && this.horizontalScrollBar._onTouchBegan();
        this.verticalScrollBar && this.verticalScrollBar._onTouchBegan();
      },
      _onScrollBarTouchEnded: function _onScrollBarTouchEnded() {
        this.horizontalScrollBar && this.horizontalScrollBar._onTouchEnded();
        this.verticalScrollBar && this.verticalScrollBar._onTouchEnded();
      },
      _dispatchEvent: function _dispatchEvent(event) {
        if ("scroll-ended" === event) this._scrollEventEmitMask = 0; else if ("scroll-to-top" === event || "scroll-to-bottom" === event || "scroll-to-left" === event || "scroll-to-right" === event) {
          var flag = 1 << eventMap[event];
          if (this._scrollEventEmitMask & flag) return;
          this._scrollEventEmitMask |= flag;
        }
        cc.Component.EventHandler.emitEvents(this.scrollEvents, this, eventMap[event]);
        this.node.emit(event, this);
      },
      _adjustContentOutOfBoundary: function _adjustContentOutOfBoundary() {
        this._outOfBoundaryAmountDirty = true;
        if (this._isOutOfBoundary()) {
          var outOfBoundary = this._getHowMuchOutOfBoundary(cc.v2(0, 0));
          var newPosition = this.getContentPosition().add(outOfBoundary);
          if (this.content) {
            this.content.setPosition(newPosition);
            this._updateScrollBar(0);
          }
        }
      },
      start: function start() {
        this._calculateBoundary();
        this.content && cc.director.once(cc.Director.EVENT_BEFORE_DRAW, this._adjustContentOutOfBoundary, this);
      },
      _hideScrollbar: function _hideScrollbar() {
        this.horizontalScrollBar && this.horizontalScrollBar.hide();
        this.verticalScrollBar && this.verticalScrollBar.hide();
      },
      _showScrollbar: function _showScrollbar() {
        this.horizontalScrollBar && this.horizontalScrollBar.show();
        this.verticalScrollBar && this.verticalScrollBar.show();
      },
      onDisable: function onDisable() {
        true;
        this._unregisterEvent();
        if (this.content) {
          this.content.off(NodeEvent.SIZE_CHANGED, this._calculateBoundary, this);
          this.content.off(NodeEvent.SCALE_CHANGED, this._calculateBoundary, this);
          if (this._view) {
            this._view.off(NodeEvent.POSITION_CHANGED, this._calculateBoundary, this);
            this._view.off(NodeEvent.SCALE_CHANGED, this._calculateBoundary, this);
            this._view.off(NodeEvent.SIZE_CHANGED, this._calculateBoundary, this);
          }
        }
        this._hideScrollbar();
        this.stopAutoScroll();
      },
      onEnable: function onEnable() {
        true;
        this._registerEvent();
        if (this.content) {
          this.content.on(NodeEvent.SIZE_CHANGED, this._calculateBoundary, this);
          this.content.on(NodeEvent.SCALE_CHANGED, this._calculateBoundary, this);
          if (this._view) {
            this._view.on(NodeEvent.POSITION_CHANGED, this._calculateBoundary, this);
            this._view.on(NodeEvent.SCALE_CHANGED, this._calculateBoundary, this);
            this._view.on(NodeEvent.SIZE_CHANGED, this._calculateBoundary, this);
          }
        }
        this._showScrollbar();
      },
      update: function update(dt) {
        this._autoScrolling && this._processAutoScrolling(dt);
      }
    });
    cc.ScrollView = module.exports = ScrollView;
  }), {
    "../CCNode": 6,
    "./CCViewGroup": 55
  } ],
  50: [ (function(require, module, exports) {
    "use strict";
    var misc = require("../utils/misc");
    var Component = require("./CCComponent");
    var Direction = cc.Enum({
      Horizontal: 0,
      Vertical: 1
    });
    var Slider = cc.Class({
      name: "cc.Slider",
      extends: Component,
      editor: false,
      ctor: function ctor() {
        this._offset = cc.v2();
        this._touchHandle = false;
        this._dragging = false;
      },
      properties: {
        handle: {
          default: null,
          type: cc.Button,
          tooltip: false,
          notify: function notify() {
            false;
          }
        },
        direction: {
          default: Direction.Horizontal,
          type: Direction,
          tooltip: false
        },
        progress: {
          default: .5,
          type: cc.Float,
          range: [ 0, 1, .1 ],
          slide: true,
          tooltip: false,
          notify: function notify() {
            this._updateHandlePosition();
          }
        },
        slideEvents: {
          default: [],
          type: cc.Component.EventHandler,
          tooltip: false
        }
      },
      statics: {
        Direction: Direction
      },
      __preload: function __preload() {
        this._updateHandlePosition();
      },
      onEnable: function onEnable() {
        this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this);
        this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this);
        if (this.handle && this.handle.isValid) {
          this.handle.node.on(cc.Node.EventType.TOUCH_START, this._onHandleDragStart, this);
          this.handle.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this);
          this.handle.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        }
      },
      onDisable: function onDisable() {
        this.node.off(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        this.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this);
        this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        this.node.off(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this);
        if (this.handle && this.handle.isValid) {
          this.handle.node.off(cc.Node.EventType.TOUCH_START, this._onHandleDragStart, this);
          this.handle.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this);
          this.handle.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        }
      },
      _onHandleDragStart: function _onHandleDragStart(event) {
        this._dragging = true;
        this._touchHandle = true;
        this._offset = this.handle.node.convertToNodeSpaceAR(event.touch.getLocation());
        event.stopPropagation();
      },
      _onTouchBegan: function _onTouchBegan(event) {
        if (!this.handle) return;
        this._dragging = true;
        this._touchHandle || this._handleSliderLogic(event.touch);
        event.stopPropagation();
      },
      _onTouchMoved: function _onTouchMoved(event) {
        if (!this._dragging) return;
        this._handleSliderLogic(event.touch);
        event.stopPropagation();
      },
      _onTouchEnded: function _onTouchEnded(event) {
        this._dragging = false;
        this._touchHandle = false;
        this._offset = cc.v2();
        event.stopPropagation();
      },
      _onTouchCancelled: function _onTouchCancelled(event) {
        this._dragging = false;
        event.stopPropagation();
      },
      _handleSliderLogic: function _handleSliderLogic(touch) {
        this._updateProgress(touch);
        this._emitSlideEvent();
      },
      _emitSlideEvent: function _emitSlideEvent() {
        cc.Component.EventHandler.emitEvents(this.slideEvents, this);
        this.node.emit("slide", this);
      },
      _updateProgress: function _updateProgress(touch) {
        if (!this.handle) return;
        var localTouchPos = this.node.convertToNodeSpace(touch.getLocation());
        this.direction === Direction.Horizontal ? this.progress = misc.clamp01((localTouchPos.x - this._offset.x) / this.node.width) : this.progress = misc.clamp01((localTouchPos.y - this._offset.y) / this.node.height);
      },
      _updateHandlePosition: function _updateHandlePosition() {
        if (!this.handle) return;
        var handlelocalPos;
        handlelocalPos = this.direction === Direction.Horizontal ? cc.v2(-this.node.width * this.node.anchorX + this.progress * this.node.width, 0) : cc.v2(0, -this.node.height * this.node.anchorY + this.progress * this.node.height);
        var worldSpacePos = this.node.convertToWorldSpaceAR(handlelocalPos);
        this.handle.node.position = this.handle.node.parent.convertToNodeSpaceAR(worldSpacePos);
      }
    });
    cc.Slider = module.exports = Slider;
  }), {
    "../utils/misc": 187,
    "./CCComponent": 39
  } ],
  51: [ (function(require, module, exports) {
    "use strict";
    var misc = require("../utils/misc");
    var NodeEvent = require("../CCNode").EventType;
    var RenderComponent = require("./CCRenderComponent");
    var RenderFlow = require("../renderer/render-flow");
    var BlendFunc = require("../utils/blend-func");
    var Material = require("../assets/material/CCMaterial");
    var SpriteType = cc.Enum({
      SIMPLE: 0,
      SLICED: 1,
      TILED: 2,
      FILLED: 3,
      MESH: 4
    });
    var FillType = cc.Enum({
      HORIZONTAL: 0,
      VERTICAL: 1,
      RADIAL: 2
    });
    var SizeMode = cc.Enum({
      CUSTOM: 0,
      TRIMMED: 1,
      RAW: 2
    });
    var State = cc.Enum({
      NORMAL: 0,
      GRAY: 1
    });
    var Sprite = cc.Class({
      name: "cc.Sprite",
      extends: RenderComponent,
      mixins: [ BlendFunc ],
      editor: false,
      properties: {
        _spriteFrame: {
          default: null,
          type: cc.SpriteFrame
        },
        _type: SpriteType.SIMPLE,
        _sizeMode: SizeMode.TRIMMED,
        _fillType: 0,
        _fillCenter: cc.v2(0, 0),
        _fillStart: 0,
        _fillRange: 0,
        _isTrimmedMode: true,
        _atlas: {
          default: null,
          type: cc.SpriteAtlas,
          tooltip: false,
          editorOnly: true,
          visible: true,
          animatable: false
        },
        spriteFrame: {
          get: function get() {
            return this._spriteFrame;
          },
          set: function set(value, force) {
            var lastSprite = this._spriteFrame;
            false;
            if (lastSprite === value) return;
            this._spriteFrame = value;
            this.markForUpdateRenderData(false);
            this._applySpriteFrame(lastSprite);
            false;
          },
          type: cc.SpriteFrame
        },
        type: {
          get: function get() {
            return this._type;
          },
          set: function set(value) {
            if (this._type !== value) {
              this.destroyRenderData(this._renderData);
              this._renderData = null;
              this._type = value;
              this._updateAssembler();
            }
          },
          type: SpriteType,
          animatable: false,
          tooltip: false
        },
        fillType: {
          get: function get() {
            return this._fillType;
          },
          set: function set(value) {
            if (value !== this._fillType) {
              if (value === FillType.RADIAL || this._fillType === FillType.RADIAL) {
                this.destroyRenderData(this._renderData);
                this._renderData = null;
              } else this._renderData && this.markForUpdateRenderData(true);
              this._fillType = value;
              this._updateAssembler();
            }
          },
          type: FillType,
          tooltip: false
        },
        fillCenter: {
          get: function get() {
            return this._fillCenter;
          },
          set: function set(value) {
            this._fillCenter.x = value.x;
            this._fillCenter.y = value.y;
            this._type === SpriteType.FILLED && this._renderData && this.markForUpdateRenderData(true);
          },
          tooltip: false
        },
        fillStart: {
          get: function get() {
            return this._fillStart;
          },
          set: function set(value) {
            this._fillStart = misc.clampf(value, -1, 1);
            this._type === SpriteType.FILLED && this._renderData && this.markForUpdateRenderData(true);
          },
          tooltip: false
        },
        fillRange: {
          get: function get() {
            return this._fillRange;
          },
          set: function set(value) {
            this._fillRange = misc.clampf(value, -1, 1);
            this._type === SpriteType.FILLED && this._renderData && this.markForUpdateRenderData(true);
          },
          tooltip: false
        },
        trim: {
          get: function get() {
            return this._isTrimmedMode;
          },
          set: function set(value) {
            if (this._isTrimmedMode !== value) {
              this._isTrimmedMode = value;
              this._type !== SpriteType.SIMPLE && this._type !== SpriteType.MESH || !this._renderData || this.markForUpdateRenderData(true);
            }
          },
          animatable: false,
          tooltip: false
        },
        sizeMode: {
          get: function get() {
            return this._sizeMode;
          },
          set: function set(value) {
            this._sizeMode = value;
            value !== SizeMode.CUSTOM && this._applySpriteSize();
          },
          animatable: false,
          type: SizeMode,
          tooltip: false
        }
      },
      statics: {
        FillType: FillType,
        Type: SpriteType,
        SizeMode: SizeMode,
        State: State
      },
      setVisible: function setVisible(visible) {
        this.enabled = visible;
      },
      setState: function setState() {},
      getState: function getState() {},
      onEnable: function onEnable() {
        this._super();
        if (!this._spriteFrame || !this._spriteFrame.textureLoaded()) {
          this.disableRender();
          if (this._spriteFrame) {
            this._spriteFrame.once("load", this._onTextureLoaded, this);
            this._spriteFrame.ensureLoadTexture();
          }
        }
        this._updateAssembler();
        this._activateMaterial();
        this.node.on(NodeEvent.SIZE_CHANGED, this._onNodeSizeDirty, this);
        this.node.on(NodeEvent.ANCHOR_CHANGED, this._onNodeSizeDirty, this);
      },
      onDisable: function onDisable() {
        this._super();
        this.node.off(NodeEvent.SIZE_CHANGED, this._onNodeSizeDirty, this);
        this.node.off(NodeEvent.ANCHOR_CHANGED, this._onNodeSizeDirty, this);
      },
      _onNodeSizeDirty: function _onNodeSizeDirty() {
        if (!this._renderData) return;
        this.markForUpdateRenderData(true);
      },
      _on3DNodeChanged: function _on3DNodeChanged() {
        this._updateAssembler();
      },
      _updateAssembler: function _updateAssembler() {
        var assembler = Sprite._assembler.getAssembler(this);
        if (this._assembler !== assembler) {
          this._assembler = assembler;
          this._renderData = null;
        }
        if (!this._renderData) {
          this._renderData = this._assembler.createData(this);
          this.markForUpdateRenderData(true);
        }
      },
      _activateMaterial: function _activateMaterial() {
        if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) {
          this.markForUpdateRenderData(true);
          this.markForRender(true);
          return;
        }
        var spriteFrame = this._spriteFrame;
        if (!spriteFrame || !spriteFrame.textureLoaded()) {
          this.disableRender();
          return;
        }
        var material = this.sharedMaterials[0];
        material = material ? Material.getInstantiatedMaterial(material, this) : Material.getInstantiatedBuiltinMaterial("2d-sprite", this);
        material.setProperty("texture", spriteFrame.getTexture());
        this.setMaterial(0, material);
        this.markForRender(true);
      },
      _applyAtlas: false,
      _canRender: function _canRender() {
        if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) {
          if (!this._enabled) return false;
        } else if (!this._enabled || !this.sharedMaterials[0] || !this.node._activeInHierarchy) return false;
        var spriteFrame = this._spriteFrame;
        if (!spriteFrame || !spriteFrame.textureLoaded()) return false;
        return true;
      },
      markForUpdateRenderData: function markForUpdateRenderData(enable) {
        if (enable && this._canRender()) {
          this.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA;
          var renderData = this._renderData;
          if (renderData) {
            renderData.uvDirty = true;
            renderData.vertDirty = true;
          }
        } else enable || (this.node._renderFlag &= ~RenderFlow.FLAG_UPDATE_RENDER_DATA);
      },
      _applySpriteSize: function _applySpriteSize() {
        if (this._spriteFrame) {
          if (SizeMode.RAW === this._sizeMode) {
            var size = this._spriteFrame.getOriginalSize();
            this.node.setContentSize(size);
          } else if (SizeMode.TRIMMED === this._sizeMode) {
            var rect = this._spriteFrame.getRect();
            this.node.setContentSize(rect.width, rect.height);
          }
          this._activateMaterial();
        }
      },
      _onTextureLoaded: function _onTextureLoaded() {
        if (!this.isValid) return;
        this._applySpriteSize();
      },
      _applySpriteFrame: function _applySpriteFrame(oldFrame) {
        oldFrame && oldFrame.off && oldFrame.off("load", this._onTextureLoaded, this);
        var spriteFrame = this._spriteFrame;
        var material = this.sharedMaterials[0];
        spriteFrame && (material && material._texture) === (spriteFrame && spriteFrame._texture) || this.markForRender(false);
        if (spriteFrame) if (oldFrame && spriteFrame._texture === oldFrame._texture) this._applySpriteSize(); else if (spriteFrame.textureLoaded()) this._onTextureLoaded(null); else {
          spriteFrame.once("load", this._onTextureLoaded, this);
          spriteFrame.ensureLoadTexture();
        }
        false;
      },
      _resized: false
    });
    false;
    cc.Sprite = module.exports = Sprite;
  }), {
    "../CCNode": 6,
    "../assets/material/CCMaterial": 29,
    "../renderer/render-flow": 148,
    "../utils/blend-func": 181,
    "../utils/misc": 187,
    "./CCRenderComponent": 47
  } ],
  52: [ (function(require, module, exports) {
    "use strict";
    var GraySpriteState = require("../utils/gray-sprite-state");
    var Toggle = cc.Class({
      name: "cc.Toggle",
      extends: require("./CCButton"),
      mixins: [ GraySpriteState ],
      editor: false,
      properties: {
        _N$isChecked: true,
        isChecked: {
          get: function get() {
            return this._N$isChecked;
          },
          set: function set(value) {
            if (value === this._N$isChecked) return;
            var group = this.toggleGroup || this._toggleContainer;
            if (group && group.enabled && this._N$isChecked && !group.allowSwitchOff) return;
            this._N$isChecked = value;
            this._updateCheckMark();
            group && group.enabled && group.updateToggles(this);
            this._emitToggleEvents();
          },
          tooltip: false
        },
        toggleGroup: {
          default: null,
          tooltip: false,
          type: require("./CCToggleGroup")
        },
        checkMark: {
          default: null,
          type: cc.Sprite,
          tooltip: false
        },
        checkEvents: {
          default: [],
          type: cc.Component.EventHandler
        },
        _resizeToTarget: {
          animatable: false,
          set: function set(value) {
            value && this._resizeNodeToTargetNode();
          }
        }
      },
      onEnable: function onEnable() {
        this._super();
        true;
        this._registerToggleEvent();
        this.toggleGroup && this.toggleGroup.enabledInHierarchy && this.toggleGroup.addToggle(this);
      },
      onDisable: function onDisable() {
        this._super();
        true;
        this._unregisterToggleEvent();
        this.toggleGroup && this.toggleGroup.enabledInHierarchy && this.toggleGroup.removeToggle(this);
      },
      _hideCheckMark: function _hideCheckMark() {
        this._N$isChecked = false;
        this._updateCheckMark();
      },
      toggle: function toggle(event) {
        this.isChecked = !this.isChecked;
      },
      check: function check() {
        this.isChecked = true;
      },
      uncheck: function uncheck() {
        this.isChecked = false;
      },
      _updateCheckMark: function _updateCheckMark() {
        this.checkMark && (this.checkMark.node.active = !!this.isChecked);
      },
      _updateDisabledState: function _updateDisabledState() {
        this._super();
        if (this.enableAutoGrayEffect && this.checkMark) {
          var useGrayMaterial = !this.interactable;
          this._switchGrayMaterial(useGrayMaterial, this.checkMark);
        }
      },
      _registerToggleEvent: function _registerToggleEvent() {
        this.node.on("click", this.toggle, this);
      },
      _unregisterToggleEvent: function _unregisterToggleEvent() {
        this.node.off("click", this.toggle, this);
      },
      _emitToggleEvents: function _emitToggleEvents() {
        this.node.emit("toggle", this);
        this.checkEvents && cc.Component.EventHandler.emitEvents(this.checkEvents, this);
      }
    });
    cc.Toggle = module.exports = Toggle;
    var js = require("../platform/js");
    js.get(Toggle.prototype, "_toggleContainer", (function() {
      var parent = this.node.parent;
      if (cc.Node.isNode(parent)) return parent.getComponent(cc.ToggleContainer);
      return null;
    }));
  }), {
    "../platform/js": 124,
    "../utils/gray-sprite-state": 184,
    "./CCButton": 37,
    "./CCToggleGroup": 54
  } ],
  53: [ (function(require, module, exports) {
    "use strict";
    var ToggleContainer = cc.Class({
      name: "cc.ToggleContainer",
      extends: cc.Component,
      editor: false,
      properties: {
        allowSwitchOff: {
          tooltip: false,
          default: false
        },
        checkEvents: {
          default: [],
          type: cc.Component.EventHandler
        }
      },
      updateToggles: function updateToggles(toggle) {
        if (!this.enabledInHierarchy) return;
        if (toggle.isChecked) {
          this.toggleItems.forEach((function(item) {
            item !== toggle && item.isChecked && item.enabled && item._hideCheckMark();
          }));
          this.checkEvents && cc.Component.EventHandler.emitEvents(this.checkEvents, toggle);
        }
      },
      _allowOnlyOneToggleChecked: function _allowOnlyOneToggleChecked() {
        var isChecked = false;
        this.toggleItems.forEach((function(item) {
          isChecked ? item._hideCheckMark() : item.isChecked && (isChecked = true);
        }));
        return isChecked;
      },
      _makeAtLeastOneToggleChecked: function _makeAtLeastOneToggleChecked() {
        var isChecked = this._allowOnlyOneToggleChecked();
        if (!isChecked && !this.allowSwitchOff) {
          var toggleItems = this.toggleItems;
          toggleItems.length > 0 && toggleItems[0].check();
        }
      },
      onEnable: function onEnable() {
        this.node.on("child-added", this._allowOnlyOneToggleChecked, this);
        this.node.on("child-removed", this._makeAtLeastOneToggleChecked, this);
      },
      onDisable: function onDisable() {
        this.node.off("child-added", this._allowOnlyOneToggleChecked, this);
        this.node.off("child-removed", this._makeAtLeastOneToggleChecked, this);
      },
      start: function start() {
        this._makeAtLeastOneToggleChecked();
      }
    });
    var js = require("../platform/js");
    js.get(ToggleContainer.prototype, "toggleItems", (function() {
      return this.node.getComponentsInChildren(cc.Toggle);
    }));
    cc.ToggleContainer = module.exports = ToggleContainer;
  }), {
    "../platform/js": 124
  } ],
  54: [ (function(require, module, exports) {
    "use strict";
    var ToggleGroup = cc.Class({
      name: "cc.ToggleGroup",
      extends: cc.Component,
      ctor: function ctor() {
        this._toggleItems = [];
      },
      editor: false,
      properties: {
        allowSwitchOff: {
          tooltip: false,
          default: false
        },
        toggleItems: {
          get: function get() {
            return this._toggleItems;
          }
        }
      },
      updateToggles: function updateToggles(toggle) {
        if (!this.enabledInHierarchy) return;
        this._toggleItems.forEach((function(item) {
          toggle.isChecked && item !== toggle && item.isChecked && item.enabled && item._hideCheckMark();
        }));
      },
      addToggle: function addToggle(toggle) {
        var index = this._toggleItems.indexOf(toggle);
        -1 === index && this._toggleItems.push(toggle);
        this._allowOnlyOneToggleChecked();
      },
      removeToggle: function removeToggle(toggle) {
        var index = this._toggleItems.indexOf(toggle);
        index > -1 && this._toggleItems.splice(index, 1);
        this._makeAtLeastOneToggleChecked();
      },
      _allowOnlyOneToggleChecked: function _allowOnlyOneToggleChecked() {
        var isChecked = false;
        this._toggleItems.forEach((function(item) {
          isChecked && item.enabled && item._hideCheckMark();
          item.isChecked && item.enabled && (isChecked = true);
        }));
        return isChecked;
      },
      _makeAtLeastOneToggleChecked: function _makeAtLeastOneToggleChecked() {
        var isChecked = this._allowOnlyOneToggleChecked();
        isChecked || this.allowSwitchOff || this._toggleItems.length > 0 && (this._toggleItems[0].isChecked = true);
      },
      start: function start() {
        this._makeAtLeastOneToggleChecked();
      }
    });
    var js = require("../platform/js");
    var showed = false;
    js.get(cc, "ToggleGroup", (function() {
      if (!showed) {
        cc.logID(1405, "cc.ToggleGroup", "cc.ToggleContainer");
        showed = true;
      }
      return ToggleGroup;
    }));
    module.exports = ToggleGroup;
  }), {
    "../platform/js": 124
  } ],
  55: [ (function(require, module, exports) {
    "use strict";
    var ViewGroup = cc.Class({
      name: "cc.ViewGroup",
      extends: require("./CCComponent")
    });
    cc.ViewGroup = module.exports = ViewGroup;
  }), {
    "./CCComponent": 39
  } ],
  56: [ (function(require, module, exports) {
    "use strict";
    var WidgetManager = require("../base-ui/CCWidgetManager");
    var AlignMode = WidgetManager.AlignMode;
    var AlignFlags = WidgetManager._AlignFlags;
    var TOP = AlignFlags.TOP;
    var MID = AlignFlags.MID;
    var BOT = AlignFlags.BOT;
    var LEFT = AlignFlags.LEFT;
    var CENTER = AlignFlags.CENTER;
    var RIGHT = AlignFlags.RIGHT;
    var TOP_BOT = TOP | BOT;
    var LEFT_RIGHT = LEFT | RIGHT;
    var Widget = cc.Class({
      name: "cc.Widget",
      extends: require("./CCComponent"),
      editor: false,
      properties: {
        target: {
          get: function get() {
            return this._target;
          },
          set: function set(value) {
            this._target = value;
            false;
          },
          type: cc.Node,
          tooltip: false
        },
        isAlignTop: {
          get: function get() {
            return (this._alignFlags & TOP) > 0;
          },
          set: function set(value) {
            this._setAlign(TOP, value);
          },
          animatable: false,
          tooltip: false
        },
        isAlignVerticalCenter: {
          get: function get() {
            return (this._alignFlags & MID) > 0;
          },
          set: function set(value) {
            if (value) {
              this.isAlignTop = false;
              this.isAlignBottom = false;
              this._alignFlags |= MID;
            } else this._alignFlags &= ~MID;
          },
          animatable: false,
          tooltip: false
        },
        isAlignBottom: {
          get: function get() {
            return (this._alignFlags & BOT) > 0;
          },
          set: function set(value) {
            this._setAlign(BOT, value);
          },
          animatable: false,
          tooltip: false
        },
        isAlignLeft: {
          get: function get() {
            return (this._alignFlags & LEFT) > 0;
          },
          set: function set(value) {
            this._setAlign(LEFT, value);
          },
          animatable: false,
          tooltip: false
        },
        isAlignHorizontalCenter: {
          get: function get() {
            return (this._alignFlags & CENTER) > 0;
          },
          set: function set(value) {
            if (value) {
              this.isAlignLeft = false;
              this.isAlignRight = false;
              this._alignFlags |= CENTER;
            } else this._alignFlags &= ~CENTER;
          },
          animatable: false,
          tooltip: false
        },
        isAlignRight: {
          get: function get() {
            return (this._alignFlags & RIGHT) > 0;
          },
          set: function set(value) {
            this._setAlign(RIGHT, value);
          },
          animatable: false,
          tooltip: false
        },
        isStretchWidth: {
          get: function get() {
            return (this._alignFlags & LEFT_RIGHT) === LEFT_RIGHT;
          },
          visible: false
        },
        isStretchHeight: {
          get: function get() {
            return (this._alignFlags & TOP_BOT) === TOP_BOT;
          },
          visible: false
        },
        top: {
          get: function get() {
            return this._top;
          },
          set: function set(value) {
            this._top = value;
          },
          tooltip: false
        },
        bottom: {
          get: function get() {
            return this._bottom;
          },
          set: function set(value) {
            this._bottom = value;
          },
          tooltip: false
        },
        left: {
          get: function get() {
            return this._left;
          },
          set: function set(value) {
            this._left = value;
          },
          tooltip: false
        },
        right: {
          get: function get() {
            return this._right;
          },
          set: function set(value) {
            this._right = value;
          },
          tooltip: false
        },
        horizontalCenter: {
          get: function get() {
            return this._horizontalCenter;
          },
          set: function set(value) {
            this._horizontalCenter = value;
          },
          tooltip: false
        },
        verticalCenter: {
          get: function get() {
            return this._verticalCenter;
          },
          set: function set(value) {
            this._verticalCenter = value;
          },
          tooltip: false
        },
        isAbsoluteHorizontalCenter: {
          get: function get() {
            return this._isAbsHorizontalCenter;
          },
          set: function set(value) {
            this._isAbsHorizontalCenter = value;
          },
          animatable: false
        },
        isAbsoluteVerticalCenter: {
          get: function get() {
            return this._isAbsVerticalCenter;
          },
          set: function set(value) {
            this._isAbsVerticalCenter = value;
          },
          animatable: false
        },
        isAbsoluteTop: {
          get: function get() {
            return this._isAbsTop;
          },
          set: function set(value) {
            this._isAbsTop = value;
          },
          animatable: false
        },
        isAbsoluteBottom: {
          get: function get() {
            return this._isAbsBottom;
          },
          set: function set(value) {
            this._isAbsBottom = value;
          },
          animatable: false
        },
        isAbsoluteLeft: {
          get: function get() {
            return this._isAbsLeft;
          },
          set: function set(value) {
            this._isAbsLeft = value;
          },
          animatable: false
        },
        isAbsoluteRight: {
          get: function get() {
            return this._isAbsRight;
          },
          set: function set(value) {
            this._isAbsRight = value;
          },
          animatable: false
        },
        alignMode: {
          default: AlignMode.ON_WINDOW_RESIZE,
          type: AlignMode,
          tooltip: false
        },
        _wasAlignOnce: {
          default: void 0,
          formerlySerializedAs: "isAlignOnce"
        },
        _target: null,
        _alignFlags: 0,
        _left: 0,
        _right: 0,
        _top: 0,
        _bottom: 0,
        _verticalCenter: 0,
        _horizontalCenter: 0,
        _isAbsLeft: true,
        _isAbsRight: true,
        _isAbsTop: true,
        _isAbsBottom: true,
        _isAbsHorizontalCenter: true,
        _isAbsVerticalCenter: true,
        _originalWidth: 0,
        _originalHeight: 0
      },
      statics: {
        AlignMode: AlignMode
      },
      onLoad: function onLoad() {
        if (void 0 !== this._wasAlignOnce) {
          this.alignMode = this._wasAlignOnce ? AlignMode.ONCE : AlignMode.ALWAYS;
          this._wasAlignOnce = void 0;
        }
      },
      onEnable: function onEnable() {
        WidgetManager.add(this);
      },
      onDisable: function onDisable() {
        WidgetManager.remove(this);
      },
      _validateTargetInDEV: false,
      _setAlign: function _setAlign(flag, isAlign) {
        var current = (this._alignFlags & flag) > 0;
        if (isAlign === current) return;
        var isHorizontal = (flag & LEFT_RIGHT) > 0;
        if (isAlign) {
          this._alignFlags |= flag;
          if (isHorizontal) {
            this.isAlignHorizontalCenter = false;
            if (this.isStretchWidth) {
              this._originalWidth = this.node.width;
              false;
            }
          } else {
            this.isAlignVerticalCenter = false;
            if (this.isStretchHeight) {
              this._originalHeight = this.node.height;
              false;
            }
          }
          false;
        } else {
          isHorizontal ? this.isStretchWidth && (this.node.width = this._originalWidth) : this.isStretchHeight && (this.node.height = this._originalHeight);
          this._alignFlags &= ~flag;
        }
      },
      updateAlignment: function updateAlignment() {
        WidgetManager.updateAlignment(this.node);
      }
    });
    Object.defineProperty(Widget.prototype, "isAlignOnce", {
      get: function get() {
        true;
        cc.warn("`widget.isAlignOnce` is deprecated, use `widget.alignMode === cc.Widget.AlignMode.ONCE` instead please.");
        return this.alignMode === AlignMode.ONCE;
      },
      set: function set(value) {
        true;
        cc.warn("`widget.isAlignOnce` is deprecated, use `widget.alignMode = cc.Widget.AlignMode.*` instead please.");
        this.alignMode = value ? AlignMode.ONCE : AlignMode.ALWAYS;
      }
    });
    cc.Widget = module.exports = Widget;
  }), {
    "../base-ui/CCWidgetManager": 32,
    "./CCComponent": 39
  } ],
  57: [ (function(require, module, exports) {
    "use strict";
    var Component = require("./CCComponent");
    var SwanSubContextView = void 0;
    var isBaiduGame = cc.sys.platform === cc.sys.BAIDU_GAME;
    true, SwanSubContextView = isBaiduGame ? cc.Class({
      name: "cc.SwanSubContextView",
      extends: Component,
      editor: false,
      properties: {
        _fps: 60,
        fps: {
          get: function get() {
            return this._fps;
          },
          set: function set(value) {
            if (this._fps === value) return;
            this._fps = value;
            this._updateInterval = 1 / value;
            this._updateSubContextFrameRate();
          },
          tooltip: false
        }
      },
      ctor: function ctor() {
        this._sprite = null;
        this._tex = new cc.Texture2D();
        this._context = null;
        this._updatedTime = performance.now();
        this._updateInterval = 0;
      },
      onLoad: function onLoad() {
        if (swan.getOpenDataContext) {
          this._updateInterval = 1e3 / this._fps;
          this._context = swan.getOpenDataContext();
          var sharedCanvas = this._context.canvas;
          if (sharedCanvas) {
            sharedCanvas.width = this.node.width;
            sharedCanvas.height = this.node.height;
          }
          this._tex.setPremultiplyAlpha(true);
          this._tex.initWithElement(sharedCanvas);
          this._sprite = this.node.getComponent(cc.Sprite);
          if (!this._sprite) {
            this._sprite = this.node.addComponent(cc.Sprite);
            this._sprite.srcBlendFactor = cc.macro.BlendFactor.ONE;
          }
          this._sprite.spriteFrame = new cc.SpriteFrame(this._tex);
        } else this.enabled = false;
      },
      onEnable: function onEnable() {
        this._runSubContextMainLoop();
        this._registerNodeEvent();
        this._updateSubContextFrameRate();
        this.updateSubContextViewport();
      },
      onDisable: function onDisable() {
        this._unregisterNodeEvent();
        this._stopSubContextMainLoop();
      },
      update: function update(dt) {
        var calledUpdateMannually = void 0 === dt;
        if (calledUpdateMannually) {
          this._context && this._context.postMessage({
            fromEngine: true,
            event: "step"
          });
          this._updateSubContextTexture();
          return;
        }
        var now = performance.now();
        var deltaTime = now - this._updatedTime;
        if (deltaTime >= this._updateInterval) {
          this._updatedTime += this._updateInterval;
          this._updateSubContextTexture();
        }
      },
      _updateSubContextTexture: function _updateSubContextTexture() {
        if (!this._tex || !this._context) return;
        this._tex.initWithElement(this._context.canvas);
        this._sprite._activateMaterial();
      },
      updateSubContextViewport: function updateSubContextViewport() {
        if (this._context) {
          var box = this.node.getBoundingBoxToWorld();
          var sx = cc.view._scaleX;
          var sy = cc.view._scaleY;
          this._context.postMessage({
            fromEngine: true,
            event: "viewport",
            x: box.x * sx + cc.view._viewportRect.x,
            y: box.y * sy + cc.view._viewportRect.y,
            width: box.width * sx,
            height: box.height * sy
          });
        }
      },
      _registerNodeEvent: function _registerNodeEvent() {
        this.node.on("position-changed", this.updateSubContextViewport, this);
        this.node.on("scale-changed", this.updateSubContextViewport, this);
        this.node.on("size-changed", this.updateSubContextViewport, this);
      },
      _unregisterNodeEvent: function _unregisterNodeEvent() {
        this.node.off("position-changed", this.updateSubContextViewport, this);
        this.node.off("scale-changed", this.updateSubContextViewport, this);
        this.node.off("size-changed", this.updateSubContextViewport, this);
      },
      _runSubContextMainLoop: function _runSubContextMainLoop() {
        this._context && this._context.postMessage({
          fromEngine: true,
          event: "mainLoop",
          value: true
        });
      },
      _stopSubContextMainLoop: function _stopSubContextMainLoop() {
        this._context && this._context.postMessage({
          fromEngine: true,
          event: "mainLoop",
          value: false
        });
      },
      _updateSubContextFrameRate: function _updateSubContextFrameRate() {
        this._context && this._context.postMessage({
          fromEngine: true,
          event: "frameRate",
          value: this._fps
        });
      }
    }) : cc.Class({
      name: "cc.SwanSubContextView",
      extends: Component
    });
    cc.SwanSubContextView = module.exports = SwanSubContextView;
  }), {
    "./CCComponent": 39
  } ],
  58: [ (function(require, module, exports) {
    "use strict";
    var Component = require("./CCComponent");
    var WXSubContextView = void 0;
    true, true;
    WXSubContextView = cc.Class({
      name: "cc.WXSubContextView",
      extends: Component
    });
    cc.WXSubContextView = module.exports = WXSubContextView;
  }), {
    "./CCComponent": 39
  } ],
  59: [ (function(require, module, exports) {
    "use strict";
    var macro = require("../../platform/CCMacro");
    var EditBoxImplBase = require("./EditBoxImplBase");
    var Label = require("../CCLabel");
    var Types = require("./types");
    var InputMode = Types.InputMode;
    var InputFlag = Types.InputFlag;
    var KeyboardReturnType = Types.KeyboardReturnType;
    function capitalize(string) {
      return string.replace(/(?:^|\s)\S/g, (function(a) {
        return a.toUpperCase();
      }));
    }
    function capitalizeFirstLetter(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }
    var EditBox = cc.Class({
      name: "cc.EditBox",
      extends: cc.Component,
      editor: false,
      properties: {
        _useOriginalSize: true,
        _string: "",
        string: {
          tooltip: false,
          get: function get() {
            return this._string;
          },
          set: function set(value) {
            this.maxLength >= 0 && value.length >= this.maxLength && (value = value.slice(0, this.maxLength));
            this._string = value;
            this._updateString(value);
          }
        },
        textLabel: {
          tooltip: false,
          default: null,
          type: Label,
          notify: function notify(oldValue) {
            if (this.textLabel && this.textLabel !== oldValue) {
              this._updateTextLabel();
              this._updateLabels();
            }
          }
        },
        placeholderLabel: {
          tooltip: false,
          default: null,
          type: Label,
          notify: function notify(oldValue) {
            if (this.placeholderLabel && this.placeholderLabel !== oldValue) {
              this._updatePlaceholderLabel();
              this._updateLabels();
            }
          }
        },
        background: {
          tooltip: false,
          default: null,
          type: cc.Sprite,
          notify: function notify(oldValue) {
            this.background && this.background !== oldValue && this._updateBackgroundSprite();
          }
        },
        _N$backgroundImage: {
          default: void 0,
          type: cc.SpriteFrame
        },
        backgroundImage: {
          get: function get() {
            if (!this.background) return null;
            return this.background.spriteFrame;
          },
          set: function set(value) {
            this.background && (this.background.spriteFrame = value);
          }
        },
        returnType: {
          default: KeyboardReturnType.DEFAULT,
          tooltip: false,
          displayName: "KeyboardReturnType",
          type: KeyboardReturnType
        },
        _N$returnType: {
          default: void 0,
          type: cc.Float
        },
        inputFlag: {
          tooltip: false,
          default: InputFlag.DEFAULT,
          type: InputFlag,
          notify: function notify() {
            this._updateString(this._string);
          }
        },
        inputMode: {
          tooltip: false,
          default: InputMode.ANY,
          type: InputMode,
          notify: function notify(oldValue) {
            if (this.inputMode !== oldValue) {
              this._updateTextLabel();
              this._updatePlaceholderLabel();
            }
          }
        },
        fontSize: {
          get: function get() {
            if (!this.textLabel) return null;
            return this.textLabel.fontSize;
          },
          set: function set(value) {
            this.textLabel && (this.textLabel.fontSize = value);
          }
        },
        _N$fontSize: {
          default: void 0,
          type: cc.Float
        },
        lineHeight: {
          get: function get() {
            if (!this.textLabel) return null;
            return this.textLabel.lineHeight;
          },
          set: function set(value) {
            this.textLabel && (this.textLabel.lineHeight = value);
          }
        },
        _N$lineHeight: {
          default: void 0,
          type: cc.Float
        },
        fontColor: {
          get: function get() {
            if (!this.textLabel) return null;
            return this.textLabel.node.color;
          },
          set: function set(value) {
            if (this.textLabel) {
              this.textLabel.node.color = value;
              this.textLabel.node.opacity = value.a;
            }
          }
        },
        _N$fontColor: {
          default: void 0,
          type: cc.Color
        },
        placeholder: {
          tooltip: false,
          get: function get() {
            if (!this.placeholderLabel) return "";
            return this.placeholderLabel.string;
          },
          set: function set(value) {
            this.placeholderLabel && (this.placeholderLabel.string = value);
          }
        },
        _N$placeholder: {
          default: void 0,
          type: cc.String
        },
        placeholderFontSize: {
          get: function get() {
            if (!this.placeholderLabel) return null;
            return this.placeholderLabel.fontSize;
          },
          set: function set(value) {
            this.placeholderLabel && (this.placeholderLabel.fontSize = value);
          }
        },
        _N$placeholderFontSize: {
          default: void 0,
          type: cc.Float
        },
        placeholderFontColor: {
          get: function get() {
            if (!this.placeholderLabel) return null;
            return this.placeholderLabel.node.color;
          },
          set: function set(value) {
            if (this.placeholderLabel) {
              this.placeholderLabel.node.color = value;
              this.placeholderLabel.node.opacity = value.a;
            }
          }
        },
        _N$placeholderFontColor: {
          default: void 0,
          type: cc.Color
        },
        maxLength: {
          tooltip: false,
          default: 20
        },
        _N$maxLength: {
          default: void 0,
          type: cc.Float
        },
        stayOnTop: {
          default: false,
          notify: function notify() {
            cc.warn("editBox.stayOnTop is removed since v2.1.");
          }
        },
        _tabIndex: 0,
        tabIndex: {
          tooltip: false,
          get: function get() {
            return this._tabIndex;
          },
          set: function set(value) {
            if (this._tabIndex !== value) {
              this._tabIndex = value;
              this._impl && this._impl.setTabIndex(value);
            }
          }
        },
        editingDidBegan: {
          default: [],
          type: cc.Component.EventHandler
        },
        textChanged: {
          default: [],
          type: cc.Component.EventHandler
        },
        editingDidEnded: {
          default: [],
          type: cc.Component.EventHandler
        },
        editingReturn: {
          default: [],
          type: cc.Component.EventHandler
        }
      },
      statics: {
        _ImplClass: EditBoxImplBase,
        KeyboardReturnType: KeyboardReturnType,
        InputFlag: InputFlag,
        InputMode: InputMode
      },
      _init: function _init() {
        this._upgradeComp();
        this._isLabelVisible = true;
        this.node.on(cc.Node.EventType.SIZE_CHANGED, this._syncSize, this);
        var impl = this._impl = new EditBox._ImplClass();
        impl.init(this);
        this._updateString(this._string);
        this._syncSize();
      },
      _updateBackgroundSprite: function _updateBackgroundSprite() {
        var background = this.background;
        if (!background) {
          var node = this.node.getChildByName("BACKGROUND_SPRITE");
          node || (node = new cc.Node("BACKGROUND_SPRITE"));
          background = node.getComponent(cc.Sprite);
          background || (background = node.addComponent(cc.Sprite));
          node.parent = this.node;
          this.background = background;
        }
        background.type = cc.Sprite.Type.SLICED;
        if (void 0 !== this._N$backgroundImage) {
          background.spriteFrame = this._N$backgroundImage;
          this._N$backgroundImage = void 0;
        }
      },
      _updateTextLabel: function _updateTextLabel() {
        var textLabel = this.textLabel;
        if (!textLabel) {
          var node = this.node.getChildByName("TEXT_LABEL");
          node || (node = new cc.Node("TEXT_LABEL"));
          textLabel = node.getComponent(Label);
          textLabel || (textLabel = node.addComponent(Label));
          node.parent = this.node;
          this.textLabel = textLabel;
        }
        textLabel.node.setAnchorPoint(0, 1);
        textLabel.overflow = Label.Overflow.CLAMP;
        if (this.inputMode === InputMode.ANY) {
          textLabel.verticalAlign = macro.VerticalTextAlignment.TOP;
          textLabel.enableWrapText = true;
        } else {
          textLabel.verticalAlign = macro.VerticalTextAlignment.CENTER;
          textLabel.enableWrapText = false;
        }
        textLabel.string = this._updateLabelStringStyle(this._string);
        if (void 0 !== this._N$fontColor) {
          textLabel.node.color = this._N$fontColor;
          textLabel.node.opacity = this._N$fontColor.a;
          this._N$fontColor = void 0;
        }
        if (void 0 !== this._N$fontSize) {
          textLabel.fontSize = this._N$fontSize;
          this._N$fontSize = void 0;
        }
        if (void 0 !== this._N$lineHeight) {
          textLabel.lineHeight = this._N$lineHeight;
          this._N$lineHeight = void 0;
        }
      },
      _updatePlaceholderLabel: function _updatePlaceholderLabel() {
        var placeholderLabel = this.placeholderLabel;
        if (!placeholderLabel) {
          var node = this.node.getChildByName("PLACEHOLDER_LABEL");
          node || (node = new cc.Node("PLACEHOLDER_LABEL"));
          placeholderLabel = node.getComponent(Label);
          placeholderLabel || (placeholderLabel = node.addComponent(Label));
          node.parent = this.node;
          this.placeholderLabel = placeholderLabel;
        }
        placeholderLabel.node.setAnchorPoint(0, 1);
        placeholderLabel.overflow = Label.Overflow.CLAMP;
        if (this.inputMode === InputMode.ANY) {
          placeholderLabel.verticalAlign = macro.VerticalTextAlignment.TOP;
          placeholderLabel.enableWrapText = true;
        } else {
          placeholderLabel.verticalAlign = macro.VerticalTextAlignment.CENTER;
          placeholderLabel.enableWrapText = false;
        }
        placeholderLabel.string = this.placeholder;
        if (void 0 !== this._N$placeholderFontColor) {
          placeholderLabel.node.color = this._N$placeholderFontColor;
          placeholderLabel.node.opacity = this._N$placeholderFontColor.a;
          this._N$placeholderFontColor = void 0;
        }
        if (void 0 !== this._N$placeholderFontSize) {
          placeholderLabel.fontSize = this._N$placeholderFontSize;
          this._N$placeholderFontSize = void 0;
        }
      },
      _upgradeComp: function _upgradeComp() {
        if (void 0 !== this._N$returnType) {
          this.returnType = this._N$returnType;
          this._N$returnType = void 0;
        }
        if (void 0 !== this._N$maxLength) {
          this.maxLength = this._N$maxLength;
          this._N$maxLength = void 0;
        }
        void 0 !== this._N$backgroundImage && this._updateBackgroundSprite();
        void 0 === this._N$fontColor && void 0 === this._N$fontSize && void 0 === this._N$lineHeight || this._updateTextLabel();
        void 0 === this._N$placeholderFontColor && void 0 === this._N$placeholderFontSize || this._updatePlaceholderLabel();
        if (void 0 !== this._N$placeholder) {
          this.placeholder = this._N$placeholder;
          this._N$placeholder = void 0;
        }
      },
      _syncSize: function _syncSize() {
        if (this._impl) {
          var size = this.node.getContentSize();
          this._impl.setSize(size.width, size.height);
        }
      },
      _showLabels: function _showLabels() {
        this._isLabelVisible = true;
        this._updateLabels();
      },
      _hideLabels: function _hideLabels() {
        this._isLabelVisible = false;
        this.textLabel && (this.textLabel.node.active = false);
        this.placeholderLabel && (this.placeholderLabel.node.active = false);
      },
      _updateLabels: function _updateLabels() {
        if (this._isLabelVisible) {
          var content = this._string;
          this.textLabel && (this.textLabel.node.active = "" !== content);
          this.placeholderLabel && (this.placeholderLabel.node.active = "" === content);
        }
      },
      _updateString: function _updateString(text) {
        var textLabel = this.textLabel;
        if (!textLabel) return;
        var displayText = text;
        displayText && (displayText = this._updateLabelStringStyle(displayText));
        textLabel.string = displayText;
        this._updateLabels();
      },
      _updateLabelStringStyle: function _updateLabelStringStyle(text, ignorePassword) {
        var inputFlag = this.inputFlag;
        if (ignorePassword || inputFlag !== InputFlag.PASSWORD) inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? text = text.toUpperCase() : inputFlag === InputFlag.INITIAL_CAPS_WORD ? text = capitalize(text) : inputFlag === InputFlag.INITIAL_CAPS_SENTENCE && (text = capitalizeFirstLetter(text)); else {
          var passwordString = "";
          var len = text.length;
          for (var i = 0; i < len; ++i) passwordString += "\u25cf";
          text = passwordString;
        }
        return text;
      },
      editBoxEditingDidBegan: function editBoxEditingDidBegan() {
        cc.Component.EventHandler.emitEvents(this.editingDidBegan, this);
        this.node.emit("editing-did-began", this);
      },
      editBoxEditingDidEnded: function editBoxEditingDidEnded() {
        cc.Component.EventHandler.emitEvents(this.editingDidEnded, this);
        this.node.emit("editing-did-ended", this);
      },
      editBoxTextChanged: function editBoxTextChanged(text) {
        text = this._updateLabelStringStyle(text, true);
        this.string = text;
        cc.Component.EventHandler.emitEvents(this.textChanged, text, this);
        this.node.emit("text-changed", this);
      },
      editBoxEditingReturn: function editBoxEditingReturn() {
        cc.Component.EventHandler.emitEvents(this.editingReturn, this);
        this.node.emit("editing-return", this);
      },
      onEnable: function onEnable() {
        true;
        this._registerEvent();
        this._impl && this._impl.enable();
      },
      onDisable: function onDisable() {
        true;
        this._unregisterEvent();
        this._impl && this._impl.disable();
      },
      onDestroy: function onDestroy() {
        this._impl && this._impl.clear();
      },
      __preload: function __preload() {
        this._init();
      },
      _registerEvent: function _registerEvent() {
        this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
      },
      _unregisterEvent: function _unregisterEvent() {
        this.node.off(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
      },
      _onTouchBegan: function _onTouchBegan(event) {
        event.stopPropagation();
      },
      _onTouchCancel: function _onTouchCancel(event) {
        event.stopPropagation();
      },
      _onTouchEnded: function _onTouchEnded(event) {
        this._impl && this._impl.beginEditing();
        event.stopPropagation();
      },
      setFocus: function setFocus() {
        cc.warnID(1400, "setFocus()", "focus()");
        this._impl && this._impl.setFocus(true);
      },
      focus: function focus() {
        this._impl && this._impl.setFocus(true);
      },
      blur: function blur() {
        this._impl && this._impl.setFocus(false);
      },
      isFocused: function isFocused() {
        return !!this._impl && this._impl.isFocused();
      },
      update: function update() {
        this._impl && this._impl.update();
      }
    });
    cc.EditBox = module.exports = EditBox;
    cc.sys.isBrowser && require("./WebEditBoxImpl");
  }), {
    "../../platform/CCMacro": 109,
    "../CCLabel": 41,
    "./EditBoxImplBase": 60,
    "./WebEditBoxImpl": 61,
    "./types": 63
  } ],
  60: [ (function(require, module, exports) {
    "use strict";
    var EditBoxImplBase = cc.Class({
      ctor: function ctor() {
        this._delegate = null;
      },
      init: function init(delegate) {},
      enable: function enable() {},
      disable: function disable() {},
      clear: function clear() {},
      update: function update() {},
      setTabIndex: function setTabIndex(index) {},
      setSize: function setSize(width, height) {},
      setFocus: function setFocus(value) {},
      isFocused: function isFocused() {},
      beginEditing: function beginEditing() {},
      endEditing: function endEditing() {}
    });
    module.exports = EditBoxImplBase;
  }), {} ],
  61: [ (function(require, module, exports) {
    "use strict";
    var utils = require("../../platform/utils");
    var macro = require("../../platform/CCMacro");
    var Types = require("./types");
    var Label = require("../CCLabel");
    var tabIndexUtil = require("./tabIndexUtil");
    var EditBox = cc.EditBox;
    var js = cc.js;
    var InputMode = Types.InputMode;
    var InputFlag = Types.InputFlag;
    var KeyboardReturnType = Types.KeyboardReturnType;
    var math = cc.vmath;
    var polyfill = {
      zoomInvalid: false
    };
    cc.sys.OS_ANDROID !== cc.sys.os || cc.sys.browserType !== cc.sys.BROWSER_TYPE_SOUGOU && cc.sys.browserType !== cc.sys.BROWSER_TYPE_360 || (polyfill.zoomInvalid = true);
    var DELAY_TIME = 800;
    var SCROLLY = 100;
    var LEFT_PADDING = 2;
    var _domCount = 0;
    var _vec3 = cc.v3();
    var _currentEditBoxImpl = null;
    var _fullscreen = false;
    var _autoResize = false;
    function WebEditBoxImpl() {
      this._domId = "EditBoxId_" + ++_domCount;
      this._placeholderStyleSheet = null;
      this._elem = null;
      this._isTextArea = false;
      this._editing = false;
      this._worldMat = math.mat4.create();
      this._cameraMat = math.mat4.create();
      this._m00 = 0;
      this._m01 = 0;
      this._m04 = 0;
      this._m05 = 0;
      this._m12 = 0;
      this._m13 = 0;
      this._w = 0;
      this._h = 0;
      this._inputMode = null;
      this._inputFlag = null;
      this._returnType = null;
      this._eventListeners = {};
      this._textLabelFont = null;
      this._textLabelFontSize = null;
      this._textLabelFontColor = null;
      this._textLabelAlign = null;
      this._placeholderLabelFont = null;
      this._placeholderLabelFontSize = null;
      this._placeholderLabelFontColor = null;
      this._placeholderLabelAlign = null;
      this._placeholderLineHeight = null;
    }
    js.extend(WebEditBoxImpl, EditBox._ImplClass);
    EditBox._ImplClass = WebEditBoxImpl;
    Object.assign(WebEditBoxImpl.prototype, {
      init: function init(delegate) {
        if (!delegate) return;
        this._delegate = delegate;
        delegate.inputMode === InputMode.ANY ? this._createTextArea() : this._createInput();
        tabIndexUtil.add(this);
        this.setTabIndex(delegate.tabIndex);
        this._initStyleSheet();
        this._registerEventListeners();
        this._addDomToGameContainer();
        _fullscreen = cc.view.isAutoFullScreenEnabled();
        _autoResize = cc.view._resizeWithBrowserSize;
      },
      enable: function enable() {},
      disable: function disable() {
        this._editing && this._elem.blur();
      },
      clear: function clear() {
        this._removeEventListeners();
        this._removeDomFromGameContainer();
        tabIndexUtil.remove(this);
        _currentEditBoxImpl === this && (_currentEditBoxImpl = null);
      },
      update: function update() {
        this._updateMatrix();
      },
      setTabIndex: function setTabIndex(index) {
        this._elem.tabIndex = index;
        tabIndexUtil.resort();
      },
      setSize: function setSize(width, height) {
        var elem = this._elem;
        elem.style.width = width + "px";
        elem.style.height = height + "px";
      },
      setFocus: function setFocus(value) {
        value ? this.beginEditing() : this._elem.blur();
      },
      isFocused: function isFocused() {
        return this._editing;
      },
      beginEditing: function beginEditing() {
        _currentEditBoxImpl && _currentEditBoxImpl !== this && _currentEditBoxImpl.setFocus(false);
        this._editing = true;
        _currentEditBoxImpl = this;
        this._showDom();
        this._elem.focus();
        this._delegate.editBoxEditingDidBegan();
      },
      endEditing: function endEditing() {},
      _createInput: function _createInput() {
        this._isTextArea = false;
        this._elem = document.createElement("input");
      },
      _createTextArea: function _createTextArea() {
        this._isTextArea = true;
        this._elem = document.createElement("textarea");
      },
      _addDomToGameContainer: function _addDomToGameContainer() {
        cc.game.container.appendChild(this._elem);
        document.head.appendChild(this._placeholderStyleSheet);
      },
      _removeDomFromGameContainer: function _removeDomFromGameContainer() {
        var hasElem = utils.contains(cc.game.container, this._elem);
        hasElem && cc.game.container.removeChild(this._elem);
        var hasStyleSheet = utils.contains(document.head, this._placeholderStyleSheet);
        hasStyleSheet && document.head.removeChild(this._placeholderStyleSheet);
        delete this._elem;
        delete this._placeholderStyleSheet;
      },
      _showDom: function _showDom() {
        this._updateMaxLength();
        this._updateInputType();
        this._updateStyleSheet();
        this._elem.style.display = "";
        this._delegate._hideLabels();
        cc.sys.isMobile && this._showDomOnMobile();
      },
      _hideDom: function _hideDom() {
        var elem = this._elem;
        elem.style.display = "none";
        this._delegate._showLabels();
        cc.sys.isMobile && this._hideDomOnMobile();
      },
      _showDomOnMobile: function _showDomOnMobile() {
        if (cc.sys.os !== cc.sys.OS_ANDROID) return;
        if (_fullscreen) {
          cc.view.enableAutoFullScreen(false);
          cc.screen.exitFullScreen();
        }
        _autoResize && cc.view.resizeWithBrowserSize(false);
        this._adjustWindowScroll();
      },
      _hideDomOnMobile: function _hideDomOnMobile() {
        cc.sys.os === cc.sys.OS_ANDROID && setTimeout((function() {
          if (!_currentEditBoxImpl) {
            _fullscreen && cc.view.enableAutoFullScreen(true);
            _autoResize && cc.view.resizeWithBrowserSize(true);
          }
        }), DELAY_TIME);
        this._scrollBackWindow();
      },
      _adjustWindowScroll: function _adjustWindowScroll() {
        var self = this;
        setTimeout((function() {
          window.scrollY < SCROLLY && self._elem.scrollIntoView({
            block: "start",
            inline: "nearest",
            behavior: "smooth"
          });
        }), DELAY_TIME);
      },
      _scrollBackWindow: function _scrollBackWindow() {
        setTimeout((function() {
          var sys = cc.sys;
          if (sys.browserType === sys.BROWSER_TYPE_WECHAT && sys.os === sys.OS_IOS) {
            window.top && window.top.scrollTo(0, 0);
            return;
          }
          window.scrollTo(0, 0);
        }), DELAY_TIME);
      },
      _updateMatrix: function _updateMatrix() {
        var node = this._delegate.node;
        node.getWorldMatrix(this._worldMat);
        var worldMat = this._worldMat;
        if (this._m00 === worldMat.m00 && this._m01 === worldMat.m01 && this._m04 === worldMat.m04 && this._m05 === worldMat.m05 && this._m12 === worldMat.m12 && this._m13 === worldMat.m13 && this._w === node._contentSize.width && this._h === node._contentSize.height) return;
        this._m00 = worldMat.m00;
        this._m01 = worldMat.m01;
        this._m04 = worldMat.m04;
        this._m05 = worldMat.m05;
        this._m12 = worldMat.m12;
        this._m13 = worldMat.m13;
        this._w = node._contentSize.width;
        this._h = node._contentSize.height;
        var scaleX = cc.view._scaleX, scaleY = cc.view._scaleY, viewport = cc.view._viewportRect, dpr = cc.view._devicePixelRatio;
        _vec3.x = -node._anchorPoint.x * this._w;
        _vec3.y = -node._anchorPoint.y * this._h;
        math.mat4.translate(worldMat, worldMat, _vec3);
        var cameraMat = void 0;
        false;
        var camera = cc.Camera.findCamera(node);
        camera.getWorldToCameraMatrix(this._cameraMat);
        cameraMat = this._cameraMat;
        math.mat4.mul(cameraMat, cameraMat, worldMat);
        scaleX /= dpr;
        scaleY /= dpr;
        var container = cc.game.container;
        var a = cameraMat.m00 * scaleX, b = cameraMat.m01, c = cameraMat.m04, d = cameraMat.m05 * scaleY;
        var offsetX = container && container.style.paddingLeft && parseInt(container.style.paddingLeft);
        offsetX += viewport.x / dpr;
        var offsetY = container && container.style.paddingBottom && parseInt(container.style.paddingBottom);
        offsetY += viewport.y / dpr;
        var tx = cameraMat.m12 * scaleX + offsetX, ty = cameraMat.m13 * scaleY + offsetY;
        if (polyfill.zoomInvalid) {
          this.setSize(node.width * a, node.height * d);
          a = 1;
          d = 1;
        }
        var elem = this._elem;
        var matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + tx + "," + -ty + ")";
        elem.style["transform"] = matrix;
        elem.style["-webkit-transform"] = matrix;
        elem.style["transform-origin"] = "0px 100% 0px";
        elem.style["-webkit-transform-origin"] = "0px 100% 0px";
      },
      _updateInputType: function _updateInputType() {
        var delegate = this._delegate, inputMode = delegate.inputMode, inputFlag = delegate.inputFlag, returnType = delegate.returnType, elem = this._elem;
        if (this._inputMode === inputMode && this._inputFlag === inputFlag && this._returnType === returnType) return;
        this._inputMode = inputMode;
        this._inputFlag = inputFlag;
        this._returnType = returnType;
        if (this._isTextArea) {
          var _textTransform = "none";
          inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? _textTransform = "uppercase" : inputFlag === InputFlag.INITIAL_CAPS_WORD && (_textTransform = "capitalize");
          elem.style.textTransform = _textTransform;
          return;
        }
        if (inputFlag === InputFlag.PASSWORD) {
          elem.type = "password";
          return;
        }
        var type = elem.type;
        if (inputMode === InputMode.EMAIL_ADDR) type = "email"; else if (inputMode === InputMode.NUMERIC || inputMode === InputMode.DECIMAL) type = "number"; else if (inputMode === InputMode.PHONE_NUMBER) {
          type = "number";
          elem.pattern = "[0-9]*";
        } else if (inputMode === InputMode.URL) type = "url"; else {
          type = "text";
          returnType === KeyboardReturnType.SEARCH && (type = "search");
        }
        elem.type = type;
        var textTransform = "none";
        inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? textTransform = "uppercase" : inputFlag === InputFlag.INITIAL_CAPS_WORD && (textTransform = "capitalize");
        elem.style.textTransform = textTransform;
      },
      _updateMaxLength: function _updateMaxLength() {
        var maxLength = this._delegate.maxLength;
        maxLength < 0 && (maxLength = 65535);
        this._elem.maxLength = maxLength;
      },
      _initStyleSheet: function _initStyleSheet() {
        var elem = this._elem;
        elem.style.display = "none";
        elem.style.border = 0;
        elem.style.background = "transparent";
        elem.style.width = "100%";
        elem.style.height = "100%";
        elem.style.active = 0;
        elem.style.outline = "medium";
        elem.style.padding = "0";
        elem.style.textTransform = "uppercase";
        elem.style.position = "absolute";
        elem.style.bottom = "0px";
        elem.style.left = LEFT_PADDING + "px";
        elem.className = "cocosEditBox";
        elem.id = this._domId;
        if (this._isTextArea) {
          elem.style.resize = "none";
          elem.style.overflow_y = "scroll";
        } else {
          elem.type = "text";
          elem.style["-moz-appearance"] = "textfield";
        }
        this._placeholderStyleSheet = document.createElement("style");
      },
      _updateStyleSheet: function _updateStyleSheet() {
        var delegate = this._delegate, elem = this._elem;
        elem.value = delegate.string;
        elem.placeholder = delegate.placeholder;
        this._updateTextLabel(delegate.textLabel);
        this._updatePlaceholderLabel(delegate.placeholderLabel);
      },
      _updateTextLabel: function _updateTextLabel(textLabel) {
        if (!textLabel) return;
        var font = textLabel.font;
        font = !font || font instanceof cc.BitmapFont ? textLabel.fontFamily : font._fontFamily;
        if (this._textLabelFont === font && this._textLabelFontSize === textLabel.fontSize && this._textLabelFontColor === textLabel.fontColor && this._textLabelAlign === textLabel.horizontalAlign) return;
        this._textLabelFont = font;
        this._textLabelFontSize = textLabel.fontSize;
        this._textLabelFontColor = textLabel.fontColor;
        this._textLabelAlign = textLabel.horizontalAlign;
        var elem = this._elem;
        elem.style.fontSize = textLabel.fontSize + "px";
        elem.style.color = textLabel.node.color.toCSS("rgba");
        elem.style.fontFamily = font;
        switch (textLabel.horizontalAlign) {
         case Label.HorizontalAlign.LEFT:
          elem.style.textAlign = "left";
          break;

         case Label.HorizontalAlign.CENTER:
          elem.style.textAlign = "center";
          break;

         case Label.HorizontalAlign.RIGHT:
          elem.style.textAlign = "right";
        }
      },
      _updatePlaceholderLabel: function _updatePlaceholderLabel(placeholderLabel) {
        if (!placeholderLabel) return;
        var font = placeholderLabel.font;
        font = !font || font instanceof cc.BitmapFont ? placeholderLabel.fontFamily : placeholderLabel.font._fontFamily;
        if (this._placeholderLabelFont === font && this._placeholderLabelFontSize === placeholderLabel.fontSize && this._placeholderLabelFontColor === placeholderLabel.fontColor && this._placeholderLabelAlign === placeholderLabel.horizontalAlign && this._placeholderLineHeight === placeholderLabel.fontSize) return;
        this._placeholderLabelFont = font;
        this._placeholderLabelFontSize = placeholderLabel.fontSize;
        this._placeholderLabelFontColor = placeholderLabel.fontColor;
        this._placeholderLabelAlign = placeholderLabel.horizontalAlign;
        this._placeholderLineHeight = placeholderLabel.fontSize;
        var styleEl = this._placeholderStyleSheet;
        var fontSize = placeholderLabel.fontSize;
        var fontColor = placeholderLabel.node.color.toCSS("rgba");
        var lineHeight = placeholderLabel.fontSize;
        var horizontalAlign = void 0;
        switch (placeholderLabel.horizontalAlign) {
         case Label.HorizontalAlign.LEFT:
          horizontalAlign = "left";
          break;

         case Label.HorizontalAlign.CENTER:
          horizontalAlign = "center";
          break;

         case Label.HorizontalAlign.RIGHT:
          horizontalAlign = "right";
        }
        styleEl.innerHTML = "\n            #" + this._domId + "::-webkit-input-placeholder {\n                text-transform: initial;\n                font-family: " + font + ";\n                font-size: " + fontSize + "px;\n                color: " + fontColor + ";\n                line-height: " + lineHeight + "px;\n                text-align: " + horizontalAlign + ";\n            }\n            #" + this._domId + "::-moz-placeholder {\n                text-transform: initial;\n                font-family: " + font + ";\n                font-size: " + fontSize + "px;\n                color: " + fontColor + ";\n                line-height: " + lineHeight + "px;\n                text-align: " + horizontalAlign + ";\n            }\n            #" + this._domId + ":-ms-input-placeholder {\n                text-transform: initial;\n                font-family: " + font + ";\n                font-size: " + fontSize + "px;\n                color: " + fontColor + ";\n                line-height: " + lineHeight + "px;\n                text-align: " + horizontalAlign + ";\n            }\n        ";
      },
      _registerEventListeners: function _registerEventListeners() {
        var impl = this, elem = this._elem, inputLock = false, cbs = this._eventListeners;
        cbs.compositionStart = function() {
          inputLock = true;
        };
        cbs.compositionEnd = function() {
          inputLock = false;
          impl._delegate.editBoxTextChanged(elem.value);
        };
        cbs.onInput = function() {
          if (inputLock) return;
          impl._delegate.editBoxTextChanged(elem.value);
        };
        cbs.onClick = function(e) {
          impl._editing && cc.sys.isMobile && impl._adjustWindowScroll();
        };
        cbs.onKeydown = function(e) {
          if (e.keyCode === macro.KEY.enter) {
            e.stopPropagation();
            impl._delegate.editBoxEditingReturn();
            impl._isTextArea || elem.blur();
          } else if (e.keyCode === macro.KEY.tab) {
            e.stopPropagation();
            e.preventDefault();
            tabIndexUtil.next(impl);
          }
        };
        cbs.onBlur = function() {
          impl._editing = false;
          _currentEditBoxImpl = null;
          impl._hideDom();
          impl._delegate.editBoxEditingDidEnded();
        };
        elem.addEventListener("compositionstart", cbs.compositionStart);
        elem.addEventListener("compositionend", cbs.compositionEnd);
        elem.addEventListener("input", cbs.onInput);
        elem.addEventListener("keydown", cbs.onKeydown);
        elem.addEventListener("blur", cbs.onBlur);
        elem.addEventListener("touchstart", cbs.onClick);
      },
      _removeEventListeners: function _removeEventListeners() {
        var elem = this._elem, cbs = this._eventListeners;
        elem.removeEventListener("compositionstart", cbs.compositionStart);
        elem.removeEventListener("compositionend", cbs.compositionEnd);
        elem.removeEventListener("input", cbs.onInput);
        elem.removeEventListener("keydown", cbs.onKeydown);
        elem.removeEventListener("blur", cbs.onBlur);
        elem.removeEventListener("touchstart", cbs.onClick);
        cbs.compositionStart = null;
        cbs.compositionEnd = null;
        cbs.onInput = null;
        cbs.onKeydown = null;
        cbs.onBlur = null;
        cbs.onClick = null;
      }
    });
  }), {
    "../../platform/CCMacro": 109,
    "../../platform/utils": 128,
    "../CCLabel": 41,
    "./tabIndexUtil": 62,
    "./types": 63
  } ],
  62: [ (function(require, module, exports) {
    "use strict";
    var tabIndexUtil = {
      _tabIndexList: [],
      add: function add(editBoxImpl) {
        var list = this._tabIndexList;
        var index = list.indexOf(editBoxImpl);
        -1 === index && list.push(editBoxImpl);
      },
      remove: function remove(editBoxImpl) {
        var list = this._tabIndexList;
        var index = list.indexOf(editBoxImpl);
        -1 !== index && list.splice(index, 1);
      },
      resort: function resort() {
        this._tabIndexList.sort((function(a, b) {
          return a._delegate._tabIndex - b._delegate._tabIndex;
        }));
      },
      next: function next(editBoxImpl) {
        var list = this._tabIndexList;
        var index = list.indexOf(editBoxImpl);
        editBoxImpl.setFocus(false);
        if (-1 !== index) {
          var nextImpl = list[index + 1];
          nextImpl && nextImpl._delegate._tabIndex >= 0 && nextImpl.setFocus(true);
        }
      }
    };
    module.exports = tabIndexUtil;
  }), {} ],
  63: [ (function(require, module, exports) {
    "use strict";
    var KeyboardReturnType = cc.Enum({
      DEFAULT: 0,
      DONE: 1,
      SEND: 2,
      SEARCH: 3,
      GO: 4,
      NEXT: 5
    });
    var InputMode = cc.Enum({
      ANY: 0,
      EMAIL_ADDR: 1,
      NUMERIC: 2,
      PHONE_NUMBER: 3,
      URL: 4,
      DECIMAL: 5,
      SINGLE_LINE: 6
    });
    var InputFlag = cc.Enum({
      PASSWORD: 0,
      SENSITIVE: 1,
      INITIAL_CAPS_WORD: 2,
      INITIAL_CAPS_SENTENCE: 3,
      INITIAL_CAPS_ALL_CHARACTERS: 4,
      DEFAULT: 5
    });
    module.exports = {
      KeyboardReturnType: KeyboardReturnType,
      InputMode: InputMode,
      InputFlag: InputFlag
    };
  }), {} ],
  64: [ (function(require, module, exports) {
    "use strict";
    require("./CCComponent");
    require("./CCComponentEventHandler");
    require("./missing-script");
    var components = [ require("./CCSprite"), require("./CCWidget"), require("./CCCanvas"), require("./CCAudioSource"), require("./CCAnimation"), require("./CCButton"), require("./CCLabel"), require("./CCProgressBar"), require("./CCMask"), require("./CCScrollBar"), require("./CCScrollView"), require("./CCPageViewIndicator"), require("./CCPageView"), require("./CCSlider"), require("./CCLayout"), require("./editbox/CCEditBox"), require("./CCLabelOutline"), require("./CCLabelShadow"), require("./CCRichText"), require("./CCToggleContainer"), require("./CCToggleGroup"), require("./CCToggle"), require("./CCBlockInputEvents"), require("./CCMotionStreak"), require("./WXSubContextView"), require("./SwanSubContextView") ];
    module.exports = components;
  }), {
    "./CCAnimation": void 0,
    "./CCAudioSource": void 0,
    "./CCBlockInputEvents": 36,
    "./CCButton": 37,
    "./CCCanvas": 38,
    "./CCComponent": 39,
    "./CCComponentEventHandler": 40,
    "./CCLabel": 41,
    "./CCLabelOutline": 42,
    "./CCLabelShadow": 43,
    "./CCLayout": 44,
    "./CCMask": 45,
    "./CCMotionStreak": void 0,
    "./CCPageView": void 0,
    "./CCPageViewIndicator": void 0,
    "./CCProgressBar": 46,
    "./CCRichText": void 0,
    "./CCScrollBar": 48,
    "./CCScrollView": 49,
    "./CCSlider": 50,
    "./CCSprite": 51,
    "./CCToggle": 52,
    "./CCToggleContainer": 53,
    "./CCToggleGroup": 54,
    "./CCWidget": 56,
    "./SwanSubContextView": 57,
    "./WXSubContextView": 58,
    "./editbox/CCEditBox": 59,
    "./missing-script": 65
  } ],
  65: [ (function(require, module, exports) {
    "use strict";
    var js = cc.js;
    var BUILTIN_CLASSID_RE = require("../utils/misc").BUILTIN_CLASSID_RE;
    var MissingClass = cc.Class({
      name: "cc.MissingClass",
      properties: {
        _$erialized: {
          default: null,
          visible: false,
          editorOnly: true
        }
      }
    });
    var MissingScript = cc.Class({
      name: "cc.MissingScript",
      extends: cc.Component,
      editor: {
        inspector: "packages://inspector/inspectors/comps/missing-script.js"
      },
      properties: {
        compiled: {
          default: false,
          serializable: false
        },
        _$erialized: {
          default: null,
          visible: false,
          editorOnly: true
        }
      },
      ctor: false,
      statics: {
        safeFindClass: function safeFindClass(id, data) {
          var cls = js._getClassById(id);
          if (cls) return cls;
          if (id) {
            cc.deserialize.reportMissingClass(id);
            return MissingScript.getMissingWrapper(id, data);
          }
          return null;
        },
        getMissingWrapper: function getMissingWrapper(id, data) {
          return data.node && (/^[0-9a-zA-Z+/]{23}$/.test(id) || BUILTIN_CLASSID_RE.test(id)) ? MissingScript : MissingClass;
        }
      },
      onLoad: function onLoad() {
        cc.warnID(4600, this.node.name);
      }
    });
    cc._MissingScript = module.exports = MissingScript;
  }), {
    "../utils/misc": 187
  } ],
  66: [ (function(require, module, exports) {
    "use strict";
    var js = cc.js;
    require("../event/event");
    var EventMouse = function EventMouse(eventType, bubbles) {
      cc.Event.call(this, cc.Event.MOUSE, bubbles);
      this._eventType = eventType;
      this._button = 0;
      this._x = 0;
      this._y = 0;
      this._prevX = 0;
      this._prevY = 0;
      this._scrollX = 0;
      this._scrollY = 0;
    };
    js.extend(EventMouse, cc.Event);
    var proto = EventMouse.prototype;
    proto.setScrollData = function(scrollX, scrollY) {
      this._scrollX = scrollX;
      this._scrollY = scrollY;
    };
    proto.getScrollX = function() {
      return this._scrollX;
    };
    proto.getScrollY = function() {
      return this._scrollY;
    };
    proto.setLocation = function(x, y) {
      this._x = x;
      this._y = y;
    };
    proto.getLocation = function() {
      return cc.v2(this._x, this._y);
    };
    proto.getLocationInView = function() {
      return cc.v2(this._x, cc.view._designResolutionSize.height - this._y);
    };
    proto._setPrevCursor = function(x, y) {
      this._prevX = x;
      this._prevY = y;
    };
    proto.getPreviousLocation = function() {
      return cc.v2(this._prevX, this._prevY);
    };
    proto.getDelta = function() {
      return cc.v2(this._x - this._prevX, this._y - this._prevY);
    };
    proto.getDeltaX = function() {
      return this._x - this._prevX;
    };
    proto.getDeltaY = function() {
      return this._y - this._prevY;
    };
    proto.setButton = function(button) {
      this._button = button;
    };
    proto.getButton = function() {
      return this._button;
    };
    proto.getLocationX = function() {
      return this._x;
    };
    proto.getLocationY = function() {
      return this._y;
    };
    EventMouse.NONE = 0;
    EventMouse.DOWN = 1;
    EventMouse.UP = 2;
    EventMouse.MOVE = 3;
    EventMouse.SCROLL = 4;
    EventMouse.BUTTON_LEFT = 0;
    EventMouse.BUTTON_RIGHT = 2;
    EventMouse.BUTTON_MIDDLE = 1;
    EventMouse.BUTTON_4 = 3;
    EventMouse.BUTTON_5 = 4;
    EventMouse.BUTTON_6 = 5;
    EventMouse.BUTTON_7 = 6;
    EventMouse.BUTTON_8 = 7;
    var EventTouch = function EventTouch(touchArr, bubbles) {
      cc.Event.call(this, cc.Event.TOUCH, bubbles);
      this._eventCode = 0;
      this._touches = touchArr || [];
      this.touch = null;
      this.currentTouch = null;
    };
    js.extend(EventTouch, cc.Event);
    proto = EventTouch.prototype;
    proto.getEventCode = function() {
      return this._eventCode;
    };
    proto.getTouches = function() {
      return this._touches;
    };
    proto._setEventCode = function(eventCode) {
      this._eventCode = eventCode;
    };
    proto._setTouches = function(touches) {
      this._touches = touches;
    };
    proto.setLocation = function(x, y) {
      this.touch && this.touch.setTouchInfo(this.touch.getID(), x, y);
    };
    proto.getLocation = function() {
      return this.touch ? this.touch.getLocation() : cc.v2();
    };
    proto.getLocationInView = function() {
      return this.touch ? this.touch.getLocationInView() : cc.v2();
    };
    proto.getPreviousLocation = function() {
      return this.touch ? this.touch.getPreviousLocation() : cc.v2();
    };
    proto.getStartLocation = function() {
      return this.touch ? this.touch.getStartLocation() : cc.v2();
    };
    proto.getID = function() {
      return this.touch ? this.touch.getID() : null;
    };
    proto.getDelta = function() {
      return this.touch ? this.touch.getDelta() : cc.v2();
    };
    proto.getDeltaX = function() {
      return this.touch ? this.touch.getDelta().x : 0;
    };
    proto.getDeltaY = function() {
      return this.touch ? this.touch.getDelta().y : 0;
    };
    proto.getLocationX = function() {
      return this.touch ? this.touch.getLocationX() : 0;
    };
    proto.getLocationY = function() {
      return this.touch ? this.touch.getLocationY() : 0;
    };
    EventTouch.MAX_TOUCHES = 5;
    EventTouch.BEGAN = 0;
    EventTouch.MOVED = 1;
    EventTouch.ENDED = 2;
    EventTouch.CANCELED = 3;
    var EventAcceleration = function EventAcceleration(acc, bubbles) {
      cc.Event.call(this, cc.Event.ACCELERATION, bubbles);
      this.acc = acc;
    };
    js.extend(EventAcceleration, cc.Event);
    var EventKeyboard = function EventKeyboard(keyCode, isPressed, bubbles) {
      cc.Event.call(this, cc.Event.KEYBOARD, bubbles);
      this.keyCode = keyCode;
      this.isPressed = isPressed;
    };
    js.extend(EventKeyboard, cc.Event);
    cc.Event.EventMouse = EventMouse;
    cc.Event.EventTouch = EventTouch;
    cc.Event.EventAcceleration = EventAcceleration;
    cc.Event.EventKeyboard = EventKeyboard;
    module.exports = cc.Event;
  }), {
    "../event/event": 73
  } ],
  67: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    cc.EventListener = function(type, listenerID, callback) {
      this._onEvent = callback;
      this._type = type || 0;
      this._listenerID = listenerID || "";
      this._registered = false;
      this._fixedPriority = 0;
      this._node = null;
      this._target = null;
      this._paused = true;
      this._isEnabled = true;
    };
    cc.EventListener.prototype = {
      constructor: cc.EventListener,
      _setPaused: function _setPaused(paused) {
        this._paused = paused;
      },
      _isPaused: function _isPaused() {
        return this._paused;
      },
      _setRegistered: function _setRegistered(registered) {
        this._registered = registered;
      },
      _isRegistered: function _isRegistered() {
        return this._registered;
      },
      _getType: function _getType() {
        return this._type;
      },
      _getListenerID: function _getListenerID() {
        return this._listenerID;
      },
      _setFixedPriority: function _setFixedPriority(fixedPriority) {
        this._fixedPriority = fixedPriority;
      },
      _getFixedPriority: function _getFixedPriority() {
        return this._fixedPriority;
      },
      _setSceneGraphPriority: function _setSceneGraphPriority(node) {
        this._target = node;
        this._node = node;
      },
      _getSceneGraphPriority: function _getSceneGraphPriority() {
        return this._node;
      },
      checkAvailable: function checkAvailable() {
        return null !== this._onEvent;
      },
      clone: function clone() {
        return null;
      },
      setEnabled: function setEnabled(enabled) {
        this._isEnabled = enabled;
      },
      isEnabled: function isEnabled() {
        return this._isEnabled;
      },
      retain: function retain() {},
      release: function release() {}
    };
    cc.EventListener.UNKNOWN = 0;
    cc.EventListener.TOUCH_ONE_BY_ONE = 1;
    cc.EventListener.TOUCH_ALL_AT_ONCE = 2;
    cc.EventListener.KEYBOARD = 3;
    cc.EventListener.MOUSE = 4;
    cc.EventListener.ACCELERATION = 6;
    cc.EventListener.CUSTOM = 8;
    var ListenerID = cc.EventListener.ListenerID = {
      MOUSE: "__cc_mouse",
      TOUCH_ONE_BY_ONE: "__cc_touch_one_by_one",
      TOUCH_ALL_AT_ONCE: "__cc_touch_all_at_once",
      KEYBOARD: "__cc_keyboard",
      ACCELERATION: "__cc_acceleration"
    };
    var Custom = function Custom(listenerId, callback) {
      this._onCustomEvent = callback;
      cc.EventListener.call(this, cc.EventListener.CUSTOM, listenerId, this._callback);
    };
    js.extend(Custom, cc.EventListener);
    js.mixin(Custom.prototype, {
      _onCustomEvent: null,
      _callback: function _callback(event) {
        null !== this._onCustomEvent && this._onCustomEvent(event);
      },
      checkAvailable: function checkAvailable() {
        return cc.EventListener.prototype.checkAvailable.call(this) && null !== this._onCustomEvent;
      },
      clone: function clone() {
        return new Custom(this._listenerID, this._onCustomEvent);
      }
    });
    var Mouse = function Mouse() {
      cc.EventListener.call(this, cc.EventListener.MOUSE, ListenerID.MOUSE, this._callback);
    };
    js.extend(Mouse, cc.EventListener);
    js.mixin(Mouse.prototype, {
      onMouseDown: null,
      onMouseUp: null,
      onMouseMove: null,
      onMouseScroll: null,
      _callback: function _callback(event) {
        var eventType = cc.Event.EventMouse;
        switch (event._eventType) {
         case eventType.DOWN:
          this.onMouseDown && this.onMouseDown(event);
          break;

         case eventType.UP:
          this.onMouseUp && this.onMouseUp(event);
          break;

         case eventType.MOVE:
          this.onMouseMove && this.onMouseMove(event);
          break;

         case eventType.SCROLL:
          this.onMouseScroll && this.onMouseScroll(event);
        }
      },
      clone: function clone() {
        var eventListener = new Mouse();
        eventListener.onMouseDown = this.onMouseDown;
        eventListener.onMouseUp = this.onMouseUp;
        eventListener.onMouseMove = this.onMouseMove;
        eventListener.onMouseScroll = this.onMouseScroll;
        return eventListener;
      },
      checkAvailable: function checkAvailable() {
        return true;
      }
    });
    var TouchOneByOne = function TouchOneByOne() {
      cc.EventListener.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, ListenerID.TOUCH_ONE_BY_ONE, null);
      this._claimedTouches = [];
    };
    js.extend(TouchOneByOne, cc.EventListener);
    js.mixin(TouchOneByOne.prototype, {
      constructor: TouchOneByOne,
      _claimedTouches: null,
      swallowTouches: false,
      onTouchBegan: null,
      onTouchMoved: null,
      onTouchEnded: null,
      onTouchCancelled: null,
      setSwallowTouches: function setSwallowTouches(needSwallow) {
        this.swallowTouches = needSwallow;
      },
      isSwallowTouches: function isSwallowTouches() {
        return this.swallowTouches;
      },
      clone: function clone() {
        var eventListener = new TouchOneByOne();
        eventListener.onTouchBegan = this.onTouchBegan;
        eventListener.onTouchMoved = this.onTouchMoved;
        eventListener.onTouchEnded = this.onTouchEnded;
        eventListener.onTouchCancelled = this.onTouchCancelled;
        eventListener.swallowTouches = this.swallowTouches;
        return eventListener;
      },
      checkAvailable: function checkAvailable() {
        if (!this.onTouchBegan) {
          cc.logID(1801);
          return false;
        }
        return true;
      }
    });
    var TouchAllAtOnce = function TouchAllAtOnce() {
      cc.EventListener.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, ListenerID.TOUCH_ALL_AT_ONCE, null);
    };
    js.extend(TouchAllAtOnce, cc.EventListener);
    js.mixin(TouchAllAtOnce.prototype, {
      constructor: TouchAllAtOnce,
      onTouchesBegan: null,
      onTouchesMoved: null,
      onTouchesEnded: null,
      onTouchesCancelled: null,
      clone: function clone() {
        var eventListener = new TouchAllAtOnce();
        eventListener.onTouchesBegan = this.onTouchesBegan;
        eventListener.onTouchesMoved = this.onTouchesMoved;
        eventListener.onTouchesEnded = this.onTouchesEnded;
        eventListener.onTouchesCancelled = this.onTouchesCancelled;
        return eventListener;
      },
      checkAvailable: function checkAvailable() {
        if (null === this.onTouchesBegan && null === this.onTouchesMoved && null === this.onTouchesEnded && null === this.onTouchesCancelled) {
          cc.logID(1802);
          return false;
        }
        return true;
      }
    });
    var Acceleration = function Acceleration(callback) {
      this._onAccelerationEvent = callback;
      cc.EventListener.call(this, cc.EventListener.ACCELERATION, ListenerID.ACCELERATION, this._callback);
    };
    js.extend(Acceleration, cc.EventListener);
    js.mixin(Acceleration.prototype, {
      constructor: Acceleration,
      _onAccelerationEvent: null,
      _callback: function _callback(event) {
        this._onAccelerationEvent(event.acc, event);
      },
      checkAvailable: function checkAvailable() {
        cc.assertID(this._onAccelerationEvent, 1803);
        return true;
      },
      clone: function clone() {
        return new Acceleration(this._onAccelerationEvent);
      }
    });
    var Keyboard = function Keyboard() {
      cc.EventListener.call(this, cc.EventListener.KEYBOARD, ListenerID.KEYBOARD, this._callback);
    };
    js.extend(Keyboard, cc.EventListener);
    js.mixin(Keyboard.prototype, {
      constructor: Keyboard,
      onKeyPressed: null,
      onKeyReleased: null,
      _callback: function _callback(event) {
        event.isPressed ? this.onKeyPressed && this.onKeyPressed(event.keyCode, event) : this.onKeyReleased && this.onKeyReleased(event.keyCode, event);
      },
      clone: function clone() {
        var eventListener = new Keyboard();
        eventListener.onKeyPressed = this.onKeyPressed;
        eventListener.onKeyReleased = this.onKeyReleased;
        return eventListener;
      },
      checkAvailable: function checkAvailable() {
        if (null === this.onKeyPressed && null === this.onKeyReleased) {
          cc.logID(1800);
          return false;
        }
        return true;
      }
    });
    cc.EventListener.create = function(argObj) {
      cc.assertID(argObj && argObj.event, 1900);
      var listenerType = argObj.event;
      delete argObj.event;
      var listener = null;
      if (listenerType === cc.EventListener.TOUCH_ONE_BY_ONE) listener = new TouchOneByOne(); else if (listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE) listener = new TouchAllAtOnce(); else if (listenerType === cc.EventListener.MOUSE) listener = new Mouse(); else if (listenerType === cc.EventListener.CUSTOM) {
        listener = new Custom(argObj.eventName, argObj.callback);
        delete argObj.eventName;
        delete argObj.callback;
      } else if (listenerType === cc.EventListener.KEYBOARD) listener = new Keyboard(); else if (listenerType === cc.EventListener.ACCELERATION) {
        listener = new Acceleration(argObj.callback);
        delete argObj.callback;
      }
      for (var key in argObj) listener[key] = argObj[key];
      return listener;
    };
    module.exports = cc.EventListener;
  }), {
    "../platform/js": 124
  } ],
  68: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    require("./CCEventListener");
    var ListenerID = cc.EventListener.ListenerID;
    var _EventListenerVector = function _EventListenerVector() {
      this._fixedListeners = [];
      this._sceneGraphListeners = [];
      this.gt0Index = 0;
    };
    _EventListenerVector.prototype = {
      constructor: _EventListenerVector,
      size: function size() {
        return this._fixedListeners.length + this._sceneGraphListeners.length;
      },
      empty: function empty() {
        return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length;
      },
      push: function push(listener) {
        0 === listener._getFixedPriority() ? this._sceneGraphListeners.push(listener) : this._fixedListeners.push(listener);
      },
      clearSceneGraphListeners: function clearSceneGraphListeners() {
        this._sceneGraphListeners.length = 0;
      },
      clearFixedListeners: function clearFixedListeners() {
        this._fixedListeners.length = 0;
      },
      clear: function clear() {
        this._sceneGraphListeners.length = 0;
        this._fixedListeners.length = 0;
      },
      getFixedPriorityListeners: function getFixedPriorityListeners() {
        return this._fixedListeners;
      },
      getSceneGraphPriorityListeners: function getSceneGraphPriorityListeners() {
        return this._sceneGraphListeners;
      }
    };
    var __getListenerID = function __getListenerID(event) {
      var eventType = cc.Event, type = event.type;
      if (type === eventType.ACCELERATION) return ListenerID.ACCELERATION;
      if (type === eventType.KEYBOARD) return ListenerID.KEYBOARD;
      if (type.startsWith(eventType.MOUSE)) return ListenerID.MOUSE;
      type.startsWith(eventType.TOUCH) && cc.logID(2e3);
      return "";
    };
    var eventManager = {
      DIRTY_NONE: 0,
      DIRTY_FIXED_PRIORITY: 1,
      DIRTY_SCENE_GRAPH_PRIORITY: 2,
      DIRTY_ALL: 3,
      _listenersMap: {},
      _priorityDirtyFlagMap: {},
      _nodeListenersMap: {},
      _toAddedListeners: [],
      _toRemovedListeners: [],
      _dirtyListeners: {},
      _inDispatch: 0,
      _isEnabled: false,
      _internalCustomListenerIDs: [],
      _setDirtyForNode: function _setDirtyForNode(node) {
        var selListeners = this._nodeListenersMap[node._id];
        if (void 0 !== selListeners) for (var j = 0, len = selListeners.length; j < len; j++) {
          var selListener = selListeners[j];
          var listenerID = selListener._getListenerID();
          null == this._dirtyListeners[listenerID] && (this._dirtyListeners[listenerID] = true);
        }
        if (node.getChildren) {
          var _children = node.getChildren();
          for (var i = 0, len = _children ? _children.length : 0; i < len; i++) this._setDirtyForNode(_children[i]);
        }
      },
      pauseTarget: function pauseTarget(node, recursive) {
        if (!(node instanceof cc._BaseNode)) {
          cc.warnID(3506);
          return;
        }
        var listeners = this._nodeListenersMap[node._id], i, len;
        if (listeners) for (i = 0, len = listeners.length; i < len; i++) listeners[i]._setPaused(true);
        if (true === recursive) {
          var locChildren = node.getChildren();
          for (i = 0, len = locChildren ? locChildren.length : 0; i < len; i++) this.pauseTarget(locChildren[i], true);
        }
      },
      resumeTarget: function resumeTarget(node, recursive) {
        if (!(node instanceof cc._BaseNode)) {
          cc.warnID(3506);
          return;
        }
        var listeners = this._nodeListenersMap[node._id], i, len;
        if (listeners) for (i = 0, len = listeners.length; i < len; i++) listeners[i]._setPaused(false);
        this._setDirtyForNode(node);
        if (true === recursive && node.getChildren) {
          var locChildren = node.getChildren();
          for (i = 0, len = locChildren ? locChildren.length : 0; i < len; i++) this.resumeTarget(locChildren[i], true);
        }
      },
      _addListener: function _addListener(listener) {
        0 === this._inDispatch ? this._forceAddEventListener(listener) : this._toAddedListeners.push(listener);
      },
      _forceAddEventListener: function _forceAddEventListener(listener) {
        var listenerID = listener._getListenerID();
        var listeners = this._listenersMap[listenerID];
        if (!listeners) {
          listeners = new _EventListenerVector();
          this._listenersMap[listenerID] = listeners;
        }
        listeners.push(listener);
        if (0 === listener._getFixedPriority()) {
          this._setDirty(listenerID, this.DIRTY_SCENE_GRAPH_PRIORITY);
          var node = listener._getSceneGraphPriority();
          null === node && cc.logID(3507);
          this._associateNodeAndEventListener(node, listener);
          node.activeInHierarchy && this.resumeTarget(node);
        } else this._setDirty(listenerID, this.DIRTY_FIXED_PRIORITY);
      },
      _getListeners: function _getListeners(listenerID) {
        return this._listenersMap[listenerID];
      },
      _updateDirtyFlagForSceneGraph: function _updateDirtyFlagForSceneGraph() {
        var locDirtyListeners = this._dirtyListeners;
        for (var selKey in locDirtyListeners) this._setDirty(selKey, this.DIRTY_SCENE_GRAPH_PRIORITY);
        this._dirtyListeners = {};
      },
      _removeAllListenersInVector: function _removeAllListenersInVector(listenerVector) {
        if (!listenerVector) return;
        var selListener;
        for (var i = listenerVector.length - 1; i >= 0; i--) {
          selListener = listenerVector[i];
          selListener._setRegistered(false);
          if (null != selListener._getSceneGraphPriority()) {
            this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
            selListener._setSceneGraphPriority(null);
          }
          0 === this._inDispatch && cc.js.array.removeAt(listenerVector, i);
        }
      },
      _removeListenersForListenerID: function _removeListenersForListenerID(listenerID) {
        var listeners = this._listenersMap[listenerID], i;
        if (listeners) {
          var fixedPriorityListeners = listeners.getFixedPriorityListeners();
          var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
          this._removeAllListenersInVector(sceneGraphPriorityListeners);
          this._removeAllListenersInVector(fixedPriorityListeners);
          delete this._priorityDirtyFlagMap[listenerID];
          if (!this._inDispatch) {
            listeners.clear();
            delete this._listenersMap[listenerID];
          }
        }
        var locToAddedListeners = this._toAddedListeners, listener;
        for (i = locToAddedListeners.length - 1; i >= 0; i--) {
          listener = locToAddedListeners[i];
          listener && listener._getListenerID() === listenerID && cc.js.array.removeAt(locToAddedListeners, i);
        }
      },
      _sortEventListeners: function _sortEventListeners(listenerID) {
        var dirtyFlag = this.DIRTY_NONE, locFlagMap = this._priorityDirtyFlagMap;
        locFlagMap[listenerID] && (dirtyFlag = locFlagMap[listenerID]);
        if (dirtyFlag !== this.DIRTY_NONE) {
          locFlagMap[listenerID] = this.DIRTY_NONE;
          dirtyFlag & this.DIRTY_FIXED_PRIORITY && this._sortListenersOfFixedPriority(listenerID);
          if (dirtyFlag & this.DIRTY_SCENE_GRAPH_PRIORITY) {
            var rootEntity = cc.director.getScene();
            rootEntity && this._sortListenersOfSceneGraphPriority(listenerID);
          }
        }
      },
      _sortListenersOfSceneGraphPriority: function _sortListenersOfSceneGraphPriority(listenerID) {
        var listeners = this._getListeners(listenerID);
        if (!listeners) return;
        var sceneGraphListener = listeners.getSceneGraphPriorityListeners();
        if (!sceneGraphListener || 0 === sceneGraphListener.length) return;
        listeners.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes);
      },
      _sortEventListenersOfSceneGraphPriorityDes: function _sortEventListenersOfSceneGraphPriorityDes(l1, l2) {
        var node1 = l1._getSceneGraphPriority(), node2 = l2._getSceneGraphPriority();
        if (!(l2 && node2 && node2._activeInHierarchy && null !== node2._parent)) return -1;
        if (!l1 || !node1 || !node1._activeInHierarchy || null === node1._parent) return 1;
        var p1 = node1, p2 = node2, ex = false;
        while (p1._parent._id !== p2._parent._id) {
          p1 = null === p1._parent._parent ? (ex = true) && node2 : p1._parent;
          p2 = null === p2._parent._parent ? (ex = true) && node1 : p2._parent;
        }
        if (p1._id === p2._id) {
          if (p1._id === node2._id) return -1;
          if (p1._id === node1._id) return 1;
        }
        return ex ? p1._localZOrder - p2._localZOrder : p2._localZOrder - p1._localZOrder;
      },
      _sortListenersOfFixedPriority: function _sortListenersOfFixedPriority(listenerID) {
        var listeners = this._listenersMap[listenerID];
        if (!listeners) return;
        var fixedListeners = listeners.getFixedPriorityListeners();
        if (!fixedListeners || 0 === fixedListeners.length) return;
        fixedListeners.sort(this._sortListenersOfFixedPriorityAsc);
        var index = 0;
        for (var len = fixedListeners.length; index < len; ) {
          if (fixedListeners[index]._getFixedPriority() >= 0) break;
          ++index;
        }
        listeners.gt0Index = index;
      },
      _sortListenersOfFixedPriorityAsc: function _sortListenersOfFixedPriorityAsc(l1, l2) {
        return l1._getFixedPriority() - l2._getFixedPriority();
      },
      _onUpdateListeners: function _onUpdateListeners(listeners) {
        var fixedPriorityListeners = listeners.getFixedPriorityListeners();
        var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
        var i, selListener, idx, toRemovedListeners = this._toRemovedListeners;
        if (sceneGraphPriorityListeners) for (i = sceneGraphPriorityListeners.length - 1; i >= 0; i--) {
          selListener = sceneGraphPriorityListeners[i];
          if (!selListener._isRegistered()) {
            cc.js.array.removeAt(sceneGraphPriorityListeners, i);
            idx = toRemovedListeners.indexOf(selListener);
            -1 !== idx && toRemovedListeners.splice(idx, 1);
          }
        }
        if (fixedPriorityListeners) for (i = fixedPriorityListeners.length - 1; i >= 0; i--) {
          selListener = fixedPriorityListeners[i];
          if (!selListener._isRegistered()) {
            cc.js.array.removeAt(fixedPriorityListeners, i);
            idx = toRemovedListeners.indexOf(selListener);
            -1 !== idx && toRemovedListeners.splice(idx, 1);
          }
        }
        sceneGraphPriorityListeners && 0 === sceneGraphPriorityListeners.length && listeners.clearSceneGraphListeners();
        fixedPriorityListeners && 0 === fixedPriorityListeners.length && listeners.clearFixedListeners();
      },
      frameUpdateListeners: function frameUpdateListeners() {
        var locListenersMap = this._listenersMap, locPriorityDirtyFlagMap = this._priorityDirtyFlagMap;
        for (var selKey in locListenersMap) if (locListenersMap[selKey].empty()) {
          delete locPriorityDirtyFlagMap[selKey];
          delete locListenersMap[selKey];
        }
        var locToAddedListeners = this._toAddedListeners;
        if (0 !== locToAddedListeners.length) {
          for (var i = 0, len = locToAddedListeners.length; i < len; i++) this._forceAddEventListener(locToAddedListeners[i]);
          locToAddedListeners.length = 0;
        }
        0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners();
      },
      _updateTouchListeners: function _updateTouchListeners(event) {
        var locInDispatch = this._inDispatch;
        cc.assertID(locInDispatch > 0, 3508);
        if (locInDispatch > 1) return;
        var listeners;
        listeners = this._listenersMap[ListenerID.TOUCH_ONE_BY_ONE];
        listeners && this._onUpdateListeners(listeners);
        listeners = this._listenersMap[ListenerID.TOUCH_ALL_AT_ONCE];
        listeners && this._onUpdateListeners(listeners);
        cc.assertID(1 === locInDispatch, 3509);
        var locToAddedListeners = this._toAddedListeners;
        if (0 !== locToAddedListeners.length) {
          for (var i = 0, len = locToAddedListeners.length; i < len; i++) this._forceAddEventListener(locToAddedListeners[i]);
          this._toAddedListeners.length = 0;
        }
        0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners();
      },
      _cleanToRemovedListeners: function _cleanToRemovedListeners() {
        var toRemovedListeners = this._toRemovedListeners;
        for (var i = 0; i < toRemovedListeners.length; i++) {
          var selListener = toRemovedListeners[i];
          var listeners = this._listenersMap[selListener._getListenerID()];
          if (!listeners) continue;
          var idx, fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
          if (sceneGraphPriorityListeners) {
            idx = sceneGraphPriorityListeners.indexOf(selListener);
            -1 !== idx && sceneGraphPriorityListeners.splice(idx, 1);
          }
          if (fixedPriorityListeners) {
            idx = fixedPriorityListeners.indexOf(selListener);
            -1 !== idx && fixedPriorityListeners.splice(idx, 1);
          }
        }
        toRemovedListeners.length = 0;
      },
      _onTouchEventCallback: function _onTouchEventCallback(listener, argsObj) {
        if (!listener._isRegistered()) return false;
        var event = argsObj.event, selTouch = event.currentTouch;
        event.currentTarget = listener._node;
        var isClaimed = false, removedIdx;
        var getCode = event.getEventCode(), EventTouch = cc.Event.EventTouch;
        if (getCode === EventTouch.BEGAN) {
          if (listener.onTouchBegan) {
            isClaimed = listener.onTouchBegan(selTouch, event);
            isClaimed && listener._registered && listener._claimedTouches.push(selTouch);
          }
        } else if (listener._claimedTouches.length > 0 && -1 !== (removedIdx = listener._claimedTouches.indexOf(selTouch))) {
          isClaimed = true;
          if (getCode === EventTouch.MOVED && listener.onTouchMoved) listener.onTouchMoved(selTouch, event); else if (getCode === EventTouch.ENDED) {
            listener.onTouchEnded && listener.onTouchEnded(selTouch, event);
            listener._registered && listener._claimedTouches.splice(removedIdx, 1);
          } else if (getCode === EventTouch.CANCELLED) {
            listener.onTouchCancelled && listener.onTouchCancelled(selTouch, event);
            listener._registered && listener._claimedTouches.splice(removedIdx, 1);
          }
        }
        if (event.isStopped()) {
          eventManager._updateTouchListeners(event);
          return true;
        }
        if (isClaimed && listener.swallowTouches) {
          argsObj.needsMutableSet && argsObj.touches.splice(selTouch, 1);
          return true;
        }
        return false;
      },
      _dispatchTouchEvent: function _dispatchTouchEvent(event) {
        this._sortEventListeners(ListenerID.TOUCH_ONE_BY_ONE);
        this._sortEventListeners(ListenerID.TOUCH_ALL_AT_ONCE);
        var oneByOneListeners = this._getListeners(ListenerID.TOUCH_ONE_BY_ONE);
        var allAtOnceListeners = this._getListeners(ListenerID.TOUCH_ALL_AT_ONCE);
        if (null === oneByOneListeners && null === allAtOnceListeners) return;
        var originalTouches = event.getTouches(), mutableTouches = cc.js.array.copy(originalTouches);
        var oneByOneArgsObj = {
          event: event,
          needsMutableSet: oneByOneListeners && allAtOnceListeners,
          touches: mutableTouches,
          selTouch: null
        };
        if (oneByOneListeners) for (var i = 0; i < originalTouches.length; i++) {
          event.currentTouch = originalTouches[i];
          event._propagationStopped = event._propagationImmediateStopped = false;
          this._dispatchEventToListeners(oneByOneListeners, this._onTouchEventCallback, oneByOneArgsObj);
        }
        if (allAtOnceListeners && mutableTouches.length > 0) {
          this._dispatchEventToListeners(allAtOnceListeners, this._onTouchesEventCallback, {
            event: event,
            touches: mutableTouches
          });
          if (event.isStopped()) return;
        }
        this._updateTouchListeners(event);
      },
      _onTouchesEventCallback: function _onTouchesEventCallback(listener, callbackParams) {
        if (!listener._registered) return false;
        var EventTouch = cc.Event.EventTouch, event = callbackParams.event, touches = callbackParams.touches, getCode = event.getEventCode();
        event.currentTarget = listener._node;
        getCode === EventTouch.BEGAN && listener.onTouchesBegan ? listener.onTouchesBegan(touches, event) : getCode === EventTouch.MOVED && listener.onTouchesMoved ? listener.onTouchesMoved(touches, event) : getCode === EventTouch.ENDED && listener.onTouchesEnded ? listener.onTouchesEnded(touches, event) : getCode === EventTouch.CANCELLED && listener.onTouchesCancelled && listener.onTouchesCancelled(touches, event);
        if (event.isStopped()) {
          eventManager._updateTouchListeners(event);
          return true;
        }
        return false;
      },
      _associateNodeAndEventListener: function _associateNodeAndEventListener(node, listener) {
        var listeners = this._nodeListenersMap[node._id];
        if (!listeners) {
          listeners = [];
          this._nodeListenersMap[node._id] = listeners;
        }
        listeners.push(listener);
      },
      _dissociateNodeAndEventListener: function _dissociateNodeAndEventListener(node, listener) {
        var listeners = this._nodeListenersMap[node._id];
        if (listeners) {
          cc.js.array.remove(listeners, listener);
          0 === listeners.length && delete this._nodeListenersMap[node._id];
        }
      },
      _dispatchEventToListeners: function _dispatchEventToListeners(listeners, onEvent, eventOrArgs) {
        var shouldStopPropagation = false;
        var fixedPriorityListeners = listeners.getFixedPriorityListeners();
        var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
        var i = 0, j, selListener;
        if (fixedPriorityListeners && 0 !== fixedPriorityListeners.length) for (;i < listeners.gt0Index; ++i) {
          selListener = fixedPriorityListeners[i];
          if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
            shouldStopPropagation = true;
            break;
          }
        }
        if (sceneGraphPriorityListeners && !shouldStopPropagation) for (j = 0; j < sceneGraphPriorityListeners.length; j++) {
          selListener = sceneGraphPriorityListeners[j];
          if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
            shouldStopPropagation = true;
            break;
          }
        }
        if (fixedPriorityListeners && !shouldStopPropagation) for (;i < fixedPriorityListeners.length; ++i) {
          selListener = fixedPriorityListeners[i];
          if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
            shouldStopPropagation = true;
            break;
          }
        }
      },
      _setDirty: function _setDirty(listenerID, flag) {
        var locDirtyFlagMap = this._priorityDirtyFlagMap;
        null == locDirtyFlagMap[listenerID] ? locDirtyFlagMap[listenerID] = flag : locDirtyFlagMap[listenerID] = flag | locDirtyFlagMap[listenerID];
      },
      _sortNumberAsc: function _sortNumberAsc(a, b) {
        return a - b;
      },
      hasEventListener: function hasEventListener(listenerID) {
        return !!this._getListeners(listenerID);
      },
      addListener: function addListener(listener, nodeOrPriority) {
        cc.assertID(listener && nodeOrPriority, 3503);
        if (!(cc.js.isNumber(nodeOrPriority) || nodeOrPriority instanceof cc._BaseNode)) {
          cc.warnID(3506);
          return;
        }
        if (listener instanceof cc.EventListener) {
          if (listener._isRegistered()) {
            cc.logID(3505);
            return;
          }
        } else {
          cc.assertID(!cc.js.isNumber(nodeOrPriority), 3504);
          listener = cc.EventListener.create(listener);
        }
        if (!listener.checkAvailable()) return;
        if (cc.js.isNumber(nodeOrPriority)) {
          if (0 === nodeOrPriority) {
            cc.logID(3500);
            return;
          }
          listener._setSceneGraphPriority(null);
          listener._setFixedPriority(nodeOrPriority);
          listener._setRegistered(true);
          listener._setPaused(false);
          this._addListener(listener);
        } else {
          listener._setSceneGraphPriority(nodeOrPriority);
          listener._setFixedPriority(0);
          listener._setRegistered(true);
          this._addListener(listener);
        }
        return listener;
      },
      addCustomListener: function addCustomListener(eventName, callback) {
        var listener = new cc.EventListener.create({
          event: cc.EventListener.CUSTOM,
          eventName: eventName,
          callback: callback
        });
        this.addListener(listener, 1);
        return listener;
      },
      removeListener: function removeListener(listener) {
        if (null == listener) return;
        var isFound, locListener = this._listenersMap;
        for (var selKey in locListener) {
          var listeners = locListener[selKey];
          var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
          isFound = this._removeListenerInVector(sceneGraphPriorityListeners, listener);
          if (isFound) this._setDirty(listener._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY); else {
            isFound = this._removeListenerInVector(fixedPriorityListeners, listener);
            isFound && this._setDirty(listener._getListenerID(), this.DIRTY_FIXED_PRIORITY);
          }
          if (listeners.empty()) {
            delete this._priorityDirtyFlagMap[listener._getListenerID()];
            delete locListener[selKey];
          }
          if (isFound) break;
        }
        if (!isFound) {
          var locToAddedListeners = this._toAddedListeners;
          for (var i = locToAddedListeners.length - 1; i >= 0; i--) {
            var selListener = locToAddedListeners[i];
            if (selListener === listener) {
              cc.js.array.removeAt(locToAddedListeners, i);
              selListener._setRegistered(false);
              break;
            }
          }
        }
      },
      _removeListenerInCallback: function _removeListenerInCallback(listeners, callback) {
        if (null == listeners) return false;
        for (var i = listeners.length - 1; i >= 0; i--) {
          var selListener = listeners[i];
          if (selListener._onCustomEvent === callback || selListener._onEvent === callback) {
            selListener._setRegistered(false);
            if (null != selListener._getSceneGraphPriority()) {
              this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
              selListener._setSceneGraphPriority(null);
            }
            0 === this._inDispatch ? cc.js.array.removeAt(listeners, i) : this._toRemovedListeners.push(selListener);
            return true;
          }
        }
        return false;
      },
      _removeListenerInVector: function _removeListenerInVector(listeners, listener) {
        if (null == listeners) return false;
        for (var i = listeners.length - 1; i >= 0; i--) {
          var selListener = listeners[i];
          if (selListener === listener) {
            selListener._setRegistered(false);
            if (null != selListener._getSceneGraphPriority()) {
              this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
              selListener._setSceneGraphPriority(null);
            }
            0 === this._inDispatch ? cc.js.array.removeAt(listeners, i) : this._toRemovedListeners.push(selListener);
            return true;
          }
        }
        return false;
      },
      removeListeners: function removeListeners(listenerType, recursive) {
        var i, _t = this;
        if (!(cc.js.isNumber(listenerType) || listenerType instanceof cc._BaseNode)) {
          cc.warnID(3506);
          return;
        }
        if (void 0 !== listenerType._id) {
          var listeners = _t._nodeListenersMap[listenerType._id], i;
          if (listeners) {
            var listenersCopy = cc.js.array.copy(listeners);
            for (i = 0; i < listenersCopy.length; i++) _t.removeListener(listenersCopy[i]);
            delete _t._nodeListenersMap[listenerType._id];
          }
          var locToAddedListeners = _t._toAddedListeners;
          for (i = 0; i < locToAddedListeners.length; ) {
            var listener = locToAddedListeners[i];
            if (listener._getSceneGraphPriority() === listenerType) {
              listener._setSceneGraphPriority(null);
              listener._setRegistered(false);
              locToAddedListeners.splice(i, 1);
            } else ++i;
          }
          if (true === recursive) {
            var locChildren = listenerType.getChildren(), len;
            for (i = 0, len = locChildren.length; i < len; i++) _t.removeListeners(locChildren[i], true);
          }
        } else listenerType === cc.EventListener.TOUCH_ONE_BY_ONE ? _t._removeListenersForListenerID(ListenerID.TOUCH_ONE_BY_ONE) : listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE ? _t._removeListenersForListenerID(ListenerID.TOUCH_ALL_AT_ONCE) : listenerType === cc.EventListener.MOUSE ? _t._removeListenersForListenerID(ListenerID.MOUSE) : listenerType === cc.EventListener.ACCELERATION ? _t._removeListenersForListenerID(ListenerID.ACCELERATION) : listenerType === cc.EventListener.KEYBOARD ? _t._removeListenersForListenerID(ListenerID.KEYBOARD) : cc.logID(3501);
      },
      removeCustomListeners: function removeCustomListeners(customEventName) {
        this._removeListenersForListenerID(customEventName);
      },
      removeAllListeners: function removeAllListeners() {
        var locListeners = this._listenersMap, locInternalCustomEventIDs = this._internalCustomListenerIDs;
        for (var selKey in locListeners) -1 === locInternalCustomEventIDs.indexOf(selKey) && this._removeListenersForListenerID(selKey);
      },
      setPriority: function setPriority(listener, fixedPriority) {
        if (null == listener) return;
        var locListeners = this._listenersMap;
        for (var selKey in locListeners) {
          var selListeners = locListeners[selKey];
          var fixedPriorityListeners = selListeners.getFixedPriorityListeners();
          if (fixedPriorityListeners) {
            var found = fixedPriorityListeners.indexOf(listener);
            if (-1 !== found) {
              null != listener._getSceneGraphPriority() && cc.logID(3502);
              if (listener._getFixedPriority() !== fixedPriority) {
                listener._setFixedPriority(fixedPriority);
                this._setDirty(listener._getListenerID(), this.DIRTY_FIXED_PRIORITY);
              }
              return;
            }
          }
        }
      },
      setEnabled: function setEnabled(enabled) {
        this._isEnabled = enabled;
      },
      isEnabled: function isEnabled() {
        return this._isEnabled;
      },
      dispatchEvent: function dispatchEvent(event) {
        if (!this._isEnabled) return;
        this._updateDirtyFlagForSceneGraph();
        this._inDispatch++;
        if (!event || !event.getType) {
          cc.errorID(3511);
          return;
        }
        if (event.getType().startsWith(cc.Event.TOUCH)) {
          this._dispatchTouchEvent(event);
          this._inDispatch--;
          return;
        }
        var listenerID = __getListenerID(event);
        this._sortEventListeners(listenerID);
        var selListeners = this._listenersMap[listenerID];
        if (null != selListeners) {
          this._dispatchEventToListeners(selListeners, this._onListenerCallback, event);
          this._onUpdateListeners(selListeners);
        }
        this._inDispatch--;
      },
      _onListenerCallback: function _onListenerCallback(listener, event) {
        event.currentTarget = listener._target;
        listener._onEvent(event);
        return event.isStopped();
      },
      dispatchCustomEvent: function dispatchCustomEvent(eventName, optionalUserData) {
        var ev = new cc.Event.EventCustom(eventName);
        ev.setUserData(optionalUserData);
        this.dispatchEvent(ev);
      }
    };
    js.get(cc, "eventManager", (function() {
      cc.warnID(1405, "cc.eventManager", "cc.EventTarget or cc.systemEvent");
      return eventManager;
    }));
    module.exports = eventManager;
  }), {
    "../platform/js": 124,
    "./CCEventListener": 67
  } ],
  69: [ (function(require, module, exports) {
    "use strict";
    cc.Touch = function(x, y, id) {
      this._lastModified = 0;
      this.setTouchInfo(id, x, y);
    };
    cc.Touch.prototype = {
      constructor: cc.Touch,
      getLocation: function getLocation() {
        return cc.v2(this._point.x, this._point.y);
      },
      getLocationX: function getLocationX() {
        return this._point.x;
      },
      getLocationY: function getLocationY() {
        return this._point.y;
      },
      getPreviousLocation: function getPreviousLocation() {
        return cc.v2(this._prevPoint.x, this._prevPoint.y);
      },
      getStartLocation: function getStartLocation() {
        return cc.v2(this._startPoint.x, this._startPoint.y);
      },
      getDelta: function getDelta() {
        return this._point.sub(this._prevPoint);
      },
      getLocationInView: function getLocationInView() {
        return cc.v2(this._point.x, cc.view._designResolutionSize.height - this._point.y);
      },
      getPreviousLocationInView: function getPreviousLocationInView() {
        return cc.v2(this._prevPoint.x, cc.view._designResolutionSize.height - this._prevPoint.y);
      },
      getStartLocationInView: function getStartLocationInView() {
        return cc.v2(this._startPoint.x, cc.view._designResolutionSize.height - this._startPoint.y);
      },
      getID: function getID() {
        return this._id;
      },
      setTouchInfo: function setTouchInfo(id, x, y) {
        this._prevPoint = this._point;
        this._point = cc.v2(x || 0, y || 0);
        this._id = id;
        if (!this._startPointCaptured) {
          this._startPoint = cc.v2(this._point);
          cc.view._convertPointWithScale(this._startPoint);
          this._startPointCaptured = true;
        }
      },
      _setPoint: function _setPoint(x, y) {
        if (void 0 === y) {
          this._point.x = x.x;
          this._point.y = x.y;
        } else {
          this._point.x = x;
          this._point.y = y;
        }
      },
      _setPrevPoint: function _setPrevPoint(x, y) {
        this._prevPoint = void 0 === y ? cc.v2(x.x, x.y) : cc.v2(x || 0, y || 0);
      }
    };
  }), {} ],
  70: [ (function(require, module, exports) {
    "use strict";
    require("./CCEvent");
    require("./CCTouch");
    require("./CCEventListener");
    var eventManager = require("./CCEventManager");
    module.exports = eventManager;
    false;
  }), {
    "./CCEvent": 66,
    "./CCEventListener": 67,
    "./CCEventManager": 68,
    "./CCTouch": 69
  } ],
  71: [ (function(require, module, exports) {
    "use strict";
    var js = cc.js;
    var CallbacksHandler = require("../platform/callbacks-invoker").CallbacksHandler;
    function EventListeners() {
      CallbacksHandler.call(this);
    }
    js.extend(EventListeners, CallbacksHandler);
    EventListeners.prototype.invoke = function(event, captureListeners) {
      var key = event.type;
      var list = this._callbackTable[key];
      if (list) {
        var rootInvoker = !list.isInvoking;
        list.isInvoking = true;
        var callbacks = list.callbacks;
        var targets = list.targets;
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          var callback = callbacks[i];
          if (callback) {
            var target = targets[i] || event.currentTarget;
            callback.call(target, event, captureListeners);
            if (event._propagationImmediateStopped) break;
          }
        }
        if (rootInvoker) {
          list.isInvoking = false;
          list.containCanceled && list.purgeCanceled();
        }
      }
    };
    module.exports = EventListeners;
    false;
  }), {
    "../platform/callbacks-invoker": 117
  } ],
  72: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    var CallbacksInvoker = require("../platform/callbacks-invoker");
    var fastRemove = js.array.fastRemove;
    function EventTarget() {
      CallbacksInvoker.call(this);
    }
    js.extend(EventTarget, CallbacksInvoker);
    var proto = EventTarget.prototype;
    proto.on = function(type, callback, target) {
      if (!callback) {
        cc.errorID(6800);
        return;
      }
      if (!this.hasEventListener(type, callback, target)) {
        this.add(type, callback, target);
        target && target.__eventTargets && target.__eventTargets.push(this);
      }
      return callback;
    };
    proto.off = function(type, callback, target) {
      if (callback) {
        this.remove(type, callback, target);
        target && target.__eventTargets && fastRemove(target.__eventTargets, this);
      } else this.removeAll(type);
    };
    proto.targetOff = proto.removeAll;
    proto.once = function(type, callback, target) {
      var eventType_hasOnceListener = "__ONCE_FLAG:" + type;
      var hasOnceListener = this.hasEventListener(eventType_hasOnceListener, callback, target);
      if (!hasOnceListener) {
        var self = this;
        var onceWrapper = function onceWrapper(arg1, arg2, arg3, arg4, arg5) {
          self.off(type, onceWrapper, target);
          self.remove(eventType_hasOnceListener, callback, target);
          callback.call(this, arg1, arg2, arg3, arg4, arg5);
        };
        this.on(type, onceWrapper, target);
        this.add(eventType_hasOnceListener, callback, target);
      }
    };
    proto.emit = CallbacksInvoker.prototype.invoke;
    proto.dispatchEvent = function(event) {
      this.invoke(event.type, event);
    };
    cc.EventTarget = module.exports = EventTarget;
  }), {
    "../platform/callbacks-invoker": 117,
    "../platform/js": 124
  } ],
  73: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    cc.Event = function(type, bubbles) {
      this.type = type;
      this.bubbles = !!bubbles;
      this.target = null;
      this.currentTarget = null;
      this.eventPhase = 0;
      this._propagationStopped = false;
      this._propagationImmediateStopped = false;
    };
    cc.Event.prototype = {
      constructor: cc.Event,
      unuse: function unuse() {
        this.type = cc.Event.NO_TYPE;
        this.target = null;
        this.currentTarget = null;
        this.eventPhase = cc.Event.NONE;
        this._propagationStopped = false;
        this._propagationImmediateStopped = false;
      },
      reuse: function reuse(type, bubbles) {
        this.type = type;
        this.bubbles = bubbles || false;
      },
      stopPropagation: function stopPropagation() {
        this._propagationStopped = true;
      },
      stopPropagationImmediate: function stopPropagationImmediate() {
        this._propagationImmediateStopped = true;
      },
      isStopped: function isStopped() {
        return this._propagationStopped || this._propagationImmediateStopped;
      },
      getCurrentTarget: function getCurrentTarget() {
        return this.currentTarget;
      },
      getType: function getType() {
        return this.type;
      }
    };
    cc.Event.NO_TYPE = "no_type";
    cc.Event.TOUCH = "touch";
    cc.Event.MOUSE = "mouse";
    cc.Event.KEYBOARD = "keyboard";
    cc.Event.ACCELERATION = "acceleration";
    cc.Event.NONE = 0;
    cc.Event.CAPTURING_PHASE = 1;
    cc.Event.AT_TARGET = 2;
    cc.Event.BUBBLING_PHASE = 3;
    var EventCustom = function EventCustom(type, bubbles) {
      cc.Event.call(this, type, bubbles);
      this.detail = null;
    };
    js.extend(EventCustom, cc.Event);
    EventCustom.prototype.reset = EventCustom;
    EventCustom.prototype.setUserData = function(data) {
      this.detail = data;
    };
    EventCustom.prototype.getUserData = function() {
      return this.detail;
    };
    EventCustom.prototype.getEventName = cc.Event.prototype.getType;
    var MAX_POOL_SIZE = 10;
    var _eventPool = new js.Pool(MAX_POOL_SIZE);
    EventCustom.put = function(event) {
      _eventPool.put(event);
    };
    EventCustom.get = function(type, bubbles) {
      var event = _eventPool._get();
      event ? event.reset(type, bubbles) : event = new EventCustom(type, bubbles);
      return event;
    };
    cc.Event.EventCustom = EventCustom;
    module.exports = cc.Event;
  }), {
    "../platform/js": 124
  } ],
  74: [ (function(require, module, exports) {
    "use strict";
    require("./event");
    require("./event-listeners");
    require("./event-target");
    require("./system-event");
  }), {
    "./event": 73,
    "./event-listeners": 71,
    "./event-target": 72,
    "./system-event": 75
  } ],
  75: [ (function(require, module, exports) {
    "use strict";
    var EventTarget = require("../event/event-target");
    var eventManager = require("../event-manager");
    var inputManger = require("../platform/CCInputManager");
    var EventType = cc.Enum({
      KEY_DOWN: "keydown",
      KEY_UP: "keyup",
      DEVICEMOTION: "devicemotion"
    });
    var keyboardListener = null;
    var accelerationListener = null;
    var SystemEvent = cc.Class({
      name: "SystemEvent",
      extends: EventTarget,
      statics: {
        EventType: EventType
      },
      setAccelerometerEnabled: function setAccelerometerEnabled(isEnable) {
        false;
        inputManger.setAccelerometerEnabled(isEnable);
      },
      setAccelerometerInterval: function setAccelerometerInterval(interval) {
        false;
        inputManger.setAccelerometerInterval(interval);
      },
      on: function on(type, callback, target) {
        false;
        this._super(type, callback, target);
        if (type === EventType.KEY_DOWN || type === EventType.KEY_UP) {
          keyboardListener || (keyboardListener = cc.EventListener.create({
            event: cc.EventListener.KEYBOARD,
            onKeyPressed: function onKeyPressed(keyCode, event) {
              event.type = EventType.KEY_DOWN;
              cc.systemEvent.dispatchEvent(event);
            },
            onKeyReleased: function onKeyReleased(keyCode, event) {
              event.type = EventType.KEY_UP;
              cc.systemEvent.dispatchEvent(event);
            }
          }));
          eventManager.hasEventListener(cc.EventListener.ListenerID.KEYBOARD) || eventManager.addListener(keyboardListener, 1);
        }
        if (type === EventType.DEVICEMOTION) {
          accelerationListener || (accelerationListener = cc.EventListener.create({
            event: cc.EventListener.ACCELERATION,
            callback: function callback(acc, event) {
              event.type = EventType.DEVICEMOTION;
              cc.systemEvent.dispatchEvent(event);
            }
          }));
          eventManager.hasEventListener(cc.EventListener.ListenerID.ACCELERATION) || eventManager.addListener(accelerationListener, 1);
        }
      },
      off: function off(type, callback, target) {
        false;
        this._super(type, callback, target);
        if (keyboardListener && (type === EventType.KEY_DOWN || type === EventType.KEY_UP)) {
          var hasKeyDownEventListener = this.hasEventListener(EventType.KEY_DOWN);
          var hasKeyUpEventListener = this.hasEventListener(EventType.KEY_UP);
          hasKeyDownEventListener || hasKeyUpEventListener || eventManager.removeListener(keyboardListener);
        }
        accelerationListener && type === EventType.DEVICEMOTION && eventManager.removeListener(accelerationListener);
      }
    });
    cc.SystemEvent = module.exports = SystemEvent;
    cc.systemEvent = new cc.SystemEvent();
  }), {
    "../event-manager": 70,
    "../event/event-target": 72,
    "../platform/CCInputManager": 108
  } ],
  76: [ (function(require, module, exports) {
    "use strict";
    var RenderComponent = require("../components/CCRenderComponent");
    var Material = require("../assets/material/CCMaterial");
    var Types = require("./types");
    var LineCap = Types.LineCap;
    var LineJoin = Types.LineJoin;
    var Graphics = cc.Class({
      name: "cc.Graphics",
      extends: RenderComponent,
      editor: false,
      ctor: function ctor() {
        this._impl = Graphics._assembler.createImpl(this);
      },
      properties: {
        _lineWidth: 1,
        _strokeColor: cc.Color.BLACK,
        _lineJoin: LineJoin.MITER,
        _lineCap: LineCap.BUTT,
        _fillColor: cc.Color.WHITE,
        _miterLimit: 10,
        lineWidth: {
          get: function get() {
            return this._lineWidth;
          },
          set: function set(value) {
            this._lineWidth = value;
            this._impl.lineWidth = value;
          }
        },
        lineJoin: {
          get: function get() {
            return this._lineJoin;
          },
          set: function set(value) {
            this._lineJoin = value;
            this._impl.lineJoin = value;
          },
          type: LineJoin
        },
        lineCap: {
          get: function get() {
            return this._lineCap;
          },
          set: function set(value) {
            this._lineCap = value;
            this._impl.lineCap = value;
          },
          type: LineCap
        },
        strokeColor: {
          get: function get() {
            return this._strokeColor;
          },
          set: function set(value) {
            this._impl.strokeColor = this._strokeColor = cc.color(value);
          }
        },
        fillColor: {
          get: function get() {
            return this._fillColor;
          },
          set: function set(value) {
            this._impl.fillColor = this._fillColor = cc.color(value);
          }
        },
        miterLimit: {
          get: function get() {
            return this._miterLimit;
          },
          set: function set(value) {
            this._miterLimit = value;
            this._impl.miterLimit = value;
          }
        }
      },
      statics: {
        LineJoin: LineJoin,
        LineCap: LineCap
      },
      onRestore: function onRestore() {
        this._impl || (this._impl = Graphics._assembler.createImpl());
      },
      onEnable: function onEnable() {
        this._super();
        this._activateMaterial();
      },
      onDestroy: function onDestroy() {
        this._super();
        this._impl.clear(this, true);
        this._impl = null;
      },
      _activateMaterial: function _activateMaterial() {
        if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) {
          this.disableRender();
          return;
        }
        this.node._renderFlag &= ~cc.RenderFlow.FLAG_RENDER;
        this.node._renderFlag |= cc.RenderFlow.FLAG_CUSTOM_IA_RENDER;
        if (this.sharedMaterials[0]) return;
        var material = Material.getInstantiatedBuiltinMaterial("2d-base", this);
        material.define("_USE_MODEL", true);
        this.setMaterial(0, material);
      },
      moveTo: function moveTo(x, y) {
        if (true, x instanceof cc.Vec2) {
          cc.warn("[moveTo] : Can not pass Vec2 as [x, y] value, please check it.");
          return;
        }
        this._impl.moveTo(x, y);
      },
      lineTo: function lineTo(x, y) {
        if (true, x instanceof cc.Vec2) {
          cc.warn("[moveTo] : Can not pass Vec2 as [x, y] value, please check it.");
          return;
        }
        this._impl.lineTo(x, y);
      },
      bezierCurveTo: function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
        this._impl.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
      },
      quadraticCurveTo: function quadraticCurveTo(cx, cy, x, y) {
        this._impl.quadraticCurveTo(cx, cy, x, y);
      },
      arc: function arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
        this._impl.arc(cx, cy, r, startAngle, endAngle, counterclockwise);
      },
      ellipse: function ellipse(cx, cy, rx, ry) {
        this._impl.ellipse(cx, cy, rx, ry);
      },
      circle: function circle(cx, cy, r) {
        this._impl.circle(cx, cy, r);
      },
      rect: function rect(x, y, w, h) {
        this._impl.rect(x, y, w, h);
      },
      roundRect: function roundRect(x, y, w, h, r) {
        this._impl.roundRect(x, y, w, h, r);
      },
      fillRect: function fillRect(x, y, w, h) {
        this.rect(x, y, w, h);
        this.fill();
      },
      clear: function clear(clean) {
        this._impl.clear(this, clean);
      },
      close: function close() {
        this._impl.close();
      },
      stroke: function stroke() {
        Graphics._assembler.stroke(this);
      },
      fill: function fill() {
        Graphics._assembler.fill(this);
      }
    });
    cc.Graphics = module.exports = Graphics;
  }), {
    "../assets/material/CCMaterial": 29,
    "../components/CCRenderComponent": 47,
    "./types": 79
  } ],
  77: [ (function(require, module, exports) {
    "use strict";
    var PointFlags = require("./types").PointFlags;
    var PI = Math.PI;
    var min = Math.min;
    var max = Math.max;
    var cos = Math.cos;
    var sin = Math.sin;
    var abs = Math.abs;
    var sign = Math.sign;
    var KAPPA90 = .5522847493;
    function arc(ctx, cx, cy, r, startAngle, endAngle, counterclockwise) {
      counterclockwise = counterclockwise || false;
      var a = 0, da = 0, hda = 0, kappa = 0;
      var dx = 0, dy = 0, x = 0, y = 0, tanx = 0, tany = 0;
      var px = 0, py = 0, ptanx = 0, ptany = 0;
      var i, ndivs;
      da = endAngle - startAngle;
      if (counterclockwise) if (abs(da) >= 2 * PI) da = 2 * PI; else while (da < 0) da += 2 * PI; else if (abs(da) >= 2 * PI) da = 2 * -PI; else while (da > 0) da -= 2 * PI;
      ndivs = 0 | max(1, min(abs(da) / (.5 * PI) + .5, 5));
      hda = da / ndivs / 2;
      kappa = abs(4 / 3 * (1 - cos(hda)) / sin(hda));
      counterclockwise || (kappa = -kappa);
      for (i = 0; i <= ndivs; i++) {
        a = startAngle + da * (i / ndivs);
        dx = cos(a);
        dy = sin(a);
        x = cx + dx * r;
        y = cy + dy * r;
        tanx = -dy * r * kappa;
        tany = dx * r * kappa;
        0 === i ? ctx.moveTo(x, y) : ctx.bezierCurveTo(px + ptanx, py + ptany, x - tanx, y - tany, x, y);
        px = x;
        py = y;
        ptanx = tanx;
        ptany = tany;
      }
    }
    function ellipse(ctx, cx, cy, rx, ry) {
      ctx.moveTo(cx - rx, cy);
      ctx.bezierCurveTo(cx - rx, cy + ry * KAPPA90, cx - rx * KAPPA90, cy + ry, cx, cy + ry);
      ctx.bezierCurveTo(cx + rx * KAPPA90, cy + ry, cx + rx, cy + ry * KAPPA90, cx + rx, cy);
      ctx.bezierCurveTo(cx + rx, cy - ry * KAPPA90, cx + rx * KAPPA90, cy - ry, cx, cy - ry);
      ctx.bezierCurveTo(cx - rx * KAPPA90, cy - ry, cx - rx, cy - ry * KAPPA90, cx - rx, cy);
      ctx.close();
    }
    function roundRect(ctx, x, y, w, h, r) {
      if (r < .1) {
        ctx.rect(x, y, w, h);
        return;
      }
      var rx = min(r, .5 * abs(w)) * sign(w), ry = min(r, .5 * abs(h)) * sign(h);
      ctx.moveTo(x, y + ry);
      ctx.lineTo(x, y + h - ry);
      ctx.bezierCurveTo(x, y + h - ry * (1 - KAPPA90), x + rx * (1 - KAPPA90), y + h, x + rx, y + h);
      ctx.lineTo(x + w - rx, y + h);
      ctx.bezierCurveTo(x + w - rx * (1 - KAPPA90), y + h, x + w, y + h - ry * (1 - KAPPA90), x + w, y + h - ry);
      ctx.lineTo(x + w, y + ry);
      ctx.bezierCurveTo(x + w, y + ry * (1 - KAPPA90), x + w - rx * (1 - KAPPA90), y, x + w - rx, y);
      ctx.lineTo(x + rx, y);
      ctx.bezierCurveTo(x + rx * (1 - KAPPA90), y, x, y + ry * (1 - KAPPA90), x, y + ry);
      ctx.close();
    }
    function tesselateBezier(ctx, x1, y1, x2, y2, x3, y3, x4, y4, level, type) {
      var x12, y12, x23, y23, x34, y34, x123, y123, x234, y234, x1234, y1234;
      var dx, dy, d2, d3;
      if (level > 10) return;
      x12 = .5 * (x1 + x2);
      y12 = .5 * (y1 + y2);
      x23 = .5 * (x2 + x3);
      y23 = .5 * (y2 + y3);
      x34 = .5 * (x3 + x4);
      y34 = .5 * (y3 + y4);
      x123 = .5 * (x12 + x23);
      y123 = .5 * (y12 + y23);
      dx = x4 - x1;
      dy = y4 - y1;
      d2 = abs((x2 - x4) * dy - (y2 - y4) * dx);
      d3 = abs((x3 - x4) * dy - (y3 - y4) * dx);
      if ((d2 + d3) * (d2 + d3) < ctx._tessTol * (dx * dx + dy * dy)) {
        ctx._addPoint(x4, y4, 0 === type ? type | PointFlags.PT_BEVEL : type);
        return;
      }
      x234 = .5 * (x23 + x34);
      y234 = .5 * (y23 + y34);
      x1234 = .5 * (x123 + x234);
      y1234 = .5 * (y123 + y234);
      tesselateBezier(ctx, x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1, 0);
      tesselateBezier(ctx, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1, type);
    }
    module.exports = {
      arc: arc,
      ellipse: ellipse,
      roundRect: roundRect,
      tesselateBezier: tesselateBezier
    };
  }), {
    "./types": 79
  } ],
  78: [ (function(require, module, exports) {
    "use strict";
    require("./graphics");
  }), {
    "./graphics": 76
  } ],
  79: [ (function(require, module, exports) {
    "use strict";
    var LineCap = cc.Enum({
      BUTT: 0,
      ROUND: 1,
      SQUARE: 2
    });
    var LineJoin = cc.Enum({
      BEVEL: 0,
      ROUND: 1,
      MITER: 2
    });
    var PointFlags = cc.Enum({
      PT_CORNER: 1,
      PT_LEFT: 2,
      PT_BEVEL: 4,
      PT_INNERBEVEL: 8
    });
    module.exports = {
      LineCap: LineCap,
      LineJoin: LineJoin,
      PointFlags: PointFlags
    };
  }), {} ],
  80: [ (function(require, module, exports) {
    "use strict";
    require("./platform");
    require("./assets");
    true;
    require("./CCNode");
    require("./CCPrivateNode");
    require("./CCScene");
    require("./components");
    require("./graphics");
    require("./collider");
    require("./collider/CCIntersection");
    require("./physics");
    require("./camera/CCCamera");
    require("./geom-utils");
    require("./mesh");
    require("./3d");
    require("./3d/polyfill-3d");
    require("./base-ui/CCWidgetManager");
  }), {
    "./3d": void 0,
    "./3d/polyfill-3d": 2,
    "./CCNode": 6,
    "./CCPrivateNode": 7,
    "./CCScene": 8,
    "./assets": 28,
    "./base-ui/CCWidgetManager": 32,
    "./camera/CCCamera": 33,
    "./collider": void 0,
    "./collider/CCIntersection": 34,
    "./components": 64,
    "./geom-utils": void 0,
    "./graphics": 78,
    "./mesh": void 0,
    "./physics": void 0,
    "./platform": 121
  } ],
  81: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    var Pipeline = require("./pipeline");
    var LoadingItems = require("./loading-items");
    var AssetLoader = require("./asset-loader");
    var Downloader = require("./downloader");
    var Loader = require("./loader");
    var AssetTable = require("./asset-table");
    var callInNextTick = require("../platform/utils").callInNextTick;
    var AutoReleaseUtils = require("./auto-release-utils");
    var ReleasedAssetChecker = (true, require("./released-asset-checker"));
    var assetTables = Object.create(null);
    assetTables.assets = new AssetTable();
    assetTables.internal = new AssetTable();
    function getXMLHttpRequest() {
      return window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject("MSXML2.XMLHTTP");
    }
    var _info = {
      url: null,
      raw: false
    };
    function getResWithUrl(res) {
      var id, result, isUuid;
      if ("object" === typeof res) {
        result = res;
        if (res.url) return result;
        id = res.uuid;
      } else {
        result = {};
        id = res;
      }
      isUuid = result.type ? "uuid" === result.type : cc.AssetLibrary._uuidInSettings(id);
      cc.AssetLibrary._getAssetInfoInRuntime(id, _info);
      result.url = isUuid ? _info.url : id;
      if (_info.url && "uuid" === result.type && _info.raw) {
        result.type = null;
        result.isRawAsset = true;
      } else isUuid || (result.isRawAsset = true);
      return result;
    }
    var _sharedResources = [];
    var _sharedList = [];
    function CCLoader() {
      var assetLoader = new AssetLoader();
      var downloader = new Downloader();
      var loader = new Loader();
      Pipeline.call(this, [ assetLoader, downloader, loader ]);
      this.assetLoader = assetLoader;
      this.md5Pipe = null;
      this.downloader = downloader;
      this.loader = loader;
      this.onProgress = null;
      this._autoReleaseSetting = js.createMap(true);
      true;
      this._releasedAssetChecker_DEBUG = new ReleasedAssetChecker();
    }
    js.extend(CCLoader, Pipeline);
    var proto = CCLoader.prototype;
    proto.init = function(director) {
      true;
      var self = this;
      director.on(cc.Director.EVENT_AFTER_UPDATE, (function() {
        self._releasedAssetChecker_DEBUG.checkCouldRelease(self._cache);
      }));
    };
    proto.getXMLHttpRequest = getXMLHttpRequest;
    proto.addDownloadHandlers = function(extMap) {
      this.downloader.addHandlers(extMap);
    };
    proto.addLoadHandlers = function(extMap) {
      this.loader.addHandlers(extMap);
    };
    proto.load = function(resources, progressCallback, completeCallback) {
      false;
      if (void 0 === completeCallback) {
        completeCallback = progressCallback;
        progressCallback = this.onProgress || null;
      }
      var self = this;
      var singleRes = false;
      var res;
      if (!(resources instanceof Array)) if (resources) {
        singleRes = true;
        resources = [ resources ];
      } else resources = [];
      _sharedResources.length = 0;
      for (var i = 0; i < resources.length; ++i) {
        var resource = resources[i];
        if (resource && resource.id) {
          cc.warnID(4920, resource.id);
          resource.uuid || resource.url || (resource.url = resource.id);
        }
        res = getResWithUrl(resource);
        if (!res.url && !res.uuid) continue;
        var item = this._cache[res.url];
        _sharedResources.push(item || res);
      }
      var queue = LoadingItems.create(this, progressCallback, (function(errors, items) {
        callInNextTick((function() {
          if (completeCallback) {
            if (singleRes) {
              var id = res.url;
              completeCallback.call(self, errors, items.getContent(id));
            } else completeCallback.call(self, errors, items);
            completeCallback = null;
          }
          var _id;
          false;
          items.destroy();
        }));
      }));
      LoadingItems.initQueueDeps(queue);
      queue.append(_sharedResources);
      _sharedResources.length = 0;
    };
    proto.flowInDeps = function(owner, urlList, callback) {
      _sharedList.length = 0;
      for (var i = 0; i < urlList.length; ++i) {
        var res = getResWithUrl(urlList[i]);
        if (!res.url && !res.uuid) continue;
        var item = this._cache[res.url];
        item ? _sharedList.push(item) : _sharedList.push(res);
      }
      var queue = LoadingItems.create(this, owner ? function(completedCount, totalCount, item) {
        this._ownerQueue && this._ownerQueue.onProgress && this._ownerQueue._childOnProgress(item);
      } : null, (function(errors, items) {
        callback(errors, items);
        owner && owner.deps && (owner.deps.length = 0);
        items.destroy();
      }));
      if (owner) {
        var ownerQueue = LoadingItems.getQueue(owner);
        queue._ownerQueue = ownerQueue._ownerQueue || ownerQueue;
      }
      var accepted = queue.append(_sharedList, owner);
      _sharedList.length = 0;
      return accepted;
    };
    proto._assetTables = assetTables;
    proto._getResUuid = function(url, type, mount, quiet) {
      mount = mount || "assets";
      var assetTable = assetTables[mount];
      if (!url || !assetTable) return null;
      var index = url.indexOf("?");
      -1 !== index && (url = url.substr(0, index));
      var uuid = assetTable.getUuid(url, type);
      if (!uuid) {
        var extname = cc.path.extname(url);
        if (extname) {
          url = url.slice(0, -extname.length);
          uuid = assetTable.getUuid(url, type);
          uuid && !quiet && cc.warnID(4901, url, extname);
        }
      }
      return uuid;
    };
    proto._getReferenceKey = function(assetOrUrlOrUuid) {
      var key;
      "object" === typeof assetOrUrlOrUuid ? key = assetOrUrlOrUuid._uuid || null : "string" === typeof assetOrUrlOrUuid && (key = this._getResUuid(assetOrUrlOrUuid, null, null, true) || assetOrUrlOrUuid);
      if (!key) {
        cc.warnID(4800, assetOrUrlOrUuid);
        return key;
      }
      cc.AssetLibrary._getAssetInfoInRuntime(key, _info);
      return this._cache[_info.url] ? _info.url : key;
    };
    proto._urlNotFound = function(url, type, completeCallback) {
      callInNextTick((function() {
        url = cc.url.normalize(url);
        var info = (type ? js.getClassName(type) : "Asset") + ' in "resources/' + url + '" does not exist.';
        completeCallback && completeCallback(new Error(info), []);
      }));
    };
    proto._parseLoadResArgs = function(type, onProgress, onComplete) {
      if (void 0 === onComplete) {
        var isValidType = type instanceof Array || js.isChildClassOf(type, cc.RawAsset);
        if (onProgress) {
          onComplete = onProgress;
          isValidType && (onProgress = this.onProgress || null);
        } else if (void 0 === onProgress && !isValidType) {
          onComplete = type;
          onProgress = this.onProgress || null;
          type = null;
        }
        if (void 0 !== onProgress && !isValidType) {
          onProgress = type;
          type = null;
        }
      }
      return {
        type: type,
        onProgress: onProgress,
        onComplete: onComplete
      };
    };
    proto.loadRes = function(url, type, mount, progressCallback, completeCallback) {
      if (5 !== arguments.length) {
        completeCallback = progressCallback;
        progressCallback = mount;
        mount = "assets";
      }
      var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
      type = args.type;
      progressCallback = args.onProgress;
      completeCallback = args.onComplete;
      var self = this;
      var uuid = self._getResUuid(url, type, mount);
      uuid ? this.load({
        type: "uuid",
        uuid: uuid
      }, progressCallback, (function(err, asset) {
        asset && self.setAutoReleaseRecursively(uuid, false);
        completeCallback && completeCallback(err, asset);
      })) : self._urlNotFound(url, type, completeCallback);
    };
    proto._loadResUuids = function(uuids, progressCallback, completeCallback, urls) {
      if (uuids.length > 0) {
        var self = this;
        var res = uuids.map((function(uuid) {
          return {
            type: "uuid",
            uuid: uuid
          };
        }));
        this.load(res, progressCallback, (function(errors, items) {
          if (completeCallback) {
            var assetRes = [];
            var urlRes = urls && [];
            for (var i = 0; i < res.length; ++i) {
              var uuid = res[i].uuid;
              var id = this._getReferenceKey(uuid);
              var item = items.getContent(id);
              if (item) {
                self.setAutoReleaseRecursively(uuid, false);
                assetRes.push(item);
                urlRes && urlRes.push(urls[i]);
              }
            }
            urls ? completeCallback(errors, assetRes, urlRes) : completeCallback(errors, assetRes);
          }
        }));
      } else completeCallback && callInNextTick((function() {
        urls ? completeCallback(null, [], []) : completeCallback(null, []);
      }));
    };
    proto.loadResArray = function(urls, type, mount, progressCallback, completeCallback) {
      if (5 !== arguments.length) {
        completeCallback = progressCallback;
        progressCallback = mount;
        mount = "assets";
      }
      var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
      type = args.type;
      progressCallback = args.onProgress;
      completeCallback = args.onComplete;
      var uuids = [];
      var isTypesArray = type instanceof Array;
      for (var i = 0; i < urls.length; i++) {
        var url = urls[i];
        var assetType = isTypesArray ? type[i] : type;
        var uuid = this._getResUuid(url, assetType, mount);
        if (!uuid) {
          this._urlNotFound(url, assetType, completeCallback);
          return;
        }
        uuids.push(uuid);
      }
      this._loadResUuids(uuids, progressCallback, completeCallback);
    };
    proto.loadResDir = function(url, type, mount, progressCallback, completeCallback) {
      if (5 !== arguments.length) {
        completeCallback = progressCallback;
        progressCallback = mount;
        mount = "assets";
      }
      if (!assetTables[mount]) return;
      var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
      type = args.type;
      progressCallback = args.onProgress;
      completeCallback = args.onComplete;
      var urls = [];
      var uuids = assetTables[mount].getUuidArray(url, type, urls);
      this._loadResUuids(uuids, progressCallback, completeCallback, urls);
    };
    proto.getRes = function(url, type) {
      var item = this._cache[url];
      if (!item) {
        var uuid = this._getResUuid(url, type, null, true);
        if (!uuid) return null;
        var ref = this._getReferenceKey(uuid);
        item = this._cache[ref];
      }
      item && item.alias && (item = item.alias);
      return item && item.complete ? item.content : null;
    };
    proto.getResCount = function() {
      return Object.keys(this._cache).length;
    };
    proto.getDependsRecursively = function(owner) {
      if (owner) {
        var key = this._getReferenceKey(owner);
        var assets = AutoReleaseUtils.getDependsRecursively(key);
        assets.push(key);
        return assets;
      }
      return [];
    };
    proto.release = function(asset) {
      if (Array.isArray(asset)) for (var i = 0; i < asset.length; i++) {
        var key = asset[i];
        this.release(key);
      } else if (asset) {
        var id = this._getReferenceKey(asset);
        var item = this.getItem(id);
        if (item) {
          var removed = this.removeItem(id);
          asset = item.content;
          (true, removed) && this._releasedAssetChecker_DEBUG.setReleased(item, id);
        }
        if (asset instanceof cc.Asset) {
          var nativeUrl = asset.nativeUrl;
          nativeUrl && this.release(nativeUrl);
          asset.destroy();
        }
      }
    };
    proto.releaseAsset = function(asset) {
      var uuid = asset._uuid;
      uuid && this.release(uuid);
    };
    proto.releaseRes = function(url, type, mount) {
      var uuid = this._getResUuid(url, type, mount);
      uuid ? this.release(uuid) : cc.errorID(4914, url);
    };
    proto.releaseResDir = function(url, type, mount) {
      mount = mount || "assets";
      if (!assetTables[mount]) return;
      var uuids = assetTables[mount].getUuidArray(url, type);
      for (var i = 0; i < uuids.length; i++) {
        var uuid = uuids[i];
        this.release(uuid);
      }
    };
    proto.releaseAll = function() {
      for (var id in this._cache) this.release(id);
    };
    proto.removeItem = function(key) {
      var removed = Pipeline.prototype.removeItem.call(this, key);
      delete this._autoReleaseSetting[key];
      return removed;
    };
    proto.setAutoRelease = function(assetOrUrlOrUuid, autoRelease) {
      var key = this._getReferenceKey(assetOrUrlOrUuid);
      !!key && (this._autoReleaseSetting[key] = !!autoRelease);
    };
    proto.setAutoReleaseRecursively = function(assetOrUrlOrUuid, autoRelease) {
      autoRelease = !!autoRelease;
      var key = this._getReferenceKey(assetOrUrlOrUuid);
      if (key) {
        this._autoReleaseSetting[key] = autoRelease;
        var depends = AutoReleaseUtils.getDependsRecursively(key);
        for (var i = 0; i < depends.length; i++) {
          var depend = depends[i];
          this._autoReleaseSetting[depend] = autoRelease;
        }
      } else false;
    };
    proto.isAutoRelease = function(assetOrUrl) {
      var key = this._getReferenceKey(assetOrUrl);
      if (key) return !!this._autoReleaseSetting[key];
      return false;
    };
    cc.loader = new CCLoader();
    false;
    module.exports = cc.loader;
  }), {
    "../platform/js": 124,
    "../platform/utils": 128,
    "./asset-loader": 82,
    "./asset-table": 83,
    "./auto-release-utils": 85,
    "./downloader": 87,
    "./loader": 90,
    "./loading-items": 91,
    "./pipeline": 94,
    "./released-asset-checker": 95
  } ],
  82: [ (function(require, module, exports) {
    "use strict";
    require("../utils/CCPath");
    var debug = require("../CCDebug");
    var Pipeline = require("./pipeline");
    var LoadingItems = require("./loading-items");
    var ID = "AssetLoader";
    var AssetLoader = function AssetLoader(extMap) {
      this.id = ID;
      this.async = true;
      this.pipeline = null;
    };
    AssetLoader.ID = ID;
    var reusedArray = [];
    AssetLoader.prototype.handle = function(item, callback) {
      var uuid = item.uuid;
      if (!uuid) return item.content || null;
      var self = this;
      cc.AssetLibrary.queryAssetInfo(uuid, (function(error, url, isRawAsset) {
        if (error) callback(error); else {
          item.url = item.rawUrl = url;
          item.isRawAsset = isRawAsset;
          if (isRawAsset) {
            var ext = cc.path.extname(url).toLowerCase();
            if (!ext) {
              callback(new Error(debug.getError(4931, uuid, url)));
              return;
            }
            ext = ext.substr(1);
            var queue = LoadingItems.getQueue(item);
            reusedArray[0] = {
              queueId: item.queueId,
              id: url,
              url: url,
              type: ext,
              error: null,
              alias: item,
              complete: true
            };
            false;
            queue.append(reusedArray);
            item.type = ext;
            callback(null, item.content);
          } else {
            item.type = "uuid";
            callback(null, item.content);
          }
        }
      }));
    };
    Pipeline.AssetLoader = module.exports = AssetLoader;
  }), {
    "../CCDebug": 3,
    "../utils/CCPath": 178,
    "./loading-items": 91,
    "./pipeline": 94
  } ],
  83: [ (function(require, module, exports) {
    "use strict";
    var pushToMap = require("../utils/misc").pushToMap;
    var js = require("../platform/js");
    function Entry(uuid, type) {
      this.uuid = uuid;
      this.type = type;
    }
    function AssetTable() {
      this._pathToUuid = js.createMap(true);
    }
    function isMatchByWord(path, test) {
      if (path.length > test.length) {
        var nextAscii = path.charCodeAt(test.length);
        return 46 === nextAscii || 47 === nextAscii;
      }
      return true;
    }
    var proto = AssetTable.prototype;
    proto.getUuid = function(path, type) {
      path = cc.url.normalize(path);
      var item = this._pathToUuid[path];
      if (item) if (Array.isArray(item)) {
        if (!type) return item[0].uuid;
        for (var i = 0; i < item.length; i++) {
          var entry = item[i];
          if (js.isChildClassOf(entry.type, type)) return entry.uuid;
        }
        if (true, js.isChildClassOf(type, cc.SpriteFrame)) for (var _i = 0; _i < item.length; _i++) {
          var _entry = item[_i];
          if (js.isChildClassOf(_entry.type, cc.SpriteAtlas)) {
            cc.errorID(4932, path);
            break;
          }
        }
      } else {
        if (!type || js.isChildClassOf(item.type, type)) return item.uuid;
        (true, js.isChildClassOf(type, cc.SpriteFrame)) && js.isChildClassOf(item.type, cc.SpriteAtlas) && cc.errorID(4932, path);
      }
      return "";
    };
    proto.getUuidArray = function(path, type, out_urls) {
      path = cc.url.normalize(path);
      "/" === path[path.length - 1] && (path = path.slice(0, -1));
      var path2uuid = this._pathToUuid;
      var uuids = [];
      var isChildClassOf = js.isChildClassOf;
      var _foundAtlasUrl;
      for (var p in path2uuid) if (p.startsWith(path) && isMatchByWord(p, path) || !path) {
        var item = path2uuid[p];
        if (Array.isArray(item)) for (var i = 0; i < item.length; i++) {
          var entry = item[i];
          if (!type || isChildClassOf(entry.type, type)) {
            uuids.push(entry.uuid);
            out_urls && out_urls.push(p);
          } else (true, entry.type === cc.SpriteAtlas) && (_foundAtlasUrl = p);
        } else if (!type || isChildClassOf(item.type, type)) {
          uuids.push(item.uuid);
          out_urls && out_urls.push(p);
        } else (true, item.type === cc.SpriteAtlas) && (_foundAtlasUrl = p);
      }
      (true, 0 === uuids.length) && _foundAtlasUrl && js.isChildClassOf(type, cc.SpriteFrame) && cc.errorID(4932, _foundAtlasUrl);
      return uuids;
    };
    proto.add = function(path, uuid, type, isMainAsset) {
      path = path.substring(0, path.length - cc.path.extname(path).length);
      var newEntry = new Entry(uuid, type);
      pushToMap(this._pathToUuid, path, newEntry, isMainAsset);
    };
    proto._getInfo_DEBUG = (true, function(uuid, out_info) {
      var path2uuid = this._pathToUuid;
      var paths = Object.keys(path2uuid);
      for (var p = 0; p < paths.length; ++p) {
        var path = paths[p];
        var item = path2uuid[path];
        if (Array.isArray(item)) for (var i = 0; i < item.length; i++) {
          var entry = item[i];
          if (entry.uuid === uuid) {
            out_info.path = path;
            out_info.type = entry.type;
            return true;
          }
        } else if (item.uuid === uuid) {
          out_info.path = path;
          out_info.type = item.type;
          return true;
        }
      }
      return false;
    });
    proto.reset = function() {
      this._pathToUuid = js.createMap(true);
    };
    module.exports = AssetTable;
  }), {
    "../platform/js": 124,
    "../utils/misc": 187
  } ],
  84: [ (function(require, module, exports) {
    "use strict";
    var sys = require("../platform/CCSys");
    var debug = require("../CCDebug");
    var __audioSupport = sys.__audioSupport;
    var formatSupport = __audioSupport.format;
    var context = __audioSupport.context;
    function loadDomAudio(item, callback) {
      var dom = document.createElement("audio");
      dom.src = item.url;
      var isXiaomiGame = cc.sys.platform === cc.sys.XIAOMI_GAME;
      var isBaiduGame = cc.sys.platform === cc.sys.BAIDU_GAME;
      if ((false, isBaiduGame) || isXiaomiGame) {
        callback(null, dom);
        return;
      }
      var clearEvent = function clearEvent() {
        clearTimeout(timer);
        dom.removeEventListener("canplaythrough", success, false);
        dom.removeEventListener("error", failure, false);
        __audioSupport.USE_LOADER_EVENT && dom.removeEventListener(__audioSupport.USE_LOADER_EVENT, success, false);
      };
      var timer = setTimeout((function() {
        0 === dom.readyState ? failure() : success();
      }), 8e3);
      var success = function success() {
        clearEvent();
        callback(null, dom);
      };
      var failure = function failure() {
        clearEvent();
        var message = "load audio failure - " + item.url;
        cc.log(message);
        callback(message);
      };
      dom.addEventListener("canplaythrough", success, false);
      dom.addEventListener("error", failure, false);
      __audioSupport.USE_LOADER_EVENT && dom.addEventListener(__audioSupport.USE_LOADER_EVENT, success, false);
    }
    function loadWebAudio(item, callback) {
      context || callback(new Error(debug.getError(4926)));
      var request = cc.loader.getXMLHttpRequest();
      request.open("GET", item.url, true);
      request.responseType = "arraybuffer";
      request.onload = function() {
        context["decodeAudioData"](request.response, (function(buffer) {
          callback(null, buffer);
        }), (function() {
          callback("decode error - " + item.id, null);
        }));
      };
      request.onerror = function() {
        callback("request error - " + item.id, null);
      };
      request.send();
    }
    function downloadAudio(item, callback) {
      if (0 === formatSupport.length) return new Error(debug.getError(4927));
      var loader;
      if (__audioSupport.WEB_AUDIO) {
        var loadByDeserializedAudio = item._owner instanceof cc.AudioClip;
        loader = loadByDeserializedAudio ? item._owner.loadMode === cc.AudioClip.LoadMode.WEB_AUDIO ? loadWebAudio : loadDomAudio : item.urlParam && item.urlParam["useDom"] ? loadDomAudio : loadWebAudio;
      } else loader = loadDomAudio;
      loader(item, callback);
    }
    module.exports = downloadAudio;
  }), {
    "../CCDebug": 3,
    "../platform/CCSys": 113
  } ],
  85: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    function parseDepends(key, parsed) {
      var item = cc.loader.getItem(key);
      if (item) {
        var depends = item.dependKeys;
        if (depends) for (var i = 0; i < depends.length; i++) {
          var depend = depends[i];
          if (!parsed[depend]) {
            parsed[depend] = true;
            parseDepends(depend, parsed);
          }
        }
      }
    }
    function visitAsset(asset, excludeMap) {
      if (!asset._uuid) return;
      var key = cc.loader._getReferenceKey(asset);
      if (!excludeMap[key]) {
        excludeMap[key] = true;
        parseDepends(key, excludeMap);
      }
    }
    function visitComponent(comp, excludeMap) {
      var props = Object.getOwnPropertyNames(comp);
      for (var i = 0; i < props.length; i++) {
        var value = comp[props[i]];
        if ("object" === typeof value && value) if (Array.isArray(value)) for (var j = 0; j < value.length; j++) {
          var val = value[j];
          val instanceof cc.RawAsset && visitAsset(val, excludeMap);
        } else if (value.constructor && value.constructor !== Object) value instanceof cc.RawAsset && visitAsset(value, excludeMap); else {
          var keys = Object.getOwnPropertyNames(value);
          for (var _j = 0; _j < keys.length; _j++) {
            var _val = value[keys[_j]];
            _val instanceof cc.RawAsset && visitAsset(_val, excludeMap);
          }
        }
      }
    }
    function visitNode(node, excludeMap) {
      for (var i = 0; i < node._components.length; i++) visitComponent(node._components[i], excludeMap);
      for (var _i = 0; _i < node._children.length; _i++) visitNode(node._children[_i], excludeMap);
    }
    module.exports = {
      autoRelease: function autoRelease(oldSceneAssets, nextSceneAssets, persistNodes) {
        var releaseSettings = cc.loader._autoReleaseSetting;
        var excludeMap = js.createMap();
        if (nextSceneAssets) for (var i = 0; i < nextSceneAssets.length; i++) excludeMap[nextSceneAssets[i]] = true;
        for (var _i2 = 0; _i2 < persistNodes.length; _i2++) visitNode(persistNodes[_i2], excludeMap);
        if (oldSceneAssets) for (var _i3 = 0; _i3 < oldSceneAssets.length; _i3++) {
          var key = oldSceneAssets[_i3];
          false === releaseSettings[key] || excludeMap[key] || cc.loader.release(key);
        }
        var keys = Object.keys(releaseSettings);
        for (var _i4 = 0; _i4 < keys.length; _i4++) {
          var _key = keys[_i4];
          true !== releaseSettings[_key] || excludeMap[_key] || cc.loader.release(_key);
        }
      },
      getDependsRecursively: function getDependsRecursively(key) {
        var depends = {};
        parseDepends(key, depends);
        return Object.keys(depends);
      }
    };
  }), {
    "../platform/js": 124
  } ],
  86: [ (function(require, module, exports) {
    "use strict";
    function downloadBinary(item, callback) {
      var url = item.url;
      var xhr = cc.loader.getXMLHttpRequest(), errInfo = "Load binary data failed: " + url;
      xhr.open("GET", url, true);
      xhr.responseType = "arraybuffer";
      xhr.onload = function() {
        var arrayBuffer = xhr.response;
        if (arrayBuffer) {
          var result = new Uint8Array(arrayBuffer);
          callback(null, result);
        } else callback({
          status: xhr.status,
          errorMessage: errInfo + "(no response)"
        });
      };
      xhr.onerror = function() {
        callback({
          status: xhr.status,
          errorMessage: errInfo + "(error)"
        });
      };
      xhr.ontimeout = function() {
        callback({
          status: xhr.status,
          errorMessage: errInfo + "(time out)"
        });
      };
      xhr.send(null);
    }
    module.exports = downloadBinary;
  }), {} ],
  87: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    var debug = require("../CCDebug");
    require("../utils/CCPath");
    var Pipeline = require("./pipeline");
    var PackDownloader = require("./pack-downloader");
    var downloadBinary = require("./binary-downloader");
    var downloadText = require("./text-downloader");
    var urlAppendTimestamp = require("./utils").urlAppendTimestamp;
    var downloadAudio;
    true;
    downloadAudio = require("./audio-downloader");
    function skip() {
      return null;
    }
    function downloadScript(item, callback, isAsync) {
      var url = item.url, d = document, s = document.createElement("script");
      "file:" !== window.location.protocol && (s.crossOrigin = "anonymous");
      s.async = isAsync;
      s.src = urlAppendTimestamp(url);
      function loadHandler() {
        s.parentNode.removeChild(s);
        s.removeEventListener("load", loadHandler, false);
        s.removeEventListener("error", errorHandler, false);
        callback(null, url);
      }
      function errorHandler() {
        s.parentNode.removeChild(s);
        s.removeEventListener("load", loadHandler, false);
        s.removeEventListener("error", errorHandler, false);
        callback(new Error(debug.getError(4928, url)));
      }
      s.addEventListener("load", loadHandler, false);
      s.addEventListener("error", errorHandler, false);
      d.body.appendChild(s);
    }
    function downloadWebp(item, callback, isCrossOrigin, img) {
      if (!cc.sys.capabilities.webp) return new Error(debug.getError(4929, item.url));
      return downloadImage(item, callback, isCrossOrigin, img);
    }
    function downloadImage(item, callback, isCrossOrigin, img) {
      void 0 === isCrossOrigin && (isCrossOrigin = true);
      var url = urlAppendTimestamp(item.url);
      img = img || new Image();
      isCrossOrigin && "file:" !== window.location.protocol ? img.crossOrigin = "anonymous" : img.crossOrigin = null;
      if (img.complete && img.naturalWidth > 0 && img.src === url) return img;
      var loadCallback = function loadCallback() {
        img.removeEventListener("load", loadCallback);
        img.removeEventListener("error", errorCallback);
        img.id = item.id;
        callback(null, img);
      };
      var errorCallback = function errorCallback() {
        img.removeEventListener("load", loadCallback);
        img.removeEventListener("error", errorCallback);
        "https:" !== window.location.protocol && img.crossOrigin && "anonymous" === img.crossOrigin.toLowerCase() ? downloadImage(item, callback, false, img) : callback(new Error(debug.getError(4930, url)));
      };
      img.addEventListener("load", loadCallback);
      img.addEventListener("error", errorCallback);
      img.src = url;
    }
    function downloadUuid(item, callback) {
      var result = PackDownloader.load(item, callback);
      if (void 0 === result) return this.extMap["json"](item, callback);
      return result || void 0;
    }
    var defaultMap = {
      js: downloadScript,
      png: downloadImage,
      jpg: downloadImage,
      bmp: downloadImage,
      jpeg: downloadImage,
      gif: downloadImage,
      ico: downloadImage,
      tiff: downloadImage,
      webp: downloadWebp,
      image: downloadImage,
      pvr: downloadBinary,
      pkm: downloadBinary,
      mp3: downloadAudio,
      ogg: downloadAudio,
      wav: downloadAudio,
      m4a: downloadAudio,
      txt: downloadText,
      xml: downloadText,
      vsh: downloadText,
      fsh: downloadText,
      atlas: downloadText,
      tmx: downloadText,
      tsx: downloadText,
      json: downloadText,
      ExportJson: downloadText,
      plist: downloadText,
      fnt: downloadText,
      font: skip,
      eot: skip,
      ttf: skip,
      woff: skip,
      svg: skip,
      ttc: skip,
      uuid: downloadUuid,
      binary: downloadBinary,
      bin: downloadBinary,
      dbbin: downloadBinary,
      default: downloadText
    };
    var ID = "Downloader";
    var Downloader = function Downloader(extMap) {
      this.id = ID;
      this.async = true;
      this.pipeline = null;
      this._curConcurrent = 0;
      this._loadQueue = [];
      this._subpackages = {};
      this.extMap = js.mixin(extMap, defaultMap);
    };
    Downloader.ID = ID;
    Downloader.PackDownloader = PackDownloader;
    Downloader.prototype.addHandlers = function(extMap) {
      js.mixin(this.extMap, extMap);
    };
    Downloader.prototype._handleLoadQueue = function() {
      while (this._curConcurrent < cc.macro.DOWNLOAD_MAX_CONCURRENT) {
        var nextOne = this._loadQueue.shift();
        if (!nextOne) break;
        var syncRet = this.handle(nextOne.item, nextOne.callback);
        void 0 !== syncRet && (syncRet instanceof Error ? nextOne.callback(syncRet) : nextOne.callback(null, syncRet));
      }
    };
    Downloader.prototype.handle = function(item, callback) {
      var self = this;
      var downloadFunc = this.extMap[item.type] || this.extMap["default"];
      var syncRet = void 0;
      if (this._curConcurrent < cc.macro.DOWNLOAD_MAX_CONCURRENT) {
        this._curConcurrent++;
        syncRet = downloadFunc.call(this, item, (function(err, result) {
          self._curConcurrent = Math.max(0, self._curConcurrent - 1);
          self._handleLoadQueue();
          callback && callback(err, result);
        }));
        if (void 0 !== syncRet) {
          this._curConcurrent = Math.max(0, this._curConcurrent - 1);
          this._handleLoadQueue();
          return syncRet;
        }
      } else if (item.ignoreMaxConcurrency) {
        syncRet = downloadFunc.call(this, item, callback);
        if (void 0 !== syncRet) return syncRet;
      } else this._loadQueue.push({
        item: item,
        callback: callback
      });
    };
    Downloader.prototype.loadSubpackage = function(name, completeCallback) {
      var pac = this._subpackages[name];
      pac ? pac.loaded ? completeCallback && completeCallback() : downloadScript({
        url: pac.path + "index.js"
      }, (function(err) {
        err || (pac.loaded = true);
        completeCallback && completeCallback(err);
      })) : completeCallback && completeCallback(new Error("Can't find subpackage " + name));
    };
    Pipeline.Downloader = module.exports = Downloader;
  }), {
    "../CCDebug": 3,
    "../platform/js": 124,
    "../utils/CCPath": 178,
    "./audio-downloader": 84,
    "./binary-downloader": 86,
    "./pack-downloader": 93,
    "./pipeline": 94,
    "./text-downloader": 97,
    "./utils": 99
  } ],
  88: [ (function(require, module, exports) {
    "use strict";
    var textUtils = require("../utils/text-utils");
    var _canvasContext = null;
    var _testString = "BES bswy:->@123\u4e01\u3041\u1101";
    var _fontFaces = {};
    var _intervalId = -1;
    var _loadingFonts = [];
    var _timeout = 3e3;
    var useNativeCheck = (function() {
      var nativeCheck = void 0;
      return function() {
        if (void 0 === nativeCheck) if (!window.FontFace) nativeCheck = false; else {
          var match = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent);
          var safari10Match = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
          nativeCheck = match ? parseInt(match[1], 10) > 42 : !safari10Match;
        }
        return nativeCheck;
      };
    })();
    function _checkFontLoaded() {
      var allFontsLoaded = true;
      var now = Date.now();
      for (var i = _loadingFonts.length - 1; i >= 0; i--) {
        var fontLoadHandle = _loadingFonts[i];
        var fontFamily = fontLoadHandle.fontFamilyName;
        if (now - fontLoadHandle.startTime > _timeout) {
          cc.warnID(4933, fontFamily);
          fontLoadHandle.callback(null, fontFamily);
          _loadingFonts.splice(i, 1);
          continue;
        }
        var oldWidth = fontLoadHandle.refWidth;
        _canvasContext.font = "40px " + fontFamily;
        var newWidth = textUtils.safeMeasureText(_canvasContext, _testString);
        if (oldWidth !== newWidth) {
          _loadingFonts.splice(i, 1);
          fontLoadHandle.callback(null, fontFamily);
        } else allFontsLoaded = false;
      }
      if (allFontsLoaded) {
        clearInterval(_intervalId);
        _intervalId = -1;
      }
    }
    function nativeCheckFontLoaded(start, font, callback) {
      var loader = new Promise(function(resolve, reject) {
        var check = function check() {
          var now = Date.now();
          now - start >= _timeout ? reject() : document.fonts.load("40px " + font).then((function(fonts) {
            fonts.length >= 1 ? resolve() : setTimeout(check, 100);
          }), (function() {
            reject();
          }));
        };
        check();
      });
      var timeoutId = null, timer = new Promise(function(resolve, reject) {
        timeoutId = setTimeout(reject, _timeout);
      });
      Promise.race([ timer, loader ]).then((function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
        callback(null, font);
      }), (function() {
        cc.warnID(4933, font);
        callback(null, font);
      }));
    }
    var fontLoader = {
      loadFont: function loadFont(item, callback) {
        var url = item.url;
        var fontFamilyName = fontLoader._getFontFamily(url);
        if (_fontFaces[fontFamilyName]) return fontFamilyName;
        if (!_canvasContext) {
          var labelCanvas = document.createElement("canvas");
          labelCanvas.width = 100;
          labelCanvas.height = 100;
          _canvasContext = labelCanvas.getContext("2d");
        }
        var fontDesc = "40px " + fontFamilyName;
        _canvasContext.font = fontDesc;
        var refWidth = textUtils.safeMeasureText(_canvasContext, _testString);
        var fontStyle = document.createElement("style");
        fontStyle.type = "text/css";
        var fontStr = "";
        isNaN(fontFamilyName - 0) ? fontStr += "@font-face { font-family:" + fontFamilyName + "; src:" : fontStr += "@font-face { font-family:'" + fontFamilyName + "'; src:";
        fontStr += "url('" + url + "');";
        fontStyle.textContent = fontStr + "}";
        document.body.appendChild(fontStyle);
        var preloadDiv = document.createElement("div");
        var divStyle = preloadDiv.style;
        divStyle.fontFamily = fontFamilyName;
        preloadDiv.innerHTML = ".";
        divStyle.position = "absolute";
        divStyle.left = "-100px";
        divStyle.top = "-100px";
        document.body.appendChild(preloadDiv);
        if (useNativeCheck()) nativeCheckFontLoaded(Date.now(), fontFamilyName, callback); else {
          var fontLoadHandle = {
            fontFamilyName: fontFamilyName,
            refWidth: refWidth,
            callback: callback,
            startTime: Date.now()
          };
          _loadingFonts.push(fontLoadHandle);
          -1 === _intervalId && (_intervalId = setInterval(_checkFontLoaded, 100));
        }
        _fontFaces[fontFamilyName] = fontStyle;
      },
      _getFontFamily: function _getFontFamily(fontHandle) {
        var ttfIndex = fontHandle.lastIndexOf(".ttf");
        if (-1 === ttfIndex) return fontHandle;
        var slashPos = fontHandle.lastIndexOf("/");
        var fontFamilyName;
        fontFamilyName = -1 === slashPos ? fontHandle.substring(0, ttfIndex) + "_LABEL" : fontHandle.substring(slashPos + 1, ttfIndex) + "_LABEL";
        -1 !== fontFamilyName.indexOf(" ") && (fontFamilyName = '"' + fontFamilyName + '"');
        return fontFamilyName;
      }
    };
    module.exports = fontLoader;
  }), {
    "../utils/text-utils": 193
  } ],
  89: [ (function(require, module, exports) {
    "use strict";
    require("./downloader");
    require("./loader");
    require("./loading-items");
    require("./pipeline");
    require("./CCLoader");
  }), {
    "./CCLoader": 81,
    "./downloader": 87,
    "./loader": 90,
    "./loading-items": 91,
    "./pipeline": 94
  } ],
  90: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    var plistParser = require("../platform/CCSAXParser").plistParser;
    var Pipeline = require("./pipeline");
    var Texture2D = require("../assets/CCTexture2D");
    var loadUuid = require("./uuid-loader");
    var fontLoader = require("./font-loader");
    function loadNothing() {
      return null;
    }
    function loadJSON(item) {
      if ("string" !== typeof item.content) return new Error("JSON Loader: Input item doesn't contain string content");
      try {
        var result = JSON.parse(item.content);
        return result;
      } catch (e) {
        return new Error("JSON Loader: Parse json [" + item.id + "] failed : " + e);
      }
    }
    function loadImage(item) {
      var loadByDeserializedAsset = item._owner instanceof cc.Asset;
      if (loadByDeserializedAsset) return null;
      var image = item.content;
      if ((true, true) && cc.sys.platform !== cc.sys.FB_PLAYABLE_ADS && !(image instanceof Image)) return new Error("Image Loader: Input item doesn't contain Image content");
      var tex = item.texture || new Texture2D();
      tex._uuid = item.uuid;
      tex.url = item.url;
      tex._setRawAsset(item.rawUrl, false);
      tex._nativeAsset = image;
      return tex;
    }
    function loadAudioAsAsset(item, callback) {
      var loadByDeserializedAsset = item._owner instanceof cc.Asset;
      if (loadByDeserializedAsset) return null;
      var audioClip = new cc.AudioClip();
      audioClip._setRawAsset(item.rawUrl, false);
      audioClip._nativeAsset = item.content;
      audioClip.url = item.url;
      return audioClip;
    }
    function loadPlist(item) {
      if ("string" !== typeof item.content) return new Error("Plist Loader: Input item doesn't contain string content");
      var result = plistParser.parse(item.content);
      return result || new Error("Plist Loader: Parse [" + item.id + "] failed");
    }
    function loadBinary(item) {
      return item.load ? item.load(item.content) : null;
    }
    var PVR_HEADER_LENGTH = 13;
    var PVR_MAGIC = 55727696;
    var PVR_HEADER_MAGIC = 0;
    var PVR_HEADER_FORMAT = 2;
    var PVR_HEADER_HEIGHT = 6;
    var PVR_HEADER_WIDTH = 7;
    var PVR_HEADER_MIPMAPCOUNT = 11;
    var PVR_HEADER_METADATA = 12;
    function loadPVRTex(item) {
      var buffer = item.content instanceof ArrayBuffer ? item.content : item.content.buffer;
      var header = new Int32Array(buffer, 0, PVR_HEADER_LENGTH);
      if (header[PVR_HEADER_MAGIC] != PVR_MAGIC) return new Error("Invalid magic number in PVR header");
      var width = header[PVR_HEADER_WIDTH];
      var height = header[PVR_HEADER_HEIGHT];
      var dataOffset = header[PVR_HEADER_METADATA] + 52;
      var pvrtcData = new Uint8Array(buffer, dataOffset);
      var pvrAsset = {
        _data: pvrtcData,
        _compressed: true,
        width: width,
        height: height
      };
      return pvrAsset;
    }
    var ETC_PKM_HEADER_SIZE = 16;
    var ETC_PKM_FORMAT_OFFSET = 6;
    var ETC_PKM_ENCODED_WIDTH_OFFSET = 8;
    var ETC_PKM_ENCODED_HEIGHT_OFFSET = 10;
    var ETC_PKM_WIDTH_OFFSET = 12;
    var ETC_PKM_HEIGHT_OFFSET = 14;
    var ETC1_RGB_NO_MIPMAPS = 0;
    var ETC2_RGB_NO_MIPMAPS = 1;
    var ETC2_RGBA_NO_MIPMAPS = 3;
    function readBEUint16(header, offset) {
      return header[offset] << 8 | header[offset + 1];
    }
    function loadPKMTex(item) {
      var buffer = item.content instanceof ArrayBuffer ? item.content : item.content.buffer;
      var header = new Uint8Array(buffer);
      var format = readBEUint16(header, ETC_PKM_FORMAT_OFFSET);
      if (format !== ETC1_RGB_NO_MIPMAPS && format !== ETC2_RGB_NO_MIPMAPS && format !== ETC2_RGBA_NO_MIPMAPS) return new Error("Invalid magic number in ETC header");
      var width = readBEUint16(header, ETC_PKM_WIDTH_OFFSET);
      var height = readBEUint16(header, ETC_PKM_HEIGHT_OFFSET);
      var encodedWidth = readBEUint16(header, ETC_PKM_ENCODED_WIDTH_OFFSET);
      var encodedHeight = readBEUint16(header, ETC_PKM_ENCODED_HEIGHT_OFFSET);
      var etcData = new Uint8Array(buffer, ETC_PKM_HEADER_SIZE);
      var etcAsset = {
        _data: etcData,
        _compressed: true,
        width: width,
        height: height
      };
      return etcAsset;
    }
    var defaultMap = {
      png: loadImage,
      jpg: loadImage,
      bmp: loadImage,
      jpeg: loadImage,
      gif: loadImage,
      ico: loadImage,
      tiff: loadImage,
      webp: loadImage,
      image: loadImage,
      pvr: loadPVRTex,
      pkm: loadPKMTex,
      mp3: loadAudioAsAsset,
      ogg: loadAudioAsAsset,
      wav: loadAudioAsAsset,
      m4a: loadAudioAsAsset,
      json: loadJSON,
      ExportJson: loadJSON,
      plist: loadPlist,
      uuid: loadUuid,
      prefab: loadUuid,
      fire: loadUuid,
      scene: loadUuid,
      binary: loadBinary,
      dbbin: loadBinary,
      bin: loadBinary,
      font: fontLoader.loadFont,
      eot: fontLoader.loadFont,
      ttf: fontLoader.loadFont,
      woff: fontLoader.loadFont,
      svg: fontLoader.loadFont,
      ttc: fontLoader.loadFont,
      default: loadNothing
    };
    var ID = "Loader";
    var Loader = function Loader(extMap) {
      this.id = ID;
      this.async = true;
      this.pipeline = null;
      this.extMap = js.mixin(extMap, defaultMap);
    };
    Loader.ID = ID;
    Loader.prototype.addHandlers = function(extMap) {
      this.extMap = js.mixin(this.extMap, extMap);
    };
    Loader.prototype.handle = function(item, callback) {
      var loadFunc = this.extMap[item.type] || this.extMap["default"];
      return loadFunc.call(this, item, callback);
    };
    Pipeline.Loader = module.exports = Loader;
  }), {
    "../assets/CCTexture2D": 27,
    "../platform/CCSAXParser": 111,
    "../platform/js": 124,
    "./font-loader": 88,
    "./pipeline": 94,
    "./uuid-loader": 100
  } ],
  91: [ (function(require, module, exports) {
    "use strict";
    var CallbacksInvoker = require("../platform/callbacks-invoker");
    require("../utils/CCPath");
    var js = require("../platform/js");
    var _qid = 0 | 998 * Math.random();
    var _queues = js.createMap(true);
    var _pool = [];
    var _POOL_MAX_LENGTH = 10;
    var ItemState = {
      WORKING: 1,
      COMPLETE: 2,
      ERROR: 3
    };
    var _queueDeps = js.createMap(true);
    function isIdValid(id) {
      var realId = id.url || id;
      return "string" === typeof realId;
    }
    function _parseUrlParam(url) {
      if (!url) return;
      var split = url.split("?");
      if (!split || !split[0] || !split[1]) return;
      var urlParam = {};
      var queries = split[1].split("&");
      queries.forEach((function(item) {
        var itemSplit = item.split("=");
        urlParam[itemSplit[0]] = itemSplit[1];
      }));
      return urlParam;
    }
    function createItem(id, queueId) {
      var url = "object" === typeof id ? id.url : id;
      var result = {
        queueId: queueId,
        id: url,
        url: url,
        rawUrl: void 0,
        urlParam: _parseUrlParam(url),
        type: "",
        error: null,
        content: null,
        complete: false,
        states: {},
        deps: null
      };
      if ("object" === typeof id) {
        js.mixin(result, id);
        if (id.skips) for (var i = 0; i < id.skips.length; i++) {
          var skip = id.skips[i];
          result.states[skip] = ItemState.COMPLETE;
        }
      }
      result.rawUrl = result.url;
      url && !result.type && (result.type = cc.path.extname(url).toLowerCase().substr(1));
      return result;
    }
    var checkedIds = [];
    function checkCircleReference(owner, item, recursiveCall) {
      if (!owner || !item) return false;
      var result = false;
      checkedIds.push(item.id);
      if (item.deps) {
        var i, deps = item.deps, subDep;
        for (i = 0; i < deps.length; i++) {
          subDep = deps[i];
          if (subDep.id === owner.id) {
            result = true;
            break;
          }
          if (checkedIds.indexOf(subDep.id) >= 0) continue;
          if (subDep.deps && checkCircleReference(owner, subDep, true)) {
            result = true;
            break;
          }
        }
      }
      recursiveCall || (checkedIds.length = 0);
      return result;
    }
    var LoadingItems = function LoadingItems(pipeline, urlList, onProgress, onComplete) {
      CallbacksInvoker.call(this);
      this._id = ++_qid;
      _queues[this._id] = this;
      this._pipeline = pipeline;
      this._errorUrls = js.createMap(true);
      this._appending = false;
      this._ownerQueue = null;
      this.onProgress = onProgress;
      this.onComplete = onComplete;
      this.map = js.createMap(true);
      this.completed = {};
      this.totalCount = 0;
      this.completedCount = 0;
      this._pipeline ? this.active = true : this.active = false;
      urlList && (urlList.length > 0 ? this.append(urlList) : this.allComplete());
    };
    LoadingItems.ItemState = new cc.Enum(ItemState);
    LoadingItems.create = function(pipeline, urlList, onProgress, onComplete) {
      if (void 0 === onProgress) {
        if ("function" === typeof urlList) {
          onComplete = urlList;
          urlList = onProgress = null;
        }
      } else if (void 0 === onComplete) if ("function" === typeof urlList) {
        onComplete = onProgress;
        onProgress = urlList;
        urlList = null;
      } else {
        onComplete = onProgress;
        onProgress = null;
      }
      var queue = _pool.pop();
      if (queue) {
        queue._pipeline = pipeline;
        queue.onProgress = onProgress;
        queue.onComplete = onComplete;
        _queues[queue._id] = queue;
        queue._pipeline && (queue.active = true);
        urlList && queue.append(urlList);
      } else queue = new LoadingItems(pipeline, urlList, onProgress, onComplete);
      return queue;
    };
    LoadingItems.getQueue = function(item) {
      return item.queueId ? _queues[item.queueId] : null;
    };
    LoadingItems.itemComplete = function(item) {
      var queue = _queues[item.queueId];
      queue && queue.itemComplete(item.id);
    };
    LoadingItems.initQueueDeps = function(queue) {
      var dep = _queueDeps[queue._id];
      if (dep) {
        dep.completed.length = 0;
        dep.deps.length = 0;
      } else dep = _queueDeps[queue._id] = {
        completed: [],
        deps: []
      };
    };
    LoadingItems.registerQueueDep = function(owner, depId) {
      var queueId = owner.queueId || owner;
      if (!queueId) return false;
      var queueDepList = _queueDeps[queueId];
      if (queueDepList) -1 === queueDepList.deps.indexOf(depId) && queueDepList.deps.push(depId); else if (owner.id) for (var id in _queueDeps) {
        var queue = _queueDeps[id];
        -1 !== queue.deps.indexOf(owner.id) && -1 === queue.deps.indexOf(depId) && queue.deps.push(depId);
      }
    };
    LoadingItems.finishDep = function(depId) {
      for (var id in _queueDeps) {
        var queue = _queueDeps[id];
        -1 !== queue.deps.indexOf(depId) && -1 === queue.completed.indexOf(depId) && queue.completed.push(depId);
      }
    };
    var proto = LoadingItems.prototype;
    js.mixin(proto, CallbacksInvoker.prototype);
    proto.append = function(urlList, owner) {
      if (!this.active) return [];
      owner && !owner.deps && (owner.deps = []);
      this._appending = true;
      var accepted = [], i, url, item;
      for (i = 0; i < urlList.length; ++i) {
        url = urlList[i];
        if (url.queueId && !this.map[url.id]) {
          this.map[url.id] = url;
          owner && owner.deps.push(url);
          if (url.complete || checkCircleReference(owner, url)) {
            this.totalCount++;
            this.itemComplete(url.id);
            continue;
          }
          var self = this;
          var queue = _queues[url.queueId];
          if (queue) {
            this.totalCount++;
            LoadingItems.registerQueueDep(owner || this._id, url.id);
            queue.addListener(url.id, (function(item) {
              self.itemComplete(item.id);
            }));
          }
          continue;
        }
        if (isIdValid(url)) {
          item = createItem(url, this._id);
          var key = item.id;
          if (!this.map[key]) {
            this.map[key] = item;
            this.totalCount++;
            owner && owner.deps.push(item);
            LoadingItems.registerQueueDep(owner || this._id, key);
            accepted.push(item);
          }
        }
      }
      this._appending = false;
      this.completedCount === this.totalCount ? this.allComplete() : this._pipeline.flowIn(accepted);
      return accepted;
    };
    proto._childOnProgress = function(item) {
      if (this.onProgress) {
        var dep = _queueDeps[this._id];
        this.onProgress(dep ? dep.completed.length : this.completedCount, dep ? dep.deps.length : this.totalCount, item);
      }
    };
    proto.allComplete = function() {
      var errors = js.isEmptyObject(this._errorUrls) ? null : this._errorUrls;
      this.onComplete && this.onComplete(errors, this);
    };
    proto.isCompleted = function() {
      return this.completedCount >= this.totalCount;
    };
    proto.isItemCompleted = function(id) {
      return !!this.completed[id];
    };
    proto.exists = function(id) {
      return !!this.map[id];
    };
    proto.getContent = function(id) {
      var item = this.map[id];
      var ret = null;
      item && (item.content ? ret = item.content : item.alias && (ret = item.alias.content));
      return ret;
    };
    proto.getError = function(id) {
      var item = this.map[id];
      var ret = null;
      item && (item.error ? ret = item.error : item.alias && (ret = item.alias.error));
      return ret;
    };
    proto.addListener = CallbacksInvoker.prototype.add;
    proto.hasListener = CallbacksInvoker.prototype.has;
    proto.removeListener = CallbacksInvoker.prototype.remove;
    proto.removeAllListeners = CallbacksInvoker.prototype.removeAll;
    proto.removeItem = function(url) {
      var item = this.map[url];
      if (!item) return;
      if (!this.completed[item.alias || url]) return;
      delete this.completed[url];
      delete this.map[url];
      if (item.alias) {
        delete this.completed[item.alias.id];
        delete this.map[item.alias.id];
      }
      this.completedCount--;
      this.totalCount--;
    };
    proto.itemComplete = function(id) {
      var item = this.map[id];
      if (!item) return;
      var errorListId = id in this._errorUrls;
      item.error instanceof Error || js.isString(item.error) ? this._errorUrls[id] = item.error : item.error ? js.mixin(this._errorUrls, item.error) : !item.error && errorListId && delete this._errorUrls[id];
      this.completed[id] = item;
      this.completedCount++;
      LoadingItems.finishDep(item.id);
      if (this.onProgress) {
        var dep = _queueDeps[this._id];
        this.onProgress(dep ? dep.completed.length : this.completedCount, dep ? dep.deps.length : this.totalCount, item);
      }
      this.invoke(id, item);
      this.removeAll(id);
      !this._appending && this.completedCount >= this.totalCount && this.allComplete();
    };
    proto.destroy = function() {
      this.active = false;
      this._appending = false;
      this._pipeline = null;
      this._ownerQueue = null;
      js.clear(this._errorUrls);
      this.onProgress = null;
      this.onComplete = null;
      this.map = js.createMap(true);
      this.completed = {};
      this.totalCount = 0;
      this.completedCount = 0;
      CallbacksInvoker.call(this);
      if (_queueDeps[this._id]) {
        _queueDeps[this._id].completed.length = 0;
        _queueDeps[this._id].deps.length = 0;
      }
      delete _queues[this._id];
      delete _queueDeps[this._id];
      -1 === _pool.indexOf(this) && _pool.length < _POOL_MAX_LENGTH && _pool.push(this);
    };
    cc.LoadingItems = module.exports = LoadingItems;
  }), {
    "../platform/callbacks-invoker": 117,
    "../platform/js": 124,
    "../utils/CCPath": 178
  } ],
  92: [ (function(require, module, exports) {
    "use strict";
    var Pipeline = require("./pipeline");
    var ID = "MD5Pipe";
    var UuidRegex = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-]{8,})/;
    var MD5Pipe = function MD5Pipe(md5AssetsMap, md5NativeAssetsMap, libraryBase) {
      this.id = ID;
      this.async = false;
      this.pipeline = null;
      this.md5AssetsMap = md5AssetsMap;
      this.md5NativeAssetsMap = md5NativeAssetsMap;
      this.libraryBase = libraryBase;
    };
    MD5Pipe.ID = ID;
    MD5Pipe.prototype.handle = function(item) {
      item.url = this.transformURL(item.url);
      return null;
    };
    MD5Pipe.prototype.transformURL = function(url) {
      var isNativeAsset = !url.startsWith(this.libraryBase);
      var map = isNativeAsset ? this.md5NativeAssetsMap : this.md5AssetsMap;
      url = url.replace(UuidRegex, (function(match, uuid) {
        var hashValue = map[uuid];
        return hashValue ? match + "." + hashValue : match;
      }));
      return url;
    };
    Pipeline.MD5Pipe = module.exports = MD5Pipe;
  }), {
    "./pipeline": 94
  } ],
  93: [ (function(require, module, exports) {
    "use strict";
    var Unpackers = require("./unpackers");
    var pushToMap = require("../utils/misc").pushToMap;
    var PackState = {
      Invalid: 0,
      Removed: 1,
      Downloading: 2,
      Loaded: 3
    };
    function UnpackerData() {
      this.unpacker = null;
      this.state = PackState.Invalid;
    }
    var uuidToPack = {};
    var packIndices = {};
    var globalUnpackers = {};
    function error(uuid, packUuid) {
      return new Error("Can not retrieve " + uuid + " from packer " + packUuid);
    }
    module.exports = {
      initPacks: function initPacks(packs) {
        packIndices = packs;
        uuidToPack = {};
        for (var packUuid in packs) {
          var uuids = packs[packUuid];
          for (var i = 0; i < uuids.length; i++) {
            var uuid = uuids[i];
            var pushFront = 1 === uuids.length;
            pushToMap(uuidToPack, uuid, packUuid, pushFront);
          }
        }
      },
      _loadNewPack: function _loadNewPack(uuid, packUuid, callback) {
        var self = this;
        var packUrl = cc.AssetLibrary.getLibUrlNoExt(packUuid) + ".json";
        cc.loader.load({
          url: packUrl,
          ignoreMaxConcurrency: true
        }, (function(err, packJson) {
          if (err) {
            cc.errorID(4916, uuid);
            return callback(err);
          }
          var res = self._doLoadNewPack(uuid, packUuid, packJson);
          res ? callback(null, res) : callback(error(uuid, packUuid));
        }));
      },
      _doPreload: function _doPreload(packUuid, packJson) {
        var unpackerData = globalUnpackers[packUuid];
        if (!unpackerData) {
          unpackerData = globalUnpackers[packUuid] = new UnpackerData();
          unpackerData.state = PackState.Downloading;
        }
        if (unpackerData.state !== PackState.Loaded) {
          unpackerData.unpacker = new Unpackers.JsonUnpacker();
          unpackerData.unpacker.load(packIndices[packUuid], packJson);
          unpackerData.state = PackState.Loaded;
        }
      },
      _doLoadNewPack: function _doLoadNewPack(uuid, packUuid, packedJson) {
        var unpackerData = globalUnpackers[packUuid];
        if (unpackerData.state !== PackState.Loaded) {
          "string" === typeof packedJson && (packedJson = JSON.parse(packedJson));
          Array.isArray(packedJson) ? unpackerData.unpacker = new Unpackers.JsonUnpacker() : packedJson.type === Unpackers.TextureUnpacker.ID && (unpackerData.unpacker = new Unpackers.TextureUnpacker());
          unpackerData.unpacker.load(packIndices[packUuid], packedJson);
          unpackerData.state = PackState.Loaded;
        }
        return unpackerData.unpacker.retrieve(uuid);
      },
      _selectLoadedPack: function _selectLoadedPack(packUuids) {
        var existsPackState = PackState.Invalid;
        var existsPackUuid = "";
        for (var i = 0; i < packUuids.length; i++) {
          var packUuid = packUuids[i];
          var unpackerData = globalUnpackers[packUuid];
          if (unpackerData) {
            var state = unpackerData.state;
            if (state === PackState.Loaded) return packUuid;
            if (state > existsPackState) {
              existsPackState = state;
              existsPackUuid = packUuid;
            }
          }
        }
        return existsPackState !== PackState.Invalid ? existsPackUuid : packUuids[0];
      },
      load: function load(item, callback) {
        var uuid = item.uuid;
        var packUuid = uuidToPack[uuid];
        if (!packUuid) return;
        Array.isArray(packUuid) && (packUuid = this._selectLoadedPack(packUuid));
        var unpackerData = globalUnpackers[packUuid];
        if (unpackerData && unpackerData.state === PackState.Loaded) {
          var json = unpackerData.unpacker.retrieve(uuid);
          return json || error(uuid, packUuid);
        }
        if (!unpackerData) {
          true;
          console.log("Create unpacker %s for %s", packUuid, uuid);
          unpackerData = globalUnpackers[packUuid] = new UnpackerData();
          unpackerData.state = PackState.Downloading;
        }
        this._loadNewPack(uuid, packUuid, callback);
        return null;
      }
    };
    false;
  }), {
    "../utils/misc": 187,
    "./unpackers": 98
  } ],
  94: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    var LoadingItems = require("./loading-items");
    var ItemState = LoadingItems.ItemState;
    function flow(pipe, item) {
      var pipeId = pipe.id;
      var itemState = item.states[pipeId];
      var next = pipe.next;
      var pipeline = pipe.pipeline;
      if (item.error || itemState === ItemState.WORKING || itemState === ItemState.ERROR) return;
      if (itemState === ItemState.COMPLETE) next ? flow(next, item) : pipeline.flowOut(item); else {
        item.states[pipeId] = ItemState.WORKING;
        var result = pipe.handle(item, (function(err, result) {
          if (err) {
            item.error = err;
            item.states[pipeId] = ItemState.ERROR;
            pipeline.flowOut(item);
          } else {
            result && (item.content = result);
            item.states[pipeId] = ItemState.COMPLETE;
            next ? flow(next, item) : pipeline.flowOut(item);
          }
        }));
        if (result instanceof Error) {
          item.error = result;
          item.states[pipeId] = ItemState.ERROR;
          pipeline.flowOut(item);
        } else if (void 0 !== result) {
          null !== result && (item.content = result);
          item.states[pipeId] = ItemState.COMPLETE;
          next ? flow(next, item) : pipeline.flowOut(item);
        }
      }
    }
    var Pipeline = function Pipeline(pipes) {
      this._pipes = pipes;
      this._cache = js.createMap(true);
      for (var i = 0; i < pipes.length; ++i) {
        var pipe = pipes[i];
        if (!pipe.handle || !pipe.id) continue;
        pipe.pipeline = this;
        pipe.next = i < pipes.length - 1 ? pipes[i + 1] : null;
      }
    };
    Pipeline.ItemState = ItemState;
    var proto = Pipeline.prototype;
    proto.insertPipe = function(pipe, index) {
      if (!pipe.handle || !pipe.id || index > this._pipes.length) {
        cc.warnID(4921);
        return;
      }
      if (this._pipes.indexOf(pipe) > 0) {
        cc.warnID(4922);
        return;
      }
      pipe.pipeline = this;
      var nextPipe = null;
      index < this._pipes.length && (nextPipe = this._pipes[index]);
      var previousPipe = null;
      index > 0 && (previousPipe = this._pipes[index - 1]);
      previousPipe && (previousPipe.next = pipe);
      pipe.next = nextPipe;
      this._pipes.splice(index, 0, pipe);
    };
    proto.insertPipeAfter = function(refPipe, newPipe) {
      var index = this._pipes.indexOf(refPipe);
      if (index < 0) return;
      this.insertPipe(newPipe, index + 1);
    };
    proto.appendPipe = function(pipe) {
      if (!pipe.handle || !pipe.id) return;
      pipe.pipeline = this;
      pipe.next = null;
      this._pipes.length > 0 && (this._pipes[this._pipes.length - 1].next = pipe);
      this._pipes.push(pipe);
    };
    proto.flowIn = function(items) {
      var i, pipe = this._pipes[0], item;
      if (pipe) {
        for (i = 0; i < items.length; i++) {
          item = items[i];
          this._cache[item.id] = item;
        }
        for (i = 0; i < items.length; i++) {
          item = items[i];
          flow(pipe, item);
        }
      } else for (i = 0; i < items.length; i++) this.flowOut(items[i]);
    };
    proto.flowInDeps = function(owner, urlList, callback) {
      var deps = LoadingItems.create(this, (function(errors, items) {
        callback(errors, items);
        items.destroy();
      }));
      return deps.append(urlList, owner);
    };
    proto.flowOut = function(item) {
      item.error ? delete this._cache[item.id] : this._cache[item.id] || (this._cache[item.id] = item);
      item.complete = true;
      LoadingItems.itemComplete(item);
    };
    proto.copyItemStates = function(srcItem, dstItems) {
      if (!(dstItems instanceof Array)) {
        dstItems.states = srcItem.states;
        return;
      }
      for (var i = 0; i < dstItems.length; ++i) dstItems[i].states = srcItem.states;
    };
    proto.getItem = function(id) {
      var item = this._cache[id];
      if (!item) return item;
      item.alias && (item = item.alias);
      return item;
    };
    proto.removeItem = function(id) {
      var removed = this._cache[id];
      removed && removed.complete && delete this._cache[id];
      return removed;
    };
    proto.clear = function() {
      for (var id in this._cache) {
        var item = this._cache[id];
        delete this._cache[id];
        if (!item.complete) {
          item.error = new Error("Canceled manually");
          this.flowOut(item);
        }
      }
    };
    cc.Pipeline = module.exports = Pipeline;
  }), {
    "../platform/js": 124,
    "./loading-items": 91
  } ],
  95: [ (function(require, module, exports) {
    "use strict";
    true;
    var ReleasedAssetChecker = function ReleasedAssetChecker() {
      this._releasedKeys = js.createMap(true);
      this._dirty = false;
    };
    var getItemDesc = function getItemDesc(item) {
      if (item.uuid) {
        tmpInfo || (tmpInfo = {
          path: "",
          type: null
        });
        if (cc.loader._assetTables.assets._getInfo_DEBUG(item.uuid, tmpInfo)) {
          tmpInfo.path = "resources/" + tmpInfo.path;
          return '"' + tmpInfo.path + '" (type: ' + js.getClassName(tmpInfo.type) + ", uuid: " + item.uuid + ")";
        }
        return '"' + item.rawUrl + '" (' + item.uuid + ")";
      }
      return '"' + item.rawUrl + '"';
    };
    var doCheckCouldRelease = function doCheckCouldRelease(releasedKey, refOwnerItem, caches) {
      var loadedAgain = caches[releasedKey];
      loadedAgain || cc.log('"' + releasedKey + '" was released but maybe still referenced by ' + getItemDesc(refOwnerItem));
    };
    var js = require("../platform/js");
    ReleasedAssetChecker.prototype.setReleased = function(item, releasedKey) {
      this._releasedKeys[releasedKey] = true;
      this._dirty = true;
    };
    var tmpInfo = null;
    ReleasedAssetChecker.prototype.checkCouldRelease = function(caches) {
      if (!this._dirty) return;
      this._dirty = false;
      var released = this._releasedKeys;
      for (var id in caches) {
        var item = caches[id];
        item.alias && (item = item.alias);
        var depends = item.dependKeys;
        if (depends) for (var i = 0; i < depends.length; ++i) {
          var depend = depends[i];
          if (released[depend]) {
            doCheckCouldRelease(depend, item, caches);
            delete released[depend];
          }
        }
      }
      js.clear(released);
    };
    module.exports = ReleasedAssetChecker;
  }), {
    "../platform/js": 124
  } ],
  96: [ (function(require, module, exports) {
    "use strict";
    var Pipeline = require("./pipeline");
    var ID = "SubPackPipe";
    var UuidRegex = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-]{8,})/;
    function getUuidFromURL(url) {
      var matches = url.match(UuidRegex);
      if (matches) return matches[1];
      return "";
    }
    var _uuidToSubPack = Object.create(null);
    var SubPackPipe = function SubPackPipe(subpackage) {
      this.id = ID;
      this.async = false;
      this.pipeline = null;
      for (var packName in subpackage) {
        var pack = subpackage[packName];
        pack.uuids && pack.uuids.forEach((function(val) {
          _uuidToSubPack[val] = pack.path;
        }));
      }
    };
    SubPackPipe.ID = ID;
    SubPackPipe.prototype.handle = function(item) {
      item.url = this.transformURL(item.url);
      return null;
    };
    SubPackPipe.prototype.transformURL = function(url) {
      var uuid = getUuidFromURL(url);
      if (uuid) {
        var subpackage = _uuidToSubPack[uuid];
        if (subpackage) return url.replace("res/raw-assets/", subpackage + "raw-assets/");
      }
      return url;
    };
    Pipeline.SubPackPipe = module.exports = SubPackPipe;
  }), {
    "./pipeline": 94
  } ],
  97: [ (function(require, module, exports) {
    "use strict";
    var urlAppendTimestamp = require("./utils").urlAppendTimestamp;
    module.exports = function(item, callback) {
      var url = item.url;
      url = urlAppendTimestamp(url);
      var xhr = cc.loader.getXMLHttpRequest(), errInfo = "Load text file failed: " + url;
      xhr.open("GET", url, true);
      xhr.overrideMimeType && xhr.overrideMimeType("text/plain; charset=utf-8");
      xhr.onload = function() {
        4 === xhr.readyState ? 200 === xhr.status || 0 === xhr.status ? callback(null, xhr.responseText) : callback({
          status: xhr.status,
          errorMessage: errInfo + "(wrong status)"
        }) : callback({
          status: xhr.status,
          errorMessage: errInfo + "(wrong readyState)"
        });
      };
      xhr.onerror = function() {
        callback({
          status: xhr.status,
          errorMessage: errInfo + "(error)"
        });
      };
      xhr.ontimeout = function() {
        callback({
          status: xhr.status,
          errorMessage: errInfo + "(time out)"
        });
      };
      xhr.send(null);
    };
  }), {
    "./utils": 99
  } ],
  98: [ (function(require, module, exports) {
    "use strict";
    var Texture2D = require("../assets/CCTexture2D");
    var js = require("../platform/js");
    function JsonUnpacker() {
      this.jsons = {};
    }
    JsonUnpacker.prototype.load = function(indices, packedJson) {
      packedJson.length !== indices.length && cc.errorID(4915);
      for (var i = 0; i < indices.length; i++) {
        var key = indices[i];
        var json = packedJson[i];
        this.jsons[key] = json;
      }
    };
    JsonUnpacker.prototype.retrieve = function(key) {
      return this.jsons[key] || null;
    };
    function TextureUnpacker() {
      this.contents = {};
    }
    TextureUnpacker.ID = js._getClassId(Texture2D);
    TextureUnpacker.prototype.load = function(indices, packedJson) {
      var datas = packedJson.data.split("|");
      datas.length !== indices.length && cc.errorID(4915);
      for (var i = 0; i < indices.length; i++) this.contents[indices[i]] = datas[i];
    };
    TextureUnpacker.prototype.retrieve = function(key) {
      var content = this.contents[key];
      return content ? {
        __type__: TextureUnpacker.ID,
        content: content
      } : null;
    };
    false;
    module.exports = {
      JsonUnpacker: JsonUnpacker,
      TextureUnpacker: TextureUnpacker
    };
  }), {
    "../assets/CCTexture2D": 27,
    "../platform/js": 124
  } ],
  99: [ (function(require, module, exports) {
    "use strict";
    var _noCacheRex = /\?/;
    module.exports = {
      urlAppendTimestamp: function urlAppendTimestamp(url) {
        cc.game.config["noCache"] && "string" === typeof url && (_noCacheRex.test(url) ? url += "&_t=" + (new Date() - 0) : url += "?_t=" + (new Date() - 0));
        return url;
      }
    };
  }), {} ],
  100: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    var debug = require("../CCDebug");
    require("../platform/deserialize");
    var LoadingItems = require("./loading-items");
    function isSceneObj(json) {
      var SCENE_ID = "cc.Scene";
      var PREFAB_ID = "cc.Prefab";
      return json && (json[0] && json[0].__type__ === SCENE_ID || json[1] && json[1].__type__ === SCENE_ID || json[0] && json[0].__type__ === PREFAB_ID);
    }
    function parseDepends(item, asset, tdInfo, deferredLoadRawAssetsInRuntime) {
      var uuidList = tdInfo.uuidList;
      var objList = tdInfo.uuidObjList;
      var propList = tdInfo.uuidPropList;
      var stillUseUrl = tdInfo._stillUseUrl;
      var depends;
      var i, dependUuid;
      var dependKeys = item.dependKeys = [];
      if (deferredLoadRawAssetsInRuntime) {
        depends = [];
        for (i = 0; i < uuidList.length; i++) {
          dependUuid = uuidList[i];
          var obj = objList[i];
          var prop = propList[i];
          var info = cc.AssetLibrary._getAssetInfoInRuntime(dependUuid);
          if (info.raw) {
            var url = info.url;
            obj[prop] = url;
            dependKeys.push(url);
          } else depends.push({
            type: "uuid",
            uuid: dependUuid,
            deferredLoadRaw: true,
            _owner: obj,
            _ownerProp: prop,
            _stillUseUrl: stillUseUrl[i]
          });
        }
      } else {
        depends = new Array(uuidList.length);
        for (i = 0; i < uuidList.length; i++) {
          dependUuid = uuidList[i];
          depends[i] = {
            type: "uuid",
            uuid: dependUuid,
            _owner: objList[i],
            _ownerProp: propList[i],
            _stillUseUrl: stillUseUrl[i]
          };
        }
        asset._native && !asset.constructor.preventPreloadNativeObject && depends.push({
          url: asset.nativeUrl,
          _owner: asset,
          _ownerProp: "_nativeAsset"
        });
      }
      return depends;
    }
    function loadDepends(pipeline, item, asset, depends, callback) {
      item.content = asset;
      var dependKeys = item.dependKeys;
      pipeline.flowInDeps(item, depends, (function(errors, items) {
        var item, missingAssetReporter;
        var itemsMap = items.map;
        for (var src in itemsMap) {
          item = itemsMap[src];
          item.uuid && item.content && (item.content._uuid = item.uuid);
        }
        for (var i = 0; i < depends.length; i++) {
          var loadCallback = function loadCallback(item) {
            var value = item.content;
            this._stillUseUrl && (value = value && cc.RawAsset.wasRawAssetType(value.constructor) ? value.nativeUrl : item.rawUrl);
            "_nativeAsset" === this._ownerProp && (this._owner.url = item.url);
            this._owner[this._ownerProp] = value;
            item.uuid !== asset._uuid && dependKeys.indexOf(item.id) < 0 && dependKeys.push(item.id);
          };
          var dep = depends[i];
          var dependSrc = dep.uuid;
          var dependUrl = dep.url;
          var dependObj = dep._owner;
          var dependProp = dep._ownerProp;
          item = itemsMap[dependUrl];
          if (!item) continue;
          var loadCallbackCtx = dep;
          if (item.complete || item.content) if (item.error) {
            var MissingObjectReporter;
            false;
            cc._throw(item.error.message || item.error.errorMessage || item.error);
          } else loadCallback.call(loadCallbackCtx, item); else {
            var queue = LoadingItems.getQueue(item);
            var list = queue._callbackTable[dependSrc];
            list ? list.unshift(loadCallback, loadCallbackCtx) : queue.addListener(dependSrc, loadCallback, loadCallbackCtx);
          }
        }
        false;
        !errors && asset.onLoad && asset.onLoad();
        callback(errors, asset);
      }));
    }
    function canDeferredLoad(asset, item, isScene) {
      false;
      var res = item.deferredLoadRaw;
      res ? asset instanceof cc.Asset && asset.constructor.preventDeferredLoadDependents && (res = false) : isScene && (asset instanceof cc.SceneAsset || asset instanceof cc.Prefab) && (res = asset.asyncLoadAssets);
      return res;
    }
    var MissingClass;
    function loadUuid(item, callback) {
      false;
      var json;
      if ("string" === typeof item.content) try {
        json = JSON.parse(item.content);
      } catch (e) {
        return new Error(debug.getError(4923, item.id, e.stack));
      } else {
        if ("object" !== typeof item.content) return new Error(debug.getError(4924));
        json = item.content;
      }
      var classFinder;
      var isScene = isSceneObj(json);
      if (isScene) {
        false;
        classFinder = cc._MissingScript.safeFindClass;
      } else classFinder = function classFinder(id) {
        var cls = js._getClassById(id);
        if (cls) return cls;
        cc.warnID(4903, id);
        return Object;
      };
      var tdInfo = cc.deserialize.Details.pool.get();
      var asset;
      try {
        asset = cc.deserialize(json, tdInfo, {
          classFinder: classFinder,
          target: item.existingAsset,
          customEnv: item
        });
      } catch (e) {
        cc.deserialize.Details.pool.put(tdInfo);
        var err = (false, e.stack);
        return new Error(debug.getError(4925, item.id, err));
      }
      asset._uuid = item.uuid;
      asset.url = asset.nativeUrl;
      false;
      var deferredLoad = canDeferredLoad(asset, item, isScene);
      var depends = parseDepends(item, asset, tdInfo, deferredLoad);
      cc.deserialize.Details.pool.put(tdInfo);
      if (0 === depends.length) {
        asset.onLoad && asset.onLoad();
        return callback(null, asset);
      }
      loadDepends(this.pipeline, item, asset, depends, callback);
    }
    module.exports = loadUuid;
    loadUuid.isSceneObj = isSceneObj;
  }), {
    "../CCDebug": 3,
    "../platform/deserialize": 119,
    "../platform/js": 124,
    "./loading-items": 91
  } ],
  101: [ (function(require, module, exports) {
    "use strict";
    var CompScheduler = require("./component-scheduler");
    var Flags = require("./platform/CCObject").Flags;
    var js = require("./platform/js");
    var callerFunctor = false;
    var MAX_POOL_SIZE = 4;
    var IsPreloadStarted = Flags.IsPreloadStarted;
    var IsOnLoadStarted = Flags.IsOnLoadStarted;
    var IsOnLoadCalled = Flags.IsOnLoadCalled;
    var Deactivating = Flags.Deactivating;
    var callPreloadInTryCatch = false;
    var callOnLoadInTryCatch = false;
    var callOnDestroyInTryCatch = false;
    var callResetInTryCatch = false;
    var callOnFocusInTryCatch = false;
    var callOnLostFocusInTryCatch = false;
    var callPreload = "c.__preload();";
    var callOnLoad = "c.onLoad();c._objFlags|=" + IsOnLoadCalled;
    var UnsortedInvoker = cc.Class({
      extends: CompScheduler.LifeCycleInvoker,
      add: function add(comp) {
        this._zero.array.push(comp);
      },
      remove: function remove(comp) {
        this._zero.fastRemove(comp);
      },
      cancelInactive: function cancelInactive(flagToClear) {
        CompScheduler.LifeCycleInvoker.stableRemoveInactive(this._zero, flagToClear);
      },
      invoke: function invoke() {
        this._invoke(this._zero);
        this._zero.array.length = 0;
      }
    });
    var invokePreload = CompScheduler.createInvokeImpl(callPreload);
    var invokeOnLoad = CompScheduler.createInvokeImpl(callOnLoad);
    var activateTasksPool = new js.Pool(MAX_POOL_SIZE);
    activateTasksPool.get = function getActivateTask() {
      var task = this._get() || {
        preload: new UnsortedInvoker(invokePreload),
        onLoad: new CompScheduler.OneOffInvoker(invokeOnLoad),
        onEnable: new CompScheduler.OneOffInvoker(CompScheduler.invokeOnEnable)
      };
      task.preload._zero.i = -1;
      var invoker = task.onLoad;
      invoker._zero.i = -1;
      invoker._neg.i = -1;
      invoker._pos.i = -1;
      invoker = task.onEnable;
      invoker._zero.i = -1;
      invoker._neg.i = -1;
      invoker._pos.i = -1;
      return task;
    };
    function _componentCorrupted(node, comp, index) {
      false;
      comp ? node._removeComponent(comp) : js.array.removeAt(node._components, index);
    }
    function _onLoadInEditor(comp) {
      if (comp.onLoad && !cc.engine._isPlaying) {
        var focused = Editor.Selection.curActivate("node") === comp.node.uuid;
        focused ? comp.onFocusInEditor && callOnFocusInTryCatch(comp) : comp.onLostFocusInEditor && callOnLostFocusInTryCatch(comp);
      }
      true;
      _Scene.AssetsWatcher.start(comp);
    }
    function ctor() {
      this._activatingStack = [];
    }
    var NodeActivator = cc.Class({
      ctor: ctor,
      reset: ctor,
      _activateNodeRecursively: function _activateNodeRecursively(node, preloadInvoker, onLoadInvoker, onEnableInvoker) {
        if (node._objFlags & Deactivating) {
          cc.errorID(3816, node.name);
          return;
        }
        node._activeInHierarchy = true;
        var originCount = node._components.length;
        for (var i = 0; i < originCount; ++i) {
          var component = node._components[i];
          if (component instanceof cc.Component) this.activateComp(component, preloadInvoker, onLoadInvoker, onEnableInvoker); else {
            _componentCorrupted(node, component, i);
            --i;
            --originCount;
          }
        }
        node._childArrivalOrder = node._children.length;
        for (var _i = 0, len = node._children.length; _i < len; ++_i) {
          var child = node._children[_i];
          child._localZOrder = 4294901760 & child._localZOrder | _i + 1;
          child._active && this._activateNodeRecursively(child, preloadInvoker, onLoadInvoker, onEnableInvoker);
        }
        node._onPostActivated(true);
      },
      _deactivateNodeRecursively: function _deactivateNodeRecursively(node) {
        false;
        node._objFlags |= Deactivating;
        node._activeInHierarchy = false;
        var originCount = node._components.length;
        for (var c = 0; c < originCount; ++c) {
          var component = node._components[c];
          if (component._enabled) {
            cc.director._compScheduler.disableComp(component);
            if (node._activeInHierarchy) {
              node._objFlags &= ~Deactivating;
              return;
            }
          }
        }
        for (var i = 0, len = node._children.length; i < len; ++i) {
          var child = node._children[i];
          if (child._activeInHierarchy) {
            this._deactivateNodeRecursively(child);
            if (node._activeInHierarchy) {
              node._objFlags &= ~Deactivating;
              return;
            }
          }
        }
        node._onPostActivated(false);
        node._objFlags &= ~Deactivating;
      },
      activateNode: function activateNode(node, active) {
        if (active) {
          var task = activateTasksPool.get();
          this._activatingStack.push(task);
          this._activateNodeRecursively(node, task.preload, task.onLoad, task.onEnable);
          task.preload.invoke();
          task.onLoad.invoke();
          task.onEnable.invoke();
          this._activatingStack.pop();
          activateTasksPool.put(task);
        } else {
          this._deactivateNodeRecursively(node);
          var stack = this._activatingStack;
          for (var i = 0; i < stack.length; i++) {
            var lastTask = stack[i];
            lastTask.preload.cancelInactive(IsPreloadStarted);
            lastTask.onLoad.cancelInactive(IsOnLoadStarted);
            lastTask.onEnable.cancelInactive();
          }
        }
        node.emit("active-in-hierarchy-changed", node);
      },
      activateComp: function(comp, preloadInvoker, onLoadInvoker, onEnableInvoker) {
        if (!cc.isValid(comp, true)) return;
        if (!(comp._objFlags & IsPreloadStarted)) {
          comp._objFlags |= IsPreloadStarted;
          comp.__preload && (preloadInvoker ? preloadInvoker.add(comp) : comp.__preload());
        }
        if (!(comp._objFlags & IsOnLoadStarted)) {
          comp._objFlags |= IsOnLoadStarted;
          if (comp.onLoad) if (onLoadInvoker) onLoadInvoker.add(comp); else {
            comp.onLoad();
            comp._objFlags |= IsOnLoadCalled;
          } else comp._objFlags |= IsOnLoadCalled;
        }
        if (comp._enabled) {
          var deactivatedOnLoading = !comp.node._activeInHierarchy;
          if (deactivatedOnLoading) return;
          cc.director._compScheduler.enableComp(comp, onEnableInvoker);
        }
      },
      destroyComp: function(comp) {
        cc.director._compScheduler.disableComp(comp);
        comp.onDestroy && comp._objFlags & IsOnLoadCalled && comp.onDestroy();
      },
      resetComp: false
    });
    module.exports = NodeActivator;
  }), {
    "./component-scheduler": 35,
    "./platform/CCObject": 110,
    "./platform/js": 124,
    "./utils/misc": 187
  } ],
  102: [ (function(require, module, exports) {
    "use strict";
    var js;
    var macro;
    var sys;
    var eventManager;
    var TOUCH_TIMEOUT;
    var bkInputManager;
    false;
  }), {
    "../event-manager": 70,
    "../platform/js": 124,
    "./CCMacro": 109,
    "./CCSys": 113
  } ],
  103: [ (function(require, module, exports) {
    "use strict";
    var Asset = require("../assets/CCAsset");
    var callInNextTick = require("./utils").callInNextTick;
    var Loader = require("../load-pipeline/CCLoader");
    var AssetTable = require("../load-pipeline/asset-table");
    var PackDownloader = require("../load-pipeline/pack-downloader");
    var AutoReleaseUtils = require("../load-pipeline/auto-release-utils");
    var decodeUuid = require("../utils/decode-uuid");
    var MD5Pipe = require("../load-pipeline/md5-pipe");
    var SubPackPipe = require("../load-pipeline/subpackage-pipe");
    var js = require("./js");
    var _libraryBase = "";
    var _rawAssetsBase = "";
    var _uuidToRawAsset = js.createMap(true);
    function isScene(asset) {
      return asset && (asset.constructor === cc.SceneAsset || asset instanceof cc.Scene);
    }
    function RawAssetEntry(url, type) {
      this.url = url;
      this.type = type;
    }
    var AssetLibrary = {
      loadAsset: function loadAsset(uuid, callback, options) {
        if ("string" !== typeof uuid) return callInNextTick(callback, new Error("[AssetLibrary] uuid must be string"), null);
        var item = {
          uuid: uuid,
          type: "uuid"
        };
        options && options.existingAsset && (item.existingAsset = options.existingAsset);
        Loader.load(item, (function(error, asset) {
          if (error || !asset) error = new Error("[AssetLibrary] loading JSON or dependencies failed: " + (error ? error.message : "Unknown error")); else {
            if (asset.constructor === cc.SceneAsset) {
              false;
              var key = cc.loader._getReferenceKey(uuid);
              asset.scene.dependAssets = AutoReleaseUtils.getDependsRecursively(key);
            }
            if (false, isScene(asset)) {
              var id = cc.loader._getReferenceKey(uuid);
              Loader.removeItem(id);
            }
          }
          callback && callback(error, asset);
        }));
      },
      getLibUrlNoExt: function getLibUrlNoExt(uuid, inRawAssetsDir) {
        true;
        uuid = decodeUuid(uuid);
        var base = (true, inRawAssetsDir ? _rawAssetsBase + "assets/" : _libraryBase);
        return base + uuid.slice(0, 2) + "/" + uuid;
      },
      _queryAssetInfoInEditor: function _queryAssetInfoInEditor(uuid, callback) {
        false;
      },
      _getAssetInfoInRuntime: function _getAssetInfoInRuntime(uuid, result) {
        result = result || {
          url: null,
          raw: false
        };
        var info = _uuidToRawAsset[uuid];
        if (info && !js.isChildClassOf(info.type, cc.Asset)) {
          result.url = _rawAssetsBase + info.url;
          result.raw = true;
        } else {
          result.url = this.getLibUrlNoExt(uuid) + ".json";
          result.raw = false;
        }
        return result;
      },
      _uuidInSettings: function _uuidInSettings(uuid) {
        return uuid in _uuidToRawAsset;
      },
      queryAssetInfo: function queryAssetInfo(uuid, callback) {
        false;
        var info = this._getAssetInfoInRuntime(uuid);
        callback(null, info.url, info.raw);
      },
      parseUuidInEditor: function parseUuidInEditor(url) {
        var uuid;
        var isImported;
        var dir;
        var dirBasename;
        var isAssetUrl;
        var index;
        false;
      },
      loadJson: function loadJson(json, callback) {
        var randomUuid = "" + (new Date().getTime() + Math.random());
        var item = {
          uuid: randomUuid,
          type: "uuid",
          content: json,
          skips: [ Loader.assetLoader.id, Loader.downloader.id ]
        };
        Loader.load(item, (function(error, asset) {
          if (error) error = new Error("[AssetLibrary] loading JSON or dependencies failed: " + error.message); else {
            if (asset.constructor === cc.SceneAsset) {
              var key = cc.loader._getReferenceKey(randomUuid);
              asset.scene.dependAssets = AutoReleaseUtils.getDependsRecursively(key);
            }
            if (false, isScene(asset)) {
              var id = cc.loader._getReferenceKey(randomUuid);
              Loader.removeItem(id);
            }
          }
          asset._uuid = "";
          callback && callback(error, asset);
        }));
      },
      getAssetByUuid: function getAssetByUuid(uuid) {
        return AssetLibrary._uuidToAsset[uuid] || null;
      },
      init: function init(options) {
        false;
        var libraryPath = options.libraryPath;
        libraryPath = libraryPath.replace(/\\/g, "/");
        _libraryBase = cc.path.stripSep(libraryPath) + "/";
        _rawAssetsBase = options.rawAssetsBase;
        if (options.subpackages) {
          var subPackPipe = new SubPackPipe(options.subpackages);
          cc.loader.insertPipeAfter(cc.loader.assetLoader, subPackPipe);
          cc.loader.subPackPipe = subPackPipe;
        }
        var md5AssetsMap = options.md5AssetsMap;
        if (md5AssetsMap && md5AssetsMap.import) {
          var i = 0, uuid = 0;
          var md5ImportMap = js.createMap(true);
          var md5Entries = md5AssetsMap.import;
          for (i = 0; i < md5Entries.length; i += 2) {
            uuid = decodeUuid(md5Entries[i]);
            md5ImportMap[uuid] = md5Entries[i + 1];
          }
          var md5RawAssetsMap = js.createMap(true);
          md5Entries = md5AssetsMap["raw-assets"];
          for (i = 0; i < md5Entries.length; i += 2) {
            uuid = decodeUuid(md5Entries[i]);
            md5RawAssetsMap[uuid] = md5Entries[i + 1];
          }
          var md5Pipe = new MD5Pipe(md5ImportMap, md5RawAssetsMap, _libraryBase);
          cc.loader.insertPipeAfter(cc.loader.assetLoader, md5Pipe);
          cc.loader.md5Pipe = md5Pipe;
        }
        var assetTables = Loader._assetTables;
        for (var mount in assetTables) assetTables[mount].reset();
        var rawAssets = options.rawAssets;
        if (rawAssets) for (var mountPoint in rawAssets) {
          var assets = rawAssets[mountPoint];
          for (var uuid in assets) {
            var info = assets[uuid];
            var url = info[0];
            var typeId = info[1];
            var type = cc.js._getClassById(typeId);
            if (!type) {
              cc.error("Cannot get", typeId);
              continue;
            }
            _uuidToRawAsset[uuid] = new RawAssetEntry(mountPoint + "/" + url, type);
            var ext = cc.path.extname(url);
            ext && (url = url.slice(0, -ext.length));
            var isSubAsset = 1 === info[2];
            assetTables[mountPoint] || (assetTables[mountPoint] = new AssetTable());
            assetTables[mountPoint].add(url, uuid, type, !isSubAsset);
          }
        }
        options.packedAssets && PackDownloader.initPacks(options.packedAssets);
        cc.url._init(options.mountPaths && options.mountPaths.assets || _rawAssetsBase + "assets");
      }
    };
    AssetLibrary._uuidToAsset = {};
    var _builtins = {
      effect: {},
      material: {}
    };
    function loadBuiltins(name, type, cb) {
      var dirname = name + "s";
      var builtin = _builtins[name] = {};
      var internalMountPath = "internal";
      false;
      cc.loader.loadResDir(dirname, type, internalMountPath, (function() {}), (function(err, assets) {
        if (err) cc.error(err); else for (var i = 0; i < assets.length; i++) builtin["" + assets[i].name] = assets[i];
        cb();
      }));
    }
    AssetLibrary._loadBuiltins = function(cb) {
      if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) return cb && cb();
      loadBuiltins("effect", cc.EffectAsset, (function() {
        loadBuiltins("material", cc.Material, cb);
      }));
    };
    AssetLibrary.getBuiltin = function(type, name) {
      return _builtins[type][name];
    };
    AssetLibrary.getBuiltins = function(type) {
      if (!type) return _builtins;
      return _builtins[type];
    };
    AssetLibrary.resetBuiltins = function() {
      _builtins = {
        effect: {},
        material: {}
      };
    };
    module.exports = cc.AssetLibrary = AssetLibrary;
  }), {
    "../assets/CCAsset": 10,
    "../load-pipeline/CCLoader": 81,
    "../load-pipeline/asset-table": 83,
    "../load-pipeline/auto-release-utils": 85,
    "../load-pipeline/md5-pipe": 92,
    "../load-pipeline/pack-downloader": 93,
    "../load-pipeline/subpackage-pipe": 96,
    "../utils/decode-uuid": 182,
    "./js": 124,
    "./utils": 128
  } ],
  104: [ (function(require, module, exports) {
    "use strict";
    var js = require("./js");
    var Enum = require("./CCEnum");
    var utils = require("./utils");
    var _isPlainEmptyObj_DEV = utils.isPlainEmptyObj_DEV;
    var _cloneable_DEV = utils.cloneable_DEV;
    var Attr = require("./attribute");
    var DELIMETER = Attr.DELIMETER;
    var getTypeChecker = Attr.getTypeChecker;
    var preprocess = require("./preprocess-class");
    require("./requiring-frame");
    var BUILTIN_ENTRIES = [ "name", "extends", "mixins", "ctor", "__ctor__", "properties", "statics", "editor", "__ES6__" ];
    var INVALID_STATICS_DEV = false;
    function pushUnique(array, item) {
      array.indexOf(item) < 0 && array.push(item);
    }
    var deferredInitializer = {
      datas: null,
      push: function push(data) {
        if (this.datas) this.datas.push(data); else {
          this.datas = [ data ];
          var self = this;
          setTimeout((function() {
            self.init();
          }), 0);
        }
      },
      init: function init() {
        var datas = this.datas;
        if (datas) {
          for (var i = 0; i < datas.length; ++i) {
            var data = datas[i];
            var cls = data.cls;
            var properties = data.props;
            "function" === typeof properties && (properties = properties());
            var name = js.getClassName(cls);
            properties ? declareProperties(cls, name, properties, cls.$super, data.mixins) : cc.errorID(3633, name);
          }
          this.datas = null;
        }
      }
    };
    function appendProp(cls, name) {
      false;
      pushUnique(cls.__props__, name);
    }
    var tmpArray = [];
    function defineProp(cls, className, propName, val, es6) {
      var defaultValue = val.default;
      false;
      Attr.setClassAttr(cls, propName, "default", defaultValue);
      appendProp(cls, propName);
      var attrs = parseAttributes(cls, val, className, propName, false);
      if (attrs) {
        var onAfterProp = tmpArray;
        for (var i = 0; i < attrs.length; i++) {
          var attr = attrs[i];
          Attr.attr(cls, propName, attr);
          attr._onAfterProp && onAfterProp.push(attr._onAfterProp);
        }
        for (var c = 0; c < onAfterProp.length; c++) onAfterProp[c](cls, propName);
        tmpArray.length = 0;
        attrs.length = 0;
      }
    }
    function defineGetSet(cls, name, propName, val, es6) {
      var getter = val.get;
      var setter = val.set;
      var proto = cls.prototype;
      var d = Object.getOwnPropertyDescriptor(proto, propName);
      var setterUndefined = !d;
      if (getter) {
        false;
        var attrs = parseAttributes(cls, val, name, propName, true);
        for (var i = 0; i < attrs.length; i++) Attr.attr(cls, propName, attrs[i]);
        attrs.length = 0;
        Attr.setClassAttr(cls, propName, "serializable", false);
        false;
        es6 || js.get(proto, propName, getter, setterUndefined, setterUndefined);
        false, false;
      }
      if (setter) {
        if (!es6) {
          false;
          js.set(proto, propName, setter, setterUndefined, setterUndefined);
        }
        false, false;
      }
    }
    function getDefault(defaultVal) {
      if ("function" === typeof defaultVal) {
        false;
        return defaultVal();
      }
      return defaultVal;
    }
    function mixinWithInherited(dest, src, filter) {
      for (var prop in src) dest.hasOwnProperty(prop) || filter && !filter(prop) || Object.defineProperty(dest, prop, js.getPropertyDescriptor(src, prop));
    }
    function doDefine(className, baseClass, mixins, options) {
      var shouldAddProtoCtor;
      var __ctor__ = options.__ctor__;
      var ctor = options.ctor;
      var __es6__ = options.__ES6__;
      var ctorToUse;
      false;
      var ctors;
      var fireClass;
      if (__es6__) {
        ctors = [ ctor ];
        fireClass = ctor;
      } else {
        ctors = __ctor__ ? [ __ctor__ ] : _getAllCtors(baseClass, mixins, options);
        fireClass = _createCtor(ctors, baseClass, className, options);
        js.value(fireClass, "extend", (function(options) {
          options.extends = this;
          return CCClass(options);
        }), true);
      }
      js.value(fireClass, "__ctors__", ctors.length > 0 ? ctors : null, true);
      var prototype = fireClass.prototype;
      if (baseClass) {
        if (!__es6__) {
          js.extend(fireClass, baseClass);
          prototype = fireClass.prototype;
        }
        fireClass.$super = baseClass;
        false;
      }
      if (mixins) {
        for (var m = mixins.length - 1; m >= 0; m--) {
          var mixin = mixins[m];
          mixinWithInherited(prototype, mixin.prototype);
          mixinWithInherited(fireClass, mixin, (function(prop) {
            return mixin.hasOwnProperty(prop) && true;
          }));
          CCClass._isCCClass(mixin) && mixinWithInherited(Attr.getClassAttrs(fireClass).constructor.prototype, Attr.getClassAttrs(mixin).constructor.prototype);
        }
        prototype.constructor = fireClass;
      }
      __es6__ || (prototype.__initProps__ = compileProps);
      js.setClassName(className, fireClass);
      return fireClass;
    }
    function define(className, baseClass, mixins, options) {
      var Component = cc.Component;
      var frame = cc._RF.peek();
      if (frame && js.isChildClassOf(baseClass, Component)) {
        if (js.isChildClassOf(frame.cls, Component)) {
          cc.errorID(3615);
          return null;
        }
        false;
        className = className || frame.script;
      }
      var cls = doDefine(className, baseClass, mixins, options);
      if (frame) if (js.isChildClassOf(baseClass, Component)) {
        var uuid = frame.uuid;
        if (uuid) {
          js._setClassId(uuid, cls);
          false;
        }
        frame.cls = cls;
      } else js.isChildClassOf(frame.cls, Component) || (frame.cls = cls);
      return cls;
    }
    function normalizeClassName_DEV(className) {
      var DefaultName = "CCClass";
      if (className) {
        className = className.replace(/^[^$A-Za-z_]/, "_").replace(/[^0-9A-Za-z_$]/g, "_");
        try {
          Function("function " + className + "(){}")();
          return className;
        } catch (e) {}
      }
      return DefaultName;
    }
    function getNewValueTypeCodeJit(value) {
      var clsName = js.getClassName(value);
      var type = value.constructor;
      var res = "new " + clsName + "(";
      for (var i = 0; i < type.__props__.length; i++) {
        var prop = type.__props__[i];
        var propVal = value[prop];
        false;
        res += propVal;
        i < type.__props__.length - 1 && (res += ",");
      }
      return res + ")";
    }
    function escapeForJS(s) {
      return JSON.stringify(s).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    function getInitPropsJit(attrs, propList) {
      var F = [];
      var func = "";
      for (var i = 0; i < propList.length; i++) {
        var prop = propList[i];
        var attrKey = prop + DELIMETER + "default";
        if (attrKey in attrs) {
          var statement;
          statement = IDENTIFIER_RE.test(prop) ? "this." + prop + "=" : "this[" + escapeForJS(prop) + "]=";
          var expression;
          var def = attrs[attrKey];
          if ("object" === typeof def && def) expression = def instanceof cc.ValueType ? getNewValueTypeCodeJit(def) : Array.isArray(def) ? "[]" : "{}"; else if ("function" === typeof def) {
            var index = F.length;
            F.push(def);
            expression = "F[" + index + "]()";
            false;
          } else expression = "string" === typeof def ? escapeForJS(def) : def;
          statement = statement + expression + ";\n";
          func += statement;
        }
      }
      var initProps;
      initProps = 0 === F.length ? Function(func) : Function("F", "return (function(){\n" + func + "})")(F);
      return initProps;
    }
    function getInitProps(attrs, propList) {
      var advancedProps = [];
      var advancedValues = [];
      var simpleProps = [];
      var simpleValues = [];
      for (var i = 0; i < propList.length; ++i) {
        var prop = propList[i];
        var attrKey = prop + DELIMETER + "default";
        if (attrKey in attrs) {
          var def = attrs[attrKey];
          if ("object" === typeof def && def || "function" === typeof def) {
            advancedProps.push(prop);
            advancedValues.push(def);
          } else {
            simpleProps.push(prop);
            simpleValues.push(def);
          }
        }
      }
      return function() {
        for (var _i = 0; _i < simpleProps.length; ++_i) this[simpleProps[_i]] = simpleValues[_i];
        for (var _i2 = 0; _i2 < advancedProps.length; _i2++) {
          var _prop = advancedProps[_i2];
          var expression;
          var def = advancedValues[_i2];
          if ("object" === typeof def) expression = def instanceof cc.ValueType ? def.clone() : Array.isArray(def) ? [] : {}; else {
            false;
            expression = def();
          }
          this[_prop] = expression;
        }
      };
    }
    var IDENTIFIER_RE = /^[A-Za-z_$][0-9A-Za-z_$]*$/;
    function compileProps(actualClass) {
      var attrs = Attr.getClassAttrs(actualClass);
      var propList = actualClass.__props__;
      if (null === propList) {
        deferredInitializer.init();
        propList = actualClass.__props__;
      }
      var initProps = getInitPropsJit(attrs, propList);
      actualClass.prototype.__initProps__ = initProps;
      initProps.call(this);
    }
    var _createCtor = function(ctors, baseClass, className, options) {
      var superCallBounded = baseClass && boundSuperCalls(baseClass, options, className);
      var ctorName = "CCClass";
      var body = "return function " + ctorName + "(){\n";
      superCallBounded && (body += "this._super=null;\n");
      body += "this.__initProps__(" + ctorName + ");\n";
      var ctorLen = ctors.length;
      if (ctorLen > 0) {
        var useTryCatch = false;
        useTryCatch && (body += "try{\n");
        var SNIPPET = "].apply(this,arguments);\n";
        if (1 === ctorLen) body += ctorName + ".__ctors__[0" + SNIPPET; else {
          body += "var cs=" + ctorName + ".__ctors__;\n";
          for (var i = 0; i < ctorLen; i++) body += "cs[" + i + SNIPPET;
        }
        useTryCatch && (body += "}catch(e){\ncc._throw(e);\n}\n");
      }
      body += "}";
      return Function(body)();
    };
    function _validateCtor_DEV(ctor, baseClass, className, options) {
      var originCtor;
      false;
      !(ctor.length > 0) || className && className.startsWith("cc.") || cc.warnID(3617, className);
      return ctor;
    }
    function _getAllCtors(baseClass, mixins, options) {
      function getCtors(cls) {
        return CCClass._isCCClass(cls) ? cls.__ctors__ || [] : [ cls ];
      }
      var ctors = [];
      var baseOrMixins = [ baseClass ].concat(mixins);
      for (var b = 0; b < baseOrMixins.length; b++) {
        var baseOrMixin = baseOrMixins[b];
        if (baseOrMixin) {
          var baseCtors = getCtors(baseOrMixin);
          for (var c = 0; c < baseCtors.length; c++) pushUnique(ctors, baseCtors[c]);
        }
      }
      var ctor = options.ctor;
      ctor && ctors.push(ctor);
      return ctors;
    }
    var SuperCallReg = /xyz/.test((function() {
      xyz;
    })) ? /\b\._super\b/ : /.*/;
    var SuperCallRegStrict = /xyz/.test((function() {
      xyz;
    })) ? /this\._super\s*\(/ : /(NONE){99}/;
    function boundSuperCalls(baseClass, options, className) {
      var hasSuperCall = false;
      for (var funcName in options) {
        if (BUILTIN_ENTRIES.indexOf(funcName) >= 0) continue;
        var func = options[funcName];
        if ("function" !== typeof func) continue;
        var pd = js.getPropertyDescriptor(baseClass.prototype, funcName);
        if (pd) {
          var superFunc = pd.value;
          if ("function" === typeof superFunc) {
            if (SuperCallReg.test(func)) {
              hasSuperCall = true;
              options[funcName] = (function(superFunc, func) {
                return function() {
                  var tmp = this._super;
                  this._super = superFunc;
                  var ret = func.apply(this, arguments);
                  this._super = tmp;
                  return ret;
                };
              })(superFunc, func);
            }
            continue;
          }
        }
        false;
      }
      return hasSuperCall;
    }
    function declareProperties(cls, className, properties, baseClass, mixins, es6) {
      cls.__props__ = [];
      baseClass && baseClass.__props__ && (cls.__props__ = baseClass.__props__.slice());
      if (mixins) for (var m = 0; m < mixins.length; ++m) {
        var mixin = mixins[m];
        mixin.__props__ && (cls.__props__ = cls.__props__.concat(mixin.__props__.filter((function(x) {
          return cls.__props__.indexOf(x) < 0;
        }))));
      }
      if (properties) {
        preprocess.preprocessAttrs(properties, className, cls, es6);
        for (var propName in properties) {
          var val = properties[propName];
          "default" in val ? defineProp(cls, className, propName, val, es6) : defineGetSet(cls, className, propName, val, es6);
        }
      }
      var attrs = Attr.getClassAttrs(cls);
      cls.__values__ = cls.__props__.filter((function(prop) {
        return false !== attrs[prop + DELIMETER + "serializable"];
      }));
    }
    function CCClass(options) {
      options = options || {};
      var name = options.name;
      var base = options.extends;
      var mixins = options.mixins;
      var cls = define(name, base, mixins, options);
      name || (name = cc.js.getClassName(cls));
      cls._sealed = true;
      base && (base._sealed = false);
      var properties = options.properties;
      if ("function" === typeof properties || base && null === base.__props__ || mixins && mixins.some((function(x) {
        return null === x.__props__;
      }))) {
        false;
        deferredInitializer.push({
          cls: cls,
          props: properties,
          mixins: mixins
        });
        cls.__props__ = cls.__values__ = null;
      } else declareProperties(cls, name, properties, base, options.mixins, options.__ES6__);
      var statics = options.statics;
      if (statics) {
        var staticPropName;
        false;
        for (staticPropName in statics) cls[staticPropName] = statics[staticPropName];
      }
      for (var funcName in options) {
        if (BUILTIN_ENTRIES.indexOf(funcName) >= 0) continue;
        var func = options[funcName];
        if (!preprocess.validateMethodWithProps(func, funcName, name, cls, base)) continue;
        js.value(cls.prototype, funcName, func, true, true);
      }
      var editor = options.editor;
      editor && !!js.isChildClassOf(base, cc.Component) && cc.Component._registerEditorProps(cls, editor);
      return cls;
    }
    CCClass._isCCClass = function(constructor) {
      return constructor && constructor.hasOwnProperty("__ctors__");
    };
    CCClass._fastDefine = function(className, constructor, serializableFields) {
      js.setClassName(className, constructor);
      var props = constructor.__props__ = constructor.__values__ = Object.keys(serializableFields);
      var attrProtos = Attr.getClassAttrsProto(constructor);
      for (var i = 0; i < props.length; i++) {
        var key = props[i];
        attrProtos[key + DELIMETER + "visible"] = false;
        attrProtos[key + DELIMETER + "default"] = serializableFields[key];
      }
    };
    CCClass.Attr = Attr;
    CCClass.attr = Attr.attr;
    CCClass.getInheritanceChain = function(klass) {
      var chain = [];
      for (;;) {
        klass = js.getSuper(klass);
        if (!klass) break;
        klass !== Object && chain.push(klass);
      }
      return chain;
    };
    var PrimitiveTypes = {
      Integer: "Number",
      Float: "Number",
      Boolean: "Boolean",
      String: "String"
    };
    var tmpAttrs = [];
    function parseAttributes(cls, attrs, className, propName, usedInGetter) {
      var ERR_Type = "";
      var attrsProto = null;
      var attrsProtoKey = "";
      function getAttrsProto() {
        attrsProtoKey = propName + DELIMETER;
        return attrsProto = Attr.getClassAttrsProto(cls);
      }
      tmpAttrs.length = 0;
      var result = tmpAttrs;
      var type = attrs.type;
      if (type) {
        var primitiveType = PrimitiveTypes[type];
        if (primitiveType) result.push({
          type: type,
          _onAfterProp: getTypeChecker(primitiveType, "cc." + type)
        }); else if ("Object" === type) false; else if (type === Attr.ScriptUuid) {
          var attr = Attr.ObjectType(cc.ScriptAsset);
          attr.type = "Script";
          result.push(attr);
        } else "object" === typeof type ? !!Enum.isEnum(type) && result.push({
          type: "Enum",
          enumList: Enum.getList(type)
        }) : "function" === typeof type && (attrs.url ? result.push({
          type: "Object",
          ctor: type,
          _onAfterProp: getTypeChecker("String", "cc.String")
        }) : result.push(attrs._short ? {
          type: "Object",
          ctor: type
        } : Attr.ObjectType(type)));
      }
      function parseSimpleAttr(attrName, expectType) {
        if (attrName in attrs) {
          var val = attrs[attrName];
          typeof val === expectType && ((attrsProto || getAttrsProto())[attrsProtoKey + attrName] = val);
        }
      }
      if (attrs.editorOnly) {
        false;
        (attrsProto || getAttrsProto())[attrsProtoKey + "editorOnly"] = true;
      }
      false;
      attrs.url && ((attrsProto || getAttrsProto())[attrsProtoKey + "saveUrlAsAsset"] = true);
      if (false === attrs.serializable) {
        false;
        (attrsProto || getAttrsProto())[attrsProtoKey + "serializable"] = false;
      }
      parseSimpleAttr("formerlySerializedAs", "string");
      false;
      var visible;
      var startsWithUS;
      false;
      var range = attrs.range;
      if (range) if (Array.isArray(range)) if (range.length >= 2) {
        (attrsProto || getAttrsProto())[attrsProtoKey + "min"] = range[0];
        attrsProto[attrsProtoKey + "max"] = range[1];
        range.length > 2 && (attrsProto[attrsProtoKey + "step"] = range[2]);
      } else false; else false;
      parseSimpleAttr("min", "number");
      parseSimpleAttr("max", "number");
      parseSimpleAttr("step", "number");
      return result;
    }
    cc.Class = CCClass;
    module.exports = {
      isArray: function isArray(defaultVal) {
        defaultVal = getDefault(defaultVal);
        return Array.isArray(defaultVal);
      },
      fastDefine: CCClass._fastDefine,
      getNewValueTypeCode: (true, getNewValueTypeCodeJit),
      IDENTIFIER_RE: IDENTIFIER_RE,
      escapeForJS: escapeForJS,
      getDefault: getDefault
    };
    false;
  }), {
    "./CCEnum": 106,
    "./attribute": 116,
    "./js": 124,
    "./preprocess-class": 125,
    "./requiring-frame": 126,
    "./utils": 128
  } ],
  105: [ (function(require, module, exports) {
    "use strict";
    require("./CCClass");
    var Preprocess = require("./preprocess-class");
    var js = require("./js");
    var isPlainEmptyObj_DEV = false;
    var CACHE_KEY = "__ccclassCache__";
    function fNOP(ctor) {
      return ctor;
    }
    function getSubDict(obj, key) {
      return obj[key] || (obj[key] = {});
    }
    function checkCtorArgument(decorate) {
      return function(target) {
        if ("function" === typeof target) return decorate(target);
        return function(ctor) {
          return decorate(ctor, target);
        };
      };
    }
    function _checkNormalArgument(validator_DEV, decorate, decoratorName) {
      return function(target) {
        false;
        return function(ctor) {
          return decorate(ctor, target);
        };
      };
    }
    var checkCompArgument = _checkNormalArgument.bind(null, false);
    function _argumentChecker(type) {
      return _checkNormalArgument.bind(null, false);
    }
    var checkStringArgument = _argumentChecker("string");
    var checkNumberArgument = _argumentChecker("number");
    function getClassCache(ctor, decoratorName) {
      false;
      return getSubDict(ctor, CACHE_KEY);
    }
    function getDefaultFromInitializer(initializer) {
      var value;
      try {
        value = initializer();
      } catch (e) {
        return initializer;
      }
      return "object" !== typeof value || null === value ? value : initializer;
    }
    function extractActualDefaultValues(ctor) {
      var dummyObj;
      try {
        dummyObj = new ctor();
      } catch (e) {
        false;
        return {};
      }
      return dummyObj;
    }
    function genProperty(ctor, properties, propName, options, desc, cache) {
      var fullOptions;
      if (options) {
        fullOptions = Preprocess.getFullFormOfProperty(options);
        fullOptions = fullOptions || options;
      }
      var existsProperty = properties[propName];
      var prop = js.mixin(existsProperty || {}, fullOptions || {});
      var isGetset = desc && (desc.get || desc.set);
      if (isGetset) {
        var errorProps;
        false;
        desc.get && (prop.get = desc.get);
        desc.set && (prop.set = desc.set);
      } else {
        false;
        var defaultValue = void 0;
        var isDefaultValueSpecified = false;
        if (desc) {
          if (desc.initializer) {
            defaultValue = getDefaultFromInitializer(desc.initializer);
            isDefaultValueSpecified = true;
          }
        } else {
          var actualDefaultValues = cache.default || (cache.default = extractActualDefaultValues(ctor));
          if (actualDefaultValues.hasOwnProperty(propName)) {
            defaultValue = actualDefaultValues[propName];
            isDefaultValueSpecified = true;
          }
        }
        false;
        prop.default = defaultValue;
      }
      properties[propName] = prop;
    }
    var ccclass = checkCtorArgument((function(ctor, name) {
      var base = js.getSuper(ctor);
      base === Object && (base = null);
      var proto = {
        name: name,
        extends: base,
        ctor: ctor,
        __ES6__: true
      };
      var cache = ctor[CACHE_KEY];
      if (cache) {
        var decoratedProto = cache.proto;
        decoratedProto && js.mixin(proto, decoratedProto);
        ctor[CACHE_KEY] = void 0;
      }
      var res = cc.Class(proto);
      var propNames;
      var i;
      var prop;
      var desc;
      var func;
      false;
      return res;
    }));
    function property(ctorProtoOrOptions, propName, desc) {
      var options = null;
      function normalized(ctorProto, propName, desc) {
        var cache = getClassCache(ctorProto.constructor);
        if (cache) {
          var ccclassProto = getSubDict(cache, "proto");
          var properties = getSubDict(ccclassProto, "properties");
          genProperty(ctorProto.constructor, properties, propName, options, desc, cache);
        }
      }
      if ("undefined" === typeof propName) {
        options = ctorProtoOrOptions;
        return normalized;
      }
      normalized(ctorProtoOrOptions, propName, desc);
    }
    function createEditorDecorator(argCheckFunc, editorPropName, staticValue) {
      return argCheckFunc((function(ctor, decoratedValue) {
        var cache = getClassCache(ctor, editorPropName);
        if (cache) {
          var value = void 0 !== staticValue ? staticValue : decoratedValue;
          var proto = getSubDict(cache, "proto");
          getSubDict(proto, "editor")[editorPropName] = value;
        }
      }), editorPropName);
    }
    function createDummyDecorator(argCheckFunc) {
      return argCheckFunc(fNOP);
    }
    var executeInEditMode = createDummyDecorator(checkCtorArgument, "executeInEditMode", true);
    var requireComponent = createEditorDecorator(checkCompArgument, "requireComponent");
    var menu = createDummyDecorator(checkStringArgument, "menu");
    var executionOrder = createEditorDecorator(checkNumberArgument, "executionOrder");
    var disallowMultiple = createDummyDecorator(checkCtorArgument, "disallowMultiple");
    var playOnFocus = createDummyDecorator(checkCtorArgument, "playOnFocus", true);
    var inspector = createDummyDecorator(checkStringArgument, "inspector");
    var icon = createDummyDecorator(checkStringArgument, "icon");
    var help = createDummyDecorator(checkStringArgument, "help");
    function mixins() {
      var mixins = [];
      for (var i = 0; i < arguments.length; i++) mixins[i] = arguments[i];
      return function(ctor) {
        var cache = getClassCache(ctor, "mixins");
        cache && (getSubDict(cache, "proto").mixins = mixins);
      };
    }
    cc._decorator = module.exports = {
      ccclass: ccclass,
      property: property,
      executeInEditMode: executeInEditMode,
      requireComponent: requireComponent,
      menu: menu,
      executionOrder: executionOrder,
      disallowMultiple: disallowMultiple,
      playOnFocus: playOnFocus,
      inspector: inspector,
      icon: icon,
      help: help,
      mixins: mixins
    };
  }), {
    "./CCClass": 104,
    "./js": 124,
    "./preprocess-class": 125,
    "./utils": 128
  } ],
  106: [ (function(require, module, exports) {
    "use strict";
    var js = require("./js");
    function Enum(obj) {
      if ("__enums__" in obj) return obj;
      js.value(obj, "__enums__", null, true);
      var lastIndex = -1;
      var keys = Object.keys(obj);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var val = obj[key];
        if (-1 === val) {
          val = ++lastIndex;
          obj[key] = val;
        } else if ("number" === typeof val) lastIndex = val; else if ("string" === typeof val && Number.isInteger(parseFloat(key))) continue;
        var reverseKey = "" + val;
        if (key !== reverseKey) {
          if ((false, false) && reverseKey in obj && obj[reverseKey] !== key) {
            cc.errorID(7100, reverseKey);
            continue;
          }
          js.value(obj, reverseKey, key);
        }
      }
      return obj;
    }
    Enum.isEnum = function(enumType) {
      return enumType && enumType.hasOwnProperty("__enums__");
    };
    Enum.getList = function(enumDef) {
      if (enumDef.__enums__) return enumDef.__enums__;
      var enums = enumDef.__enums__ = [];
      for (var name in enumDef) {
        var value = enumDef[name];
        Number.isInteger(value) && enums.push({
          name: name,
          value: value
        });
      }
      enums.sort((function(a, b) {
        return a.value - b.value;
      }));
      return enums;
    };
    var _TestEnum;
    false;
    module.exports = cc.Enum = Enum;
  }), {
    "./js": 124
  } ],
  107: [ (function(require, module, exports) {
    "use strict";
    var eventManager = require("../event-manager");
    var inputManager = require("./CCInputManager");
    var PORTRAIT = 0;
    var LANDSCAPE_LEFT = -90;
    var PORTRAIT_UPSIDE_DOWN = 180;
    var LANDSCAPE_RIGHT = 90;
    var _didAccelerateFun = void 0;
    cc.Acceleration = function(x, y, z, timestamp) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
      this.timestamp = timestamp || 0;
    };
    inputManager.setAccelerometerEnabled = function(isEnable) {
      var _t = this;
      if (_t._accelEnabled === isEnable) return;
      _t._accelEnabled = isEnable;
      var scheduler = cc.director.getScheduler();
      scheduler.enableForTarget(_t);
      if (_t._accelEnabled) {
        _t._registerAccelerometerEvent();
        _t._accelCurTime = 0;
        scheduler.scheduleUpdate(_t);
      } else {
        _t._unregisterAccelerometerEvent();
        _t._accelCurTime = 0;
        scheduler.unscheduleUpdate(_t);
      }
      false, false;
    };
    inputManager.setAccelerometerInterval = function(interval) {
      if (this._accelInterval !== interval) {
        this._accelInterval = interval;
        false, false;
      }
    };
    inputManager._registerKeyboardEvent = function() {
      cc.game.canvas.addEventListener("keydown", (function(e) {
        eventManager.dispatchEvent(new cc.Event.EventKeyboard(e.keyCode, true));
        e.stopPropagation();
        e.preventDefault();
      }), false);
      cc.game.canvas.addEventListener("keyup", (function(e) {
        eventManager.dispatchEvent(new cc.Event.EventKeyboard(e.keyCode, false));
        e.stopPropagation();
        e.preventDefault();
      }), false);
    };
    inputManager._registerAccelerometerEvent = function() {
      var w = window, _t = this;
      _t._acceleration = new cc.Acceleration();
      _t._accelDeviceEvent = w.DeviceMotionEvent || w.DeviceOrientationEvent;
      cc.sys.browserType === cc.sys.BROWSER_TYPE_MOBILE_QQ && (_t._accelDeviceEvent = window.DeviceOrientationEvent);
      var _deviceEventType = _t._accelDeviceEvent === w.DeviceMotionEvent ? "devicemotion" : "deviceorientation";
      var ua = navigator.userAgent;
      (/Android/.test(ua) || /Adr/.test(ua) && cc.sys.browserType === cc.BROWSER_TYPE_UC) && (_t._minus = -1);
      _didAccelerateFun = _t.didAccelerate.bind(_t);
      w.addEventListener(_deviceEventType, _didAccelerateFun, false);
    };
    inputManager._unregisterAccelerometerEvent = function() {
      var w = window, _t = this;
      var _deviceEventType = _t._accelDeviceEvent === w.DeviceMotionEvent ? "devicemotion" : "deviceorientation";
      _didAccelerateFun && w.removeEventListener(_deviceEventType, _didAccelerateFun, false);
    };
    inputManager.didAccelerate = function(eventData) {
      var _t = this, w = window;
      if (!_t._accelEnabled) return;
      var mAcceleration = _t._acceleration;
      var x = void 0, y = void 0, z = void 0;
      if (_t._accelDeviceEvent === window.DeviceMotionEvent) {
        var eventAcceleration = eventData["accelerationIncludingGravity"];
        x = _t._accelMinus * eventAcceleration.x * .1;
        y = _t._accelMinus * eventAcceleration.y * .1;
        z = .1 * eventAcceleration.z;
      } else {
        x = eventData["gamma"] / 90 * .981;
        y = -eventData["beta"] / 90 * .981;
        z = eventData["alpha"] / 90 * .981;
      }
      if (cc.view._isRotated) {
        var tmp = x;
        x = -y;
        y = tmp;
      }
      mAcceleration.x = x;
      mAcceleration.y = y;
      mAcceleration.z = z;
      mAcceleration.timestamp = eventData.timeStamp || Date.now();
      var tmpX = mAcceleration.x;
      if (w.orientation === LANDSCAPE_RIGHT) {
        mAcceleration.x = -mAcceleration.y;
        mAcceleration.y = tmpX;
      } else if (w.orientation === LANDSCAPE_LEFT) {
        mAcceleration.x = mAcceleration.y;
        mAcceleration.y = -tmpX;
      } else if (w.orientation === PORTRAIT_UPSIDE_DOWN) {
        mAcceleration.x = -mAcceleration.x;
        mAcceleration.y = -mAcceleration.y;
      }
      if (cc.sys.os === cc.sys.OS_ANDROID && cc.sys.browserType !== cc.sys.BROWSER_TYPE_MOBILE_QQ) {
        mAcceleration.x = -mAcceleration.x;
        mAcceleration.y = -mAcceleration.y;
      }
    };
  }), {
    "../event-manager": 70,
    "./CCInputManager": 108
  } ],
  108: [ (function(require, module, exports) {
    "use strict";
    var macro = require("./CCMacro");
    var sys = require("./CCSys");
    var eventManager = require("../event-manager");
    var TOUCH_TIMEOUT = macro.TOUCH_TIMEOUT;
    var _vec2 = cc.v2();
    var inputManager = {
      _mousePressed: false,
      _isRegisterEvent: false,
      _preTouchPoint: cc.v2(0, 0),
      _prevMousePoint: cc.v2(0, 0),
      _preTouchPool: [],
      _preTouchPoolPointer: 0,
      _touches: [],
      _touchesIntegerDict: {},
      _indexBitsUsed: 0,
      _maxTouches: 8,
      _accelEnabled: false,
      _accelInterval: .2,
      _accelMinus: 1,
      _accelCurTime: 0,
      _acceleration: null,
      _accelDeviceEvent: null,
      _getUnUsedIndex: function _getUnUsedIndex() {
        var temp = this._indexBitsUsed;
        var now = cc.sys.now();
        for (var i = 0; i < this._maxTouches; i++) {
          if (!(1 & temp)) {
            this._indexBitsUsed |= 1 << i;
            return i;
          }
          var touch = this._touches[i];
          if (now - touch._lastModified > TOUCH_TIMEOUT) {
            this._removeUsedIndexBit(i);
            delete this._touchesIntegerDict[touch.getID()];
            return i;
          }
          temp >>= 1;
        }
        return -1;
      },
      _removeUsedIndexBit: function _removeUsedIndexBit(index) {
        if (index < 0 || index >= this._maxTouches) return;
        var temp = 1 << index;
        temp = ~temp;
        this._indexBitsUsed &= temp;
      },
      _glView: null,
      handleTouchesBegin: function handleTouchesBegin(touches) {
        var selTouch = void 0, index = void 0, curTouch = void 0, touchID = void 0, handleTouches = [], locTouchIntDict = this._touchesIntegerDict, now = sys.now();
        for (var i = 0, len = touches.length; i < len; i++) {
          selTouch = touches[i];
          touchID = selTouch.getID();
          index = locTouchIntDict[touchID];
          if (null == index) {
            var unusedIndex = this._getUnUsedIndex();
            if (-1 === unusedIndex) {
              cc.logID(2300, unusedIndex);
              continue;
            }
            curTouch = this._touches[unusedIndex] = new cc.Touch(selTouch._point.x, selTouch._point.y, selTouch.getID());
            curTouch._lastModified = now;
            curTouch._setPrevPoint(selTouch._prevPoint);
            locTouchIntDict[touchID] = unusedIndex;
            handleTouches.push(curTouch);
          }
        }
        if (handleTouches.length > 0) {
          this._glView._convertTouchesWithScale(handleTouches);
          var touchEvent = new cc.Event.EventTouch(handleTouches);
          touchEvent._eventCode = cc.Event.EventTouch.BEGAN;
          eventManager.dispatchEvent(touchEvent);
        }
      },
      handleTouchesMove: function handleTouchesMove(touches) {
        var selTouch = void 0, index = void 0, touchID = void 0, handleTouches = [], locTouches = this._touches, now = sys.now();
        for (var i = 0, len = touches.length; i < len; i++) {
          selTouch = touches[i];
          touchID = selTouch.getID();
          index = this._touchesIntegerDict[touchID];
          if (null == index) continue;
          if (locTouches[index]) {
            locTouches[index]._setPoint(selTouch._point);
            locTouches[index]._setPrevPoint(selTouch._prevPoint);
            locTouches[index]._lastModified = now;
            handleTouches.push(locTouches[index]);
          }
        }
        if (handleTouches.length > 0) {
          this._glView._convertTouchesWithScale(handleTouches);
          var touchEvent = new cc.Event.EventTouch(handleTouches);
          touchEvent._eventCode = cc.Event.EventTouch.MOVED;
          eventManager.dispatchEvent(touchEvent);
        }
      },
      handleTouchesEnd: function handleTouchesEnd(touches) {
        var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
        if (handleTouches.length > 0) {
          this._glView._convertTouchesWithScale(handleTouches);
          var touchEvent = new cc.Event.EventTouch(handleTouches);
          touchEvent._eventCode = cc.Event.EventTouch.ENDED;
          eventManager.dispatchEvent(touchEvent);
        }
        this._preTouchPool.length = 0;
      },
      handleTouchesCancel: function handleTouchesCancel(touches) {
        var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
        if (handleTouches.length > 0) {
          this._glView._convertTouchesWithScale(handleTouches);
          var touchEvent = new cc.Event.EventTouch(handleTouches);
          touchEvent._eventCode = cc.Event.EventTouch.CANCELLED;
          eventManager.dispatchEvent(touchEvent);
        }
        this._preTouchPool.length = 0;
      },
      getSetOfTouchesEndOrCancel: function getSetOfTouchesEndOrCancel(touches) {
        var selTouch = void 0, index = void 0, touchID = void 0, handleTouches = [], locTouches = this._touches, locTouchesIntDict = this._touchesIntegerDict;
        for (var i = 0, len = touches.length; i < len; i++) {
          selTouch = touches[i];
          touchID = selTouch.getID();
          index = locTouchesIntDict[touchID];
          if (null == index) continue;
          if (locTouches[index]) {
            locTouches[index]._setPoint(selTouch._point);
            locTouches[index]._setPrevPoint(selTouch._prevPoint);
            handleTouches.push(locTouches[index]);
            this._removeUsedIndexBit(index);
            delete locTouchesIntDict[touchID];
          }
        }
        return handleTouches;
      },
      getHTMLElementPosition: function getHTMLElementPosition(element) {
        false;
        var docElem = document.documentElement;
        var leftOffset = window.pageXOffset - docElem.clientLeft;
        var topOffset = window.pageYOffset - docElem.clientTop;
        if (element.getBoundingClientRect) {
          var box = element.getBoundingClientRect();
          return {
            left: box.left + leftOffset,
            top: box.top + topOffset,
            width: box.width,
            height: box.height
          };
        }
        return element instanceof HTMLCanvasElement ? {
          left: leftOffset,
          top: topOffset,
          width: element.width,
          height: element.height
        } : {
          left: leftOffset,
          top: topOffset,
          width: parseInt(element.style.width),
          height: parseInt(element.style.height)
        };
      },
      getPreTouch: function getPreTouch(touch) {
        var preTouch = null;
        var locPreTouchPool = this._preTouchPool;
        var id = touch.getID();
        for (var i = locPreTouchPool.length - 1; i >= 0; i--) if (locPreTouchPool[i].getID() === id) {
          preTouch = locPreTouchPool[i];
          break;
        }
        preTouch || (preTouch = touch);
        return preTouch;
      },
      setPreTouch: function setPreTouch(touch) {
        var find = false;
        var locPreTouchPool = this._preTouchPool;
        var id = touch.getID();
        for (var i = locPreTouchPool.length - 1; i >= 0; i--) if (locPreTouchPool[i].getID() === id) {
          locPreTouchPool[i] = touch;
          find = true;
          break;
        }
        if (!find) if (locPreTouchPool.length <= 50) locPreTouchPool.push(touch); else {
          locPreTouchPool[this._preTouchPoolPointer] = touch;
          this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50;
        }
      },
      getTouchByXY: function getTouchByXY(tx, ty, pos) {
        var locPreTouch = this._preTouchPoint;
        var location = this._glView.convertToLocationInView(tx, ty, pos);
        var touch = new cc.Touch(location.x, location.y, 0);
        touch._setPrevPoint(locPreTouch.x, locPreTouch.y);
        locPreTouch.x = location.x;
        locPreTouch.y = location.y;
        return touch;
      },
      getMouseEvent: function getMouseEvent(location, pos, eventType) {
        var locPreMouse = this._prevMousePoint;
        var mouseEvent = new cc.Event.EventMouse(eventType);
        mouseEvent._setPrevCursor(locPreMouse.x, locPreMouse.y);
        locPreMouse.x = location.x;
        locPreMouse.y = location.y;
        this._glView._convertMouseToLocationInView(locPreMouse, pos);
        mouseEvent.setLocation(locPreMouse.x, locPreMouse.y);
        return mouseEvent;
      },
      getPointByEvent: function getPointByEvent(event, pos) {
        if (null != event.pageX) return {
          x: event.pageX,
          y: event.pageY
        };
        false;
        pos.left -= document.body.scrollLeft;
        pos.top -= document.body.scrollTop;
        return {
          x: event.clientX,
          y: event.clientY
        };
      },
      getTouchesByEvent: function getTouchesByEvent(event, pos) {
        var touchArr = [], locView = this._glView;
        var touch_event = void 0, touch = void 0, preLocation = void 0;
        var locPreTouch = this._preTouchPoint;
        var length = event.changedTouches.length;
        for (var i = 0; i < length; i++) {
          touch_event = event.changedTouches[i];
          if (touch_event) {
            var location = void 0;
            location = sys.BROWSER_TYPE_FIREFOX === sys.browserType ? locView.convertToLocationInView(touch_event.pageX, touch_event.pageY, pos, _vec2) : locView.convertToLocationInView(touch_event.clientX, touch_event.clientY, pos, _vec2);
            if (null != touch_event.identifier) {
              touch = new cc.Touch(location.x, location.y, touch_event.identifier);
              preLocation = this.getPreTouch(touch).getLocation();
              touch._setPrevPoint(preLocation.x, preLocation.y);
              this.setPreTouch(touch);
            } else {
              touch = new cc.Touch(location.x, location.y);
              touch._setPrevPoint(locPreTouch.x, locPreTouch.y);
            }
            locPreTouch.x = location.x;
            locPreTouch.y = location.y;
            touchArr.push(touch);
          }
        }
        return touchArr;
      },
      registerSystemEvent: function registerSystemEvent(element) {
        if (this._isRegisterEvent) return;
        this._glView = cc.view;
        var selfPointer = this;
        var prohibition = sys.isMobile;
        var supportMouse = "mouse" in sys.capabilities;
        var supportTouches = "touches" in sys.capabilities;
        false;
        if (supportMouse) {
          if (!prohibition) {
            window.addEventListener("mousedown", (function() {
              selfPointer._mousePressed = true;
            }), false);
            window.addEventListener("mouseup", (function(event) {
              if (!selfPointer._mousePressed) return;
              selfPointer._mousePressed = false;
              var pos = selfPointer.getHTMLElementPosition(element);
              var location = selfPointer.getPointByEvent(event, pos);
              if (!cc.rect(pos.left, pos.top, pos.width, pos.height).contains(location)) {
                selfPointer.handleTouchesEnd([ selfPointer.getTouchByXY(location.x, location.y, pos) ]);
                var mouseEvent = selfPointer.getMouseEvent(location, pos, cc.Event.EventMouse.UP);
                mouseEvent.setButton(event.button);
                eventManager.dispatchEvent(mouseEvent);
              }
            }), false);
          }
          var EventMouse = cc.Event.EventMouse;
          var _mouseEventsOnElement = [ !prohibition && [ "mousedown", EventMouse.DOWN, function(event, mouseEvent, location, pos) {
            selfPointer._mousePressed = true;
            selfPointer.handleTouchesBegin([ selfPointer.getTouchByXY(location.x, location.y, pos) ]);
            element.focus();
          } ], !prohibition && [ "mouseup", EventMouse.UP, function(event, mouseEvent, location, pos) {
            selfPointer._mousePressed = false;
            selfPointer.handleTouchesEnd([ selfPointer.getTouchByXY(location.x, location.y, pos) ]);
          } ], !prohibition && [ "mousemove", EventMouse.MOVE, function(event, mouseEvent, location, pos) {
            selfPointer.handleTouchesMove([ selfPointer.getTouchByXY(location.x, location.y, pos) ]);
            selfPointer._mousePressed || mouseEvent.setButton(null);
          } ], [ "mousewheel", EventMouse.SCROLL, function(event, mouseEvent) {
            mouseEvent.setScrollData(0, event.wheelDelta);
          } ], [ "DOMMouseScroll", EventMouse.SCROLL, function(event, mouseEvent) {
            mouseEvent.setScrollData(0, -120 * event.detail);
          } ] ];
          for (var i = 0; i < _mouseEventsOnElement.length; ++i) {
            var entry = _mouseEventsOnElement[i];
            entry && (function() {
              var name = entry[0];
              var type = entry[1];
              var handler = entry[2];
              element.addEventListener(name, (function(event) {
                var pos = selfPointer.getHTMLElementPosition(element);
                var location = selfPointer.getPointByEvent(event, pos);
                var mouseEvent = selfPointer.getMouseEvent(location, pos, type);
                mouseEvent.setButton(event.button);
                handler(event, mouseEvent, location, pos);
                eventManager.dispatchEvent(mouseEvent);
                event.stopPropagation();
                event.preventDefault();
              }), false);
            })();
          }
        }
        if (window.navigator.msPointerEnabled) {
          var _pointerEventsMap = {
            MSPointerDown: selfPointer.handleTouchesBegin,
            MSPointerMove: selfPointer.handleTouchesMove,
            MSPointerUp: selfPointer.handleTouchesEnd,
            MSPointerCancel: selfPointer.handleTouchesCancel
          };
          var _loop = function _loop(eventName) {
            var touchEvent = _pointerEventsMap[eventName];
            element.addEventListener(eventName, (function(event) {
              var pos = selfPointer.getHTMLElementPosition(element);
              pos.left -= document.documentElement.scrollLeft;
              pos.top -= document.documentElement.scrollTop;
              touchEvent.call(selfPointer, [ selfPointer.getTouchByXY(event.clientX, event.clientY, pos) ]);
              event.stopPropagation();
            }), false);
          };
          for (var eventName in _pointerEventsMap) _loop(eventName);
        }
        if (supportTouches) {
          var _touchEventsMap = {
            touchstart: function touchstart(touchesToHandle) {
              selfPointer.handleTouchesBegin(touchesToHandle);
              true;
              element.focus();
            },
            touchmove: function touchmove(touchesToHandle) {
              selfPointer.handleTouchesMove(touchesToHandle);
            },
            touchend: function touchend(touchesToHandle) {
              selfPointer.handleTouchesEnd(touchesToHandle);
            },
            touchcancel: function touchcancel(touchesToHandle) {
              selfPointer.handleTouchesCancel(touchesToHandle);
            }
          };
          var registerTouchEvent = void 0;
          if (cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB) {
            _touchEventsMap = {
              onTouchStart: _touchEventsMap.touchstart,
              onTouchMove: _touchEventsMap.touchmove,
              onTouchEnd: _touchEventsMap.touchend,
              onTouchCancel: _touchEventsMap.touchcancel
            };
            registerTouchEvent = function registerTouchEvent(eventName) {
              var handler = _touchEventsMap[eventName];
              wx[eventName]((function(event) {
                if (!event.changedTouches) return;
                var pos = selfPointer.getHTMLElementPosition(element);
                var body = document.body;
                pos.left -= body.scrollLeft || 0;
                pos.top -= body.scrollTop || 0;
                handler(selfPointer.getTouchesByEvent(event, pos));
              }));
            };
          } else registerTouchEvent = function registerTouchEvent(eventName) {
            var handler = _touchEventsMap[eventName];
            element.addEventListener(eventName, (function(event) {
              if (!event.changedTouches) return;
              var pos = selfPointer.getHTMLElementPosition(element);
              var body = document.body;
              pos.left -= body.scrollLeft || 0;
              pos.top -= body.scrollTop || 0;
              handler(selfPointer.getTouchesByEvent(event, pos));
              event.stopPropagation();
              event.preventDefault();
            }), false);
          };
          for (var eventName in _touchEventsMap) registerTouchEvent(eventName);
        }
        cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB && this._registerKeyboardEvent();
        this._isRegisterEvent = true;
      },
      _registerKeyboardEvent: function _registerKeyboardEvent() {},
      _registerAccelerometerEvent: function _registerAccelerometerEvent() {},
      update: function update(dt) {
        if (this._accelCurTime > this._accelInterval) {
          this._accelCurTime -= this._accelInterval;
          eventManager.dispatchEvent(new cc.Event.EventAcceleration(this._acceleration));
        }
        this._accelCurTime += dt;
      }
    };
    module.exports = _cc.inputManager = inputManager;
  }), {
    "../event-manager": 70,
    "./CCMacro": 109,
    "./CCSys": 113
  } ],
  109: [ (function(require, module, exports) {
    "use strict";
    var js = require("./js");
    cc.macro = {
      RAD: Math.PI / 180,
      DEG: 180 / Math.PI,
      REPEAT_FOREVER: Number.MAX_VALUE - 1,
      FLT_EPSILON: 1.192092896e-7,
      MIN_ZINDEX: -Math.pow(2, 15),
      MAX_ZINDEX: Math.pow(2, 15) - 1,
      ONE: 1,
      ZERO: 0,
      SRC_ALPHA: 770,
      SRC_ALPHA_SATURATE: 776,
      SRC_COLOR: 768,
      DST_ALPHA: 772,
      DST_COLOR: 774,
      ONE_MINUS_SRC_ALPHA: 771,
      ONE_MINUS_SRC_COLOR: 769,
      ONE_MINUS_DST_ALPHA: 773,
      ONE_MINUS_DST_COLOR: 775,
      ONE_MINUS_CONSTANT_ALPHA: 32772,
      ONE_MINUS_CONSTANT_COLOR: 32770,
      ORIENTATION_PORTRAIT: 1,
      ORIENTATION_LANDSCAPE: 2,
      ORIENTATION_AUTO: 3,
      DENSITYDPI_DEVICE: "device-dpi",
      DENSITYDPI_HIGH: "high-dpi",
      DENSITYDPI_MEDIUM: "medium-dpi",
      DENSITYDPI_LOW: "low-dpi",
      FIX_ARTIFACTS_BY_STRECHING_TEXEL_TMX: true,
      DIRECTOR_STATS_POSITION: cc.v2(0, 0),
      ENABLE_STACKABLE_ACTIONS: true,
      TOUCH_TIMEOUT: 5e3,
      BATCH_VERTEX_COUNT: 2e4,
      ENABLE_TILEDMAP_CULLING: true,
      DOWNLOAD_MAX_CONCURRENT: 64,
      ENABLE_TRANSPARENT_CANVAS: false,
      ENABLE_WEBGL_ANTIALIAS: false,
      ENABLE_CULLING: false,
      CLEANUP_IMAGE_CACHE: false,
      SHOW_MESH_WIREFRAME: false,
      ROTATE_ACTION_CCW: false
    };
    var SUPPORT_TEXTURE_FORMATS = [ ".pkm", ".pvr", ".webp", ".jpg", ".jpeg", ".bmp", ".png" ];
    cc.macro.SUPPORT_TEXTURE_FORMATS = SUPPORT_TEXTURE_FORMATS;
    cc.macro.KEY = {
      none: 0,
      back: 6,
      menu: 18,
      backspace: 8,
      tab: 9,
      enter: 13,
      shift: 16,
      ctrl: 17,
      alt: 18,
      pause: 19,
      capslock: 20,
      escape: 27,
      space: 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      left: 37,
      up: 38,
      right: 39,
      down: 40,
      select: 41,
      insert: 45,
      Delete: 46,
      0: 48,
      1: 49,
      2: 50,
      3: 51,
      4: 52,
      5: 53,
      6: 54,
      7: 55,
      8: 56,
      9: 57,
      a: 65,
      b: 66,
      c: 67,
      d: 68,
      e: 69,
      f: 70,
      g: 71,
      h: 72,
      i: 73,
      j: 74,
      k: 75,
      l: 76,
      m: 77,
      n: 78,
      o: 79,
      p: 80,
      q: 81,
      r: 82,
      s: 83,
      t: 84,
      u: 85,
      v: 86,
      w: 87,
      x: 88,
      y: 89,
      z: 90,
      num0: 96,
      num1: 97,
      num2: 98,
      num3: 99,
      num4: 100,
      num5: 101,
      num6: 102,
      num7: 103,
      num8: 104,
      num9: 105,
      "*": 106,
      "+": 107,
      "-": 109,
      numdel: 110,
      "/": 111,
      f1: 112,
      f2: 113,
      f3: 114,
      f4: 115,
      f5: 116,
      f6: 117,
      f7: 118,
      f8: 119,
      f9: 120,
      f10: 121,
      f11: 122,
      f12: 123,
      numlock: 144,
      scrolllock: 145,
      ";": 186,
      semicolon: 186,
      equal: 187,
      "=": 187,
      ",": 188,
      comma: 188,
      dash: 189,
      ".": 190,
      period: 190,
      forwardslash: 191,
      grave: 192,
      "[": 219,
      openbracket: 219,
      backslash: 220,
      "]": 221,
      closebracket: 221,
      quote: 222,
      dpadLeft: 1e3,
      dpadRight: 1001,
      dpadUp: 1003,
      dpadDown: 1004,
      dpadCenter: 1005
    };
    cc.macro.ImageFormat = cc.Enum({
      JPG: 0,
      PNG: 1,
      TIFF: 2,
      WEBP: 3,
      PVR: 4,
      ETC: 5,
      S3TC: 6,
      ATITC: 7,
      TGA: 8,
      RAWDATA: 9,
      UNKNOWN: 10
    });
    cc.macro.BlendFactor = cc.Enum({
      ONE: 1,
      ZERO: 0,
      SRC_ALPHA: 770,
      SRC_COLOR: 768,
      DST_ALPHA: 772,
      DST_COLOR: 774,
      ONE_MINUS_SRC_ALPHA: 771,
      ONE_MINUS_SRC_COLOR: 769,
      ONE_MINUS_DST_ALPHA: 773,
      ONE_MINUS_DST_COLOR: 775
    });
    cc.macro.TextAlignment = cc.Enum({
      LEFT: 0,
      CENTER: 1,
      RIGHT: 2
    });
    cc.macro.VerticalTextAlignment = cc.Enum({
      TOP: 0,
      CENTER: 1,
      BOTTOM: 2
    });
    module.exports = cc.macro;
  }), {
    "./js": 124
  } ],
  110: [ (function(require, module, exports) {
    "use strict";
    var js = require("./js");
    var CCClass = require("./CCClass");
    var Destroyed = 1;
    var RealDestroyed = 2;
    var ToDestroy = 4;
    var DontSave = 8;
    var EditorOnly = 16;
    var Dirty = 32;
    var DontDestroy = 64;
    var Destroying = 128;
    var Deactivating = 256;
    var LockedInEditor = 512;
    var HideInHierarchy = 1024;
    var IsOnEnableCalled = 2048;
    var IsEditorOnEnableCalled = 4096;
    var IsPreloadStarted = 8192;
    var IsOnLoadCalled = 16384;
    var IsOnLoadStarted = 32768;
    var IsStartCalled = 65536;
    var IsRotationLocked = 1 << 17;
    var IsScaleLocked = 1 << 18;
    var IsAnchorLocked = 1 << 19;
    var IsSizeLocked = 1 << 20;
    var IsPositionLocked = 1 << 21;
    var PersistentMask = ~(ToDestroy | Dirty | Destroying | DontDestroy | Deactivating | IsPreloadStarted | IsOnLoadStarted | IsOnLoadCalled | IsStartCalled | IsOnEnableCalled | IsEditorOnEnableCalled | IsRotationLocked | IsScaleLocked | IsAnchorLocked | IsSizeLocked | IsPositionLocked);
    function CCObject() {
      this._name = "";
      this._objFlags = 0;
    }
    CCClass.fastDefine("cc.Object", CCObject, {
      _name: "",
      _objFlags: 0
    });
    js.value(CCObject, "Flags", {
      Destroyed: Destroyed,
      DontSave: DontSave,
      EditorOnly: EditorOnly,
      Dirty: Dirty,
      DontDestroy: DontDestroy,
      PersistentMask: PersistentMask,
      Destroying: Destroying,
      Deactivating: Deactivating,
      LockedInEditor: LockedInEditor,
      HideInHierarchy: HideInHierarchy,
      IsPreloadStarted: IsPreloadStarted,
      IsOnLoadStarted: IsOnLoadStarted,
      IsOnLoadCalled: IsOnLoadCalled,
      IsOnEnableCalled: IsOnEnableCalled,
      IsStartCalled: IsStartCalled,
      IsEditorOnEnableCalled: IsEditorOnEnableCalled,
      IsPositionLocked: IsPositionLocked,
      IsRotationLocked: IsRotationLocked,
      IsScaleLocked: IsScaleLocked,
      IsAnchorLocked: IsAnchorLocked,
      IsSizeLocked: IsSizeLocked
    });
    var objectsToDestroy = [];
    function deferredDestroy() {
      var deleteCount = objectsToDestroy.length;
      for (var i = 0; i < deleteCount; ++i) {
        var obj = objectsToDestroy[i];
        obj._objFlags & Destroyed || obj._destroyImmediate();
      }
      deleteCount === objectsToDestroy.length ? objectsToDestroy.length = 0 : objectsToDestroy.splice(0, deleteCount);
      false;
    }
    js.value(CCObject, "_deferredDestroy", deferredDestroy);
    false;
    var prototype = CCObject.prototype;
    js.getset(prototype, "name", (function() {
      return this._name;
    }), (function(value) {
      this._name = value;
    }), true);
    js.get(prototype, "isValid", (function() {
      return !(this._objFlags & Destroyed);
    }), true);
    false, false;
    var deferredDestroyTimer = null;
    prototype.destroy = function() {
      if (this._objFlags & Destroyed) {
        cc.warnID(5e3);
        return false;
      }
      if (this._objFlags & ToDestroy) return false;
      this._objFlags |= ToDestroy;
      objectsToDestroy.push(this);
      false;
      return true;
    };
    false, false;
    function compileDestruct(obj, ctor) {
      var shouldSkipId = obj instanceof cc._BaseNode || obj instanceof cc.Component;
      var idToSkip = shouldSkipId ? "_id" : null;
      var key, propsToReset = {};
      for (key in obj) if (obj.hasOwnProperty(key)) {
        if (key === idToSkip) continue;
        switch (typeof obj[key]) {
         case "string":
          propsToReset[key] = "";
          break;

         case "object":
         case "function":
          propsToReset[key] = null;
        }
      }
      if (cc.Class._isCCClass(ctor)) {
        var attrs = cc.Class.Attr.getClassAttrs(ctor);
        var propList = ctor.__props__;
        for (var i = 0; i < propList.length; i++) {
          key = propList[i];
          var attrKey = key + cc.Class.Attr.DELIMETER + "default";
          if (attrKey in attrs) {
            if (shouldSkipId && "_id" === key) continue;
            switch (typeof attrs[attrKey]) {
             case "string":
              propsToReset[key] = "";
              break;

             case "object":
             case "function":
              propsToReset[key] = null;
              break;

             case "undefined":
              propsToReset[key] = void 0;
            }
          }
        }
      }
      true;
      var func = "";
      for (key in propsToReset) {
        var statement;
        statement = CCClass.IDENTIFIER_RE.test(key) ? "o." + key + "=" : "o[" + CCClass.escapeForJS(key) + "]=";
        var val = propsToReset[key];
        "" === val && (val = '""');
        func += statement + val + ";\n";
      }
      return Function("o", func);
    }
    prototype._destruct = function() {
      var ctor = this.constructor;
      var destruct = ctor.__destruct__;
      if (!destruct) {
        destruct = compileDestruct(this, ctor);
        js.value(ctor, "__destruct__", destruct, true);
      }
      destruct(this);
    };
    prototype._onPreDestroy = null;
    prototype._destroyImmediate = function() {
      if (this._objFlags & Destroyed) {
        cc.errorID(5e3);
        return;
      }
      this._onPreDestroy && this._onPreDestroy();
      true;
      this._destruct();
      this._objFlags |= Destroyed;
    };
    false;
    prototype._deserialize = null;
    cc.isValid = function(value, strictMode) {
      return "object" === typeof value ? !!value && !(value._objFlags & (strictMode ? Destroyed | ToDestroy : Destroyed)) : "undefined" !== typeof value;
    };
    false, false;
    cc.Object = module.exports = CCObject;
  }), {
    "./CCClass": 104,
    "./js": 124
  } ],
  111: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    cc.SAXParser = function() {
      if (true, window.DOMParser) {
        this._isSupportDOMParser = true;
        this._parser = new DOMParser();
      } else {
        this._isSupportDOMParser = false;
        this._parser = null;
      }
    };
    cc.SAXParser.prototype = {
      constructor: cc.SAXParser,
      parse: function parse(xmlTxt) {
        return this._parseXML(xmlTxt);
      },
      _parseXML: function _parseXML(textxml) {
        var xmlDoc;
        if (this._isSupportDOMParser) xmlDoc = this._parser.parseFromString(textxml, "text/xml"); else {
          xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
          xmlDoc.async = "false";
          xmlDoc.loadXML(textxml);
        }
        return xmlDoc;
      }
    };
    cc.PlistParser = function() {
      cc.SAXParser.call(this);
    };
    js.extend(cc.PlistParser, cc.SAXParser);
    js.mixin(cc.PlistParser.prototype, {
      parse: function parse(xmlTxt) {
        var xmlDoc = this._parseXML(xmlTxt);
        var plist = xmlDoc.documentElement;
        if ("plist" !== plist.tagName) {
          cc.warnID(5100);
          return {};
        }
        var node = null;
        for (var i = 0, len = plist.childNodes.length; i < len; i++) {
          node = plist.childNodes[i];
          if (1 === node.nodeType) break;
        }
        xmlDoc = null;
        return this._parseNode(node);
      },
      _parseNode: function _parseNode(node) {
        var data = null, tagName = node.tagName;
        if ("dict" === tagName) data = this._parseDict(node); else if ("array" === tagName) data = this._parseArray(node); else if ("string" === tagName) if (1 === node.childNodes.length) data = node.firstChild.nodeValue; else {
          data = "";
          for (var i = 0; i < node.childNodes.length; i++) data += node.childNodes[i].nodeValue;
        } else "false" === tagName ? data = false : "true" === tagName ? data = true : "real" === tagName ? data = parseFloat(node.firstChild.nodeValue) : "integer" === tagName && (data = parseInt(node.firstChild.nodeValue, 10));
        return data;
      },
      _parseArray: function _parseArray(node) {
        var data = [];
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
          var child = node.childNodes[i];
          if (1 !== child.nodeType) continue;
          data.push(this._parseNode(child));
        }
        return data;
      },
      _parseDict: function _parseDict(node) {
        var data = {};
        var key = null;
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
          var child = node.childNodes[i];
          if (1 !== child.nodeType) continue;
          "key" === child.tagName ? key = child.firstChild.nodeValue : data[key] = this._parseNode(child);
        }
        return data;
      }
    });
    cc.saxParser = new cc.SAXParser();
    cc.plistParser = new cc.PlistParser();
    module.exports = {
      saxParser: cc.saxParser,
      plistParser: cc.plistParser
    };
  }), {
    "../platform/js": 124
  } ],
  112: [ (function(require, module, exports) {
    "use strict";
    cc.screen = {
      _supportsFullScreen: false,
      _onfullscreenchange: null,
      _onfullscreenerror: null,
      _preOnFullScreenChange: null,
      _preOnFullScreenError: null,
      _preOnTouch: null,
      _touchEvent: "",
      _fn: null,
      _fnMap: [ [ "requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement", "fullscreenerror" ], [ "requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement", "fullscreenerror" ], [ "webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement", "webkitfullscreenerror" ], [ "mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen", "mozFullScreenElement", "mozfullscreenerror" ], [ "msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement", "msfullscreenerror" ] ],
      init: function init() {
        this._fn = {};
        var i, l, val, map = this._fnMap, valL;
        for (i = 0, l = map.length; i < l; i++) {
          val = map[i];
          if (val && "undefined" !== typeof document[val[1]]) {
            for (i = 0, valL = val.length; i < valL; i++) this._fn[map[0][i]] = val[i];
            break;
          }
        }
        this._supportsFullScreen = void 0 !== this._fn.requestFullscreen;
        this._touchEvent = "ontouchend" in window ? "touchend" : "mousedown";
      },
      fullScreen: function fullScreen() {
        return !!this._supportsFullScreen && !!(document[this._fn.fullscreenElement] || document[this._fn.webkitFullscreenElement] || document[this._fn.mozFullScreenElement]);
      },
      requestFullScreen: function requestFullScreen(element, onFullScreenChange, onFullScreenError) {
        if (element && "video" === element.tagName.toLowerCase()) {
          if (cc.sys.os === cc.sys.OS_IOS && cc.sys.isBrowser && element.readyState > 0) {
            element.webkitEnterFullscreen && element.webkitEnterFullscreen();
            return;
          }
          element.setAttribute("x5-video-player-fullscreen", "true");
        }
        if (!this._supportsFullScreen) return;
        element = element || document.documentElement;
        if (onFullScreenChange) {
          var eventName = this._fn.fullscreenchange;
          this._onfullscreenchange && document.removeEventListener(eventName, this._onfullscreenchange);
          this._onfullscreenchange = onFullScreenChange;
          document.addEventListener(eventName, onFullScreenChange, false);
        }
        if (onFullScreenError) {
          var _eventName = this._fn.fullscreenerror;
          this._onfullscreenerror && document.removeEventListener(_eventName, this._onfullscreenerror);
          this._onfullscreenerror = onFullScreenError;
          document.addEventListener(_eventName, onFullScreenError, {
            once: true
          });
        }
        element[this._fn.requestFullscreen]();
      },
      exitFullScreen: function exitFullScreen(element) {
        if (element && "video" === element.tagName.toLowerCase()) {
          if (cc.sys.os === cc.sys.OS_IOS && cc.sys.isBrowser) {
            element.webkitExitFullscreen && element.webkitExitFullscreen();
            return;
          }
          element.setAttribute("x5-video-player-fullscreen", "false");
        }
        return !this._supportsFullScreen || document[this._fn.exitFullscreen]();
      },
      autoFullScreen: function autoFullScreen(element, onFullScreenChange) {
        element = element || document.body;
        this._ensureFullScreen(element, onFullScreenChange);
        this.requestFullScreen(element, onFullScreenChange);
      },
      disableAutoFullScreen: function disableAutoFullScreen(element) {
        var touchTarget = cc.game.canvas || element;
        var touchEventName = this._touchEvent;
        if (this._preOnTouch) {
          touchTarget.removeEventListener(touchEventName, this._preOnTouch);
          this._preOnTouch = null;
        }
      },
      _ensureFullScreen: function _ensureFullScreen(element, onFullScreenChange) {
        var self = this;
        var touchTarget = cc.game.canvas || element;
        var fullScreenErrorEventName = this._fn.fullscreenerror;
        var touchEventName = this._touchEvent;
        function onFullScreenError() {
          self._preOnFullScreenError = null;
          function onTouch() {
            self._preOnTouch = null;
            self.requestFullScreen(element, onFullScreenChange);
          }
          self._preOnTouch && touchTarget.removeEventListener(touchEventName, self._preOnTouch);
          self._preOnTouch = onTouch;
          touchTarget.addEventListener(touchEventName, self._preOnTouch, {
            once: true
          });
        }
        this._preOnFullScreenError && element.removeEventListener(fullScreenErrorEventName, this._preOnFullScreenError);
        this._preOnFullScreenError = onFullScreenError;
        element.addEventListener(fullScreenErrorEventName, onFullScreenError, {
          once: true
        });
      }
    };
    cc.screen.init();
  }), {} ],
  113: [ (function(require, module, exports) {
    "use strict";
    var settingPlatform = void 0;
    true;
    settingPlatform = window._CCSettings ? _CCSettings.platform : void 0;
    var isBaiduGame = "baidugame" === settingPlatform || "baidugame-subcontext" === settingPlatform;
    var isVivoGame = "qgame" === settingPlatform;
    var isOppoGame = "quickgame" === settingPlatform;
    var isHuaweiGame = "huawei" === settingPlatform;
    var isJKWGame = "jkw-game" === settingPlatform;
    var _global = "undefined" === typeof window ? global : window;
    function initSys() {
      cc.sys = {};
      var sys = cc.sys;
      sys.LANGUAGE_ENGLISH = "en";
      sys.LANGUAGE_CHINESE = "zh";
      sys.LANGUAGE_FRENCH = "fr";
      sys.LANGUAGE_ITALIAN = "it";
      sys.LANGUAGE_GERMAN = "de";
      sys.LANGUAGE_SPANISH = "es";
      sys.LANGUAGE_DUTCH = "du";
      sys.LANGUAGE_RUSSIAN = "ru";
      sys.LANGUAGE_KOREAN = "ko";
      sys.LANGUAGE_JAPANESE = "ja";
      sys.LANGUAGE_HUNGARIAN = "hu";
      sys.LANGUAGE_PORTUGUESE = "pt";
      sys.LANGUAGE_ARABIC = "ar";
      sys.LANGUAGE_NORWEGIAN = "no";
      sys.LANGUAGE_POLISH = "pl";
      sys.LANGUAGE_TURKISH = "tr";
      sys.LANGUAGE_UKRAINIAN = "uk";
      sys.LANGUAGE_ROMANIAN = "ro";
      sys.LANGUAGE_BULGARIAN = "bg";
      sys.LANGUAGE_UNKNOWN = "unknown";
      sys.OS_IOS = "iOS";
      sys.OS_ANDROID = "Android";
      sys.OS_WINDOWS = "Windows";
      sys.OS_MARMALADE = "Marmalade";
      sys.OS_LINUX = "Linux";
      sys.OS_BADA = "Bada";
      sys.OS_BLACKBERRY = "Blackberry";
      sys.OS_OSX = "OS X";
      sys.OS_WP8 = "WP8";
      sys.OS_WINRT = "WINRT";
      sys.OS_UNKNOWN = "Unknown";
      sys.UNKNOWN = -1;
      sys.WIN32 = 0;
      sys.LINUX = 1;
      sys.MACOS = 2;
      sys.ANDROID = 3;
      sys.IPHONE = 4;
      sys.IPAD = 5;
      sys.BLACKBERRY = 6;
      sys.NACL = 7;
      sys.EMSCRIPTEN = 8;
      sys.TIZEN = 9;
      sys.WINRT = 10;
      sys.WP8 = 11;
      sys.MOBILE_BROWSER = 100;
      sys.DESKTOP_BROWSER = 101;
      sys.EDITOR_PAGE = 102;
      sys.EDITOR_CORE = 103;
      sys.WECHAT_GAME = 104;
      sys.QQ_PLAY = 105;
      sys.FB_PLAYABLE_ADS = 106;
      sys.BAIDU_GAME = 107;
      sys.VIVO_GAME = 108;
      sys.OPPO_GAME = 109;
      sys.HUAWEI_GAME = 110;
      sys.XIAOMI_GAME = 111;
      sys.JKW_GAME = 112;
      sys.BROWSER_TYPE_WECHAT = "wechat";
      sys.BROWSER_TYPE_WECHAT_GAME = "wechatgame";
      sys.BROWSER_TYPE_WECHAT_GAME_SUB = "wechatgamesub";
      sys.BROWSER_TYPE_BAIDU_GAME = "baidugame";
      sys.BROWSER_TYPE_BAIDU_GAME_SUB = "baidugamesub";
      sys.BROWSER_TYPE_XIAOMI_GAME = "xiaomigame";
      sys.BROWSER_TYPE_QQ_PLAY = "qqplay";
      sys.BROWSER_TYPE_ANDROID = "androidbrowser";
      sys.BROWSER_TYPE_IE = "ie";
      sys.BROWSER_TYPE_QQ = "qqbrowser";
      sys.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser";
      sys.BROWSER_TYPE_UC = "ucbrowser";
      sys.BROWSER_TYPE_UCBS = "ucbs";
      sys.BROWSER_TYPE_360 = "360browser";
      sys.BROWSER_TYPE_BAIDU_APP = "baiduboxapp";
      sys.BROWSER_TYPE_BAIDU = "baidubrowser";
      sys.BROWSER_TYPE_MAXTHON = "maxthon";
      sys.BROWSER_TYPE_OPERA = "opera";
      sys.BROWSER_TYPE_OUPENG = "oupeng";
      sys.BROWSER_TYPE_MIUI = "miuibrowser";
      sys.BROWSER_TYPE_FIREFOX = "firefox";
      sys.BROWSER_TYPE_SAFARI = "safari";
      sys.BROWSER_TYPE_CHROME = "chrome";
      sys.BROWSER_TYPE_LIEBAO = "liebao";
      sys.BROWSER_TYPE_QZONE = "qzone";
      sys.BROWSER_TYPE_SOUGOU = "sogou";
      sys.BROWSER_TYPE_UNKNOWN = "unknown";
      sys.isNative = (false, false);
      sys.isBrowser = "object" === typeof window && "object" === typeof document && !isBaiduGame;
      sys.glExtension = function(name) {
        if ((false, isBaiduGame) && "OES_texture_float" === name) return false;
        return !!cc.renderer.device.ext(name);
      };
      sys.getMaxJointMatrixSize = function() {
        if (!sys._maxJointMatrixSize) {
          var JOINT_MATRICES_SIZE = 50;
          var LEFT_UNIFORM_SIZE = 10;
          var gl = cc.game._renderContext;
          var maxUniforms = Math.floor(gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS) / 4) - LEFT_UNIFORM_SIZE;
          sys._maxJointMatrixSize = maxUniforms < JOINT_MATRICES_SIZE ? 0 : JOINT_MATRICES_SIZE;
        }
        return sys._maxJointMatrixSize;
      };
      if (_global.__platform && _global.__platform.getSystemInfo) {
        var _env = _global.__platform.getSystemInfo();
        sys.isNative = _env.isNative;
        sys.isBrowser = _env.isBrowser;
        sys.platform = _env.platform;
        sys.browserType = _env.browserType;
        sys.isMobile = _env.isMobile;
        sys.language = _env.language;
        sys.languageCode = _env.language.toLowerCase();
        sys.os = _env.os;
        sys.osVersion = _env.osVersion;
        sys.osMainVersion = _env.osMainVersion;
        sys.browserVersion = _env.browserVersion;
        sys.windowPixelResolution = _env.windowPixelResolution;
        sys.localStorage = _env.localStorage;
        sys.capabilities = _env.capabilities;
        sys.__audioSupport = _env.audioSupport;
        _global.__platform = void 0;
      } else {
        false;
        var platform;
        var languageCode;
        var w;
        var h;
        var ratio;
        var capabilities;
        false, false;
        var env;
        var system;
        var version;
        var w;
        var h;
        var ratio;
        var _supportWebGL;
        var _canvas;
        false;
        var env;
        var w;
        var h;
        var ratio;
        false;
        if (isBaiduGame) {
          var _env2 = __device.getSystemInfo();
          sys.platform = _env2.platform;
          sys.browserType = _env2.browserType;
          sys.isMobile = _env2.isMobile;
          sys.language = _env2.language;
          sys.languageCode = _env2.language.toLowerCase();
          sys.os = _env2.os;
          sys.osVersion = _env2.osVersion;
          sys.osMainVersion = _env2.osMainVersion;
          sys.browserVersion = _env2.browserVersion;
          sys.windowPixelResolution = _env2.windowPixelResolution;
          sys.localStorage = _env2.localStorage;
          sys.capabilities = _env2.capabilities;
          sys.__audioSupport = _env2.audioSupport;
        } else {
          var win = window, nav = win.navigator, doc = document, docEle = doc.documentElement;
          var ua = nav.userAgent.toLowerCase();
          false;
          sys.isMobile = /mobile|android|iphone|ipad/.test(ua);
          "undefined" !== typeof FbPlayableAd ? sys.platform = sys.FB_PLAYABLE_ADS : sys.platform = sys.isMobile ? sys.MOBILE_BROWSER : sys.DESKTOP_BROWSER;
          var currLanguage = nav.language;
          currLanguage = currLanguage || nav.browserLanguage;
          sys.languageCode = currLanguage.toLowerCase();
          currLanguage = currLanguage ? currLanguage.split("-")[0] : sys.LANGUAGE_ENGLISH;
          sys.language = currLanguage;
          var isAndroid = false, iOS = false, osVersion = "", osMainVersion = 0;
          var uaResult = /android (\d+(?:\.\d+)*)/i.exec(ua) || /android (\d+(?:\.\d+)*)/i.exec(nav.platform);
          if (uaResult) {
            isAndroid = true;
            osVersion = uaResult[1] || "";
            osMainVersion = parseInt(osVersion) || 0;
          }
          uaResult = /(iPad|iPhone|iPod).*OS ((\d+_?){2,3})/i.exec(ua);
          if (uaResult) {
            iOS = true;
            osVersion = uaResult[2] || "";
            osMainVersion = parseInt(osVersion) || 0;
          } else if (/(iPhone|iPad|iPod)/.exec(nav.platform)) {
            iOS = true;
            osVersion = "";
            osMainVersion = 0;
          }
          var osName = sys.OS_UNKNOWN;
          -1 !== nav.appVersion.indexOf("Win") ? osName = sys.OS_WINDOWS : iOS ? osName = sys.OS_IOS : -1 !== nav.appVersion.indexOf("Mac") ? osName = sys.OS_OSX : -1 !== nav.appVersion.indexOf("X11") && -1 === nav.appVersion.indexOf("Linux") ? osName = sys.OS_UNIX : isAndroid ? osName = sys.OS_ANDROID : -1 === nav.appVersion.indexOf("Linux") && -1 === ua.indexOf("ubuntu") || (osName = sys.OS_LINUX);
          sys.os = osName;
          sys.osVersion = osVersion;
          sys.osMainVersion = osMainVersion;
          sys.browserType = sys.BROWSER_TYPE_UNKNOWN;
          (function() {
            var typeReg1 = /mqqbrowser|micromessenger|qq|sogou|qzone|liebao|maxthon|ucbs|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|mxbrowser|miuibrowser/i;
            var typeReg2 = /qqbrowser|ucbrowser/i;
            var typeReg3 = /chrome|safari|firefox|trident|opera|opr\/|oupeng/i;
            var browserTypes = typeReg1.exec(ua);
            browserTypes || (browserTypes = typeReg2.exec(ua));
            browserTypes || (browserTypes = typeReg3.exec(ua));
            var browserType = browserTypes ? browserTypes[0].toLowerCase() : sys.BROWSER_TYPE_UNKNOWN;
            false;
            false;
            "micromessenger" === browserType ? browserType = sys.BROWSER_TYPE_WECHAT : "safari" === browserType && isAndroid ? browserType = sys.BROWSER_TYPE_ANDROID : "qq" === browserType && ua.match(/android.*applewebkit/i) ? browserType = sys.BROWSER_TYPE_ANDROID : "trident" === browserType ? browserType = sys.BROWSER_TYPE_IE : "360 aphone" === browserType ? browserType = sys.BROWSER_TYPE_360 : "mxbrowser" === browserType ? browserType = sys.BROWSER_TYPE_MAXTHON : "opr/" === browserType && (browserType = sys.BROWSER_TYPE_OPERA);
            sys.browserType = browserType;
          })();
          sys.browserVersion = "";
          (function() {
            var versionReg1 = /(mqqbrowser|micromessenger|qq|sogou|qzone|liebao|maxthon|uc|ucbs|360 aphone|360|baiduboxapp|baidu|maxthon|mxbrowser|miui(?:.hybrid)?)(mobile)?(browser)?\/?([\d.]+)/i;
            var versionReg2 = /(qqbrowser|chrome|safari|firefox|trident|opera|opr\/|oupeng)(mobile)?(browser)?\/?([\d.]+)/i;
            var tmp = ua.match(versionReg1);
            tmp || (tmp = ua.match(versionReg2));
            sys.browserVersion = tmp ? tmp[4] : "";
          })();
          var w = window.innerWidth || document.documentElement.clientWidth;
          var h = window.innerHeight || document.documentElement.clientHeight;
          var ratio = window.devicePixelRatio || 1;
          sys.windowPixelResolution = {
            width: ratio * w,
            height: ratio * h
          };
          sys._checkWebGLRenderMode = function() {
            if (cc.game.renderType !== cc.game.RENDER_TYPE_WEBGL) throw new Error("This feature supports WebGL render mode only.");
          };
          var _tmpCanvas1 = document.createElement("canvas");
          var create3DContext = function create3DContext(canvas, opt_attribs, opt_contextType) {
            if (!opt_contextType) return create3DContext(canvas, opt_attribs, "webgl") || create3DContext(canvas, opt_attribs, "experimental-webgl") || create3DContext(canvas, opt_attribs, "webkit-3d") || create3DContext(canvas, opt_attribs, "moz-webgl") || null;
            try {
              return canvas.getContext(opt_contextType, opt_attribs);
            } catch (e) {
              return null;
            }
          };
          try {
            var localStorage = sys.localStorage = win.localStorage;
            localStorage.setItem("storage", "");
            localStorage.removeItem("storage");
            localStorage = null;
          } catch (e) {
            var warn = function warn() {
              cc.warnID(5200);
            };
            sys.localStorage = {
              getItem: warn,
              setItem: warn,
              removeItem: warn,
              clear: warn
            };
          }
          var _supportWebp = _tmpCanvas1.toDataURL("image/webp").startsWith("data:image/webp");
          var _supportCanvas = !!_tmpCanvas1.getContext("2d");
          var _supportWebGL = false;
          false;
          sys.browserType === sys.BROWSER_TYPE_WECHAT_GAME ? _supportWebGL = true : win.WebGLRenderingContext && (_supportWebGL = true);
          var capabilities = sys.capabilities = {
            canvas: _supportCanvas,
            opengl: _supportWebGL,
            webp: _supportWebp
          };
          (void 0 !== docEle["ontouchstart"] || void 0 !== doc["ontouchstart"] || nav.msPointerEnabled) && (capabilities["touches"] = true);
          void 0 !== docEle["onmouseup"] && (capabilities["mouse"] = true);
          void 0 !== docEle["onkeyup"] && (capabilities["keyboard"] = true);
          (win.DeviceMotionEvent || win.DeviceOrientationEvent) && (capabilities["accelerometer"] = true);
          var __audioSupport;
          (function() {
            var DEBUG = false;
            var version = sys.browserVersion;
            var supportWebAudio = sys.browserType !== sys.BROWSER_TYPE_WECHAT_GAME && !!(window.AudioContext || window.webkitAudioContext || window.mozAudioContext);
            __audioSupport = {
              ONLY_ONE: false,
              WEB_AUDIO: supportWebAudio,
              DELAY_CREATE_CTX: false
            };
            sys.os === sys.OS_IOS && (__audioSupport.USE_LOADER_EVENT = "loadedmetadata");
            if (sys.browserType === sys.BROWSER_TYPE_FIREFOX) {
              __audioSupport.DELAY_CREATE_CTX = true;
              __audioSupport.USE_LOADER_EVENT = "canplay";
            }
            sys.os === sys.OS_ANDROID && sys.browserType === sys.BROWSER_TYPE_UC && (__audioSupport.ONE_SOURCE = true);
            DEBUG && setTimeout((function() {
              cc.log("browse type: " + sys.browserType);
              cc.log("browse version: " + version);
              cc.log("MULTI_CHANNEL: " + __audioSupport.MULTI_CHANNEL);
              cc.log("WEB_AUDIO: " + __audioSupport.WEB_AUDIO);
              cc.log("AUTOPLAY: " + __audioSupport.AUTOPLAY);
            }), 0);
          })();
          try {
            if (__audioSupport.WEB_AUDIO) {
              __audioSupport.context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)();
              __audioSupport.DELAY_CREATE_CTX && setTimeout((function() {
                __audioSupport.context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)();
              }), 0);
            }
          } catch (error) {
            __audioSupport.WEB_AUDIO = false;
            cc.logID(5201);
          }
          var formatSupport = [];
          (function() {
            var audio = document.createElement("audio");
            if (audio.canPlayType) {
              var ogg = audio.canPlayType('audio/ogg; codecs="vorbis"');
              ogg && formatSupport.push(".ogg");
              var mp3 = audio.canPlayType("audio/mpeg");
              mp3 && formatSupport.push(".mp3");
              var wav = audio.canPlayType('audio/wav; codecs="1"');
              wav && formatSupport.push(".wav");
              var mp4 = audio.canPlayType("audio/mp4");
              mp4 && formatSupport.push(".mp4");
              var m4a = audio.canPlayType("audio/x-m4a");
              m4a && formatSupport.push(".m4a");
            }
          })();
          __audioSupport.format = formatSupport;
          sys.__audioSupport = __audioSupport;
        }
      }
      sys.NetworkType = {
        NONE: 0,
        LAN: 1,
        WWAN: 2
      };
      sys.getNetworkType = function() {
        return sys.NetworkType.LAN;
      };
      sys.getBatteryLevel = function() {
        return 1;
      };
      sys.garbageCollect = function() {};
      sys.restartVM = function() {};
      sys.getSafeAreaRect = function() {
        var visibleSize = cc.view.getVisibleSize();
        return cc.rect(0, 0, visibleSize.width, visibleSize.height);
      };
      sys.isObjectValid = function(obj) {
        if (obj) return true;
        return false;
      };
      sys.dump = function() {
        var self = this;
        var str = "";
        str += "isMobile : " + self.isMobile + "\r\n";
        str += "language : " + self.language + "\r\n";
        str += "browserType : " + self.browserType + "\r\n";
        str += "browserVersion : " + self.browserVersion + "\r\n";
        str += "capabilities : " + JSON.stringify(self.capabilities) + "\r\n";
        str += "os : " + self.os + "\r\n";
        str += "osVersion : " + self.osVersion + "\r\n";
        str += "platform : " + self.platform + "\r\n";
        str += "Using " + (cc.game.renderType === cc.game.RENDER_TYPE_WEBGL ? "WEBGL" : "CANVAS") + " renderer.\r\n";
        cc.log(str);
      };
      sys.openURL = function(url) {
        false, false;
        window.open(url);
      };
      sys.now = function() {
        return Date.now ? Date.now() : +new Date();
      };
      return sys;
    }
    var sys = cc && cc.sys ? cc.sys : initSys();
    module.exports = sys;
  }), {} ],
  114: [ (function(require, module, exports) {
    "use strict";
    var EventTarget = require("../event/event-target");
    var js = require("../platform/js");
    var renderer = require("../renderer");
    require("../platform/CCClass");
    var isXiaomiGame = cc.sys.platform === cc.sys.XIAOMI_GAME;
    var isBaiduGame = cc.sys.platform === cc.sys.BAIDU_GAME;
    var __BrowserGetter = {
      init: function init() {
        (true, false) || isBaiduGame || isXiaomiGame || (this.html = document.getElementsByTagName("html")[0]);
      },
      availWidth: function availWidth(frame) {
        return frame && frame !== this.html ? frame.clientWidth : window.innerWidth;
      },
      availHeight: function availHeight(frame) {
        return frame && frame !== this.html ? frame.clientHeight : window.innerHeight;
      },
      meta: {
        width: "device-width"
      },
      adaptationType: cc.sys.browserType
    };
    cc.sys.os === cc.sys.OS_IOS && (__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_SAFARI);
    isBaiduGame && (cc.sys.browserType === cc.sys.BROWSER_TYPE_BAIDU_GAME_SUB ? __BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_BAIDU_GAME_SUB : __BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_BAIDU_GAME);
    isXiaomiGame && (__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_XIAOMI_GAME);
    false;
    false;
    switch (__BrowserGetter.adaptationType) {
     case cc.sys.BROWSER_TYPE_SAFARI:
      __BrowserGetter.meta["minimal-ui"] = "true";

     case cc.sys.BROWSER_TYPE_SOUGOU:
     case cc.sys.BROWSER_TYPE_UC:
      __BrowserGetter.availWidth = function(frame) {
        return frame.clientWidth;
      };
      __BrowserGetter.availHeight = function(frame) {
        return frame.clientHeight;
      };
      break;

     case cc.sys.BROWSER_TYPE_WECHAT_GAME:
      __BrowserGetter.availWidth = function() {
        return window.innerWidth;
      };
      __BrowserGetter.availHeight = function() {
        return window.innerHeight;
      };
      break;

     case cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB:
      var sharedCanvas = window.sharedCanvas || wx.getSharedCanvas();
      __BrowserGetter.availWidth = function() {
        return sharedCanvas.width;
      };
      __BrowserGetter.availHeight = function() {
        return sharedCanvas.height;
      };
    }
    var _scissorRect = null;
    var View = function View() {
      EventTarget.call(this);
      var _t = this, _strategyer = cc.ContainerStrategy, _strategy = cc.ContentStrategy;
      __BrowserGetter.init(this);
      _t._frameSize = cc.size(0, 0);
      _t._designResolutionSize = cc.size(0, 0);
      _t._originalDesignResolutionSize = cc.size(0, 0);
      _t._scaleX = 1;
      _t._scaleY = 1;
      _t._viewportRect = cc.rect(0, 0, 0, 0);
      _t._visibleRect = cc.rect(0, 0, 0, 0);
      _t._autoFullScreen = false;
      _t._devicePixelRatio = 1;
      _t._maxPixelRatio = 2;
      _t._retinaEnabled = false;
      _t._resizeCallback = null;
      _t._resizing = false;
      _t._resizeWithBrowserSize = false;
      _t._orientationChanging = true;
      _t._isRotated = false;
      _t._orientation = cc.macro.ORIENTATION_AUTO;
      _t._isAdjustViewport = true;
      _t._antiAliasEnabled = false;
      _t._resolutionPolicy = null;
      _t._rpExactFit = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.EXACT_FIT);
      _t._rpShowAll = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.SHOW_ALL);
      _t._rpNoBorder = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.NO_BORDER);
      _t._rpFixedHeight = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_HEIGHT);
      _t._rpFixedWidth = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_WIDTH);
      cc.game.once(cc.game.EVENT_ENGINE_INITED, this.init, this);
    };
    cc.js.extend(View, EventTarget);
    cc.js.mixin(View.prototype, {
      init: function init() {
        this._initFrameSize();
        this.enableAntiAlias(true);
        var w = cc.game.canvas.width, h = cc.game.canvas.height;
        this._designResolutionSize.width = w;
        this._designResolutionSize.height = h;
        this._originalDesignResolutionSize.width = w;
        this._originalDesignResolutionSize.height = h;
        this._viewportRect.width = w;
        this._viewportRect.height = h;
        this._visibleRect.width = w;
        this._visibleRect.height = h;
        cc.winSize.width = this._visibleRect.width;
        cc.winSize.height = this._visibleRect.height;
        cc.visibleRect && cc.visibleRect.init(this._visibleRect);
      },
      _resizeEvent: function _resizeEvent(forceOrEvent) {
        var view;
        view = this.setDesignResolutionSize ? this : cc.view;
        var prevFrameW = view._frameSize.width, prevFrameH = view._frameSize.height, prevRotated = view._isRotated;
        if (cc.sys.isMobile) {
          var containerStyle = cc.game.container.style, margin = containerStyle.margin;
          containerStyle.margin = "0";
          containerStyle.display = "none";
          view._initFrameSize();
          containerStyle.margin = margin;
          containerStyle.display = "block";
        } else view._initFrameSize();
        if (true !== forceOrEvent && view._isRotated === prevRotated && view._frameSize.width === prevFrameW && view._frameSize.height === prevFrameH) return;
        var width = view._originalDesignResolutionSize.width;
        var height = view._originalDesignResolutionSize.height;
        view._resizing = true;
        width > 0 && view.setDesignResolutionSize(width, height, view._resolutionPolicy);
        view._resizing = false;
        view.emit("canvas-resize");
        view._resizeCallback && view._resizeCallback.call();
      },
      _orientationChange: function _orientationChange() {
        cc.view._orientationChanging = true;
        cc.view._resizeEvent();
      },
      resizeWithBrowserSize: function resizeWithBrowserSize(enabled) {
        if (enabled) {
          if (!this._resizeWithBrowserSize) {
            this._resizeWithBrowserSize = true;
            window.addEventListener("resize", this._resizeEvent);
            window.addEventListener("orientationchange", this._orientationChange);
          }
        } else if (this._resizeWithBrowserSize) {
          this._resizeWithBrowserSize = false;
          window.removeEventListener("resize", this._resizeEvent);
          window.removeEventListener("orientationchange", this._orientationChange);
        }
      },
      setResizeCallback: function setResizeCallback(callback) {
        false;
        "function" !== typeof callback && null != callback || (this._resizeCallback = callback);
      },
      setOrientation: function setOrientation(orientation) {
        orientation &= cc.macro.ORIENTATION_AUTO;
        if (orientation && this._orientation !== orientation) {
          this._orientation = orientation;
          var designWidth = this._originalDesignResolutionSize.width;
          var designHeight = this._originalDesignResolutionSize.height;
          this.setDesignResolutionSize(designWidth, designHeight, this._resolutionPolicy);
        }
      },
      _initFrameSize: function _initFrameSize() {
        var locFrameSize = this._frameSize;
        var w = __BrowserGetter.availWidth(cc.game.frame);
        var h = __BrowserGetter.availHeight(cc.game.frame);
        var isLandscape = w >= h;
        if ((false, !cc.sys.isMobile) || isLandscape && this._orientation & cc.macro.ORIENTATION_LANDSCAPE || !isLandscape && this._orientation & cc.macro.ORIENTATION_PORTRAIT) {
          locFrameSize.width = w;
          locFrameSize.height = h;
          cc.game.container.style["-webkit-transform"] = "rotate(0deg)";
          cc.game.container.style.transform = "rotate(0deg)";
          this._isRotated = false;
        } else {
          locFrameSize.width = h;
          locFrameSize.height = w;
          cc.game.container.style["-webkit-transform"] = "rotate(90deg)";
          cc.game.container.style.transform = "rotate(90deg)";
          cc.game.container.style["-webkit-transform-origin"] = "0px 0px 0px";
          cc.game.container.style.transformOrigin = "0px 0px 0px";
          this._isRotated = true;
        }
        this._orientationChanging && setTimeout((function() {
          cc.view._orientationChanging = false;
        }), 1e3);
      },
      _adjustSizeKeepCanvasSize: function _adjustSizeKeepCanvasSize() {
        var designWidth = this._originalDesignResolutionSize.width;
        var designHeight = this._originalDesignResolutionSize.height;
        designWidth > 0 && this.setDesignResolutionSize(designWidth, designHeight, this._resolutionPolicy);
      },
      _setViewportMeta: function _setViewportMeta(metas, overwrite) {
        var vp = document.getElementById("cocosMetaElement");
        vp && overwrite && document.head.removeChild(vp);
        var elems = document.getElementsByName("viewport"), currentVP = elems ? elems[0] : null, content, key, pattern;
        content = currentVP ? currentVP.content : "";
        vp = vp || document.createElement("meta");
        vp.id = "cocosMetaElement";
        vp.name = "viewport";
        vp.content = "";
        for (key in metas) if (-1 == content.indexOf(key)) content += "," + key + "=" + metas[key]; else if (overwrite) {
          pattern = new RegExp(key + "s*=s*[^,]+");
          content.replace(pattern, key + "=" + metas[key]);
        }
        /^,/.test(content) && (content = content.substr(1));
        vp.content = content;
        currentVP && (currentVP.content = content);
        document.head.appendChild(vp);
      },
      _adjustViewportMeta: function _adjustViewportMeta() {
        if (this._isAdjustViewport && !isBaiduGame && !isXiaomiGame) {
          this._setViewportMeta(__BrowserGetter.meta, false);
          this._isAdjustViewport = false;
        }
      },
      adjustViewportMeta: function adjustViewportMeta(enabled) {
        this._isAdjustViewport = enabled;
      },
      enableRetina: function enableRetina(enabled) {
        this._retinaEnabled = !!enabled;
      },
      isRetinaEnabled: function isRetinaEnabled() {
        return this._retinaEnabled;
      },
      enableAntiAlias: function enableAntiAlias(enabled) {
        if (this._antiAliasEnabled === enabled) return;
        this._antiAliasEnabled = enabled;
        if (cc.game.renderType === cc.game.RENDER_TYPE_WEBGL) {
          var cache = cc.loader._cache;
          for (var key in cache) {
            var item = cache[key];
            var tex = item && item.content instanceof cc.Texture2D ? item.content : null;
            if (tex) {
              var Filter = cc.Texture2D.Filter;
              enabled ? tex.setFilters(Filter.LINEAR, Filter.LINEAR) : tex.setFilters(Filter.NEAREST, Filter.NEAREST);
            }
          }
        } else if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) {
          var ctx = cc.game.canvas.getContext("2d");
          ctx.imageSmoothingEnabled = enabled;
          ctx.mozImageSmoothingEnabled = enabled;
        }
      },
      isAntiAliasEnabled: function isAntiAliasEnabled() {
        return this._antiAliasEnabled;
      },
      enableAutoFullScreen: function enableAutoFullScreen(enabled) {
        if (enabled && enabled !== this._autoFullScreen && cc.sys.isMobile && cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT) {
          this._autoFullScreen = true;
          cc.screen.autoFullScreen(cc.game.frame);
        } else {
          this._autoFullScreen = false;
          cc.screen.disableAutoFullScreen(cc.game.frame);
        }
      },
      isAutoFullScreenEnabled: function isAutoFullScreenEnabled() {
        return this._autoFullScreen;
      },
      setCanvasSize: function setCanvasSize(width, height) {
        var canvas = cc.game.canvas;
        var container = cc.game.container;
        canvas.width = width * this._devicePixelRatio;
        canvas.height = height * this._devicePixelRatio;
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        container.style.width = width + "px";
        container.style.height = height + "px";
        this._resizeEvent();
      },
      getCanvasSize: function getCanvasSize() {
        return cc.size(cc.game.canvas.width, cc.game.canvas.height);
      },
      getFrameSize: function getFrameSize() {
        return cc.size(this._frameSize.width, this._frameSize.height);
      },
      setFrameSize: function setFrameSize(width, height) {
        this._frameSize.width = width;
        this._frameSize.height = height;
        cc.game.frame.style.width = width + "px";
        cc.game.frame.style.height = height + "px";
        this._resizeEvent(true);
      },
      getVisibleSize: function getVisibleSize() {
        return cc.size(this._visibleRect.width, this._visibleRect.height);
      },
      getVisibleSizeInPixel: function getVisibleSizeInPixel() {
        return cc.size(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY);
      },
      getVisibleOrigin: function getVisibleOrigin() {
        return cc.v2(this._visibleRect.x, this._visibleRect.y);
      },
      getVisibleOriginInPixel: function getVisibleOriginInPixel() {
        return cc.v2(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY);
      },
      getResolutionPolicy: function getResolutionPolicy() {
        return this._resolutionPolicy;
      },
      setResolutionPolicy: function setResolutionPolicy(resolutionPolicy) {
        var _t = this;
        if (resolutionPolicy instanceof cc.ResolutionPolicy) _t._resolutionPolicy = resolutionPolicy; else {
          var _locPolicy = cc.ResolutionPolicy;
          resolutionPolicy === _locPolicy.EXACT_FIT && (_t._resolutionPolicy = _t._rpExactFit);
          resolutionPolicy === _locPolicy.SHOW_ALL && (_t._resolutionPolicy = _t._rpShowAll);
          resolutionPolicy === _locPolicy.NO_BORDER && (_t._resolutionPolicy = _t._rpNoBorder);
          resolutionPolicy === _locPolicy.FIXED_HEIGHT && (_t._resolutionPolicy = _t._rpFixedHeight);
          resolutionPolicy === _locPolicy.FIXED_WIDTH && (_t._resolutionPolicy = _t._rpFixedWidth);
        }
      },
      setDesignResolutionSize: function setDesignResolutionSize(width, height, resolutionPolicy) {
        if (!(width > 0 || height > 0)) {
          cc.logID(2200);
          return;
        }
        this.setResolutionPolicy(resolutionPolicy);
        var policy = this._resolutionPolicy;
        policy && policy.preApply(this);
        cc.sys.isMobile && this._adjustViewportMeta();
        this._orientationChanging = true;
        this._resizing || this._initFrameSize();
        if (!policy) {
          cc.logID(2201);
          return;
        }
        this._originalDesignResolutionSize.width = this._designResolutionSize.width = width;
        this._originalDesignResolutionSize.height = this._designResolutionSize.height = height;
        var result = policy.apply(this, this._designResolutionSize);
        if (result.scale && 2 === result.scale.length) {
          this._scaleX = result.scale[0];
          this._scaleY = result.scale[1];
        }
        if (result.viewport) {
          var vp = this._viewportRect, vb = this._visibleRect, rv = result.viewport;
          vp.x = rv.x;
          vp.y = rv.y;
          vp.width = rv.width;
          vp.height = rv.height;
          vb.x = 0;
          vb.y = 0;
          vb.width = rv.width / this._scaleX;
          vb.height = rv.height / this._scaleY;
        }
        policy.postApply(this);
        cc.winSize.width = this._visibleRect.width;
        cc.winSize.height = this._visibleRect.height;
        cc.visibleRect && cc.visibleRect.init(this._visibleRect);
        renderer.updateCameraViewport();
        this.emit("design-resolution-changed");
      },
      getDesignResolutionSize: function getDesignResolutionSize() {
        return cc.size(this._designResolutionSize.width, this._designResolutionSize.height);
      },
      setRealPixelResolution: function setRealPixelResolution(width, height, resolutionPolicy) {
        if ((true, true) && !isBaiduGame && !isXiaomiGame) {
          this._setViewportMeta({
            width: width
          }, true);
          document.documentElement.style.width = width + "px";
          document.body.style.width = width + "px";
          document.body.style.left = "0px";
          document.body.style.top = "0px";
        }
        this.setDesignResolutionSize(width, height, resolutionPolicy);
      },
      setViewportInPoints: function setViewportInPoints(x, y, w, h) {
        var locScaleX = this._scaleX, locScaleY = this._scaleY;
        cc.game._renderContext.viewport(x * locScaleX + this._viewportRect.x, y * locScaleY + this._viewportRect.y, w * locScaleX, h * locScaleY);
      },
      setScissorInPoints: function setScissorInPoints(x, y, w, h) {
        var scaleX = this._scaleX, scaleY = this._scaleY;
        var sx = Math.ceil(x * scaleX + this._viewportRect.x);
        var sy = Math.ceil(y * scaleY + this._viewportRect.y);
        var sw = Math.ceil(w * scaleX);
        var sh = Math.ceil(h * scaleY);
        var gl = cc.game._renderContext;
        if (!_scissorRect) {
          var boxArr = gl.getParameter(gl.SCISSOR_BOX);
          _scissorRect = cc.rect(boxArr[0], boxArr[1], boxArr[2], boxArr[3]);
        }
        if (_scissorRect.x !== sx || _scissorRect.y !== sy || _scissorRect.width !== sw || _scissorRect.height !== sh) {
          _scissorRect.x = sx;
          _scissorRect.y = sy;
          _scissorRect.width = sw;
          _scissorRect.height = sh;
          gl.scissor(sx, sy, sw, sh);
        }
      },
      isScissorEnabled: function isScissorEnabled() {
        return cc.game._renderContext.isEnabled(gl.SCISSOR_TEST);
      },
      getScissorRect: function getScissorRect() {
        if (!_scissorRect) {
          var boxArr = gl.getParameter(gl.SCISSOR_BOX);
          _scissorRect = cc.rect(boxArr[0], boxArr[1], boxArr[2], boxArr[3]);
        }
        var scaleXFactor = 1 / this._scaleX;
        var scaleYFactor = 1 / this._scaleY;
        return cc.rect((_scissorRect.x - this._viewportRect.x) * scaleXFactor, (_scissorRect.y - this._viewportRect.y) * scaleYFactor, _scissorRect.width * scaleXFactor, _scissorRect.height * scaleYFactor);
      },
      getViewportRect: function getViewportRect() {
        return this._viewportRect;
      },
      getScaleX: function getScaleX() {
        return this._scaleX;
      },
      getScaleY: function getScaleY() {
        return this._scaleY;
      },
      getDevicePixelRatio: function getDevicePixelRatio() {
        return this._devicePixelRatio;
      },
      convertToLocationInView: function convertToLocationInView(tx, ty, relatedPos, out) {
        var result = out || cc.v2();
        var x = this._devicePixelRatio * (tx - relatedPos.left);
        var y = this._devicePixelRatio * (relatedPos.top + relatedPos.height - ty);
        if (this._isRotated) {
          result.x = cc.game.canvas.width - y;
          result.y = x;
        } else {
          result.x = x;
          result.y = y;
        }
        return result;
      },
      _convertMouseToLocationInView: function _convertMouseToLocationInView(in_out_point, relatedPos) {
        var viewport = this._viewportRect, _t = this;
        in_out_point.x = (_t._devicePixelRatio * (in_out_point.x - relatedPos.left) - viewport.x) / _t._scaleX;
        in_out_point.y = (_t._devicePixelRatio * (relatedPos.top + relatedPos.height - in_out_point.y) - viewport.y) / _t._scaleY;
      },
      _convertPointWithScale: function _convertPointWithScale(point) {
        var viewport = this._viewportRect;
        point.x = (point.x - viewport.x) / this._scaleX;
        point.y = (point.y - viewport.y) / this._scaleY;
      },
      _convertTouchesWithScale: function _convertTouchesWithScale(touches) {
        var viewport = this._viewportRect, scaleX = this._scaleX, scaleY = this._scaleY, selTouch, selPoint, selPrePoint;
        for (var i = 0; i < touches.length; i++) {
          selTouch = touches[i];
          selPoint = selTouch._point;
          selPrePoint = selTouch._prevPoint;
          selPoint.x = (selPoint.x - viewport.x) / scaleX;
          selPoint.y = (selPoint.y - viewport.y) / scaleY;
          selPrePoint.x = (selPrePoint.x - viewport.x) / scaleX;
          selPrePoint.y = (selPrePoint.y - viewport.y) / scaleY;
        }
      }
    });
    cc.ContainerStrategy = cc.Class({
      name: "ContainerStrategy",
      preApply: function preApply(view) {},
      apply: function apply(view, designedResolution) {},
      postApply: function postApply(view) {},
      _setupContainer: function _setupContainer(view, w, h) {
        var locCanvas = cc.game.canvas, locContainer = cc.game.container;
        if ((true, !isBaiduGame) && !isXiaomiGame) {
          if (cc.sys.os === cc.sys.OS_ANDROID) {
            document.body.style.width = (view._isRotated ? h : w) + "px";
            document.body.style.height = (view._isRotated ? w : h) + "px";
          }
          locContainer.style.width = locCanvas.style.width = w + "px";
          locContainer.style.height = locCanvas.style.height = h + "px";
        }
        var devicePixelRatio = view._devicePixelRatio = 1;
        view.isRetinaEnabled() && (devicePixelRatio = view._devicePixelRatio = Math.min(view._maxPixelRatio, window.devicePixelRatio || 1));
        locCanvas.width = w * devicePixelRatio;
        locCanvas.height = h * devicePixelRatio;
      },
      _fixContainer: function _fixContainer() {
        document.body.insertBefore(cc.game.container, document.body.firstChild);
        var bs = document.body.style;
        bs.width = window.innerWidth + "px";
        bs.height = window.innerHeight + "px";
        bs.overflow = "hidden";
        var contStyle = cc.game.container.style;
        contStyle.position = "fixed";
        contStyle.left = contStyle.top = "0px";
        document.body.scrollTop = 0;
      }
    });
    cc.ContentStrategy = cc.Class({
      name: "ContentStrategy",
      ctor: function ctor() {
        this._result = {
          scale: [ 1, 1 ],
          viewport: null
        };
      },
      _buildResult: function _buildResult(containerW, containerH, contentW, contentH, scaleX, scaleY) {
        Math.abs(containerW - contentW) < 2 && (contentW = containerW);
        Math.abs(containerH - contentH) < 2 && (contentH = containerH);
        var viewport = cc.rect((containerW - contentW) / 2, (containerH - contentH) / 2, contentW, contentH);
        cc.game.renderType === cc.game.RENDER_TYPE_CANVAS;
        this._result.scale = [ scaleX, scaleY ];
        this._result.viewport = viewport;
        return this._result;
      },
      preApply: function preApply(view) {},
      apply: function apply(view, designedResolution) {
        return {
          scale: [ 1, 1 ]
        };
      },
      postApply: function postApply(view) {}
    });
    (function() {
      var EqualToFrame = cc.Class({
        name: "EqualToFrame",
        extends: cc.ContainerStrategy,
        apply: function apply(view) {
          var frameH = view._frameSize.height, containerStyle = cc.game.container.style;
          this._setupContainer(view, view._frameSize.width, view._frameSize.height);
          view._isRotated ? containerStyle.margin = "0 0 0 " + frameH + "px" : containerStyle.margin = "0px";
          containerStyle.padding = "0px";
        }
      });
      var ProportionalToFrame = cc.Class({
        name: "ProportionalToFrame",
        extends: cc.ContainerStrategy,
        apply: function apply(view, designedResolution) {
          var frameW = view._frameSize.width, frameH = view._frameSize.height, containerStyle = cc.game.container.style, designW = designedResolution.width, designH = designedResolution.height, scaleX = frameW / designW, scaleY = frameH / designH, containerW, containerH;
          scaleX < scaleY ? (containerW = frameW, containerH = designH * scaleX) : (containerW = designW * scaleY, 
          containerH = frameH);
          var offx = Math.round((frameW - containerW) / 2);
          var offy = Math.round((frameH - containerH) / 2);
          containerW = frameW - 2 * offx;
          containerH = frameH - 2 * offy;
          this._setupContainer(view, containerW, containerH);
          true;
          view._isRotated ? containerStyle.margin = "0 0 0 " + frameH + "px" : containerStyle.margin = "0px";
          containerStyle.paddingLeft = offx + "px";
          containerStyle.paddingRight = offx + "px";
          containerStyle.paddingTop = offy + "px";
          containerStyle.paddingBottom = offy + "px";
        }
      });
      var EqualToWindow = cc.Class({
        name: "EqualToWindow",
        extends: EqualToFrame,
        preApply: function preApply(view) {
          this._super(view);
          cc.game.frame = document.documentElement;
        },
        apply: function apply(view) {
          this._super(view);
          this._fixContainer();
        }
      });
      var ProportionalToWindow = cc.Class({
        name: "ProportionalToWindow",
        extends: ProportionalToFrame,
        preApply: function preApply(view) {
          this._super(view);
          cc.game.frame = document.documentElement;
        },
        apply: function apply(view, designedResolution) {
          this._super(view, designedResolution);
          this._fixContainer();
        }
      });
      var OriginalContainer = cc.Class({
        name: "OriginalContainer",
        extends: cc.ContainerStrategy,
        apply: function apply(view) {
          this._setupContainer(view, cc.game.canvas.width, cc.game.canvas.height);
        }
      });
      cc.ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame();
      cc.ContainerStrategy.PROPORTION_TO_FRAME = new ProportionalToFrame();
      cc.ContainerStrategy.ORIGINAL_CONTAINER = new OriginalContainer();
      var ExactFit = cc.Class({
        name: "ExactFit",
        extends: cc.ContentStrategy,
        apply: function apply(view, designedResolution) {
          var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scaleX = containerW / designedResolution.width, scaleY = containerH / designedResolution.height;
          return this._buildResult(containerW, containerH, containerW, containerH, scaleX, scaleY);
        }
      });
      var ShowAll = cc.Class({
        name: "ShowAll",
        extends: cc.ContentStrategy,
        apply: function apply(view, designedResolution) {
          var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH, scale = 0, contentW, contentH;
          scaleX < scaleY ? (scale = scaleX, contentW = containerW, contentH = designH * scale) : (scale = scaleY, 
          contentW = designW * scale, contentH = containerH);
          return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        }
      });
      var NoBorder = cc.Class({
        name: "NoBorder",
        extends: cc.ContentStrategy,
        apply: function apply(view, designedResolution) {
          var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH, scale, contentW, contentH;
          scaleX < scaleY ? (scale = scaleY, contentW = designW * scale, contentH = containerH) : (scale = scaleX, 
          contentW = containerW, contentH = designH * scale);
          return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        }
      });
      var FixedHeight = cc.Class({
        name: "FixedHeight",
        extends: cc.ContentStrategy,
        apply: function apply(view, designedResolution) {
          var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designH = designedResolution.height, scale = containerH / designH, contentW = containerW, contentH = containerH;
          return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        }
      });
      var FixedWidth = cc.Class({
        name: "FixedWidth",
        extends: cc.ContentStrategy,
        apply: function apply(view, designedResolution) {
          var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, scale = containerW / designW, contentW = containerW, contentH = containerH;
          return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        }
      });
      cc.ContentStrategy.EXACT_FIT = new ExactFit();
      cc.ContentStrategy.SHOW_ALL = new ShowAll();
      cc.ContentStrategy.NO_BORDER = new NoBorder();
      cc.ContentStrategy.FIXED_HEIGHT = new FixedHeight();
      cc.ContentStrategy.FIXED_WIDTH = new FixedWidth();
    })();
    cc.ResolutionPolicy = cc.Class({
      name: "cc.ResolutionPolicy",
      ctor: function ctor(containerStg, contentStg) {
        this._containerStrategy = null;
        this._contentStrategy = null;
        this.setContainerStrategy(containerStg);
        this.setContentStrategy(contentStg);
      },
      preApply: function preApply(view) {
        this._containerStrategy.preApply(view);
        this._contentStrategy.preApply(view);
      },
      apply: function apply(view, designedResolution) {
        this._containerStrategy.apply(view, designedResolution);
        return this._contentStrategy.apply(view, designedResolution);
      },
      postApply: function postApply(view) {
        this._containerStrategy.postApply(view);
        this._contentStrategy.postApply(view);
      },
      setContainerStrategy: function setContainerStrategy(containerStg) {
        containerStg instanceof cc.ContainerStrategy && (this._containerStrategy = containerStg);
      },
      setContentStrategy: function setContentStrategy(contentStg) {
        contentStg instanceof cc.ContentStrategy && (this._contentStrategy = contentStg);
      }
    });
    js.get(cc.ResolutionPolicy.prototype, "canvasSize", (function() {
      return cc.v2(cc.game.canvas.width, cc.game.canvas.height);
    }));
    cc.ResolutionPolicy.EXACT_FIT = 0;
    cc.ResolutionPolicy.NO_BORDER = 1;
    cc.ResolutionPolicy.SHOW_ALL = 2;
    cc.ResolutionPolicy.FIXED_HEIGHT = 3;
    cc.ResolutionPolicy.FIXED_WIDTH = 4;
    cc.ResolutionPolicy.UNKNOWN = 5;
    cc.view = new View();
    cc.winSize = cc.v2();
    module.exports = cc.view;
  }), {
    "../event/event-target": 72,
    "../platform/CCClass": 104,
    "../platform/js": 124,
    "../renderer": 147
  } ],
  115: [ (function(require, module, exports) {
    "use strict";
    cc.visibleRect = {
      topLeft: cc.v2(0, 0),
      topRight: cc.v2(0, 0),
      top: cc.v2(0, 0),
      bottomLeft: cc.v2(0, 0),
      bottomRight: cc.v2(0, 0),
      bottom: cc.v2(0, 0),
      center: cc.v2(0, 0),
      left: cc.v2(0, 0),
      right: cc.v2(0, 0),
      width: 0,
      height: 0,
      init: function init(visibleRect) {
        var w = this.width = visibleRect.width;
        var h = this.height = visibleRect.height;
        var l = visibleRect.x, b = visibleRect.y, t = b + h, r = l + w;
        this.topLeft.x = l;
        this.topLeft.y = t;
        this.topRight.x = r;
        this.topRight.y = t;
        this.top.x = l + w / 2;
        this.top.y = t;
        this.bottomLeft.x = l;
        this.bottomLeft.y = b;
        this.bottomRight.x = r;
        this.bottomRight.y = b;
        this.bottom.x = l + w / 2;
        this.bottom.y = b;
        this.center.x = l + w / 2;
        this.center.y = b + h / 2;
        this.left.x = l;
        this.left.y = b + h / 2;
        this.right.x = r;
        this.right.y = b + h / 2;
      }
    };
  }), {} ],
  116: [ (function(require, module, exports) {
    "use strict";
    var js = require("./js");
    var isPlainEmptyObj = require("./utils").isPlainEmptyObj_DEV;
    var DELIMETER = "$_$";
    function createAttrsSingle(owner, ownerCtor, superAttrs) {
      var AttrsCtor;
      var ctorName;
      false;
      AttrsCtor = function AttrsCtor() {};
      superAttrs && js.extend(AttrsCtor, superAttrs.constructor);
      var attrs = new AttrsCtor();
      js.value(owner, "__attrs__", attrs);
      return attrs;
    }
    function createAttrs(subclass) {
      var superClass;
      var chains = cc.Class.getInheritanceChain(subclass);
      for (var i = chains.length - 1; i >= 0; i--) {
        var cls = chains[i];
        var attrs = cls.hasOwnProperty("__attrs__") && cls.__attrs__;
        if (!attrs) {
          superClass = chains[i + 1];
          createAttrsSingle(cls, cls, superClass && superClass.__attrs__);
        }
      }
      superClass = chains[0];
      createAttrsSingle(subclass, subclass, superClass && superClass.__attrs__);
      return subclass.__attrs__;
    }
    function attr(ctor, propName, newAttrs) {
      var attrs, setter, key;
      if ("function" === typeof ctor) {
        attrs = getClassAttrs(ctor);
        setter = attrs.constructor.prototype;
      } else {
        var instance = ctor;
        attrs = instance.__attrs__;
        if (!attrs) {
          ctor = instance.constructor;
          var clsAttrs = getClassAttrs(ctor);
          attrs = createAttrsSingle(instance, ctor, clsAttrs);
        }
        setter = attrs;
      }
      if ("undefined" === typeof newAttrs) {
        var prefix = propName + DELIMETER;
        var ret = {};
        for (key in attrs) key.startsWith(prefix) && (ret[key.slice(prefix.length)] = attrs[key]);
        return ret;
      }
      if ("object" === typeof newAttrs) for (key in newAttrs) 95 !== key.charCodeAt(0) && (setter[propName + DELIMETER + key] = newAttrs[key]); else false;
    }
    function getClassAttrs(ctor) {
      return ctor.hasOwnProperty("__attrs__") && ctor.__attrs__ || createAttrs(ctor);
    }
    function getClassAttrsProto(ctor) {
      return getClassAttrs(ctor).constructor.prototype;
    }
    function setClassAttr(ctor, propName, key, value) {
      var proto = getClassAttrsProto(ctor);
      proto[propName + DELIMETER + key] = value;
    }
    cc.Integer = "Integer";
    cc.Float = "Float";
    false;
    cc.Boolean = "Boolean";
    cc.String = "String";
    function getTypeChecker(type, attrName) {
      false;
    }
    function ObjectType(typeCtor) {
      return {
        type: "Object",
        ctor: typeCtor,
        _onAfterProp: false
      };
    }
    module.exports = {
      attr: attr,
      getClassAttrs: getClassAttrs,
      getClassAttrsProto: getClassAttrsProto,
      setClassAttr: setClassAttr,
      DELIMETER: DELIMETER,
      getTypeChecker: getTypeChecker,
      ObjectType: ObjectType,
      ScriptUuid: {}
    };
  }), {
    "./CCClass": 104,
    "./js": 124,
    "./utils": 128
  } ],
  117: [ (function(require, module, exports) {
    "use strict";
    var js = require("./js");
    var fastRemoveAt = js.array.fastRemoveAt;
    function CallbackList() {
      this.callbacks = [];
      this.targets = [];
      this.isInvoking = false;
      this.containCanceled = false;
    }
    var proto = CallbackList.prototype;
    proto.removeBy = function(array, value) {
      var callbacks = this.callbacks;
      var targets = this.targets;
      for (var i = 0; i < array.length; ++i) if (array[i] === value) {
        fastRemoveAt(callbacks, i);
        fastRemoveAt(targets, i);
        --i;
      }
    };
    proto.cancel = function(index) {
      this.callbacks[index] = this.targets[index] = null;
      this.containCanceled = true;
    };
    proto.cancelAll = function() {
      var callbacks = this.callbacks;
      var targets = this.targets;
      for (var i = 0; i < callbacks.length; i++) callbacks[i] = targets[i] = null;
      this.containCanceled = true;
    };
    proto.purgeCanceled = function() {
      this.removeBy(this.callbacks, null);
      this.containCanceled = false;
    };
    var MAX_SIZE = 16;
    var callbackListPool = new js.Pool(function(list) {
      list.callbacks.length = 0;
      list.targets.length = 0;
      list.isInvoking = false;
      list.containCanceled = false;
    }, MAX_SIZE);
    callbackListPool.get = function() {
      return this._get() || new CallbackList();
    };
    function CallbacksHandler() {
      this._callbackTable = js.createMap(true);
    }
    proto = CallbacksHandler.prototype;
    proto.add = function(key, callback, target) {
      var list = this._callbackTable[key];
      list || (list = this._callbackTable[key] = callbackListPool.get());
      list.callbacks.push(callback);
      list.targets.push(target || null);
    };
    proto.hasEventListener = function(key, callback, target) {
      var list = this._callbackTable[key];
      if (!list) return false;
      var callbacks = list.callbacks;
      if (!callback) {
        if (list.isInvoking) {
          for (var i = 0; i < callbacks.length; i++) if (callbacks[i]) return true;
          return false;
        }
        return callbacks.length > 0;
      }
      target = target || null;
      var targets = list.targets;
      for (var _i = 0; _i < callbacks.length; ++_i) if (callbacks[_i] === callback && targets[_i] === target) return true;
      return false;
    };
    proto.removeAll = function(keyOrTarget) {
      if ("string" === typeof keyOrTarget) {
        var list = this._callbackTable[keyOrTarget];
        if (list) if (list.isInvoking) list.cancelAll(); else {
          callbackListPool.put(list);
          delete this._callbackTable[keyOrTarget];
        }
      } else if (keyOrTarget) for (var key in this._callbackTable) {
        var _list = this._callbackTable[key];
        if (_list.isInvoking) {
          var targets = _list.targets;
          for (var i = 0; i < targets.length; ++i) targets[i] === keyOrTarget && _list.cancel(i);
        } else _list.removeBy(_list.targets, keyOrTarget);
      }
    };
    proto.remove = function(key, callback, target) {
      var list = this._callbackTable[key];
      if (list) {
        target = target || null;
        var callbacks = list.callbacks;
        var targets = list.targets;
        for (var i = 0; i < callbacks.length; ++i) if (callbacks[i] === callback && targets[i] === target) {
          if (list.isInvoking) list.cancel(i); else {
            fastRemoveAt(callbacks, i);
            fastRemoveAt(targets, i);
          }
          break;
        }
      }
    };
    var CallbacksInvoker = function CallbacksInvoker() {
      CallbacksHandler.call(this);
    };
    js.extend(CallbacksInvoker, CallbacksHandler);
    false;
    CallbacksInvoker.prototype.invoke = function(key, p1, p2, p3, p4, p5) {
      var list = this._callbackTable[key];
      if (list) {
        var rootInvoker = !list.isInvoking;
        list.isInvoking = true;
        var callbacks = list.callbacks;
        var targets = list.targets;
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          var callback = callbacks[i];
          if (callback) {
            var target = targets[i];
            target ? callback.call(target, p1, p2, p3, p4, p5) : callback(p1, p2, p3, p4, p5);
          }
        }
        if (rootInvoker) {
          list.isInvoking = false;
          list.containCanceled && list.purgeCanceled();
        }
      }
    };
    CallbacksInvoker.CallbacksHandler = CallbacksHandler;
    module.exports = CallbacksInvoker;
  }), {
    "./js": 124
  } ],
  118: [ (function(require, module, exports) {
    "use strict";
    function deepFlatten(strList, array) {
      for (var i = 0; i < array.length; i++) {
        var item = array[i];
        Array.isArray(item) ? deepFlatten(strList, item) : strList.push(item);
      }
    }
    function flattenCodeArray(array) {
      var separator = "";
      var strList = [];
      deepFlatten(strList, array);
      return strList.join(separator);
    }
    module.exports = {
      flattenCodeArray: flattenCodeArray
    };
  }), {} ],
  119: [ (function(require, module, exports) {
    "use strict";
    var js = require("./js");
    var Attr = require("./attribute");
    var CCClass = require("./CCClass");
    var misc = require("../utils/misc");
    var Details = function Details() {
      this.uuidList = [];
      this.uuidObjList = [];
      this.uuidPropList = [];
      this._stillUseUrl = js.createMap(true);
    };
    Details.prototype.reset = function() {
      this.uuidList.length = 0;
      this.uuidObjList.length = 0;
      this.uuidPropList.length = 0;
      js.clear(this._stillUseUrl);
    };
    false, false;
    Details.prototype.push = function(obj, propName, uuid, _stillUseUrl) {
      _stillUseUrl && (this._stillUseUrl[this.uuidList.length] = true);
      this.uuidList.push(uuid);
      this.uuidObjList.push(obj);
      this.uuidPropList.push(propName);
    };
    Details.pool = new js.Pool(function(obj) {
      obj.reset();
    }, 10);
    Details.pool.get = function() {
      return this._get() || new Details();
    };
    var _Deserializer = (function() {
      function _Deserializer(result, target, classFinder, customEnv, ignoreEditorOnly) {
        this.result = result;
        this.customEnv = customEnv;
        this.deserializedList = [];
        this.deserializedData = null;
        this._classFinder = classFinder;
        false;
        this._idList = [];
        this._idObjList = [];
        this._idPropList = [];
      }
      function _dereference(self) {
        var deserializedList = self.deserializedList;
        var idPropList = self._idPropList;
        var idList = self._idList;
        var idObjList = self._idObjList;
        var onDereferenced = self._classFinder && self._classFinder.onDereferenced;
        var i, propName, id;
        false;
        for (i = 0; i < idList.length; i++) {
          propName = idPropList[i];
          id = idList[i];
          idObjList[i][propName] = deserializedList[id];
        }
      }
      var prototype = _Deserializer.prototype;
      prototype.deserialize = function(jsonObj) {
        if (Array.isArray(jsonObj)) {
          var jsonArray = jsonObj;
          var refCount = jsonArray.length;
          this.deserializedList.length = refCount;
          for (var i = 0; i < refCount; i++) if (jsonArray[i]) {
            var mainTarget;
            false, false;
            this.deserializedList[i] = this._deserializeObject(jsonArray[i], false);
          }
          this.deserializedData = refCount > 0 ? this.deserializedList[0] : [];
        } else {
          this.deserializedList.length = 1;
          false, false;
          this.deserializedData = jsonObj ? this._deserializeObject(jsonObj, false) : null;
          this.deserializedList[0] = this.deserializedData;
        }
        _dereference(this);
        return this.deserializedData;
      };
      prototype._deserializeObject = function(serialized, _stillUseUrl, target, owner, propName) {
        var prop;
        var obj = null;
        var klass = null;
        var type = serialized.__type__;
        if (type) {
          klass = this._classFinder(type, serialized, owner, propName);
          if (!klass) {
            var notReported = this._classFinder === js._getClassById;
            notReported && cc.deserialize.reportMissingClass(type);
            return null;
          }
          if ((false, false) && target) {
            target instanceof klass || cc.warnID(5300, js.getClassName(target), klass);
            obj = target;
          } else obj = new klass();
          if (obj._deserialize) {
            obj._deserialize(serialized.content, this);
            return obj;
          }
          cc.Class._isCCClass(klass) ? _deserializeFireClass(this, obj, serialized, klass, target) : this._deserializeTypedObject(obj, serialized, klass);
        } else if (Array.isArray(serialized)) {
          if ((false, false) && target) {
            target.length = serialized.length;
            obj = target;
          } else obj = new Array(serialized.length);
          for (var i = 0; i < serialized.length; i++) {
            prop = serialized[i];
            if ("object" === typeof prop && prop) {
              false, false;
              this._deserializeObjField(obj, prop, "" + i, null, _stillUseUrl);
            } else obj[i] = prop;
          }
        } else {
          obj = (false, false) && target || {};
          this._deserializePrimitiveObject(obj, serialized);
        }
        return obj;
      };
      prototype._deserializeObjField = function(obj, jsonObj, propName, target, _stillUseUrl) {
        var id = jsonObj.__id__;
        if (void 0 === id) {
          var uuid = jsonObj.__uuid__;
          if (uuid) this.result.push(obj, propName, uuid, _stillUseUrl); else {
            false, false;
            obj[propName] = this._deserializeObject(jsonObj, _stillUseUrl);
          }
        } else {
          var dObj = this.deserializedList[id];
          if (dObj) obj[propName] = dObj; else {
            this._idList.push(id);
            this._idObjList.push(obj);
            this._idPropList.push(propName);
          }
        }
      };
      prototype._deserializePrimitiveObject = function(instance, serialized) {
        var self = this;
        for (var propName in serialized) if (serialized.hasOwnProperty(propName)) {
          var prop = serialized[propName];
          if ("object" !== typeof prop) "__type__" !== propName && (instance[propName] = prop); else if (prop) {
            false, false;
            self._deserializeObjField(instance, prop, propName);
          } else instance[propName] = null;
        }
      };
      prototype._deserializeTypedObject = function(instance, serialized, klass) {
        if (klass === cc.Vec2) {
          instance.x = serialized.x || 0;
          instance.y = serialized.y || 0;
          return;
        }
        if (klass === cc.Vec3) {
          instance.x = serialized.x || 0;
          instance.y = serialized.y || 0;
          instance.z = serialized.z || 0;
          return;
        }
        if (klass === cc.Color) {
          instance.r = serialized.r || 0;
          instance.g = serialized.g || 0;
          instance.b = serialized.b || 0;
          var a = serialized.a;
          instance.a = void 0 === a ? 255 : a;
          return;
        }
        if (klass === cc.Size) {
          instance.width = serialized.width || 0;
          instance.height = serialized.height || 0;
          return;
        }
        var DEFAULT = Attr.DELIMETER + "default";
        var attrs = Attr.getClassAttrs(klass);
        var fastDefinedProps = klass.__props__ || Object.keys(instance);
        for (var i = 0; i < fastDefinedProps.length; i++) {
          var propName = fastDefinedProps[i];
          var value = serialized[propName];
          void 0 !== value && serialized.hasOwnProperty(propName) || (value = CCClass.getDefault(attrs[propName + DEFAULT]));
          if ("object" !== typeof value) instance[propName] = value; else if (value) {
            false, false;
            this._deserializeObjField(instance, value, propName);
          } else instance[propName] = null;
        }
      };
      function compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, assumeHavePropIfIsValue, stillUseUrl) {
        if (defaultValue instanceof cc.ValueType) {
          assumeHavePropIfIsValue || sources.push("if(prop){");
          var ctorCode = js.getClassName(defaultValue);
          sources.push("s._deserializeTypedObject(o" + accessorToSet + ",prop," + ctorCode + ");");
          assumeHavePropIfIsValue || sources.push("}else o" + accessorToSet + "=null;");
        } else {
          sources.push("if(prop){");
          sources.push("s._deserializeObjField(o,prop," + propNameLiteralToSet + (false, ",null,") + !!stillUseUrl + ");");
          sources.push("}else o" + accessorToSet + "=null;");
        }
      }
      var compileDeserialize = function(self, klass) {
        var TYPE = Attr.DELIMETER + "type";
        var EDITOR_ONLY = Attr.DELIMETER + "editorOnly";
        var DEFAULT = Attr.DELIMETER + "default";
        var SAVE_URL_AS_ASSET = Attr.DELIMETER + "saveUrlAsAsset";
        var FORMERLY_SERIALIZED_AS = Attr.DELIMETER + "formerlySerializedAs";
        var attrs = Attr.getClassAttrs(klass);
        var props = klass.__values__;
        var sources = [ "var prop;" ];
        var fastMode = misc.BUILTIN_CLASSID_RE.test(js._getClassId(klass));
        for (var p = 0; p < props.length; p++) {
          var propName = props[p];
          if ((false, false) && attrs[propName + EDITOR_ONLY]) continue;
          var accessorToSet, propNameLiteralToSet;
          if (CCClass.IDENTIFIER_RE.test(propName)) {
            propNameLiteralToSet = '"' + propName + '"';
            accessorToSet = "." + propName;
          } else {
            propNameLiteralToSet = CCClass.escapeForJS(propName);
            accessorToSet = "[" + propNameLiteralToSet + "]";
          }
          var accessorToGet = accessorToSet;
          if (attrs[propName + FORMERLY_SERIALIZED_AS]) {
            var propNameToRead = attrs[propName + FORMERLY_SERIALIZED_AS];
            accessorToGet = CCClass.IDENTIFIER_RE.test(propNameToRead) ? "." + propNameToRead : "[" + CCClass.escapeForJS(propNameToRead) + "]";
          }
          sources.push("prop=d" + accessorToGet + ";");
          sources.push("if(typeof " + (false, "prop") + '!=="undefined"){');
          var stillUseUrl = attrs[propName + SAVE_URL_AS_ASSET];
          var defaultValue = CCClass.getDefault(attrs[propName + DEFAULT]);
          if (fastMode) {
            var isPrimitiveType;
            var userType = attrs[propName + TYPE];
            if (void 0 === defaultValue && userType) isPrimitiveType = userType === cc.String || userType === cc.Integer || userType === cc.Float || userType === cc.Boolean; else {
              var defaultType = typeof defaultValue;
              isPrimitiveType = "string" === defaultType && !stillUseUrl || "number" === defaultType || "boolean" === defaultType;
            }
            isPrimitiveType ? sources.push("o" + accessorToSet + "=prop;") : compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, true, stillUseUrl);
          } else {
            sources.push("if(typeof " + (false, "prop") + '!=="object"){o' + accessorToSet + "=prop;}else{");
            compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, false, stillUseUrl);
            sources.push("}");
          }
          sources.push("}");
        }
        if (cc.js.isChildClassOf(klass, cc._BaseNode) || cc.js.isChildClassOf(klass, cc.Component)) {
          var mayUsedInPersistRoot;
          false, false;
          sources.push("d._id&&(o._id=d._id);");
        }
        if ("_$erialized" === props[props.length - 1]) {
          sources.push("o._$erialized=JSON.parse(JSON.stringify(d));");
          sources.push("s._deserializePrimitiveObject(o._$erialized,d);");
        }
        return Function("s", "o", "d", "k", "t", sources.join(""));
      };
      function unlinkUnusedPrefab(self, serialized, obj) {
        var uuid = serialized["asset"] && serialized["asset"].__uuid__;
        if (uuid) {
          var last = self.result.uuidList.length - 1;
          if (self.result.uuidList[last] === uuid && self.result.uuidObjList[last] === obj && "asset" === self.result.uuidPropList[last]) {
            self.result.uuidList.pop();
            self.result.uuidObjList.pop();
            self.result.uuidPropList.pop();
          } else {
            var debugEnvOnlyInfo = "Failed to skip prefab asset while deserializing PrefabInfo";
            cc.warn(debugEnvOnlyInfo);
          }
        }
      }
      function _deserializeFireClass(self, obj, serialized, klass, target) {
        var deserialize;
        if (klass.hasOwnProperty("__deserialize__")) deserialize = klass.__deserialize__; else {
          deserialize = compileDeserialize(self, klass);
          js.value(klass, "__deserialize__", deserialize, true);
        }
        deserialize(self, obj, serialized, klass, target);
        false, false;
      }
      _Deserializer.pool = new js.Pool(function(obj) {
        obj.result = null;
        obj.customEnv = null;
        obj.deserializedList.length = 0;
        obj.deserializedData = null;
        obj._classFinder = null;
        false;
        obj._idList.length = 0;
        obj._idObjList.length = 0;
        obj._idPropList.length = 0;
      }, 1);
      _Deserializer.pool.get = function(result, target, classFinder, customEnv, ignoreEditorOnly) {
        var cache = this._get();
        if (cache) {
          cache.result = result;
          cache.customEnv = customEnv;
          cache._classFinder = classFinder;
          false;
          return cache;
        }
        return new _Deserializer(result, target, classFinder, customEnv, ignoreEditorOnly);
      };
      return _Deserializer;
    })();
    cc.deserialize = function(data, details, options) {
      options = options || {};
      var classFinder = options.classFinder || js._getClassById;
      var createAssetRefs = options.createAssetRefs || cc.sys.platform === cc.sys.EDITOR_CORE;
      var target = (false, false) && options.target;
      var customEnv = options.customEnv;
      var ignoreEditorOnly = options.ignoreEditorOnly;
      false;
      "string" === typeof data && (data = JSON.parse(data));
      var tempDetails = !details;
      details = details || Details.pool.get();
      var deserializer = _Deserializer.pool.get(details, target, classFinder, customEnv, ignoreEditorOnly);
      cc.game._isCloning = true;
      var res = deserializer.deserialize(data);
      cc.game._isCloning = false;
      _Deserializer.pool.put(deserializer);
      createAssetRefs && details.assignAssetsBy(Editor.serialize.asAsset);
      tempDetails && Details.pool.put(details);
      return res;
    };
    cc.deserialize.Details = Details;
    cc.deserialize.reportMissingClass = function(id) {
      false;
      cc.warnID(5302, id);
    };
  }), {
    "../utils/misc": 187,
    "./CCClass": 104,
    "./attribute": 116,
    "./js": 124
  } ],
  120: [ (function(require, module, exports) {
    "use strict";
    var NonUuidMark = ".";
    function IdGenerater(category) {
      this.id = 0 | 998 * Math.random();
      this.prefix = category ? category + NonUuidMark : "";
    }
    IdGenerater.prototype.getNewId = function() {
      return this.prefix + ++this.id;
    };
    IdGenerater.global = new IdGenerater("global");
    module.exports = IdGenerater;
  }), {} ],
  121: [ (function(require, module, exports) {
    "use strict";
    require("./js");
    require("./CCClass");
    require("./CCClassDecorator");
    require("./CCEnum");
    require("./CCObject");
    require("./callbacks-invoker");
    require("./url");
    require("./deserialize");
    require("./instantiate");
    require("./instantiate-jit");
    require("./requiring-frame");
    require("./CCSys");
    require("./CCMacro");
    true;
    require("./CCAssetLibrary");
    require("./CCVisibleRect");
  }), {
    "./CCAssetLibrary": 103,
    "./CCClass": 104,
    "./CCClassDecorator": 105,
    "./CCEnum": 106,
    "./CCMacro": 109,
    "./CCObject": 110,
    "./CCSys": 113,
    "./CCVisibleRect": 115,
    "./callbacks-invoker": 117,
    "./deserialize": 119,
    "./instantiate": 123,
    "./instantiate-jit": 122,
    "./js": 124,
    "./requiring-frame": 126,
    "./url": 127
  } ],
  122: [ (function(require, module, exports) {
    "use strict";
    var CCObject = require("./CCObject");
    var Destroyed = CCObject.Flags.Destroyed;
    var PersistentMask = CCObject.Flags.PersistentMask;
    var Attr = require("./attribute");
    var js = require("./js");
    var CCClass = require("./CCClass");
    var Compiler = require("./compiler");
    var DEFAULT = Attr.DELIMETER + "default";
    var IDENTIFIER_RE = CCClass.IDENTIFIER_RE;
    var escapeForJS = CCClass.escapeForJS;
    var VAR = "var ";
    var LOCAL_OBJ = "o";
    var LOCAL_TEMP_OBJ = "t";
    var LOCAL_ARRAY = "a";
    var LINE_INDEX_OF_NEW_OBJ = 0;
    var DEFAULT_MODULE_CACHE = {
      "cc.Node": "cc.Node",
      "cc.Sprite": "cc.Sprite",
      "cc.Label": "cc.Label",
      "cc.Button": "cc.Button",
      "cc.Widget": "cc.Widget",
      "cc.Animation": "cc.Animation",
      "cc.ClickEvent": false,
      "cc.PrefabInfo": false
    };
    function Declaration(varName, expression) {
      this.varName = varName;
      this.expression = expression;
    }
    Declaration.prototype.toString = function() {
      return VAR + this.varName + "=" + this.expression + ";";
    };
    function mergeDeclaration(statement, expression) {
      return expression instanceof Declaration ? new Declaration(expression.varName, statement + expression.expression) : statement + expression;
    }
    function writeAssignment(codeArray, statement, expression) {
      if (Array.isArray(expression)) {
        expression[0] = mergeDeclaration(statement, expression[0]);
        codeArray.push(expression);
      } else codeArray.push(mergeDeclaration(statement, expression) + ";");
    }
    function Assignments(targetExpression) {
      this._exps = [];
      this._targetExp = targetExpression;
    }
    Assignments.prototype.append = function(key, expression) {
      this._exps.push([ key, expression ]);
    };
    Assignments.prototype.writeCode = function(codeArray) {
      var targetVar;
      if (this._exps.length > 1) {
        codeArray.push(LOCAL_TEMP_OBJ + "=" + this._targetExp + ";");
        targetVar = LOCAL_TEMP_OBJ;
      } else {
        if (1 !== this._exps.length) return;
        targetVar = this._targetExp;
      }
      for (var i = 0; i < this._exps.length; i++) {
        var pair = this._exps[i];
        writeAssignment(codeArray, targetVar + getPropAccessor(pair[0]) + "=", pair[1]);
      }
    };
    Assignments.pool = new js.Pool(function(obj) {
      obj._exps.length = 0;
      obj._targetExp = null;
    }, 1);
    Assignments.pool.get = function(targetExpression) {
      var cache = this._get() || new Assignments();
      cache._targetExp = targetExpression;
      return cache;
    };
    function equalsToDefault(def, value) {
      if ("function" === typeof def) try {
        def = def();
      } catch (e) {
        return false;
      }
      if (def === value) return true;
      if (def && value) {
        if (def instanceof cc.ValueType && def.equals(value)) return true;
        if (Array.isArray(def) && Array.isArray(value) || def.constructor === Object && value.constructor === Object) try {
          return Array.isArray(def) && Array.isArray(value) && 0 === def.length && 0 === value.length;
        } catch (e) {}
      }
      return false;
    }
    function getPropAccessor(key) {
      return IDENTIFIER_RE.test(key) ? "." + key : "[" + escapeForJS(key) + "]";
    }
    function Parser(obj, parent) {
      this.parent = parent;
      this.objsToClear_iN$t = [];
      this.codeArray = [];
      this.objs = [];
      this.funcs = [];
      this.funcModuleCache = js.createMap();
      js.mixin(this.funcModuleCache, DEFAULT_MODULE_CACHE);
      this.globalVariables = [];
      this.globalVariableId = 0;
      this.localVariableId = 0;
      this.codeArray.push(VAR + LOCAL_OBJ + "," + LOCAL_TEMP_OBJ + ";", "if(R){", LOCAL_OBJ + "=R;", "}else{", LOCAL_OBJ + "=R=new " + this.getFuncModule(obj.constructor, true) + "();", "}");
      js.value(obj, "_iN$t", {
        globalVar: "R"
      }, true);
      this.objsToClear_iN$t.push(obj);
      this.enumerateObject(this.codeArray, obj);
      var globalVariablesDeclaration;
      this.globalVariables.length > 0 && (globalVariablesDeclaration = VAR + this.globalVariables.join(",") + ";");
      var code = Compiler.flattenCodeArray([ "return (function(R){", globalVariablesDeclaration || [], this.codeArray, "return o;", "})" ]);
      this.result = Function("O", "F", code)(this.objs, this.funcs);
      for (var i = 0, len = this.objsToClear_iN$t.length; i < len; ++i) this.objsToClear_iN$t[i]._iN$t = null;
      this.objsToClear_iN$t.length = 0;
    }
    var proto = Parser.prototype;
    proto.getFuncModule = function(func, usedInNew) {
      var clsName = js.getClassName(func);
      if (clsName) {
        var cache = this.funcModuleCache[clsName];
        if (cache) return cache;
        if (void 0 === cache) {
          var clsNameIsModule = -1 !== clsName.indexOf(".");
          if (clsNameIsModule) try {
            clsNameIsModule = func === Function("return " + clsName)();
            if (clsNameIsModule) {
              this.funcModuleCache[clsName] = clsName;
              return clsName;
            }
          } catch (e) {}
        }
      }
      var index = this.funcs.indexOf(func);
      if (index < 0) {
        index = this.funcs.length;
        this.funcs.push(func);
      }
      var res = "F[" + index + "]";
      usedInNew && (res = "(" + res + ")");
      this.funcModuleCache[clsName] = res;
      return res;
    };
    proto.getObjRef = function(obj) {
      var index = this.objs.indexOf(obj);
      if (index < 0) {
        index = this.objs.length;
        this.objs.push(obj);
      }
      return "O[" + index + "]";
    };
    proto.setValueType = function(codeArray, defaultValue, srcValue, targetExpression) {
      var assignments = Assignments.pool.get(targetExpression);
      var fastDefinedProps = defaultValue.constructor.__props__;
      fastDefinedProps || (fastDefinedProps = Object.keys(defaultValue));
      for (var i = 0; i < fastDefinedProps.length; i++) {
        var propName = fastDefinedProps[i];
        var prop = srcValue[propName];
        if (defaultValue[propName] === prop) continue;
        var expression = this.enumerateField(srcValue, propName, prop);
        assignments.append(propName, expression);
      }
      assignments.writeCode(codeArray);
      Assignments.pool.put(assignments);
    };
    proto.enumerateCCClass = function(codeArray, obj, klass) {
      var props = klass.__values__;
      var attrs = Attr.getClassAttrs(klass);
      for (var p = 0; p < props.length; p++) {
        var key = props[p];
        var val = obj[key];
        var defaultValue = attrs[key + DEFAULT];
        if (equalsToDefault(defaultValue, val)) continue;
        if ("object" === typeof val && val instanceof cc.ValueType) {
          defaultValue = CCClass.getDefault(defaultValue);
          if (defaultValue && defaultValue.constructor === val.constructor) {
            var targetExpression = LOCAL_OBJ + getPropAccessor(key);
            this.setValueType(codeArray, defaultValue, val, targetExpression);
            continue;
          }
        }
        this.setObjProp(codeArray, obj, key, val);
      }
    };
    proto.instantiateArray = function(value) {
      if (0 === value.length) return "[]";
      var arrayVar = LOCAL_ARRAY + ++this.localVariableId;
      var declaration = new Declaration(arrayVar, "new Array(" + value.length + ")");
      var codeArray = [ declaration ];
      js.value(value, "_iN$t", {
        globalVar: "",
        source: codeArray
      }, true);
      this.objsToClear_iN$t.push(value);
      for (var i = 0; i < value.length; ++i) {
        var statement = arrayVar + "[" + i + "]=";
        var expression = this.enumerateField(value, i, value[i]);
        writeAssignment(codeArray, statement, expression);
      }
      return codeArray;
    };
    proto.enumerateField = function(obj, key, value) {
      if ("object" === typeof value && value) {
        var _iN$t = value._iN$t;
        if (_iN$t) {
          var globalVar = _iN$t.globalVar;
          if (!globalVar) {
            globalVar = _iN$t.globalVar = "v" + ++this.globalVariableId;
            this.globalVariables.push(globalVar);
            var line = _iN$t.source[LINE_INDEX_OF_NEW_OBJ];
            _iN$t.source[LINE_INDEX_OF_NEW_OBJ] = mergeDeclaration(globalVar + "=", line);
          }
          return globalVar;
        }
        return Array.isArray(value) ? this.instantiateArray(value) : this.instantiateObj(value);
      }
      if ("function" === typeof value) return this.getFuncModule(value);
      if ("string" === typeof value) return escapeForJS(value);
      "_objFlags" === key && obj instanceof CCObject && (value &= PersistentMask);
      return value;
    };
    proto.setObjProp = function(codeArray, obj, key, value) {
      var statement = LOCAL_OBJ + getPropAccessor(key) + "=";
      var expression = this.enumerateField(obj, key, value);
      writeAssignment(codeArray, statement, expression);
    };
    proto.enumerateObject = function(codeArray, obj) {
      var klass = obj.constructor;
      if (cc.Class._isCCClass(klass)) this.enumerateCCClass(codeArray, obj, klass); else for (var key in obj) {
        if (!obj.hasOwnProperty(key) || 95 === key.charCodeAt(0) && 95 === key.charCodeAt(1) && "__type__" !== key) continue;
        var value = obj[key];
        if ("object" === typeof value && value && value === obj._iN$t) continue;
        this.setObjProp(codeArray, obj, key, value);
      }
    };
    proto.instantiateObj = function(obj) {
      if (obj instanceof cc.ValueType) return CCClass.getNewValueTypeCode(obj);
      if (obj instanceof cc.Asset) return this.getObjRef(obj);
      if (obj._objFlags & Destroyed) return null;
      var createCode;
      var ctor = obj.constructor;
      if (cc.Class._isCCClass(ctor)) {
        if (this.parent) if (this.parent instanceof cc.Component) {
          if (obj instanceof cc._BaseNode || obj instanceof cc.Component) return this.getObjRef(obj);
        } else if (this.parent instanceof cc._BaseNode) if (obj instanceof cc._BaseNode) {
          if (!obj.isChildOf(this.parent)) return this.getObjRef(obj);
        } else if (obj instanceof cc.Component && !obj.node.isChildOf(this.parent)) return this.getObjRef(obj);
        createCode = new Declaration(LOCAL_OBJ, "new " + this.getFuncModule(ctor, true) + "()");
      } else if (ctor === Object) createCode = new Declaration(LOCAL_OBJ, "{}"); else {
        if (ctor) return this.getObjRef(obj);
        createCode = new Declaration(LOCAL_OBJ, "Object.create(null)");
      }
      var codeArray = [ createCode ];
      js.value(obj, "_iN$t", {
        globalVar: "",
        source: codeArray
      }, true);
      this.objsToClear_iN$t.push(obj);
      this.enumerateObject(codeArray, obj);
      return [ "(function(){", codeArray, "return o;})();" ];
    };
    function compile(node) {
      var root = node instanceof cc._BaseNode && node;
      var parser = new Parser(node, root);
      return parser.result;
    }
    module.exports = {
      compile: compile,
      equalsToDefault: equalsToDefault
    };
    false;
  }), {
    "./CCClass": 104,
    "./CCObject": 110,
    "./attribute": 116,
    "./compiler": 118,
    "./js": 124
  } ],
  123: [ (function(require, module, exports) {
    "use strict";
    var CCObject = require("./CCObject");
    var CCValueType = require("../value-types/value-type");
    var Destroyed = CCObject.Flags.Destroyed;
    var PersistentMask = CCObject.Flags.PersistentMask;
    var _isDomNode = require("./utils").isDomNode;
    var js = require("./js");
    function instantiate(original, internal_force) {
      if (!internal_force) {
        if ("object" !== typeof original || Array.isArray(original)) {
          false;
          return null;
        }
        if (!original) {
          false;
          return null;
        }
        if (!cc.isValid(original)) {
          false;
          return null;
        }
        false;
      }
      var clone;
      if (original instanceof CCObject) {
        if (original._instantiate) {
          cc.game._isCloning = true;
          clone = original._instantiate();
          cc.game._isCloning = false;
          return clone;
        }
        if (original instanceof cc.Asset) {
          false;
          return null;
        }
      }
      cc.game._isCloning = true;
      clone = doInstantiate(original);
      cc.game._isCloning = false;
      return clone;
    }
    var objsToClearTmpVar = [];
    function doInstantiate(obj, parent) {
      if (Array.isArray(obj)) {
        false;
        return null;
      }
      if (_isDomNode && _isDomNode(obj)) {
        false;
        return null;
      }
      var clone;
      if (obj._iN$t) clone = obj._iN$t; else if (obj.constructor) {
        var klass = obj.constructor;
        clone = new klass();
      } else clone = Object.create(null);
      enumerateObject(obj, clone, parent);
      for (var i = 0, len = objsToClearTmpVar.length; i < len; ++i) objsToClearTmpVar[i]._iN$t = null;
      objsToClearTmpVar.length = 0;
      return clone;
    }
    function enumerateCCClass(klass, obj, clone, parent) {
      var props = klass.__values__;
      for (var p = 0; p < props.length; p++) {
        var key = props[p];
        var value = obj[key];
        if ("object" === typeof value && value) {
          var initValue = clone[key];
          initValue instanceof CCValueType && initValue.constructor === value.constructor ? initValue.set(value) : clone[key] = value._iN$t || instantiateObj(value, parent);
        } else clone[key] = value;
      }
    }
    function enumerateObject(obj, clone, parent) {
      js.value(obj, "_iN$t", clone, true);
      objsToClearTmpVar.push(obj);
      var klass = obj.constructor;
      if (cc.Class._isCCClass(klass)) enumerateCCClass(klass, obj, clone, parent); else for (var key in obj) {
        if (!obj.hasOwnProperty(key) || 95 === key.charCodeAt(0) && 95 === key.charCodeAt(1) && "__type__" !== key) continue;
        var value = obj[key];
        if ("object" === typeof value && value) {
          if (value === clone) continue;
          clone[key] = value._iN$t || instantiateObj(value, parent);
        } else clone[key] = value;
      }
      obj instanceof CCObject && (clone._objFlags &= PersistentMask);
    }
    function instantiateObj(obj, parent) {
      if (obj instanceof CCValueType) return obj.clone();
      if (obj instanceof cc.Asset) return obj;
      var clone;
      if (Array.isArray(obj)) {
        var len = obj.length;
        clone = new Array(len);
        js.value(obj, "_iN$t", clone, true);
        for (var i = 0; i < len; ++i) {
          var value = obj[i];
          clone[i] = "object" === typeof value && value ? value._iN$t || instantiateObj(value, parent) : value;
        }
        objsToClearTmpVar.push(obj);
        return clone;
      }
      if (obj._objFlags & Destroyed) return null;
      var ctor = obj.constructor;
      if (cc.Class._isCCClass(ctor)) {
        if (parent) if (parent instanceof cc.Component) {
          if (obj instanceof cc._BaseNode || obj instanceof cc.Component) return obj;
        } else if (parent instanceof cc._BaseNode) if (obj instanceof cc._BaseNode) {
          if (!obj.isChildOf(parent)) return obj;
        } else if (obj instanceof cc.Component && !obj.node.isChildOf(parent)) return obj;
        clone = new ctor();
      } else if (ctor === Object) clone = {}; else {
        if (ctor) return obj;
        clone = Object.create(null);
      }
      enumerateObject(obj, clone, parent);
      return clone;
    }
    instantiate._clone = doInstantiate;
    cc.instantiate = instantiate;
    module.exports = instantiate;
  }), {
    "../value-types/value-type": 201,
    "./CCObject": 110,
    "./js": 124,
    "./utils": 128
  } ],
  124: [ (function(require, module, exports) {
    "use strict";
    var tempCIDGenerater = new (require("./id-generater"))("TmpCId.");
    function _getPropertyDescriptor(obj, name) {
      while (obj) {
        var pd = Object.getOwnPropertyDescriptor(obj, name);
        if (pd) return pd;
        obj = Object.getPrototypeOf(obj);
      }
      return null;
    }
    function _copyprop(name, source, target) {
      var pd = _getPropertyDescriptor(source, name);
      Object.defineProperty(target, name, pd);
    }
    var js = {
      isNumber: function isNumber(obj) {
        return "number" === typeof obj || obj instanceof Number;
      },
      isString: function isString(obj) {
        return "string" === typeof obj || obj instanceof String;
      },
      addon: function addon(obj) {
        obj = obj || {};
        for (var i = 1, length = arguments.length; i < length; i++) {
          var source = arguments[i];
          if (source) {
            if ("object" !== typeof source) {
              cc.errorID(5402, source);
              continue;
            }
            for (var name in source) name in obj || _copyprop(name, source, obj);
          }
        }
        return obj;
      },
      mixin: function mixin(obj) {
        obj = obj || {};
        for (var i = 1, length = arguments.length; i < length; i++) {
          var source = arguments[i];
          if (source) {
            if ("object" !== typeof source) {
              cc.errorID(5403, source);
              continue;
            }
            for (var name in source) _copyprop(name, source, obj);
          }
        }
        return obj;
      },
      extend: function extend(cls, base) {
        false;
        for (var p in base) base.hasOwnProperty(p) && (cls[p] = base[p]);
        cls.prototype = Object.create(base.prototype, {
          constructor: {
            value: cls,
            writable: true,
            configurable: true
          }
        });
        return cls;
      },
      getSuper: function getSuper(ctor) {
        var proto = ctor.prototype;
        var dunderProto = proto && Object.getPrototypeOf(proto);
        return dunderProto && dunderProto.constructor;
      },
      isChildClassOf: function isChildClassOf(subclass, superclass) {
        if (subclass && superclass) {
          if ("function" !== typeof subclass) return false;
          if ("function" !== typeof superclass) {
            false;
            return false;
          }
          if (subclass === superclass) return true;
          for (;;) {
            subclass = js.getSuper(subclass);
            if (!subclass) return false;
            if (subclass === superclass) return true;
          }
        }
        return false;
      },
      clear: function clear(obj) {
        var keys = Object.keys(obj);
        for (var i = 0; i < keys.length; i++) delete obj[keys[i]];
      },
      isEmptyObject: function isEmptyObject(obj) {
        for (var key in obj) return false;
        return true;
      },
      getPropertyDescriptor: _getPropertyDescriptor
    };
    var tmpValueDesc = {
      value: void 0,
      enumerable: false,
      writable: false,
      configurable: true
    };
    js.value = function(obj, prop, value, writable, enumerable) {
      tmpValueDesc.value = value;
      tmpValueDesc.writable = writable;
      tmpValueDesc.enumerable = enumerable;
      Object.defineProperty(obj, prop, tmpValueDesc);
      tmpValueDesc.value = void 0;
    };
    var tmpGetSetDesc = {
      get: null,
      set: null,
      enumerable: false
    };
    js.getset = function(obj, prop, getter, setter, enumerable, configurable) {
      if ("function" !== typeof setter) {
        enumerable = setter;
        setter = void 0;
      }
      tmpGetSetDesc.get = getter;
      tmpGetSetDesc.set = setter;
      tmpGetSetDesc.enumerable = enumerable;
      tmpGetSetDesc.configurable = configurable;
      Object.defineProperty(obj, prop, tmpGetSetDesc);
      tmpGetSetDesc.get = null;
      tmpGetSetDesc.set = null;
    };
    var tmpGetDesc = {
      get: null,
      enumerable: false,
      configurable: false
    };
    js.get = function(obj, prop, getter, enumerable, configurable) {
      tmpGetDesc.get = getter;
      tmpGetDesc.enumerable = enumerable;
      tmpGetDesc.configurable = configurable;
      Object.defineProperty(obj, prop, tmpGetDesc);
      tmpGetDesc.get = null;
    };
    var tmpSetDesc = {
      set: null,
      enumerable: false,
      configurable: false
    };
    js.set = function(obj, prop, setter, enumerable, configurable) {
      tmpSetDesc.set = setter;
      tmpSetDesc.enumerable = enumerable;
      tmpSetDesc.configurable = configurable;
      Object.defineProperty(obj, prop, tmpSetDesc);
      tmpSetDesc.set = null;
    };
    js.getClassName = function(objOrCtor) {
      if ("function" === typeof objOrCtor) {
        var prototype = objOrCtor.prototype;
        if (prototype && prototype.hasOwnProperty("__classname__") && prototype.__classname__) return prototype.__classname__;
        var retval = "";
        objOrCtor.name && (retval = objOrCtor.name);
        if (objOrCtor.toString) {
          var arr, str = objOrCtor.toString();
          arr = "[" === str.charAt(0) ? str.match(/\[\w+\s*(\w+)\]/) : str.match(/function\s*(\w+)/);
          arr && 2 === arr.length && (retval = arr[1]);
        }
        return "Object" !== retval ? retval : "";
      }
      if (objOrCtor && objOrCtor.constructor) return js.getClassName(objOrCtor.constructor);
      return "";
    };
    function isTempClassId(id) {
      return "string" !== typeof id || id.startsWith(tempCIDGenerater.prefix);
    }
    (function() {
      var _idToClass = {};
      var _nameToClass = {};
      function setup(key, publicName, table) {
        js.getset(js, publicName, (function() {
          return Object.assign({}, table);
        }), (function(value) {
          js.clear(table);
          Object.assign(table, value);
        }));
        return function(id, constructor) {
          constructor.prototype.hasOwnProperty(key) && delete table[constructor.prototype[key]];
          js.value(constructor.prototype, key, id);
          if (id) {
            var registered = table[id];
            if (registered && registered !== constructor) {
              var error = "A Class already exists with the same " + key + ' : "' + id + '".';
              false;
              cc.error(error);
            } else table[id] = constructor;
          }
        };
      }
      js._setClassId = setup("__cid__", "_registeredClassIds", _idToClass);
      var doSetClassName = setup("__classname__", "_registeredClassNames", _nameToClass);
      js.setClassName = function(className, constructor) {
        doSetClassName(className, constructor);
        if (!constructor.prototype.hasOwnProperty("__cid__")) {
          var id = className || tempCIDGenerater.getNewId();
          id && js._setClassId(id, constructor);
        }
      };
      js.unregisterClass = function() {
        for (var i = 0; i < arguments.length; i++) {
          var p = arguments[i].prototype;
          var classId = p.__cid__;
          classId && delete _idToClass[classId];
          var classname = p.__classname__;
          classname && delete _nameToClass[classname];
        }
      };
      js._getClassById = function(classId) {
        return _idToClass[classId];
      };
      js.getClassByName = function(classname) {
        return _nameToClass[classname];
      };
      js._getClassId = function(obj, allowTempId) {
        allowTempId = "undefined" === typeof allowTempId || allowTempId;
        var res;
        if ("function" === typeof obj && obj.prototype.hasOwnProperty("__cid__")) {
          res = obj.prototype.__cid__;
          if (!allowTempId && (false, false) && isTempClassId(res)) return "";
          return res;
        }
        if (obj && obj.constructor) {
          var prototype = obj.constructor.prototype;
          if (prototype && prototype.hasOwnProperty("__cid__")) {
            res = obj.__cid__;
            if (!allowTempId && (false, false) && isTempClassId(res)) return "";
            return res;
          }
        }
        return "";
      };
    })();
    js.obsolete = function(obj, obsoleted, newExpr, writable) {
      var extractPropName = /([^.]+)$/;
      var oldProp = extractPropName.exec(obsoleted)[0];
      var newProp = extractPropName.exec(newExpr)[0];
      function get() {
        false;
        return this[newProp];
      }
      writable ? js.getset(obj, oldProp, get, (function(value) {
        false;
        this[newProp] = value;
      })) : js.get(obj, oldProp, get);
    };
    js.obsoletes = function(obj, objName, props, writable) {
      for (var obsoleted in props) {
        var newName = props[obsoleted];
        js.obsolete(obj, objName + "." + obsoleted, newName, writable);
      }
    };
    var REGEXP_NUM_OR_STR = /(%d)|(%s)/;
    var REGEXP_STR = /%s/;
    js.formatStr = function() {
      var argLen = arguments.length;
      if (0 === argLen) return "";
      var msg = arguments[0];
      if (1 === argLen) return "" + msg;
      var hasSubstitution = "string" === typeof msg && REGEXP_NUM_OR_STR.test(msg);
      if (hasSubstitution) for (var i = 1; i < argLen; ++i) {
        var arg = arguments[i];
        var regExpToTest = "number" === typeof arg ? REGEXP_NUM_OR_STR : REGEXP_STR;
        regExpToTest.test(msg) ? msg = msg.replace(regExpToTest, arg) : msg += " " + arg;
      } else for (var _i = 1; _i < argLen; ++_i) msg += " " + arguments[_i];
      return msg;
    };
    js.shiftArguments = function() {
      var len = arguments.length - 1;
      var args = new Array(len);
      for (var i = 0; i < len; ++i) args[i] = arguments[i + 1];
      return args;
    };
    js.createMap = function(forceDictMode) {
      var map = Object.create(null);
      if (forceDictMode) {
        var INVALID_IDENTIFIER_1 = ".";
        var INVALID_IDENTIFIER_2 = "/";
        map[INVALID_IDENTIFIER_1] = true;
        map[INVALID_IDENTIFIER_2] = true;
        delete map[INVALID_IDENTIFIER_1];
        delete map[INVALID_IDENTIFIER_2];
      }
      return map;
    };
    function removeAt(array, index) {
      array.splice(index, 1);
    }
    function fastRemoveAt(array, index) {
      var length = array.length;
      if (index < 0 || index >= length) return;
      array[index] = array[length - 1];
      array.length = length - 1;
    }
    function remove(array, value) {
      var index = array.indexOf(value);
      if (index >= 0) {
        removeAt(array, index);
        return true;
      }
      return false;
    }
    function fastRemove(array, value) {
      var index = array.indexOf(value);
      if (index >= 0) {
        array[index] = array[array.length - 1];
        --array.length;
      }
    }
    function verifyType(array, type) {
      if (array && array.length > 0) for (var i = 0; i < array.length; i++) if (!(array[i] instanceof type)) {
        cc.logID(1300);
        return false;
      }
      return true;
    }
    function removeArray(array, minusArr) {
      for (var i = 0, l = minusArr.length; i < l; i++) remove(array, minusArr[i]);
    }
    function appendObjectsAt(array, addObjs, index) {
      array.splice.apply(array, [ index, 0 ].concat(addObjs));
      return array;
    }
    var indexOf = Array.prototype.indexOf;
    function contains(array, value) {
      return array.indexOf(value) >= 0;
    }
    function copy(array) {
      var i, len = array.length, arr_clone = new Array(len);
      for (i = 0; i < len; i += 1) arr_clone[i] = array[i];
      return arr_clone;
    }
    js.array = {
      remove: remove,
      fastRemove: fastRemove,
      removeAt: removeAt,
      fastRemoveAt: fastRemoveAt,
      contains: contains,
      verifyType: verifyType,
      removeArray: removeArray,
      appendObjectsAt: appendObjectsAt,
      copy: copy,
      indexOf: indexOf,
      MutableForwardIterator: require("../utils/mutable-forward-iterator")
    };
    function Pool(cleanupFunc, size) {
      if (void 0 === size) {
        size = cleanupFunc;
        cleanupFunc = null;
      }
      this.get = null;
      this.count = 0;
      this._pool = new Array(size);
      this._cleanup = cleanupFunc;
    }
    Pool.prototype._get = function() {
      if (this.count > 0) {
        --this.count;
        var cache = this._pool[this.count];
        this._pool[this.count] = null;
        return cache;
      }
      return null;
    };
    Pool.prototype.put = function(obj) {
      var pool = this._pool;
      if (this.count < pool.length) {
        if (this._cleanup && false === this._cleanup(obj)) return;
        pool[this.count] = obj;
        ++this.count;
      }
    };
    Pool.prototype.resize = function(length) {
      if (length >= 0) {
        this._pool.length = length;
        this.count > length && (this.count = length);
      }
    };
    js.Pool = Pool;
    cc.js = js;
    module.exports = js;
  }), {
    "../utils/mutable-forward-iterator": 188,
    "./id-generater": 120
  } ],
  125: [ (function(require, module, exports) {
    "use strict";
    var js = require("./js");
    var SerializableAttrs = {
      url: {
        canUsedInGet: true
      },
      default: {},
      serializable: {},
      editorOnly: {},
      formerlySerializedAs: {}
    };
    var TYPO_TO_CORRECT_DEV = false;
    function parseNotify(val, propName, notify, properties) {
      if (val.get || val.set) {
        false;
        return;
      }
      if (val.hasOwnProperty("default")) {
        var newKey = "_N$" + propName;
        val.get = function() {
          return this[newKey];
        };
        val.set = function(value) {
          var oldValue = this[newKey];
          this[newKey] = value;
          notify.call(this, oldValue);
        };
        false;
        var newValue = {};
        properties[newKey] = newValue;
        for (var attr in SerializableAttrs) {
          var v = SerializableAttrs[attr];
          if (val.hasOwnProperty(attr)) {
            newValue[attr] = val[attr];
            v.canUsedInGet || delete val[attr];
          }
        }
      } else false;
    }
    function checkUrl(val, className, propName, url) {
      Array.isArray(url) && url.length > 0 && (url = url[0]);
      false;
      val.type = url;
    }
    function parseType(val, type, className, propName) {
      if (Array.isArray(type)) {
        var isArray;
        false;
        if (!(type.length > 0)) return cc.errorID(5508, className, propName);
        if (cc.RawAsset.isRawAssetType(type[0])) {
          val.url = type[0];
          delete val.type;
          return;
        }
        val.type = type = type[0];
      }
      false;
    }
    function postCheckType(val, type, className, propName) {
      false;
    }
    function getBaseClassWherePropertyDefined_DEV(propName, cls) {
      var res;
      false;
    }
    exports.getFullFormOfProperty = function(options, propname_dev, classname_dev) {
      var isLiteral = options && options.constructor === Object;
      if (!isLiteral) {
        if (Array.isArray(options) && options.length > 0) {
          var type = options[0];
          false;
          return {
            default: [],
            type: options,
            _short: true
          };
        }
        if ("function" === typeof options) {
          var type = options;
          if (!cc.RawAsset.isRawAssetType(type)) {
            if (!cc.RawAsset.wasRawAssetType(type)) return {
              default: js.isChildClassOf(type, cc.ValueType) ? new type() : null,
              type: type,
              _short: true
            };
            false;
          }
          return {
            default: "",
            url: type,
            _short: true
          };
        }
        return {
          default: options,
          _short: true
        };
      }
      return null;
    };
    exports.preprocessAttrs = function(properties, className, cls, es6) {
      for (var propName in properties) {
        var val = properties[propName];
        var fullForm = exports.getFullFormOfProperty(val, propName, className);
        fullForm && (val = properties[propName] = fullForm);
        if (val) {
          var maybeTypeScript;
          false;
          var baseClass;
          false;
          var notify = val.notify;
          if (notify) {
            false;
            parseNotify(val, propName, notify, properties);
          }
          "type" in val && parseType(val, val.type, className, propName);
          "url" in val && checkUrl(val, className, propName, val.url);
          "type" in val && postCheckType(val, val.type, className, propName);
        }
      }
    };
    var CALL_SUPER_DESTROY_REG_DEV;
    false;
    exports.validateMethodWithProps = function(func, funcName, className, cls, base) {
      false;
      if ("function" !== typeof func && null !== func) {
        var overrided;
        var baseFuc;
        var subFuc;
        var correct;
        false;
        return false;
      }
      false;
      return true;
    };
  }), {
    "./CCClass": 104,
    "./js": 124
  } ],
  126: [ (function(require, module, exports) {
    "use strict";
    var requiringFrames = [];
    cc._RF = {
      push: function push(module, uuid, script) {
        if (void 0 === script) {
          script = uuid;
          uuid = "";
        }
        requiringFrames.push({
          uuid: uuid,
          script: script,
          module: module,
          exports: module.exports,
          beh: null
        });
      },
      pop: function pop() {
        var frameInfo = requiringFrames.pop();
        var module = frameInfo.module;
        var exports = module.exports;
        if (exports === frameInfo.exports) {
          for (var anyKey in exports) return;
          module.exports = exports = frameInfo.cls;
        }
      },
      peek: function peek() {
        return requiringFrames[requiringFrames.length - 1];
      }
    };
    false;
  }), {} ],
  127: [ (function(require, module, exports) {
    "use strict";
    cc.url = {
      _rawAssets: "",
      normalize: function normalize(url) {
        url && (46 === url.charCodeAt(0) && 47 === url.charCodeAt(1) ? url = url.slice(2) : 47 === url.charCodeAt(0) && (url = url.slice(1)));
        return url;
      },
      raw: function raw(url) {
        false;
        url = this.normalize(url);
        if (url.startsWith("resources/")) {
          var uuid = cc.loader._getResUuid(url.slice(10), cc.Asset, null, true);
          if (uuid) return cc.AssetLibrary.getLibUrlNoExt(uuid, true) + cc.path.extname(url);
        } else cc.errorID(7002, url);
        return this._rawAssets + url;
      },
      _init: function _init(assets) {
        this._rawAssets = cc.path.stripSep(assets) + "/";
      }
    };
    module.exports = cc.url;
  }), {} ],
  128: [ (function(require, module, exports) {
    "use strict";
    var js = require("./js");
    module.exports = {
      contains: function contains(refNode, otherNode) {
        if ("function" == typeof refNode.contains) return refNode.contains(otherNode);
        if ("function" == typeof refNode.compareDocumentPosition) return !!(16 & refNode.compareDocumentPosition(otherNode));
        var node = otherNode.parentNode;
        if (node) do {
          if (node === refNode) return true;
          node = node.parentNode;
        } while (null !== node);
        return false;
      },
      isDomNode: "object" === typeof window && ("function" === typeof Node ? function(obj) {
        return obj instanceof Node;
      } : function(obj) {
        return obj && "object" === typeof obj && "number" === typeof obj.nodeType && "string" === typeof obj.nodeName;
      }),
      callInNextTick: function(callback, p1, p2) {
        callback && setTimeout((function() {
          callback(p1, p2);
        }), 0);
      }
    };
    false;
    false;
  }), {
    "./js": 124
  } ],
  129: [ (function(require, module, exports) {
    "use strict";
    require("./platform/js");
    require("./value-types");
    require("./utils");
    require("./platform/CCInputManager");
    require("./platform/CCInputExtension");
    require("./event");
    require("./platform/CCSys");
    require("./platform/CCMacro");
    require("./load-pipeline");
    require("./CCDirector");
    require("./renderer");
    true;
    require("./platform/CCView");
    require("./platform/CCScreen");
    require("./CCScheduler");
    require("./event-manager");
  }), {
    "./CCDirector": 4,
    "./CCScheduler": 9,
    "./event": 74,
    "./event-manager": 70,
    "./load-pipeline": 89,
    "./platform/CCInputExtension": 107,
    "./platform/CCInputManager": 108,
    "./platform/CCMacro": 109,
    "./platform/CCScreen": 112,
    "./platform/CCSys": 113,
    "./platform/CCView": 114,
    "./platform/js": 124,
    "./renderer": 147,
    "./utils": 185,
    "./value-types": 196
  } ],
  130: [ (function(require, module, exports) {
    "use strict";
    var Device = function Device(canvasEL) {
      var ctx;
      try {
        ctx = canvasEL.getContext("2d");
      } catch (err) {
        console.error(err);
        return;
      }
      this._canvas = canvasEL;
      this._ctx = ctx;
      this._caps = {};
      this._stats = {
        drawcalls: 0
      };
      this._vx = this._vy = this._vw = this._vh = 0;
      this._sx = this._sy = this._sw = this._sh = 0;
    };
    Device.prototype._restoreTexture = function _restoreTexture(unit) {};
    Device.prototype.setViewport = function setViewport(x, y, w, h) {
      if (this._vx !== x || this._vy !== y || this._vw !== w || this._vh !== h) {
        this._vx = x;
        this._vy = y;
        this._vw = w;
        this._vh = h;
      }
    };
    Device.prototype.setScissor = function setScissor(x, y, w, h) {
      if (this._sx !== x || this._sy !== y || this._sw !== w || this._sh !== h) {
        this._sx = x;
        this._sy = y;
        this._sw = w;
        this._sh = h;
      }
    };
    Device.prototype.clear = function clear(color) {
      var ctx = this._ctx;
      ctx.clearRect(this._vx, this._vy, this._vw, this._vh);
      if (color && (0 !== color[0] || 0 !== color[1] || 0 !== color[2])) {
        ctx.fillStyle = "rgb(" + color[0] + "," + color[1] + "," + color[2] + ")";
        ctx.globalAlpha = color[3];
        ctx.fillRect(this._vx, this._vy, this._vw, this._vh);
      }
    };
    module.exports = Device;
  }), {} ],
  131: [ (function(require, module, exports) {
    "use strict";
    var Texture2D = function Texture2D(device, options) {
      this._device = device;
      this._width = 4;
      this._height = 4;
      this._image = null;
      if (options) {
        void 0 !== options.width && (this._width = options.width);
        void 0 !== options.height && (this._height = options.height);
        this.updateImage(options);
      }
    };
    Texture2D.prototype.update = function update(options) {
      this.updateImage(options);
    };
    Texture2D.prototype.updateImage = function updateImage(options) {
      if (options.images && options.images[0]) {
        var image = options.images[0];
        image && image !== this._image && (this._image = image);
      }
    };
    Texture2D.prototype.destroy = function destroy() {
      this._image = null;
    };
    module.exports = Texture2D;
  }), {} ],
  132: [ (function(require, module, exports) {
    "use strict";
    var ForwardRenderer = function ForwardRenderer() {};
    ForwardRenderer.prototype = {
      constructor: ForwardRenderer,
      clear: function clear() {},
      render: function render() {}
    };
    module.exports = ForwardRenderer;
  }), {} ],
  133: [ (function(require, module, exports) {
    "use strict";
    module.exports = {
      ForwardRenderer: require("./forward-renderer"),
      RenderComponentHandle: require("./render-component-handle"),
      _renderers: require("./renderers")
    };
  }), {
    "./forward-renderer": 132,
    "./render-component-handle": 134,
    "./renderers": 137
  } ],
  134: [ (function(require, module, exports) {
    "use strict";
    require("./renderers");
    var utils = require("./renderers/utils");
    var RenderComponentHandle = function RenderComponentHandle(device, defaultCamera) {
      this._device = device;
      this._camera = defaultCamera;
      this.parentOpacity = 1;
      this.parentOpacityDirty = 0;
      this.worldMatDirty = 0;
      this.walking = false;
    };
    RenderComponentHandle.prototype = {
      constructor: RenderComponentHandle,
      reset: function reset() {
        var ctx = this._device._ctx;
        var canvas = this._device._canvas;
        var color = cc.Camera.main ? cc.Camera.main.backgroundColor : cc.color();
        var rgba = "rgba(" + color.r + ", " + color.g + ", " + color.b + ", " + color.a / 255 + ")";
        ctx.fillStyle = rgba;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        this._device._stats.drawcalls = 0;
        utils.context.reset();
      },
      terminate: function terminate() {},
      _commitComp: function _commitComp(comp, assembler) {
        var ctx = this._device._ctx;
        var cam = this._camera;
        ctx.setTransform(cam.a, cam.b, cam.c, cam.d, cam.tx, cam.ty);
        ctx.scale(1, -1);
        assembler.draw(ctx, comp);
      }
    };
    module.exports = RenderComponentHandle;
  }), {
    "./renderers": 137,
    "./renderers/utils": 146
  } ],
  135: [ (function(require, module, exports) {
    "use strict";
    var Helper = require("../../../../graphics/helper");
    var Types = require("../../../../graphics/types");
    var js = require("../../../../platform/js");
    var PointFlags = Types.PointFlags;
    var LineJoin = Types.LineJoin;
    var LineCap = Types.LineCap;
    function Impl() {
      this.cmds = [];
      this.style = {
        strokeStyle: "black",
        fillStyle: "white",
        lineCap: "butt",
        lineJoin: "miter",
        miterLimit: 10
      };
    }
    var _proto = Impl.prototype;
    js.mixin(_proto, {
      moveTo: function moveTo(x, y) {
        this.cmds.push([ "moveTo", [ x, y ] ]);
      },
      lineTo: function lineTo(x, y) {
        this.cmds.push([ "lineTo", [ x, y ] ]);
      },
      bezierCurveTo: function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
        this.cmds.push([ "bezierCurveTo", [ c1x, c1y, c2x, c2y, x, y ] ]);
      },
      quadraticCurveTo: function quadraticCurveTo(cx, cy, x, y) {
        this.cmds.push([ "quadraticCurveTo", [ cx, cy, x, y ] ]);
      },
      arc: function arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
        Helper.arc(this, cx, cy, r, startAngle, endAngle, counterclockwise);
      },
      ellipse: function ellipse(cx, cy, rx, ry) {
        Helper.ellipse(this, cx, cy, rx, ry);
      },
      circle: function circle(cx, cy, r) {
        Helper.ellipse(this, cx, cy, r, r);
      },
      rect: function rect(x, y, w, h) {
        this.moveTo(x, y);
        this.lineTo(x, y + h);
        this.lineTo(x + w, y + h);
        this.lineTo(x + w, y);
        this.close();
      },
      roundRect: function roundRect(x, y, w, h, r) {
        Helper.roundRect(this, x, y, w, h, r);
      },
      clear: function clear(comp, clean) {
        this.cmds.length = 0;
      },
      close: function close() {
        this.cmds.push([ "closePath", [] ]);
      },
      stroke: function stroke() {
        this.cmds.push([ "stroke", [] ]);
      },
      fill: function fill() {
        this.cmds.push([ "fill", [] ]);
      }
    });
    js.set(_proto, "strokeColor", (function(v) {
      var strokeStyle = "rgba(" + (0 | v.r) + "," + (0 | v.g) + "," + (0 | v.b) + "," + v.a / 255 + ")";
      this.cmds.push([ "strokeStyle", strokeStyle ]);
      this.style.strokeStyle = strokeStyle;
    }));
    js.set(_proto, "fillColor", (function(v) {
      var fillStyle = "rgba(" + (0 | v.r) + "," + (0 | v.g) + "," + (0 | v.b) + "," + v.a / 255 + ")";
      this.cmds.push([ "fillStyle", fillStyle ]);
      this.style.fillStyle = fillStyle;
    }));
    js.set(_proto, "lineWidth", (function(v) {
      this.cmds.push([ "lineWidth", v ]);
      this.style.lineWidth = v;
    }));
    js.set(_proto, "lineCap", (function(v) {
      var lineCap = "butt";
      v === LineCap.BUTT ? lineCap = "butt" : v === LineCap.ROUND ? lineCap = "round" : v === LineCap.SQUARE && (lineCap = "square");
      this.cmds.push([ "lineCap", lineCap ]);
      this.style.lineCap = lineCap;
    }));
    js.set(_proto, "lineJoin", (function(v) {
      var lineJoin = "bevel";
      v === LineJoin.BEVEL ? lineJoin = "bevel" : v === LineJoin.ROUND ? lineJoin = "round" : v === LineJoin.MITER && (lineJoin = "miter");
      this.cmds.push([ "lineJoin", lineJoin ]);
      this.style.lineJoin = lineJoin;
    }));
    js.set(_proto, "miterLimit", (function(v) {
      this.cmds.push([ "miterLimit", v ]);
      this.style.miterLimit = v;
    }));
    module.exports = Impl;
  }), {
    "../../../../graphics/helper": 77,
    "../../../../graphics/types": 79,
    "../../../../platform/js": 124
  } ],
  136: [ (function(require, module, exports) {
    "use strict";
    var Impl = require("./impl");
    module.exports = {
      createImpl: function createImpl() {
        return new Impl();
      },
      draw: function draw(ctx, comp) {
        var node = comp.node;
        var matrix = node._worldMatrix;
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        ctx.transform(a, b, c, d, tx, ty);
        ctx.save();
        ctx.globalAlpha = node.opacity / 255;
        var style = comp._impl.style;
        ctx.strokeStyle = style.strokeStyle;
        ctx.fillStyle = style.fillStyle;
        ctx.lineWidth = style.lineWidth;
        ctx.lineJoin = style.lineJoin;
        ctx.miterLimit = style.miterLimit;
        var endPath = true;
        var cmds = comp._impl.cmds;
        for (var i = 0, l = cmds.length; i < l; i++) {
          var cmd = cmds[i];
          var ctxCmd = cmd[0], args = cmd[1];
          if ("moveTo" === ctxCmd && endPath) {
            ctx.beginPath();
            endPath = false;
          } else "fill" !== ctxCmd && "stroke" !== ctxCmd && "fillRect" !== ctxCmd || (endPath = true);
          "function" === typeof ctx[ctxCmd] ? ctx[ctxCmd].apply(ctx, args) : ctx[ctxCmd] = args;
        }
        ctx.restore();
        return 1;
      },
      stroke: function stroke(comp) {
        comp._impl.stroke();
      },
      fill: function fill(comp) {
        comp._impl.fill();
      }
    };
  }), {
    "./impl": 135
  } ],
  137: [ (function(require, module, exports) {
    "use strict";
    var js = require("../../../platform/js");
    var Sprite = require("../../../components/CCSprite");
    var Label = require("../../../components/CCLabel");
    var Mask = require("../../../components/CCMask");
    var Graphics = require("../../../graphics/graphics");
    var spriteRenderer = require("./sprite");
    var labelRenderer = require("./label");
    var graphicsRenderer = require("./graphics");
    var maskRenderer = require("./mask");
    var map = {};
    var postMap = {};
    function addRenderer(Component, handler, postHandler) {
      var name = js.getClassName(Component);
      map[name] = handler;
      postHandler && (postMap[name] = postHandler);
      Component._assembler = handler;
      Component._postAssembler = postHandler;
    }
    addRenderer(Sprite, spriteRenderer);
    addRenderer(Label, labelRenderer);
    Mask && addRenderer(Mask, maskRenderer.beforeHandler, maskRenderer.afterHandler);
    Graphics && addRenderer(Graphics, graphicsRenderer);
    module.exports = {
      map: map,
      postMap: postMap,
      addRenderer: addRenderer
    };
  }), {
    "../../../components/CCLabel": 41,
    "../../../components/CCMask": 45,
    "../../../components/CCSprite": 51,
    "../../../graphics/graphics": 76,
    "../../../platform/js": 124,
    "./graphics": 136,
    "./label": 139,
    "./mask": 141,
    "./sprite": 142
  } ],
  138: [ (function(require, module, exports) {
    "use strict";
    var bmfontUtils = require("../../../utils/label/bmfont");
    var js = require("../../../../platform/js");
    var utils = require("../utils");
    module.exports = js.addon({
      createData: function createData(comp) {
        return comp.requestRenderData();
      },
      appendQuad: function appendQuad(renderData, texture, rect, rotated, x, y, scale) {
        var dataOffset = renderData.dataLength;
        renderData.dataLength += 2;
        var data = renderData._data;
        var texw = texture.width, texh = texture.height;
        var rectWidth = rect.width, rectHeight = rect.height;
        var l = void 0, b = void 0, r = void 0, t = void 0;
        if (rotated) {
          l = rect.x;
          r = rect.x + rectHeight;
          b = rect.y;
          t = rect.y + rectWidth;
          data[dataOffset].u = l;
          data[dataOffset].v = t;
          data[dataOffset + 1].u = l;
          data[dataOffset + 1].v = b;
        } else {
          l = rect.x;
          r = rect.x + rectWidth;
          b = rect.y;
          t = rect.y + rectHeight;
          data[dataOffset].u = l;
          data[dataOffset].v = b;
          data[dataOffset + 1].u = r;
          data[dataOffset + 1].v = t;
        }
        data[dataOffset].x = x;
        data[dataOffset].y = y - rectHeight * scale;
        data[dataOffset + 1].x = x + rectWidth * scale;
        data[dataOffset + 1].y = y;
      },
      draw: function draw(ctx, comp) {
        var node = comp.node;
        var matrix = node._worldMatrix;
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        ctx.transform(a, b, c, d, tx, ty);
        ctx.scale(1, -1);
        utils.context.setGlobalAlpha(ctx, node.opacity / 255);
        var tex = comp._frame._texture, data = comp._renderData._data;
        var image = utils.getColorizedImage(tex, node._color);
        for (var i = 0, l = data.length; i < l; i += 2) {
          var x = data[i].x;
          var y = data[i].y;
          var w = data[i + 1].x - x;
          var h = data[i + 1].y - y;
          y = -y - h;
          var sx = data[i].u;
          var sy = data[i].v;
          var sw = data[i + 1].u - sx;
          var sh = data[i + 1].v - sy;
          ctx.drawImage(image, sx, sy, sw, sh, x, y, w, h);
        }
        return 1;
      }
    }, bmfontUtils);
  }), {
    "../../../../platform/js": 124,
    "../../../utils/label/bmfont": 151,
    "../utils": 146
  } ],
  139: [ (function(require, module, exports) {
    "use strict";
    var Label = require("../../../../components/CCLabel");
    var ttf = require("./ttf");
    var bmfont = require("./bmfont");
    var canvasPool = {
      pool: [],
      get: function get() {
        var data = this.pool.pop();
        if (!data) {
          var canvas = document.createElement("canvas");
          var context = canvas.getContext("2d");
          data = {
            canvas: canvas,
            context: context
          };
        }
        return data;
      },
      put: function put(canvas) {
        if (this.pool.length >= 32) return;
        this.pool.push(canvas);
      }
    };
    Label._canvasPool = canvasPool;
    module.exports = {
      getAssembler: function getAssembler(comp) {
        var assembler = ttf;
        comp.font instanceof cc.BitmapFont && (assembler = bmfont);
        return assembler;
      },
      createData: function createData(comp) {
        return comp._assembler.createData(comp);
      },
      draw: function draw(ctx, comp) {
        if (!comp._texture) return 0;
        var assembler = comp._assembler;
        if (!assembler) return 0;
        assembler.updateRenderData(comp);
        return assembler.draw(ctx, comp);
      }
    };
  }), {
    "../../../../components/CCLabel": 41,
    "./bmfont": 138,
    "./ttf": 140
  } ],
  140: [ (function(require, module, exports) {
    "use strict";
    var ttfUtils = require("../../../utils/label/ttf");
    var js = require("../../../../platform/js");
    var utils = require("../utils");
    module.exports = js.addon({
      createData: function createData(sprite) {
        var renderData = sprite.requestRenderData();
        renderData.dataLength = 2;
        return renderData;
      },
      _updateVerts: function _updateVerts(comp) {
        var renderData = comp._renderData;
        var node = comp.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height;
        var data = renderData._data;
        data[0].x = -appx;
        data[0].y = -appy;
        data[1].x = width - appx;
        data[1].y = height - appy;
      },
      _updateTexture: function _updateTexture(comp) {
        ttfUtils._updateTexture(comp);
        var texture = comp._frame._texture;
        utils.dropColorizedImage(texture, comp.node.color);
      },
      draw: function draw(ctx, comp) {
        var node = comp.node;
        var matrix = node._worldMatrix;
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        ctx.transform(a, b, c, d, tx, ty);
        ctx.scale(1, -1);
        utils.context.setGlobalAlpha(ctx, node.opacity / 255);
        var tex = comp._frame._texture, data = comp._renderData._data;
        var image = tex.getHtmlElementObj();
        var x = data[0].x;
        var y = data[0].y;
        var w = data[1].x - x;
        var h = data[1].y - y;
        y = -y - h;
        ctx.drawImage(image, x, y, w, h);
        return 1;
      }
    }, ttfUtils);
  }), {
    "../../../../platform/js": 124,
    "../../../utils/label/ttf": 154,
    "../utils": 146
  } ],
  141: [ (function(require, module, exports) {
    "use strict";
    var Mask = require("../../../components/CCMask");
    var graphicsHandler = require("./graphics");
    var beforeHandler = {
      updateRenderData: function updateRenderData(comp) {},
      draw: function draw(ctx, mask) {
        ctx.save();
        graphicsHandler.draw(ctx, mask._graphics);
        ctx.clip();
      }
    };
    var afterHandler = {
      updateRenderData: function updateRenderData(comp) {},
      draw: function draw(ctx, mask) {
        ctx.restore();
      }
    };
    module.exports = {
      beforeHandler: beforeHandler,
      afterHandler: afterHandler
    };
  }), {
    "../../../components/CCMask": 45,
    "./graphics": 136
  } ],
  142: [ (function(require, module, exports) {
    "use strict";
    var Sprite = require("../../../../components/CCSprite");
    var SpriteType = Sprite.Type;
    var FillType = Sprite.FillType;
    var simple = require("./simple");
    var sliced = require("./sliced");
    var tiled = require("./tiled");
    false;
    module.exports = {
      getAssembler: function getAssembler(sprite) {
        switch (sprite.type) {
         case SpriteType.SIMPLE:
          return simple;

         case SpriteType.SLICED:
          return sliced;

         case SpriteType.TILED:
          return tiled;

         case SpriteType.FILLED:
          return sprite._fillType === FillType.RADIAL, null;
        }
      },
      createData: function createData(sprite) {
        return sprite._assembler.createData(sprite);
      }
    };
  }), {
    "../../../../components/CCSprite": 51,
    "../../../webgl/assemblers/sprite/index.js": 171,
    "./simple": 143,
    "./sliced": 144,
    "./tiled": 145
  } ],
  143: [ (function(require, module, exports) {
    "use strict";
    var utils = require("../utils");
    var renderer = {
      createData: function createData(sprite) {
        var renderData = sprite.requestRenderData();
        renderData.dataLength = 2;
        return renderData;
      },
      updateRenderData: function updateRenderData(sprite) {
        sprite._material || sprite._activateMaterial();
        var renderData = sprite._renderData;
        renderData.uvDirty && this.updateUVs(sprite);
        renderData.vertDirty && this.updateVerts(sprite);
      },
      updateUVs: function updateUVs(sprite) {
        var frame = sprite.spriteFrame;
        var renderData = sprite._renderData;
        var data = renderData._data;
        var rect = frame._rect;
        var texture = frame._texture;
        if (frame._rotated) {
          var l = rect.x;
          var r = rect.height;
          var b = rect.y;
          var t = rect.width;
          data[0].u = l;
          data[0].v = t;
          data[1].u = r;
          data[1].v = b;
        } else {
          var _l = rect.x;
          var _r = rect.width;
          var _b = rect.y;
          var _t = rect.height;
          data[0].u = _l;
          data[0].v = _b;
          data[1].u = _r;
          data[1].v = _t;
        }
        renderData.uvDirty = false;
      },
      updateVerts: function updateVerts(sprite) {
        var renderData = sprite._renderData, node = sprite.node, data = renderData._data, cw = node.width, ch = node.height, appx = node.anchorX * cw, appy = node.anchorY * ch, l = void 0, b = void 0, r = void 0, t = void 0;
        if (sprite.trim) {
          l = -appx;
          b = -appy;
          r = cw;
          t = ch;
        } else {
          var frame = sprite.spriteFrame, ow = frame._originalSize.width, oh = frame._originalSize.height, rw = frame._rect.width, rh = frame._rect.height, offset = frame._offset, scaleX = cw / ow, scaleY = ch / oh;
          var trimLeft = offset.x + (ow - rw) / 2;
          var trimRight = offset.x - (ow - rw) / 2;
          var trimBottom = offset.y + (oh - rh) / 2;
          var trimTop = offset.y - (oh - rh) / 2;
          l = trimLeft * scaleX - appx;
          b = trimBottom * scaleY - appy;
          r = cw;
          t = ch;
        }
        data[0].x = l;
        data[0].y = b;
        data[1].x = r;
        data[1].y = t;
        renderData.vertDirty = false;
      },
      draw: function draw(ctx, comp) {
        var node = comp.node;
        var matrix = node._worldMatrix;
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        ctx.transform(a, b, c, d, tx, ty);
        ctx.scale(1, -1);
        utils.context.setGlobalAlpha(ctx, node.opacity / 255);
        var tex = comp._spriteFrame._texture, data = comp._renderData._data;
        var image = utils.getColorizedImage(tex, node._color);
        var x = data[0].x;
        var y = data[0].y;
        var w = data[1].x;
        var h = data[1].y;
        y = -y - h;
        var sx = data[0].u;
        var sy = data[0].v;
        var sw = data[1].u;
        var sh = data[1].v;
        ctx.drawImage(image, sx, sy, sw, sh, x, y, w, h);
        return 1;
      }
    };
    module.exports = renderer;
  }), {
    "../utils": 146
  } ],
  144: [ (function(require, module, exports) {
    "use strict";
    var utils = require("../utils");
    var simple = require("./simple");
    var renderer = {
      createData: function createData(sprite) {
        var renderData = sprite.requestRenderData();
        renderData.dataLength = 4;
        return renderData;
      },
      updateRenderData: simple.updateRenderData,
      updateUVs: function updateUVs(sprite) {
        var frame = sprite.spriteFrame;
        var renderData = sprite._renderData;
        var rect = frame._rect;
        var texture = frame._texture;
        var leftWidth = frame.insetLeft;
        var rightWidth = frame.insetRight;
        var centerWidth = rect.width - leftWidth - rightWidth;
        var topHeight = frame.insetTop;
        var bottomHeight = frame.insetBottom;
        var centerHeight = rect.height - topHeight - bottomHeight;
        var data = renderData._data;
        if (frame._rotated) {
          data[0].u = rect.x;
          data[1].u = bottomHeight + rect.x;
          data[2].u = bottomHeight + centerHeight + rect.x;
          data[3].u = rect.x + rect.height;
          data[3].v = rect.y;
          data[2].v = leftWidth + rect.y;
          data[1].v = leftWidth + centerWidth + rect.y;
          data[0].v = rect.y + rect.width;
        } else {
          data[0].u = rect.x;
          data[1].u = leftWidth + rect.x;
          data[2].u = leftWidth + centerWidth + rect.x;
          data[3].u = rect.x + rect.width;
          data[3].v = rect.y;
          data[2].v = topHeight + rect.y;
          data[1].v = topHeight + centerHeight + rect.y;
          data[0].v = rect.y + rect.height;
        }
        renderData.uvDirty = false;
      },
      updateVerts: function updateVerts(sprite) {
        var renderData = sprite._renderData, data = renderData._data, node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height;
        var frame = sprite.spriteFrame;
        var rect = frame._rect;
        var leftWidth = frame.insetLeft;
        var rightWidth = frame.insetRight;
        var topHeight = frame.insetTop;
        var bottomHeight = frame.insetBottom;
        var sizableWidth = width - leftWidth - rightWidth;
        var sizableHeight = height - topHeight - bottomHeight;
        var xScale = width / (leftWidth + rightWidth);
        var yScale = height / (topHeight + bottomHeight);
        xScale = isNaN(xScale) || xScale > 1 ? 1 : xScale;
        yScale = isNaN(yScale) || yScale > 1 ? 1 : yScale;
        sizableWidth = sizableWidth < 0 ? 0 : sizableWidth;
        sizableHeight = sizableHeight < 0 ? 0 : sizableHeight;
        data[0].x = -appx;
        data[0].y = -appy;
        data[1].x = leftWidth * xScale - appx;
        data[1].y = bottomHeight * yScale - appy;
        data[2].x = data[1].x + sizableWidth;
        data[2].y = data[1].y + sizableHeight;
        data[3].x = width - appx;
        data[3].y = height - appy;
        renderData.vertDirty = false;
      },
      draw: function draw(ctx, comp) {
        var node = comp.node;
        var matrix = node._worldMatrix;
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        ctx.transform(a, b, c, d, tx, ty);
        ctx.scale(1, -1);
        utils.context.setGlobalAlpha(ctx, node.opacity / 255);
        var tex = comp._spriteFrame._texture, data = comp._renderData._data;
        var image = utils.getColorizedImage(tex, node._color);
        var drawCall = 0;
        var off = void 0, ld = void 0, rd = void 0, td = void 0, bd = void 0, x = void 0, y = void 0, w = void 0, h = void 0, sx = void 0, sy = void 0, sw = void 0, sh = void 0;
        for (var r = 0; r < 3; ++r) {
          bd = data[r];
          td = data[r + 1];
          for (var _c = 0; _c < 3; ++_c) {
            ld = data[_c];
            rd = data[_c + 1];
            x = ld.x;
            y = bd.y;
            w = rd.x - x;
            h = td.y - y;
            y = -y - h;
            sx = ld.u;
            sy = td.v;
            sw = rd.u - sx;
            sh = bd.v - sy;
            if (sw > 0 && sh > 0 && w > 0 && h > 0) {
              ctx.drawImage(image, sx, sy, sw, sh, x, y, w, h);
              drawCall++;
            }
          }
        }
        return drawCall;
      }
    };
    module.exports = renderer;
  }), {
    "../utils": 146,
    "./simple": 143
  } ],
  145: [ (function(require, module, exports) {
    "use strict";
    var utils = require("../utils");
    var renderer = {
      createData: function createData(sprite) {
        var renderData = sprite.requestRenderData();
        return renderData;
      },
      updateRenderData: function updateRenderData(sprite) {
        sprite._material || sprite._activateMaterial();
      },
      draw: function draw(ctx, sprite) {
        var node = sprite.node;
        var matrix = node._worldMatrix;
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        ctx.transform(a, b, c, d, tx, ty);
        ctx.scale(1, -1);
        utils.context.setGlobalAlpha(ctx, node.opacity / 255);
        var frame = sprite.spriteFrame;
        var rect = frame._rect;
        var tex = frame._texture;
        var sx = rect.x;
        var sy = rect.y;
        var sw = frame._rotated ? rect.height : rect.width;
        var sh = frame._rotated ? rect.width : rect.height;
        var image = utils.getFrameCache(tex, node._color, sx, sy, sw, sh);
        var w = node.width, h = node.height, x = -node.anchorX * w, y = -node.anchorY * h;
        y = -y - h;
        ctx.translate(x, y);
        ctx.fillStyle = ctx.createPattern(image, "repeat");
        ctx.fillRect(0, 0, w, h);
        return 1;
      }
    };
    module.exports = renderer;
  }), {
    "../utils": 146
  } ],
  146: [ (function(require, module, exports) {
    "use strict";
    var WHITE = 16777215;
    var MAX_CANVAS_COUNT = 32;
    function colorizedFrame(canvas, texture, color, sx, sy, sw, sh) {
      var image = texture._image;
      var ctx = canvas.getContext("2d");
      canvas.width = sw;
      canvas.height = sh;
      ctx.globalCompositeOperation = "source-over";
      ctx.fillStyle = "rgb(" + color.r + "," + color.g + "," + color.b + ")";
      ctx.fillRect(0, 0, sw, sh);
      ctx.globalCompositeOperation = "multiply";
      ctx.drawImage(image, sx, sy, sw, sh, 0, 0, sw, sh);
      ctx.globalCompositeOperation = "destination-atop";
      ctx.drawImage(image, sx, sy, sw, sh, 0, 0, sw, sh);
      return canvas;
    }
    var canvasMgr = {
      canvasMap: {},
      canvasUsed: {},
      canvasPool: [],
      checking: false,
      check: function check() {
        var exist = false;
        for (var key in this.canvasUsed) {
          exist = true;
          if (this.canvasUsed[key]) this.canvasUsed[key] = false; else {
            var canvas = this.canvasMap[key];
            canvas.width = 0;
            canvas.height = 0;
            this.canvasPool.length < 32 && this.canvasPool.push(canvas);
            delete this.canvasMap[key];
            delete this.canvasUsed[key];
          }
        }
        if (!exist) {
          cc.director.off(cc.Director.EVENT_AFTER_DRAW, this.check, this);
          this.checking = false;
        }
      },
      startCheck: function startCheck() {
        cc.director.on(cc.Director.EVENT_AFTER_DRAW, this.check, this);
        this.checking = true;
      },
      getCanvas: function getCanvas(key) {
        this.canvasUsed[key] = true;
        return this.canvasMap[key];
      },
      cacheCanvas: function cacheCanvas(canvas, key) {
        this.canvasMap[key] = canvas;
        this.canvasUsed[key] = true;
        this.checking || this.startCheck();
      },
      dropImage: function dropImage(key) {
        this.canvasMap[key] && delete this.canvasMap[key];
      }
    };
    module.exports = {
      getColorizedImage: function getColorizedImage(texture, color) {
        if (!texture) return null;
        if (0 === texture.width || 0 === texture.height) return texture._image;
        var cval = 16777215 & color._val;
        if (cval === WHITE) return texture._image;
        var key = texture.url + cval;
        var cache = canvasMgr.getCanvas(key);
        if (!cache) {
          cache = canvasMgr.canvasPool.pop() || document.createElement("canvas");
          colorizedFrame(cache, texture, color, 0, 0, texture.width, texture.height);
          canvasMgr.cacheCanvas(cache, key);
        }
        return cache;
      },
      getFrameCache: function getFrameCache(texture, color, sx, sy, sw, sh) {
        if (!texture || !texture.url || sx < 0 || sy < 0 || sw <= 0 || sh <= 0) return null;
        var key = texture.url;
        var generate = false;
        var cval = 16777215 & color._val;
        if (cval !== WHITE) {
          key += cval;
          generate = true;
        }
        if (0 !== sx || 0 !== sy && sw !== texture.width && sh !== texture.height) {
          key += "_" + sx + "_" + sy + "_" + sw + "_" + sh;
          generate = true;
        }
        if (!generate) return texture._image;
        var cache = canvasMgr.getCanvas(key);
        if (!cache) {
          cache = canvasMgr.canvasPool.pop() || document.createElement("canvas");
          colorizedFrame(cache, texture, color, sx, sy, sw, sh);
          canvasMgr.cacheCanvas(cache, key);
        }
        return cache;
      },
      dropColorizedImage: function dropColorizedImage(texture, color) {
        var key = texture.url + (16777215 & color._val);
        canvasMgr.dropImage(key);
      }
    };
    var _globalAlpha = -1;
    var context = {
      setGlobalAlpha: function setGlobalAlpha(ctx, alpha) {
        if (_globalAlpha === alpha) return;
        _globalAlpha = alpha;
        ctx.globalAlpha = _globalAlpha;
      },
      reset: function reset() {
        _globalAlpha = -1;
      }
    };
    module.exports.context = context;
  }), {} ],
  147: [ (function(require, module, exports) {
    "use strict";
    var _forwardRenderer = require("../../renderer/renderers/forward-renderer");
    var _forwardRenderer2 = _interopRequireDefault(_forwardRenderer);
    var _config = require("../../renderer/config");
    var _config2 = _interopRequireDefault(_config);
    var _gfx = require("../../renderer/gfx");
    var _gfx2 = _interopRequireDefault(_gfx);
    var _scene = require("../../renderer/scene/scene");
    var _scene2 = _interopRequireDefault(_scene);
    var _inputAssembler = require("../../renderer/core/input-assembler");
    var _inputAssembler2 = _interopRequireDefault(_inputAssembler);
    var _iaRenderData = require("../../renderer/render-data/ia-render-data");
    var _iaRenderData2 = _interopRequireDefault(_iaRenderData);
    var _pass = require("../../renderer/core/pass");
    var _pass2 = _interopRequireDefault(_pass);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RenderFlow = require("./render-flow");
    function _initBuiltins(device) {
      var defaultTexture = new _gfx2.default.Texture2D(device, {
        images: [],
        width: 128,
        height: 128,
        wrapS: _gfx2.default.WRAP_REPEAT,
        wrapT: _gfx2.default.WRAP_REPEAT,
        format: _gfx2.default.TEXTURE_FMT_RGB8,
        mipmap: false
      });
      return {
        defaultTexture: defaultTexture
      };
    }
    cc.renderer = module.exports = {
      Texture2D: null,
      InputAssembler: _inputAssembler2.default,
      IARenderData: _iaRenderData2.default,
      Pass: _pass2.default,
      renderEngine: null,
      canvas: null,
      device: null,
      scene: null,
      drawCalls: 0,
      _handle: null,
      _cameraNode: null,
      _camera: null,
      _forward: null,
      initWebGL: function initWebGL(canvas, opts) {
        require("./webgl/assemblers");
        var ModelBatcher = require("./webgl/model-batcher");
        this.Texture2D = _gfx2.default.Texture2D;
        this.canvas = canvas;
        false;
        this.device = new _gfx2.default.Device(canvas, opts);
        this.scene = new _scene2.default();
        this._handle = new ModelBatcher(this.device, this.scene);
        RenderFlow.init(this._handle);
        var builtins = _initBuiltins(this.device);
        this._forward = new _forwardRenderer2.default(this.device, builtins);
        _config2.default.addStage("shadowcast");
        _config2.default.addStage("opaque");
        _config2.default.addStage("transparent");
      },
      initCanvas: function initCanvas(canvas) {
        var canvasRenderer = require("./canvas");
        var Texture2D = require("./canvas/Texture2D");
        var Device = require("./canvas/Device");
        this.Device = Device;
        this.Texture2D = Texture2D;
        this.canvas = canvas;
        this.device = new Device(canvas);
        this._camera = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          tx: 0,
          ty: 0
        };
        this._handle = new canvasRenderer.RenderComponentHandle(this.device, this._camera);
        RenderFlow.init(this._handle);
        this._forward = new canvasRenderer.ForwardRenderer();
      },
      updateCameraViewport: function updateCameraViewport() {
        if (true, cc.director) {
          var ecScene = cc.director.getScene();
          ecScene.setScale(1, 1, 1);
        }
        if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) {
          var vp = cc.view.getViewportRect();
          this.device.setViewport(vp.x, vp.y, vp.width, vp.height);
          this._camera.a = cc.view.getScaleX();
          this._camera.d = cc.view.getScaleY();
          this._camera.tx = vp.x;
          this._camera.ty = vp.y + vp.height;
        }
      },
      render: function render(ecScene) {
        this.device._stats.drawcalls = 0;
        if (ecScene) {
          RenderFlow.visit(ecScene);
          this._forward.render(this.scene);
          this.drawCalls = this.device._stats.drawcalls;
        }
      },
      clear: function clear() {
        this._handle.reset();
        this._forward.clear();
      }
    };
  }), {
    "../../renderer/config": 220,
    "../../renderer/core/input-assembler": 223,
    "../../renderer/core/pass": 224,
    "../../renderer/gfx": 233,
    "../../renderer/render-data/ia-render-data": 252,
    "../../renderer/renderers/forward-renderer": 254,
    "../../renderer/scene/scene": 257,
    "./canvas": 133,
    "./canvas/Device": 130,
    "./canvas/Texture2D": 131,
    "./render-flow": 148,
    "./webgl/assemblers": 159,
    "./webgl/model-batcher": 174
  } ],
  148: [ (function(require, module, exports) {
    "use strict";
    var DONOTHING = 0;
    var LOCAL_TRANSFORM = 1;
    var WORLD_TRANSFORM = 2;
    var TRANSFORM = LOCAL_TRANSFORM | WORLD_TRANSFORM;
    var UPDATE_RENDER_DATA = 4;
    var OPACITY = 8;
    var RENDER = 16;
    var CUSTOM_IA_RENDER = 32;
    var CHILDREN = 64;
    var POST_UPDATE_RENDER_DATA = 128;
    var POST_RENDER = 256;
    var FINAL = 512;
    var _batcher = void 0;
    var _cullingMask = 0;
    function RenderFlow() {
      this._func = init;
      this._next = null;
    }
    var _proto = RenderFlow.prototype;
    _proto._doNothing = function() {};
    _proto._localTransform = function(node) {
      node._updateLocalMatrix();
      node._renderFlag &= ~LOCAL_TRANSFORM;
      this._next._func(node);
    };
    _proto._worldTransform = function(node) {
      _batcher.worldMatDirty++;
      var t = node._matrix;
      var position = node._position;
      t.m12 = position.x;
      t.m13 = position.y;
      t.m14 = position.z;
      node._mulMat(node._worldMatrix, node._parent._worldMatrix, t);
      node._renderFlag &= ~WORLD_TRANSFORM;
      this._next._func(node);
      _batcher.worldMatDirty--;
    };
    _proto._opacity = function(node) {
      _batcher.parentOpacityDirty++;
      var comp = node._renderComponent;
      comp && comp._updateColor && comp._updateColor();
      node._renderFlag &= ~OPACITY;
      this._next._func(node);
      _batcher.parentOpacityDirty--;
    };
    _proto._updateRenderData = function(node) {
      var comp = node._renderComponent;
      comp._assembler.updateRenderData(comp);
      node._renderFlag &= ~UPDATE_RENDER_DATA;
      this._next._func(node);
    };
    _proto._render = function(node) {
      var comp = node._renderComponent;
      _batcher._commitComp(comp, comp._assembler, node._cullingMask);
      this._next._func(node);
    };
    _proto._customIARender = function(node) {
      var comp = node._renderComponent;
      _batcher._commitIA(comp, comp._assembler, node._cullingMask);
      this._next._func(node);
    };
    _proto._children = function(node) {
      var cullingMask = _cullingMask;
      var batcher = _batcher;
      var parentOpacity = batcher.parentOpacity;
      var opacity = batcher.parentOpacity *= node._opacity / 255;
      var worldTransformFlag = batcher.worldMatDirty ? WORLD_TRANSFORM : 0;
      var worldOpacityFlag = batcher.parentOpacityDirty ? OPACITY : 0;
      var worldDirtyFlag = worldTransformFlag | worldOpacityFlag;
      var children = node._children;
      for (var i = 0, l = children.length; i < l; i++) {
        var c = children[i];
        c._renderFlag |= worldDirtyFlag;
        if (!c._activeInHierarchy || 0 === c._opacity) continue;
        var colorVal = c._color._val;
        c._color._fastSetA(c._opacity * opacity);
        flows[c._renderFlag]._func(c);
        c._color._val = colorVal;
      }
      batcher.parentOpacity = parentOpacity;
      this._next._func(node);
    };
    _proto._postUpdateRenderData = function(node) {
      var comp = node._renderComponent;
      comp._postAssembler && comp._postAssembler.updateRenderData(comp);
      node._renderFlag &= ~POST_UPDATE_RENDER_DATA;
      this._next._func(node);
    };
    _proto._postRender = function(node) {
      var comp = node._renderComponent;
      _batcher._commitComp(comp, comp._postAssembler, node._cullingMask);
      this._next._func(node);
    };
    var EMPTY_FLOW = new RenderFlow();
    EMPTY_FLOW._func = EMPTY_FLOW._doNothing;
    EMPTY_FLOW._next = EMPTY_FLOW;
    var flows = {};
    function createFlow(flag, next) {
      var flow = new RenderFlow();
      flow._next = next || EMPTY_FLOW;
      switch (flag) {
       case DONOTHING:
        flow._func = flow._doNothing;
        break;

       case LOCAL_TRANSFORM:
        flow._func = flow._localTransform;
        break;

       case WORLD_TRANSFORM:
        flow._func = flow._worldTransform;
        break;

       case OPACITY:
        flow._func = flow._opacity;
        break;

       case UPDATE_RENDER_DATA:
        flow._func = flow._updateRenderData;
        break;

       case RENDER:
        flow._func = flow._render;
        break;

       case CUSTOM_IA_RENDER:
        flow._func = flow._customIARender;
        break;

       case CHILDREN:
        flow._func = flow._children;
        break;

       case POST_UPDATE_RENDER_DATA:
        flow._func = flow._postUpdateRenderData;
        break;

       case POST_RENDER:
        flow._func = flow._postRender;
      }
      return flow;
    }
    function getFlow(flag) {
      var flow = null;
      var tFlag = FINAL;
      while (tFlag > 0) {
        tFlag & flag && (flow = createFlow(tFlag, flow));
        tFlag >>= 1;
      }
      return flow;
    }
    function init(node) {
      var flag = node._renderFlag;
      var r = flows[flag] = getFlow(flag);
      r._func(node);
    }
    RenderFlow.flows = flows;
    RenderFlow.createFlow = createFlow;
    RenderFlow.visit = function(scene) {
      _batcher.reset();
      _batcher.walking = true;
      _cullingMask = 1 << scene.groupIndex;
      if (scene._renderFlag & WORLD_TRANSFORM) {
        _batcher.worldMatDirty++;
        scene._calculWorldMatrix();
        scene._renderFlag &= ~WORLD_TRANSFORM;
        flows[scene._renderFlag]._func(scene);
        _batcher.worldMatDirty--;
      } else flows[scene._renderFlag]._func(scene);
      _batcher.terminate();
      _batcher.walking = false;
    };
    RenderFlow.init = function(batcher) {
      _batcher = batcher;
      flows[0] = EMPTY_FLOW;
      for (var i = 1; i < FINAL; i++) flows[i] = new RenderFlow();
    };
    RenderFlow.FLAG_DONOTHING = DONOTHING;
    RenderFlow.FLAG_LOCAL_TRANSFORM = LOCAL_TRANSFORM;
    RenderFlow.FLAG_WORLD_TRANSFORM = WORLD_TRANSFORM;
    RenderFlow.FLAG_TRANSFORM = TRANSFORM;
    RenderFlow.FLAG_OPACITY = OPACITY;
    RenderFlow.FLAG_UPDATE_RENDER_DATA = UPDATE_RENDER_DATA;
    RenderFlow.FLAG_RENDER = RENDER;
    RenderFlow.FLAG_CUSTOM_IA_RENDER = CUSTOM_IA_RENDER;
    RenderFlow.FLAG_CHILDREN = CHILDREN;
    RenderFlow.FLAG_POST_UPDATE_RENDER_DATA = POST_UPDATE_RENDER_DATA;
    RenderFlow.FLAG_POST_RENDER = POST_RENDER;
    RenderFlow.FLAG_FINAL = FINAL;
    module.exports = cc.RenderFlow = RenderFlow;
  }), {} ],
  149: [ (function(require, module, exports) {
    "use strict";
    var RenderTexture = require("../../../assets/CCRenderTexture");
    var space = 2;
    function Atlas(width, height) {
      var texture = new RenderTexture();
      texture.initWithSize(width, height);
      texture.update();
      this._texture = texture;
      this._x = space;
      this._y = space;
      this._nexty = space;
      this._width = width;
      this._height = height;
      this._innerTextureInfos = {};
      this._innerSpriteFrames = [];
    }
    Atlas.DEFAULT_HASH = new RenderTexture()._getHash();
    cc.js.mixin(Atlas.prototype, {
      insertSpriteFrame: function insertSpriteFrame(spriteFrame) {
        var rect = spriteFrame._rect, texture = spriteFrame._texture, info = this._innerTextureInfos[texture._id];
        var sx = rect.x, sy = rect.y;
        if (info) {
          sx += info.x;
          sy += info.y;
        } else {
          var width = texture.width, height = texture.height;
          if (this._x + width + space > this._width) {
            this._x = space;
            this._y = this._nexty;
          }
          this._y + height > this._nexty && (this._nexty = this._y + height + space);
          if (this._nexty > this._height) return null;
          this._texture.drawTextureAt(texture, this._x - 1, this._y);
          this._texture.drawTextureAt(texture, this._x + 1, this._y);
          this._texture.drawTextureAt(texture, this._x, this._y - 1);
          this._texture.drawTextureAt(texture, this._x, this._y + 1);
          this._texture.drawTextureAt(texture, this._x, this._y);
          this._innerTextureInfos[texture._id] = {
            x: this._x,
            y: this._y,
            texture: texture
          };
          sx += this._x;
          sy += this._y;
          this._x += width + space;
          this._dirty = true;
        }
        var frame = {
          x: sx,
          y: sy,
          texture: this._texture
        };
        this._innerSpriteFrames.push(spriteFrame);
        return frame;
      },
      update: function update() {
        if (!this._dirty) return;
        this._texture.update();
        this._dirty = false;
      },
      deleteInnerTexture: function deleteInnerTexture(texture) {
        texture && delete this._innerTextureInfos[texture._id];
      },
      reset: function reset() {
        this._x = space;
        this._y = space;
        this._nexty = space;
        var frames = this._innerSpriteFrames;
        for (var i = 0, l = frames.length; i < l; i++) {
          var frame = frames[i];
          if (!frame.isValid) continue;
          frame._resetDynamicAtlasFrame();
        }
        this._innerSpriteFrames.length = 0;
        this._innerTextureInfos = {};
      },
      destroy: function destroy() {
        this.reset();
        this._texture.destroy();
      }
    });
    module.exports = Atlas;
  }), {
    "../../../assets/CCRenderTexture": 20
  } ],
  150: [ (function(require, module, exports) {
    "use strict";
    var Atlas = require("./atlas");
    var _atlases = [];
    var _atlasIndex = -1;
    var _maxAtlasCount = 5;
    var _textureSize = 2048;
    var _minFrameSize = 8;
    var _maxFrameSize = 512;
    var _debugNode = null;
    function newAtlas() {
      var atlas = _atlases[++_atlasIndex];
      if (!atlas) {
        atlas = new Atlas(_textureSize, _textureSize);
        _atlases.push(atlas);
      }
      return atlas;
    }
    function beforeSceneLoad() {
      dynamicAtlasManager.reset();
    }
    var _enabled = false;
    var dynamicAtlasManager = {
      get enabled() {
        return _enabled;
      },
      set enabled(value) {
        if (_enabled === value) return;
        if (value) {
          this.reset();
          cc.director.on(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, beforeSceneLoad);
        } else cc.director.off(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, beforeSceneLoad);
        _enabled = value;
      },
      get maxAtlasCount() {
        return _maxAtlasCount;
      },
      set maxAtlasCount(value) {
        _maxAtlasCount = value;
      },
      get textureSize() {
        return _textureSize;
      },
      set textureSize(value) {
        _textureSize = value;
      },
      get maxFrameSize() {
        return _maxFrameSize;
      },
      set maxFrameSize(value) {
        _maxFrameSize = value;
      },
      insertSpriteFrame: function insertSpriteFrame(spriteFrame) {
        false;
        if (!_enabled || _atlasIndex === _maxAtlasCount || !spriteFrame || spriteFrame._original) return null;
        var texture = spriteFrame._texture;
        if (texture instanceof cc.RenderTexture || texture._isCompressed()) return null;
        var w = texture.width, h = texture.height;
        if (w > _maxFrameSize || h > _maxFrameSize || w <= _minFrameSize || h <= _minFrameSize || texture._getHash() !== Atlas.DEFAULT_HASH) return null;
        var atlas = _atlases[_atlasIndex];
        atlas || (atlas = newAtlas());
        var frame = atlas.insertSpriteFrame(spriteFrame);
        if (!frame && _atlasIndex !== _maxAtlasCount) {
          atlas = newAtlas();
          return atlas.insertSpriteFrame(spriteFrame);
        }
        return frame;
      },
      reset: function reset() {
        for (var i = 0, l = _atlases.length; i < l; i++) _atlases[i].destroy();
        _atlases.length = 0;
        _atlasIndex = -1;
      },
      deleteAtlasTexture: function deleteAtlasTexture(spriteFrame) {
        if (!spriteFrame._original) return;
        var texture = spriteFrame._original._texture;
        if (texture) for (var i = 0, l = _atlases.length; i < l; i++) _atlases[i].deleteInnerTexture(texture);
      },
      showDebug: false,
      update: function update() {
        if (!this.enabled) return;
        for (var i = 0; i <= _atlasIndex; i++) _atlases[i].update();
      }
    };
    module.exports = cc.dynamicAtlasManager = dynamicAtlasManager;
  }), {
    "./atlas": 149
  } ],
  151: [ (function(require, module, exports) {
    "use strict";
    var macro = require("../../../platform/CCMacro");
    var Label = require("../../../components/CCLabel");
    var Overflow = Label.Overflow;
    var textUtils = require("../../../utils/text-utils");
    var FontLetterDefinition = function FontLetterDefinition() {
      this._u = 0;
      this._v = 0;
      this._width = 0;
      this._height = 0;
      this._offsetX = 0;
      this._offsetY = 0;
      this._textureID = 0;
      this._validDefinition = false;
      this._xAdvance = 0;
    };
    cc.FontAtlas = function(texture) {
      this._letterDefinitions = {};
      this._texture = texture;
    };
    cc.FontAtlas.prototype = {
      constructor: cc.FontAtlas,
      addLetterDefinitions: function addLetterDefinitions(letter, letterDefinition) {
        this._letterDefinitions[letter] = letterDefinition;
      },
      cloneLetterDefinition: function cloneLetterDefinition() {
        var copyLetterDefinitions = {};
        for (var key in this._letterDefinitions) {
          var value = new FontLetterDefinition();
          cc.js.mixin(value, this._letterDefinitions[key]);
          copyLetterDefinitions[key] = value;
        }
        return copyLetterDefinitions;
      },
      assignLetterDefinitions: function assignLetterDefinitions(letterDefinition) {
        for (var key in this._letterDefinitions) {
          var newValue = letterDefinition[key];
          var oldValue = this._letterDefinitions[key];
          cc.js.mixin(oldValue, newValue);
        }
      },
      scaleFontLetterDefinition: function scaleFontLetterDefinition(scaleFactor) {
        for (var fontDefinition in this._letterDefinitions) {
          var letterDefinitions = this._letterDefinitions[fontDefinition];
          letterDefinitions._width *= scaleFactor;
          letterDefinitions._height *= scaleFactor;
          letterDefinitions._offsetX *= scaleFactor;
          letterDefinitions._offsetY *= scaleFactor;
          letterDefinitions._xAdvance *= scaleFactor;
        }
      },
      getLetterDefinitionForChar: function getLetterDefinitionForChar(char) {
        var hasKey = this._letterDefinitions.hasOwnProperty(char.charCodeAt(0));
        var letterDefinition = void 0;
        letterDefinition = hasKey ? this._letterDefinitions[char.charCodeAt(0)] : null;
        return letterDefinition;
      }
    };
    var FontAtlasManager = function FontAtlasManager() {
      this._fontAtlas = {};
      this._references = {};
      cc.director.on(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, this.clear, this);
    };
    FontAtlasManager.prototype.getFontAtlas = function(comp) {
      var fontAsset = comp.font;
      var fntConfig = fontAsset._fntConfig;
      var name = fntConfig.atlasName;
      var atlas = this._fontAtlas[name];
      if (!atlas) {
        atlas = this.createFontAtlas(fontAsset);
        this._fontAtlas[name] = atlas;
      }
      this._references[name] || (this._references[name] = []);
      -1 === this._references[name].indexOf(comp.node._id) && this._references[name].push(comp.node._id);
      return this._fontAtlas[name];
    };
    FontAtlasManager.prototype.releaseFontAtlas = function(font, id) {
      if (!font) return;
      if (!(font instanceof cc.BitmapFont)) return;
      if (!font._fntConfig) return;
      var fntConfig = font._fntConfig;
      var name = fntConfig.atlasName;
      var reference = this._references[name];
      if (reference) for (var i = reference.length - 1; i >= 0; i--) if (reference[i] === id) {
        reference.splice(i, 1);
        break;
      }
      reference && 0 !== reference.length || delete this._fontAtlas[name];
    };
    FontAtlasManager.prototype.createFontAtlas = function(fontAsset) {
      var spriteFrame = fontAsset.spriteFrame;
      var fntConfig = fontAsset._fntConfig;
      var atlas = new cc.FontAtlas(spriteFrame.texture);
      var fontDict = fntConfig.fontDefDictionary;
      for (var fontDef in fontDict) {
        var letterDefinition = new FontLetterDefinition();
        var rect = fontDict[fontDef].rect;
        letterDefinition._offsetX = fontDict[fontDef].xOffset;
        letterDefinition._offsetY = fontDict[fontDef].yOffset;
        letterDefinition._width = rect.width;
        letterDefinition._height = rect.height;
        letterDefinition._u = rect.x;
        letterDefinition._v = rect.y;
        letterDefinition._textureID = 0;
        letterDefinition._validDefinition = true;
        letterDefinition._xAdvance = fontDict[fontDef].xAdvance;
        atlas.addLetterDefinitions(fontDef, letterDefinition);
      }
      return atlas;
    };
    FontAtlasManager.prototype.clear = function() {
      this._fontAtlas = {};
      this._references = {};
    };
    cc.Label.FontAtlasManager = new FontAtlasManager();
    var LetterInfo = function LetterInfo() {
      this._char = "";
      this._valid = true;
      this._positionX = 0;
      this._positionY = 0;
      this._lineIndex = 0;
    };
    var _tmpRect = cc.rect();
    var _comp = null;
    var _horizontalKernings = [];
    var _lettersInfo = [];
    var _linesWidth = [];
    var _linesOffsetX = [];
    var _labelDimensions = cc.size();
    var _fontAtlas = null;
    var _fntConfig = null;
    var _numberOfLines = 0;
    var _textDesiredHeight = 0;
    var _letterOffsetY = 0;
    var _tailoredTopY = 0;
    var _tailoredBottomY = 0;
    var _bmfontScale = 1;
    var _lineBreakWithoutSpaces = false;
    var _spriteFrame = null;
    var _lineSpacing = 0;
    var _string = "";
    var _fontSize = 0;
    var _originFontSize = 0;
    var _contentSize = cc.size();
    var _hAlign = 0;
    var _vAlign = 0;
    var _spacingX = 0;
    var _lineHeight = 0;
    var _overflow = 0;
    var _isWrapText = false;
    var _labelWidth = 0;
    var _labelHeight = 0;
    var _maxLineWidth = 0;
    module.exports = {
      updateRenderData: function updateRenderData(comp) {
        if (!comp._renderData.vertDirty) return;
        if (_comp === comp) return;
        _comp = comp;
        this._updateProperties();
        this._updateContent();
        _comp._actualFontSize = _fontSize;
        _comp.node.setContentSize(_contentSize);
        _comp._renderData.vertDirty = _comp._renderData.uvDirty = false;
        _comp = null;
        this._resetProperties();
      },
      _updateFontScale: function _updateFontScale() {
        _bmfontScale = _fontSize / _originFontSize;
      },
      _updateProperties: function _updateProperties() {
        var fontAsset = _comp.font;
        _spriteFrame = fontAsset.spriteFrame;
        _fntConfig = fontAsset._fntConfig;
        _fontAtlas = cc.Label.FontAtlasManager.getFontAtlas(_comp);
        _string = _comp.string.toString();
        _fontSize = _comp.fontSize;
        _originFontSize = _fntConfig.fontSize;
        _contentSize.width = _comp.node._contentSize.width;
        _contentSize.height = _comp.node._contentSize.height;
        _hAlign = _comp.horizontalAlign;
        _vAlign = _comp.verticalAlign;
        _spacingX = _comp.spacingX;
        _overflow = _comp.overflow;
        _lineHeight = _comp._lineHeight;
        _isWrapText = _overflow !== Overflow.NONE && (_overflow === Overflow.RESIZE_HEIGHT || _comp.enableWrapText);
        this._setupBMFontOverflowMetrics();
      },
      _resetProperties: function _resetProperties() {
        _fontAtlas = null;
        _fntConfig = null;
        _spriteFrame = null;
      },
      _updateContent: function _updateContent() {
        this._updateFontScale();
        this._computeHorizontalKerningForText();
        this._alignText();
      },
      _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {
        var string = _string;
        var stringLen = string.length;
        var kerningDict = _fntConfig.kerningDict;
        var horizontalKernings = _horizontalKernings;
        var prev = -1;
        for (var i = 0; i < stringLen; ++i) {
          var key = string.charCodeAt(i);
          var kerningAmount = kerningDict[prev << 16 | 65535 & key] || 0;
          horizontalKernings[i] = i < stringLen - 1 ? kerningAmount : 0;
          prev = key;
        }
      },
      _multilineTextWrap: function _multilineTextWrap(nextTokenFunc) {
        var textLen = _string.length;
        var lineIndex = 0;
        var nextTokenX = 0;
        var nextTokenY = 0;
        var longestLine = 0;
        var letterRight = 0;
        var highestY = 0;
        var lowestY = 0;
        var letterDef = null;
        var letterPosition = cc.v2(0, 0);
        this._updateFontScale();
        var letterDefinitions = _fontAtlas._letterDefinitions;
        for (var index = 0; index < textLen; ) {
          var character = _string.charAt(index);
          if ("\n" === character) {
            _linesWidth.push(letterRight);
            letterRight = 0;
            lineIndex++;
            nextTokenX = 0;
            nextTokenY -= _lineHeight * _bmfontScale + _lineSpacing;
            this._recordPlaceholderInfo(index, character);
            index++;
            continue;
          }
          var tokenLen = nextTokenFunc(_string, index, textLen);
          var tokenHighestY = highestY;
          var tokenLowestY = lowestY;
          var tokenRight = letterRight;
          var nextLetterX = nextTokenX;
          var newLine = false;
          for (var tmp = 0; tmp < tokenLen; ++tmp) {
            var letterIndex = index + tmp;
            character = _string.charAt(letterIndex);
            if ("\r" === character) {
              this._recordPlaceholderInfo(letterIndex, character);
              continue;
            }
            letterDef = _fontAtlas.getLetterDefinitionForChar(character);
            if (!letterDef) {
              this._recordPlaceholderInfo(letterIndex, character);
              console.log("Can't find letter definition in texture atlas " + _fntConfig.atlasName + " for letter:" + character);
              continue;
            }
            var letterX = nextLetterX + letterDef._offsetX * _bmfontScale;
            if (_isWrapText && _maxLineWidth > 0 && nextTokenX > 0 && letterX + letterDef._width * _bmfontScale > _maxLineWidth && !textUtils.isUnicodeSpace(character)) {
              _linesWidth.push(letterRight);
              letterRight = 0;
              lineIndex++;
              nextTokenX = 0;
              nextTokenY -= _lineHeight * _bmfontScale + _lineSpacing;
              newLine = true;
              break;
            }
            letterPosition.x = letterX;
            letterPosition.y = nextTokenY - letterDef._offsetY * _bmfontScale;
            this._recordLetterInfo(letterDefinitions, letterPosition, character, letterIndex, lineIndex);
            letterIndex + 1 < _horizontalKernings.length && letterIndex < textLen - 1 && (nextLetterX += _horizontalKernings[letterIndex + 1]);
            nextLetterX += letterDef._xAdvance * _bmfontScale + _spacingX;
            tokenRight = letterPosition.x + letterDef._width * _bmfontScale;
            tokenHighestY < letterPosition.y && (tokenHighestY = letterPosition.y);
            tokenLowestY > letterPosition.y - letterDef._height * _bmfontScale && (tokenLowestY = letterPosition.y - letterDef._height * _bmfontScale);
          }
          if (newLine) continue;
          nextTokenX = nextLetterX;
          letterRight = tokenRight;
          highestY < tokenHighestY && (highestY = tokenHighestY);
          lowestY > tokenLowestY && (lowestY = tokenLowestY);
          longestLine < letterRight && (longestLine = letterRight);
          index += tokenLen;
        }
        _linesWidth.push(letterRight);
        _numberOfLines = lineIndex + 1;
        _textDesiredHeight = _numberOfLines * _lineHeight * _bmfontScale;
        _numberOfLines > 1 && (_textDesiredHeight += (_numberOfLines - 1) * _lineSpacing);
        _contentSize.width = _labelWidth;
        _contentSize.height = _labelHeight;
        _labelWidth <= 0 && (_contentSize.width = parseFloat(longestLine.toFixed(2)));
        _labelHeight <= 0 && (_contentSize.height = parseFloat(_textDesiredHeight.toFixed(2)));
        _tailoredTopY = _contentSize.height;
        _tailoredBottomY = 0;
        highestY > 0 && (_tailoredTopY = _contentSize.height + highestY);
        lowestY < -_textDesiredHeight && (_tailoredBottomY = _textDesiredHeight + lowestY);
        return true;
      },
      _getFirstCharLen: function _getFirstCharLen() {
        return 1;
      },
      _getFirstWordLen: function _getFirstWordLen(text, startIndex, textLen) {
        var character = text.charAt(startIndex);
        if (textUtils.isUnicodeCJK(character) || "\n" === character || textUtils.isUnicodeSpace(character)) return 1;
        var len = 1;
        var letterDef = _fontAtlas.getLetterDefinitionForChar(character);
        if (!letterDef) return len;
        var nextLetterX = letterDef._xAdvance * _bmfontScale + _spacingX;
        var letterX = void 0;
        for (var index = startIndex + 1; index < textLen; ++index) {
          character = text.charAt(index);
          letterDef = _fontAtlas.getLetterDefinitionForChar(character);
          if (!letterDef) break;
          letterX = nextLetterX + letterDef._offsetX * _bmfontScale;
          if (letterX + letterDef._width * _bmfontScale > _maxLineWidth && !textUtils.isUnicodeSpace(character) && _maxLineWidth > 0) return len;
          nextLetterX += letterDef._xAdvance * _bmfontScale + _spacingX;
          if ("\n" === character || textUtils.isUnicodeSpace(character) || textUtils.isUnicodeCJK(character)) break;
          len++;
        }
        return len;
      },
      _multilineTextWrapByWord: function _multilineTextWrapByWord() {
        return this._multilineTextWrap(this._getFirstWordLen);
      },
      _multilineTextWrapByChar: function _multilineTextWrapByChar() {
        return this._multilineTextWrap(this._getFirstCharLen);
      },
      _recordPlaceholderInfo: function _recordPlaceholderInfo(letterIndex, char) {
        if (letterIndex >= _lettersInfo.length) {
          var tmpInfo = new LetterInfo();
          _lettersInfo.push(tmpInfo);
        }
        _lettersInfo[letterIndex]._char = char;
        _lettersInfo[letterIndex]._valid = false;
      },
      _recordLetterInfo: function _recordLetterInfo(letterDefinitions, letterPosition, character, letterIndex, lineIndex) {
        if (letterIndex >= _lettersInfo.length) {
          var tmpInfo = new LetterInfo();
          _lettersInfo.push(tmpInfo);
        }
        character = character.charCodeAt(0);
        _lettersInfo[letterIndex]._lineIndex = lineIndex;
        _lettersInfo[letterIndex]._char = character;
        _lettersInfo[letterIndex]._valid = letterDefinitions[character]._validDefinition;
        _lettersInfo[letterIndex]._positionX = letterPosition.x;
        _lettersInfo[letterIndex]._positionY = letterPosition.y;
      },
      _alignText: function _alignText() {
        _textDesiredHeight = 0;
        _linesWidth.length = 0;
        _lineBreakWithoutSpaces ? this._multilineTextWrapByChar() : this._multilineTextWrapByWord();
        this._computeAlignmentOffset();
        _overflow === Overflow.SHRINK && _fontSize > 0 && this._isVerticalClamp() && this._shrinkLabelToContentSize(this._isVerticalClamp);
        this._updateQuads() || _overflow === Overflow.SHRINK && this._shrinkLabelToContentSize(this._isHorizontalClamp);
      },
      _scaleFontSizeDown: function _scaleFontSizeDown(fontSize) {
        var shouldUpdateContent = true;
        if (!fontSize) {
          fontSize = .1;
          shouldUpdateContent = false;
        }
        _fontSize = fontSize;
        shouldUpdateContent && this._updateContent();
      },
      _shrinkLabelToContentSize: function _shrinkLabelToContentSize(lambda) {
        var fontSize = _fontSize;
        var originalLineHeight = _lineHeight;
        var fontAtlas = _fontAtlas;
        var i = 0;
        var tempLetterDefinition = fontAtlas.cloneLetterDefinition();
        var flag = true;
        while (lambda()) {
          ++i;
          var newFontSize = fontSize - i;
          flag = false;
          if (newFontSize <= 0) break;
          var scale = newFontSize / fontSize;
          fontAtlas.assignLetterDefinitions(tempLetterDefinition);
          fontAtlas.scaleFontLetterDefinition(scale);
          _lineHeight = originalLineHeight * scale;
          _lineBreakWithoutSpaces ? this._multilineTextWrapByChar() : this._multilineTextWrapByWord();
          this._computeAlignmentOffset();
        }
        _lineHeight = originalLineHeight;
        fontAtlas.assignLetterDefinitions(tempLetterDefinition);
        flag || fontSize - i >= 0 && this._scaleFontSizeDown(fontSize - i);
      },
      _isVerticalClamp: function _isVerticalClamp() {
        return _textDesiredHeight > _contentSize.height;
      },
      _isHorizontalClamp: function _isHorizontalClamp() {
        var letterDefinitions = _fontAtlas._letterDefinitions;
        var letterClamp = false;
        for (var ctr = 0, l = _string.length; ctr < l; ++ctr) {
          var letterInfo = _lettersInfo[ctr];
          if (letterInfo._valid) {
            var letterDef = letterDefinitions[letterInfo._char];
            var px = letterInfo._positionX + letterDef._width * _bmfontScale;
            var lineIndex = letterInfo._lineIndex;
            if (_labelWidth > 0) if (_isWrapText) {
              var wordWidth = _linesWidth[lineIndex];
              if (wordWidth > _contentSize.width && (px > _contentSize.width || px < 0)) {
                letterClamp = true;
                break;
              }
            } else if (px > _contentSize.width) {
              letterClamp = true;
              break;
            }
          }
        }
        return letterClamp;
      },
      _isHorizontalClamped: function _isHorizontalClamped(px, lineIndex) {
        var wordWidth = _linesWidth[lineIndex];
        var letterOverClamp = px > _contentSize.width || px < 0;
        return _isWrapText ? wordWidth > _contentSize.width && letterOverClamp : letterOverClamp;
      },
      _updateQuads: function _updateQuads() {
        var letterDefinitions = _fontAtlas._letterDefinitions;
        var texture = _spriteFrame._texture;
        var node = _comp.node;
        var renderData = _comp._renderData;
        renderData.dataLength = renderData.vertexCount = renderData.indiceCount = 0;
        var contentSize = _contentSize, appx = node._anchorPoint.x * contentSize.width, appy = node._anchorPoint.y * contentSize.height;
        var ret = true;
        for (var ctr = 0, l = _string.length; ctr < l; ++ctr) {
          var letterInfo = _lettersInfo[ctr];
          if (!letterInfo._valid) continue;
          var letterDef = letterDefinitions[letterInfo._char];
          _tmpRect.height = letterDef._height;
          _tmpRect.width = letterDef._width;
          _tmpRect.x = letterDef._u;
          _tmpRect.y = letterDef._v;
          var py = letterInfo._positionY + _letterOffsetY;
          if (_labelHeight > 0) {
            if (py > _tailoredTopY) {
              var clipTop = py - _tailoredTopY;
              _tmpRect.y += clipTop;
              _tmpRect.height -= clipTop;
              py -= clipTop;
            }
            py - letterDef._height * _bmfontScale < _tailoredBottomY && (_tmpRect.height = py < _tailoredBottomY ? 0 : py - _tailoredBottomY);
          }
          var lineIndex = letterInfo._lineIndex;
          var px = letterInfo._positionX + letterDef._width / 2 * _bmfontScale + _linesOffsetX[lineIndex];
          if (_labelWidth > 0 && this._isHorizontalClamped(px, lineIndex)) if (_overflow === Overflow.CLAMP) _tmpRect.width = 0; else if (_overflow === Overflow.SHRINK) {
            if (_contentSize.width > letterDef._width) {
              ret = false;
              break;
            }
            _tmpRect.width = 0;
          }
          if (_tmpRect.height > 0 && _tmpRect.width > 0) {
            var isRotated = _spriteFrame.isRotated();
            var originalSize = _spriteFrame._originalSize;
            var rect = _spriteFrame._rect;
            var offset = _spriteFrame._offset;
            var trimmedLeft = offset.x + (originalSize.width - rect.width) / 2;
            var trimmedTop = offset.y - (originalSize.height - rect.height) / 2;
            if (isRotated) {
              var originalX = _tmpRect.x;
              _tmpRect.x = rect.x + rect.height - _tmpRect.y - _tmpRect.height - trimmedTop;
              _tmpRect.y = originalX + rect.y - trimmedLeft;
              _tmpRect.y < 0 && (_tmpRect.height = _tmpRect.height + trimmedTop);
            } else {
              _tmpRect.x += rect.x - trimmedLeft;
              _tmpRect.y += rect.y + trimmedTop;
            }
            var letterPositionX = letterInfo._positionX + _linesOffsetX[letterInfo._lineIndex];
            this.appendQuad(renderData, texture, _tmpRect, isRotated, letterPositionX - appx, py - appy, _bmfontScale);
          }
        }
        return ret;
      },
      appendQuad: function appendQuad(renderData, texture, rect, rotated, x, y, scale) {},
      _computeAlignmentOffset: function _computeAlignmentOffset() {
        _linesOffsetX.length = 0;
        switch (_hAlign) {
         case macro.TextAlignment.LEFT:
          for (var i = 0; i < _numberOfLines; ++i) _linesOffsetX.push(0);
          break;

         case macro.TextAlignment.CENTER:
          for (var _i = 0, l = _linesWidth.length; _i < l; _i++) _linesOffsetX.push((_contentSize.width - _linesWidth[_i]) / 2);
          break;

         case macro.TextAlignment.RIGHT:
          for (var _i2 = 0, _l = _linesWidth.length; _i2 < _l; _i2++) _linesOffsetX.push(_contentSize.width - _linesWidth[_i2]);
        }
        switch (_vAlign) {
         case macro.VerticalTextAlignment.TOP:
          _letterOffsetY = _contentSize.height;
          break;

         case macro.VerticalTextAlignment.CENTER:
          _letterOffsetY = (_contentSize.height + _textDesiredHeight) / 2;
          break;

         case macro.VerticalTextAlignment.BOTTOM:
          _letterOffsetY = _textDesiredHeight;
        }
      },
      _setupBMFontOverflowMetrics: function _setupBMFontOverflowMetrics() {
        var newWidth = _contentSize.width, newHeight = _contentSize.height;
        _overflow === Overflow.RESIZE_HEIGHT && (newHeight = 0);
        if (_overflow === Overflow.NONE) {
          newWidth = 0;
          newHeight = 0;
        }
        _labelWidth = newWidth;
        _labelHeight = newHeight;
        _labelDimensions.width = newWidth;
        _labelDimensions.height = newHeight;
        _maxLineWidth = newWidth;
      }
    };
  }), {
    "../../../components/CCLabel": 41,
    "../../../platform/CCMacro": 109,
    "../../../utils/text-utils": 193
  } ],
  152: [ (function(require, module, exports) {
    "use strict";
    function LabelFrame() {
      this._rect = null;
      this.uv = [];
      this._texture = null;
      this._original = null;
    }
    LabelFrame.prototype = {
      constructor: LabelFrame,
      getRect: function getRect() {
        return cc.rect(this._rect);
      },
      setRect: function setRect(rect) {
        this._rect = rect;
        this._texture && this._calculateUV();
      },
      _setDynamicAtlasFrame: function _setDynamicAtlasFrame(frame) {
        if (!frame) return;
        this._original = {
          _texture: this._texture,
          _x: this._rect.x,
          _y: this._rect.y
        };
        this._texture = frame.texture;
        this._rect.x = frame.x;
        this._rect.y = frame.y;
        this._calculateUV();
      },
      _resetDynamicAtlasFrame: function _resetDynamicAtlasFrame() {
        if (!this._original) return;
        this._rect.x = this._original._x;
        this._rect.y = this._original._y;
        this._texture = this._original._texture;
        this._original = null;
        this._calculateUV();
      },
      _refreshTexture: function _refreshTexture(texture) {
        this._texture = texture;
        this._rect = cc.rect(0, 0, texture.width, texture.height);
        this._calculateUV();
      },
      _calculateUV: function _calculateUV() {
        var rect = this._rect, texture = this._texture, uv = this.uv, texw = texture.width, texh = texture.height;
        var l = 0 === texw ? 0 : rect.x / texw;
        var r = 0 === texw ? 0 : (rect.x + rect.width) / texw;
        var b = 0 === texh ? 0 : (rect.y + rect.height) / texh;
        var t = 0 === texh ? 0 : rect.y / texh;
        uv[0] = l;
        uv[1] = b;
        uv[2] = r;
        uv[3] = b;
        uv[4] = l;
        uv[5] = t;
        uv[6] = r;
        uv[7] = t;
      }
    };
    module.exports = LabelFrame;
  }), {} ],
  153: [ (function(require, module, exports) {
    "use strict";
    var macro = require("../../../platform/CCMacro");
    var Label = require("../../../components/CCLabel");
    var LabelOutline = require("../../../components/CCLabelOutline");
    var textUtils = require("../../../utils/text-utils");
    var Component = require("../../../components/CCComponent");
    var RenderTexture = require("../../../assets/CCRenderTexture");
    var OUTLINE_SUPPORTED = cc.js.isChildClassOf(LabelOutline, Component);
    var Overflow = Label.Overflow;
    var WHITE = cc.Color.WHITE;
    var space = 2;
    var LetterInfo = function LetterInfo() {
      this.char = "";
      this.valid = true;
      this.x = 0;
      this.y = 0;
      this.line = 0;
      this.hash = "";
    };
    var FontLetterDefinition = function FontLetterDefinition() {
      this.u = 0;
      this.v = 0;
      this.w = 0;
      this.h = 0;
      this.texture = null;
      this.offsetX = 0;
      this.offsetY = 0;
      this.valid = false;
      this.xAdvance = 0;
    };
    var _invisibleAlpha = (1 / 255).toFixed(3);
    function LetterTexture(char, labelInfo) {
      this._texture = null;
      this._labelInfo = labelInfo;
      this._char = char;
      this._hash = null;
      this._data = null;
      this._canvas = null;
      this._context = null;
      this._width = 0;
      this._height = 0;
      this._hash = char.charCodeAt(0) + labelInfo.hash;
    }
    LetterTexture.prototype = {
      constructor: LetterTexture,
      updateRenderData: function updateRenderData() {
        this._updateProperties();
        this._updateTexture();
      },
      _updateProperties: function _updateProperties() {
        this._texture = new cc.Texture2D();
        this._data = Label._canvasPool.get();
        this._canvas = this._data.canvas;
        this._context = this._data.context;
        this._context.font = this._labelInfo.fontDesc;
        var width = textUtils.safeMeasureText(this._context, this._char);
        this._width = parseFloat(width.toFixed(2)) + 2 * this._labelInfo.margin;
        this._height = (1 + textUtils.BASELINE_RATIO) * this._labelInfo.fontSize + 2 * this._labelInfo.margin;
        this._canvas.width !== this._width && (this._canvas.width = this._width);
        this._canvas.height !== this._height && (this._canvas.height = this._height);
        this._texture.initWithElement(this._canvas);
      },
      _updateTexture: function _updateTexture() {
        var context = this._context;
        var labelInfo = this._labelInfo, width = this._canvas.width, height = this._canvas.height;
        var startX = width / 2;
        var startY = height / 2 + this._labelInfo.fontSize * textUtils.MIDDLE_RATIO;
        var color = labelInfo.color;
        context.textAlign = "center";
        context.textBaseline = "alphabetic";
        context.clearRect(0, 0, width, height);
        context.fillStyle = "rgba(" + color.r + ", " + color.g + ", " + color.b + ", " + _invisibleAlpha + ")";
        context.fillRect(0, 0, width, height);
        context.font = labelInfo.fontDesc;
        context.lineJoin = "round";
        context.fillStyle = "rgba(" + color.r + ", " + color.g + ", " + color.b + ", 1)";
        if (labelInfo.isOutlined) {
          var strokeColor = labelInfo.out || WHITE;
          context.strokeStyle = "rgba(" + strokeColor.r + ", " + strokeColor.g + ", " + strokeColor.b + ", " + strokeColor.a / 255 + ")";
          context.lineWidth = 2 * labelInfo.margin;
          context.strokeText(this._char, startX, startY);
        }
        context.fillText(this._char, startX, startY);
        this._texture.handleLoadedTexture();
      },
      destroy: function destroy() {
        this._texture.destroy();
        this._texture = null;
        Label._canvasPool.put(this._data);
      }
    };
    function LetterAtlas(width, height) {
      var texture = new RenderTexture();
      texture.initWithSize(width, height);
      texture.update();
      this._texture = texture;
      this._x = space;
      this._y = space;
      this._nexty = space;
      this._width = width;
      this._height = height;
      this._letterDefinitions = {};
      cc.director.on(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
    }
    cc.js.mixin(LetterAtlas.prototype, {
      insertLetterTexture: function insertLetterTexture(letterTexture) {
        var texture = letterTexture._texture;
        var width = texture.width, height = texture.height;
        if (this._x + width + space > this._width) {
          this._x = space;
          this._y = this._nexty;
        }
        this._y + height > this._nexty && (this._nexty = this._y + height + space);
        if (this._nexty > this._height) return null;
        this._texture.drawTextureAt(texture, this._x, this._y);
        this._dirty = true;
        var letterDefinition = new FontLetterDefinition();
        letterDefinition.u = this._x;
        letterDefinition.v = this._y;
        letterDefinition.texture = this._texture;
        letterDefinition.valid = true;
        letterDefinition.w = letterTexture._width;
        letterDefinition.h = letterTexture._height;
        letterDefinition.xAdvance = letterTexture._width;
        this._x += width + space;
        this._letterDefinitions[letterTexture._hash] = letterDefinition;
        return letterDefinition;
      },
      update: function update() {
        if (!this._dirty) return;
        this._texture.update();
        this._dirty = false;
      },
      reset: function reset() {
        this._x = space;
        this._y = space;
        this._nexty = space;
        var chars = this._letterDefinitions;
        for (var i = 0, l = chars.length; i < l; i++) {
          var char = chars[i];
          if (!char.isValid) continue;
          char.destroy();
        }
        this._letterDefinitions = {};
      },
      destroy: function destroy() {
        this.reset();
        this._texture.destroy();
      },
      beforeSceneLoad: function beforeSceneLoad() {
        this.destroy();
        var texture = new RenderTexture();
        texture.initWithSize(this._width, this._height);
        texture.update();
        this._texture = texture;
      },
      getLetter: function getLetter(key) {
        return this._letterDefinitions[key];
      },
      addLetterDefinitions: function addLetterDefinitions(key, letterDefinition) {
        this._letterDefinitions[key] = letterDefinition;
      },
      cloneLetterDefinition: function cloneLetterDefinition() {
        var copyLetterDefinitions = {};
        for (var key in this._letterDefinitions) {
          var value = new FontLetterDefinition();
          cc.js.mixin(value, this._letterDefinitions[key]);
          copyLetterDefinitions[key] = value;
        }
        return copyLetterDefinitions;
      },
      assignLetterDefinitions: function assignLetterDefinitions(letterDefinition) {
        for (var key in this._letterDefinitions) {
          var newValue = letterDefinition[key];
          var oldValue = this._letterDefinitions[key];
          cc.js.mixin(oldValue, newValue);
        }
      },
      scaleFontLetterDefinition: function scaleFontLetterDefinition(scaleFactor) {
        for (var fontDefinition in this._letterDefinitions) {
          var letterDefinitions = this._letterDefinitions[fontDefinition];
          letterDefinitions.w *= scaleFactor;
          letterDefinitions.h *= scaleFactor;
          letterDefinitions.offsetX *= scaleFactor;
          letterDefinitions.offsetY *= scaleFactor;
          letterDefinitions.xAdvance *= scaleFactor;
        }
      },
      getLetterDefinitionForChar: function getLetterDefinitionForChar(char, labelInfo) {
        var hash = char.charCodeAt(0) + labelInfo.hash;
        var letterDefinition = this._letterDefinitions[hash];
        if (!letterDefinition) {
          var temp = new LetterTexture(char, labelInfo);
          temp.updateRenderData();
          letterDefinition = this.insertLetterTexture(temp);
          temp.destroy();
        }
        return letterDefinition;
      }
    });
    var _tmpRect = cc.rect();
    var _comp = null;
    var _horizontalKernings = [];
    var _lettersInfo = [];
    var _linesWidth = [];
    var _linesOffsetX = [];
    var _labelDimensions = cc.size();
    var _fontAtlas = null;
    var _fntConfig = null;
    var _numberOfLines = 0;
    var _textDesiredHeight = 0;
    var _letterOffsetY = 0;
    var _tailoredTopY = 0;
    var _tailoredBottomY = 0;
    var _bmfontScale = 1;
    var _lineBreakWithoutSpaces = false;
    var _lineSpacing = 0;
    var _string = "";
    var _fontSize = 0;
    var _originFontSize = 0;
    var _contentSize = cc.size();
    var _hAlign = 0;
    var _vAlign = 0;
    var _spacingX = 0;
    var _lineHeight = 0;
    var _overflow = 0;
    var _isWrapText = false;
    var _labelWidth = 0;
    var _labelHeight = 0;
    var _maxLineWidth = 0;
    var _atlasWidth = 2048;
    var _atlasHeight = 2048;
    var _fontFamily = "";
    var _isBold = false;
    var _labelInfo = {
      fontSize: 0,
      lineHeight: 0,
      hash: "",
      fontFamily: "",
      fontDesc: "Arial",
      hAlign: 0,
      vAlign: 0,
      color: WHITE,
      isOutlined: false,
      out: WHITE,
      margin: 0
    };
    module.exports = {
      _getAssemblerData: function _getAssemblerData() {
        _fontAtlas || (_fontAtlas = new LetterAtlas(_atlasWidth, _atlasHeight));
        return _fontAtlas._texture;
      },
      updateRenderData: function updateRenderData(comp) {
        if (!comp._renderData.vertDirty) return;
        if (_comp === comp) return;
        _comp = comp;
        this._updateFontFamily(comp);
        _labelInfo.fontFamily = _fontFamily;
        this._updateProperties();
        _labelInfo.fontDesc = this._getFontDesc();
        this._updateContent();
        _comp._actualFontSize = _fontSize;
        _comp.node.setContentSize(_contentSize);
        _comp._renderData.vertDirty = _comp._renderData.uvDirty = false;
        _comp = null;
        this._resetProperties();
      },
      _updateFontScale: function _updateFontScale() {
        _bmfontScale = _fontSize / _originFontSize;
      },
      _updateProperties: function _updateProperties() {
        _string = _comp.string.toString();
        _fontSize = _comp.fontSize;
        _originFontSize = _fontSize;
        _hAlign = _comp.horizontalAlign;
        _vAlign = _comp.verticalAlign;
        _spacingX = _comp.spacingX;
        _overflow = _comp.overflow;
        _lineHeight = _comp._lineHeight;
        _isBold = _comp._isBold;
        _isWrapText = _overflow !== Overflow.NONE && (_overflow === Overflow.RESIZE_HEIGHT || _comp.enableWrapText);
        var outline = OUTLINE_SUPPORTED && _comp.getComponent(LabelOutline);
        if (outline && outline.enabled) {
          _labelInfo.isOutlined = true;
          _labelInfo.margin = outline.width;
          _labelInfo.out = outline.color;
          _labelInfo.out.a = outline.color.a * _comp.node.color.a / 255;
        } else {
          _labelInfo.isOutlined = false;
          _labelInfo.margin = 0;
        }
        _contentSize.width = _comp.node._contentSize.width + 2 * _labelInfo.margin;
        _contentSize.height = _comp.node._contentSize.height + 2 * _labelInfo.margin;
        _labelInfo.lineHeight = _lineHeight;
        _labelInfo.fontSize = _fontSize;
        _labelInfo.fontFamily = _fontFamily;
        _labelInfo.color = _comp.node.color;
        _labelInfo.hash = this._computeHash(_labelInfo);
        this._setupBMFontOverflowMetrics();
      },
      _updateFontFamily: function _updateFontFamily(comp) {
        if (comp.useSystemFont) _fontFamily = comp.fontFamily; else if (comp.font) if (comp.font._nativeAsset) _fontFamily = comp.font._nativeAsset; else {
          _fontFamily = cc.loader.getRes(comp.font.nativeUrl);
          _fontFamily || cc.loader.load(comp.font.nativeUrl, (function(err, fontFamily) {
            _fontFamily = fontFamily || "Arial";
            comp.font._nativeAsset = fontFamily;
            comp._updateRenderData(true);
          }));
        } else _fontFamily = "Arial";
      },
      _computeHash: function _computeHash(labelInfo) {
        var hashData = "";
        var color = labelInfo.color.toHEX("#rrggbb");
        var out = "";
        labelInfo.isOutlined && (out = out + labelInfo.margin + labelInfo.out.toHEX("#rrggbb"));
        return hashData + labelInfo.fontSize + labelInfo.fontFamily + color + out;
      },
      _getFontDesc: function _getFontDesc() {
        var fontDesc = _fontSize.toString() + "px ";
        fontDesc += _fontFamily;
        _isBold && (fontDesc = "bold " + fontDesc);
        return fontDesc;
      },
      _resetProperties: function _resetProperties() {},
      _updateContent: function _updateContent() {
        this._updateFontScale();
        this._alignText();
      },
      _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {
        var string = _string;
        var stringLen = string.length;
        var kerningDict = _fntConfig.kerningDict;
        var horizontalKernings = _horizontalKernings;
        var prev = -1;
        for (var i = 0; i < stringLen; ++i) {
          var key = string.charCodeAt(i);
          var kerningAmount = kerningDict[prev << 16 | 65535 & key] || 0;
          horizontalKernings[i] = i < stringLen - 1 ? kerningAmount : 0;
          prev = key;
        }
      },
      _multilineTextWrap: function _multilineTextWrap(nextTokenFunc) {
        var textLen = _string.length;
        var lineIndex = 0;
        var nextTokenX = 0;
        var nextTokenY = 0;
        var longestLine = 0;
        var letterRight = 0;
        var highestY = 0;
        var lowestY = 0;
        var letterDef = null;
        var letterPosition = cc.v2(0, 0);
        this._updateFontScale();
        for (var index = 0; index < textLen; ) {
          var character = _string.charAt(index);
          if ("\n" === character) {
            _linesWidth.push(letterRight);
            letterRight = 0;
            lineIndex++;
            nextTokenX = 0;
            nextTokenY -= _lineHeight * _bmfontScale + _lineSpacing;
            this._recordPlaceholderInfo(index, character);
            index++;
            continue;
          }
          var tokenLen = nextTokenFunc(_string, index, textLen);
          var tokenHighestY = highestY;
          var tokenLowestY = lowestY;
          var tokenRight = letterRight;
          var nextLetterX = nextTokenX;
          var newLine = false;
          for (var tmp = 0; tmp < tokenLen; ++tmp) {
            var letterIndex = index + tmp;
            character = _string.charAt(letterIndex);
            if ("\r" === character) {
              this._recordPlaceholderInfo(letterIndex, character);
              continue;
            }
            letterDef = _fontAtlas.getLetterDefinitionForChar(character, _labelInfo);
            if (!letterDef) {
              this._recordPlaceholderInfo(letterIndex, character);
              continue;
            }
            var letterX = nextLetterX + letterDef.offsetX * _bmfontScale - _labelInfo.margin;
            if (_isWrapText && _maxLineWidth > 0 && nextTokenX > 0 && letterX + letterDef.w * _bmfontScale > _maxLineWidth && !textUtils.isUnicodeSpace(character)) {
              _linesWidth.push(letterRight);
              letterRight = 0;
              lineIndex++;
              nextTokenX = 0;
              nextTokenY -= _lineHeight * _bmfontScale + _lineSpacing;
              newLine = true;
              break;
            }
            letterPosition.x = letterX;
            letterPosition.y = nextTokenY - letterDef.offsetY * _bmfontScale + _labelInfo.margin + _fontSize * textUtils.MIDDLE_RATIO / 2;
            this._recordLetterInfo(letterPosition, character, letterIndex, lineIndex);
            letterIndex + 1 < _horizontalKernings.length && letterIndex < textLen - 1 && (nextLetterX += _horizontalKernings[letterIndex + 1]);
            nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX - 2 * _labelInfo.margin;
            tokenRight = letterPosition.x + letterDef.w * _bmfontScale - _labelInfo.margin;
            tokenHighestY < letterPosition.y && (tokenHighestY = letterPosition.y);
            tokenLowestY > letterPosition.y - letterDef.h * _bmfontScale && (tokenLowestY = letterPosition.y - letterDef.h * _bmfontScale);
          }
          if (newLine) continue;
          nextTokenX = nextLetterX;
          letterRight = tokenRight;
          highestY < tokenHighestY && (highestY = tokenHighestY);
          lowestY > tokenLowestY && (lowestY = tokenLowestY);
          longestLine < letterRight && (longestLine = letterRight);
          index += tokenLen;
        }
        _linesWidth.push(letterRight);
        _numberOfLines = lineIndex + 1;
        _textDesiredHeight = _numberOfLines * _lineHeight * _bmfontScale;
        _numberOfLines > 1 && (_textDesiredHeight += (_numberOfLines - 1) * _lineSpacing);
        _contentSize.width = _labelWidth;
        _contentSize.height = _labelHeight;
        _labelWidth <= 0 && (_contentSize.width = parseFloat(longestLine.toFixed(2)) + 2 * _labelInfo.margin);
        _labelHeight <= 0 && (_contentSize.height = parseFloat(_textDesiredHeight.toFixed(2)) + 2 * _labelInfo.margin + _fontSize * textUtils.BASELINE_RATIO);
        _tailoredTopY = _contentSize.height;
        _tailoredBottomY = 0;
        highestY > 0 && (_tailoredTopY = _contentSize.height + highestY);
        lowestY < -_textDesiredHeight && (_tailoredBottomY = _textDesiredHeight + lowestY);
        return true;
      },
      _getFirstCharLen: function _getFirstCharLen() {
        return 1;
      },
      _getFirstWordLen: function _getFirstWordLen(text, startIndex, textLen) {
        var character = text.charAt(startIndex);
        if (textUtils.isUnicodeCJK(character) || "\n" === character || textUtils.isUnicodeSpace(character)) return 1;
        var len = 1;
        var letterDef = _fontAtlas.getLetterDefinitionForChar(character, _labelInfo);
        if (!letterDef) return len;
        var nextLetterX = letterDef.xAdvance * _bmfontScale + _spacingX;
        var letterX = void 0;
        for (var index = startIndex + 1; index < textLen; ++index) {
          character = text.charAt(index);
          letterDef = _fontAtlas.getLetterDefinitionForChar(character, _labelInfo);
          if (!letterDef) break;
          letterX = nextLetterX + letterDef.offsetX * _bmfontScale;
          if (letterX + letterDef.w * _bmfontScale > _maxLineWidth && !textUtils.isUnicodeSpace(character) && _maxLineWidth > 0) return len;
          nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX;
          if ("\n" === character || textUtils.isUnicodeSpace(character) || textUtils.isUnicodeCJK(character)) break;
          len++;
        }
        return len;
      },
      _multilineTextWrapByWord: function _multilineTextWrapByWord() {
        return this._multilineTextWrap(this._getFirstWordLen);
      },
      _multilineTextWrapByChar: function _multilineTextWrapByChar() {
        return this._multilineTextWrap(this._getFirstCharLen);
      },
      _recordPlaceholderInfo: function _recordPlaceholderInfo(letterIndex, char) {
        if (letterIndex >= _lettersInfo.length) {
          var tmpInfo = new LetterInfo();
          _lettersInfo.push(tmpInfo);
        }
        _lettersInfo[letterIndex].char = char;
        _lettersInfo[letterIndex].hash = char.charCodeAt(0) + _labelInfo.hash;
        _lettersInfo[letterIndex].valid = false;
      },
      _recordLetterInfo: function _recordLetterInfo(letterPosition, character, letterIndex, lineIndex) {
        if (letterIndex >= _lettersInfo.length) {
          var tmpInfo = new LetterInfo();
          _lettersInfo.push(tmpInfo);
        }
        var char = character.charCodeAt(0);
        var key = char + _labelInfo.hash;
        _lettersInfo[letterIndex].line = lineIndex;
        _lettersInfo[letterIndex].char = character;
        _lettersInfo[letterIndex].hash = key;
        _lettersInfo[letterIndex].valid = _fontAtlas.getLetter(key).valid;
        _lettersInfo[letterIndex].x = letterPosition.x;
        _lettersInfo[letterIndex].y = letterPosition.y;
      },
      _alignText: function _alignText() {
        _textDesiredHeight = 0;
        _linesWidth.length = 0;
        _lineBreakWithoutSpaces ? this._multilineTextWrapByChar() : this._multilineTextWrapByWord();
        this._computeAlignmentOffset();
        this._updateQuads();
      },
      _scaleFontSizeDown: function _scaleFontSizeDown(fontSize) {
        var shouldUpdateContent = true;
        if (!fontSize) {
          fontSize = .1;
          shouldUpdateContent = false;
        }
        _fontSize = fontSize;
        shouldUpdateContent && this._updateContent();
      },
      _isVerticalClamp: function _isVerticalClamp() {
        return _textDesiredHeight > _contentSize.height;
      },
      _isHorizontalClamp: function _isHorizontalClamp() {
        var letterClamp = false;
        for (var ctr = 0, l = _string.length; ctr < l; ++ctr) {
          var letterInfo = _lettersInfo[ctr];
          if (letterInfo.valid) {
            var letterDef = _fontAtlas.getLetter(letterInfo.hash);
            var px = letterInfo.x + letterDef.w * _bmfontScale;
            var lineIndex = letterInfo.line;
            if (_labelWidth > 0) if (_isWrapText) {
              var wordWidth = _linesWidth[lineIndex];
              if (wordWidth > _contentSize.width && (px > _contentSize.width || px < 0)) {
                letterClamp = true;
                break;
              }
            } else if (px > _contentSize.width) {
              letterClamp = true;
              break;
            }
          }
        }
        return letterClamp;
      },
      _isHorizontalClamped: function _isHorizontalClamped(px, lineIndex) {
        var wordWidth = _linesWidth[lineIndex];
        var letterOverClamp = px > _contentSize.width || px < 0;
        return _isWrapText ? wordWidth > _contentSize.width && letterOverClamp : letterOverClamp;
      },
      _updateQuads: function _updateQuads() {
        var texture = _fontAtlas._texture;
        var node = _comp.node;
        var renderData = _comp._renderData;
        renderData.dataLength = renderData.vertexCount = renderData.indiceCount = 0;
        var contentSize = _contentSize, appx = node._anchorPoint.x * contentSize.width, appy = node._anchorPoint.y * contentSize.height;
        var ret = true;
        for (var ctr = 0, l = _string.length; ctr < l; ++ctr) {
          var letterInfo = _lettersInfo[ctr];
          if (!letterInfo.valid) continue;
          var letterDef = _fontAtlas.getLetter(letterInfo.hash);
          _tmpRect.height = letterDef.h;
          _tmpRect.width = letterDef.w;
          _tmpRect.x = letterDef.u;
          _tmpRect.y = letterDef.v;
          var py = letterInfo.y + _letterOffsetY;
          if (_labelHeight > 0) {
            if (py > _tailoredTopY) {
              var clipTop = py - _tailoredTopY;
              _tmpRect.y += clipTop;
              _tmpRect.height -= clipTop;
              py -= clipTop;
            }
            py - letterDef.h * _bmfontScale < _tailoredBottomY && (_tmpRect.height = py < _tailoredBottomY ? 0 : py - _tailoredBottomY);
          }
          var lineIndex = letterInfo.line;
          var px = letterInfo.x + letterDef.w / 2 * _bmfontScale + _linesOffsetX[lineIndex];
          if (_labelWidth > 0 && this._isHorizontalClamped(px, lineIndex)) if (_overflow === Overflow.CLAMP) _tmpRect.width = 0; else if (_overflow === Overflow.SHRINK) {
            if (_contentSize.width > letterDef.w) {
              ret = false;
              break;
            }
            _tmpRect.width = 0;
          }
          if (_tmpRect.height > 0 && _tmpRect.width > 0) {
            var letterPositionX = letterInfo.x + _linesOffsetX[letterInfo.line];
            this.appendQuad(renderData, texture, _tmpRect, false, letterPositionX - appx, py - appy, _bmfontScale);
          }
        }
        return ret;
      },
      appendQuad: function appendQuad(renderData, texture, rect, rotated, x, y, scale) {},
      _computeAlignmentOffset: function _computeAlignmentOffset() {
        _linesOffsetX.length = 0;
        switch (_hAlign) {
         case macro.TextAlignment.LEFT:
          for (var i = 0; i < _numberOfLines; ++i) _linesOffsetX.push(0);
          break;

         case macro.TextAlignment.CENTER:
          for (var _i = 0, l = _linesWidth.length; _i < l; _i++) _linesOffsetX.push((_contentSize.width - _linesWidth[_i]) / 2);
          break;

         case macro.TextAlignment.RIGHT:
          for (var _i2 = 0, _l = _linesWidth.length; _i2 < _l; _i2++) _linesOffsetX.push(_contentSize.width - _linesWidth[_i2]);
        }
        switch (_vAlign) {
         case macro.VerticalTextAlignment.TOP:
          _letterOffsetY = _contentSize.height;
          break;

         case macro.VerticalTextAlignment.CENTER:
          _letterOffsetY = (_contentSize.height + _textDesiredHeight) / 2 - (_lineHeight - _fontSize) / 2;
          break;

         case macro.VerticalTextAlignment.BOTTOM:
          _letterOffsetY = (_contentSize.height + _textDesiredHeight) / 2 - (_lineHeight - _fontSize);
        }
      },
      _setupBMFontOverflowMetrics: function _setupBMFontOverflowMetrics() {
        var newWidth = _contentSize.width, newHeight = _contentSize.height;
        _overflow === Overflow.RESIZE_HEIGHT && (newHeight = 0);
        if (_overflow === Overflow.NONE) {
          newWidth = 0;
          newHeight = 0;
        }
        _labelWidth = newWidth;
        _labelHeight = newHeight;
        _labelDimensions.width = newWidth;
        _labelDimensions.height = newHeight;
        _maxLineWidth = newWidth;
      }
    };
  }), {
    "../../../assets/CCRenderTexture": 20,
    "../../../components/CCComponent": 39,
    "../../../components/CCLabel": 41,
    "../../../components/CCLabelOutline": 42,
    "../../../platform/CCMacro": 109,
    "../../../utils/text-utils": 193
  } ],
  154: [ (function(require, module, exports) {
    "use strict";
    var macro = require("../../../platform/CCMacro");
    var textUtils = require("../../../utils/text-utils");
    var Component = require("../../../components/CCComponent");
    var Label = require("../../../components/CCLabel");
    var LabelOutline = require("../../../components/CCLabelOutline");
    var LabelShadow = require("../../../components/CCLabelShadow");
    var Overflow = Label.Overflow;
    var packToDynamicAtlas = require("../utils").packToDynamicAtlas;
    var deleteFromDynamicAtlas = require("../utils").deleteFromDynamicAtlas;
    var MAX_SIZE = 2048;
    var _invisibleAlpha = (1 / 255).toFixed(3);
    var _context = null;
    var _canvas = null;
    var _texture = null;
    var _fontDesc = "";
    var _string = "";
    var _fontSize = 0;
    var _drawFontSize = 0;
    var _splitedStrings = [];
    var _canvasSize = cc.Size.ZERO;
    var _lineHeight = 0;
    var _hAlign = 0;
    var _vAlign = 0;
    var _color = null;
    var _fontFamily = "";
    var _overflow = Overflow.NONE;
    var _isWrapText = false;
    var _outlineComp = null;
    var _outlineColor = cc.Color.WHITE;
    var _shadowComp = null;
    var _shadowColor = cc.Color.BLACK;
    var _canvasPadding = cc.rect();
    var _contentSizeExtend = cc.Size.ZERO;
    var _nodeContentSize = cc.Size.ZERO;
    var _enableBold = false;
    var _enableItalic = false;
    var _enableUnderline = false;
    var _underlineThickness = 0;
    var _drawUnderlinePos = cc.Vec2.ZERO;
    var _drawUnderlineWidth = 0;
    var _sharedLabelData = void 0;
    module.exports = {
      _getAssemblerData: function _getAssemblerData() {
        _sharedLabelData = Label._canvasPool.get();
        _sharedLabelData.canvas.width = _sharedLabelData.canvas.height = 1;
        return _sharedLabelData;
      },
      _resetAssemblerData: function _resetAssemblerData(assemblerData) {
        assemblerData && Label._canvasPool.put(assemblerData);
      },
      updateRenderData: function updateRenderData(comp) {
        if (!comp._renderData.vertDirty) return;
        this._updateFontFamily(comp);
        this._updateProperties(comp);
        this._calculateLabelFont();
        this._calculateSplitedStrings();
        this._updateLabelDimensions();
        this._calculateTextBaseline();
        this._updateTexture(comp);
        this._calDynamicAtlas(comp);
        comp._actualFontSize = _fontSize;
        comp.node.setContentSize(_nodeContentSize);
        this._updateVerts(comp);
        comp._renderData.vertDirty = comp._renderData.uvDirty = false;
        _context = null;
        _canvas = null;
        _texture = null;
      },
      _updateVerts: function _updateVerts() {},
      _updateFontFamily: function _updateFontFamily(comp) {
        if (comp.useSystemFont) _fontFamily = comp.fontFamily; else if (comp.font) if (comp.font._nativeAsset) _fontFamily = comp.font._nativeAsset; else {
          _fontFamily = cc.loader.getRes(comp.font.nativeUrl);
          _fontFamily || cc.loader.load(comp.font.nativeUrl, (function(err, fontFamily) {
            _fontFamily = fontFamily || "Arial";
            comp.font._nativeAsset = fontFamily;
            comp._updateRenderData(true);
          }));
        } else _fontFamily = "Arial";
      },
      _updatePaddingRect: function _updatePaddingRect() {
        var top = 0, bottom = 0, left = 0, right = 0;
        var outlineWidth = 0;
        _contentSizeExtend.width = _contentSizeExtend.height = 0;
        if (_outlineComp) {
          outlineWidth = _outlineComp.width;
          top = bottom = left = right = outlineWidth;
          _contentSizeExtend.width = _contentSizeExtend.height = 2 * outlineWidth;
        }
        if (_shadowComp) {
          var shadowWidth = _shadowComp.blur + outlineWidth;
          left = Math.max(left, -_shadowComp._offset.x + shadowWidth);
          right = Math.max(right, _shadowComp._offset.x + shadowWidth);
          top = Math.max(top, _shadowComp._offset.y + shadowWidth);
          bottom = Math.max(bottom, -_shadowComp._offset.y + shadowWidth);
        }
        if (_enableItalic) {
          var offset = _drawFontSize * Math.tan(.20943951);
          right += offset;
          _contentSizeExtend.width += offset;
        }
        _canvasPadding.x = left;
        _canvasPadding.y = top;
        _canvasPadding.width = left + right;
        _canvasPadding.height = top + bottom;
      },
      _updateProperties: function _updateProperties(comp) {
        var assemblerData = comp._assemblerData;
        _context = assemblerData.context;
        _canvas = assemblerData.canvas;
        _texture = comp._frame._original ? comp._frame._original._texture : comp._frame._texture;
        _string = comp.string.toString();
        _fontSize = comp._fontSize;
        _drawFontSize = _fontSize;
        _underlineThickness = _drawFontSize / 8;
        _overflow = comp.overflow;
        _canvasSize.width = comp.node.width;
        _canvasSize.height = comp.node.height;
        _nodeContentSize = comp.node.getContentSize();
        _lineHeight = comp._lineHeight;
        _hAlign = comp.horizontalAlign;
        _vAlign = comp.verticalAlign;
        _color = comp.node.color;
        _enableBold = comp._isBold;
        _enableItalic = comp._isItalic;
        _enableUnderline = comp._isUnderline;
        _isWrapText = _overflow !== Overflow.NONE && (_overflow === Overflow.RESIZE_HEIGHT || comp.enableWrapText);
        _outlineComp = LabelOutline && comp.getComponent(LabelOutline);
        _outlineComp = _outlineComp && _outlineComp.enabled && _outlineComp.width > 0 ? _outlineComp : null;
        _outlineComp && _outlineColor.set(_outlineComp.color);
        _shadowComp = LabelShadow && comp.getComponent(LabelShadow);
        _shadowComp = _shadowComp && _shadowComp.enabled ? _shadowComp : null;
        if (_shadowComp) {
          _shadowColor.set(_shadowComp.color);
          _shadowColor.a = _shadowColor.a * comp.node.color.a / 255;
        }
        this._updatePaddingRect();
      },
      _calculateFillTextStartPosition: function _calculateFillTextStartPosition() {
        var labelX = 0;
        _hAlign === macro.TextAlignment.RIGHT ? labelX = _canvasSize.width - _canvasPadding.width : _hAlign === macro.TextAlignment.CENTER && (labelX = (_canvasSize.width - _canvasPadding.width) / 2);
        var firstLinelabelY = 0;
        var lineHeight = this._getLineHeight();
        var drawStartY = lineHeight * (_splitedStrings.length - 1);
        firstLinelabelY = _vAlign === macro.VerticalTextAlignment.TOP ? _fontSize : _vAlign === macro.VerticalTextAlignment.CENTER ? .5 * (_canvasSize.height - drawStartY) + _fontSize * textUtils.MIDDLE_RATIO - _canvasPadding.height / 2 : _canvasSize.height - drawStartY - _fontSize * textUtils.BASELINE_RATIO - _canvasPadding.height;
        return cc.v2(labelX + _canvasPadding.x, firstLinelabelY + _canvasPadding.y);
      },
      _setupOutline: function _setupOutline() {
        _context.strokeStyle = "rgba(" + _outlineColor.r + ", " + _outlineColor.g + ", " + _outlineColor.b + ", " + _outlineColor.a / 255 + ")";
        _context.lineWidth = 2 * _outlineComp.width;
      },
      _setupShadow: function _setupShadow() {
        _context.shadowColor = "rgba(" + _shadowColor.r + ", " + _shadowColor.g + ", " + _shadowColor.b + ", " + _shadowColor.a / 255 + ")";
        _context.shadowBlur = _shadowComp.blur;
        _context.shadowOffsetX = _shadowComp.offset.x;
        _context.shadowOffsetY = -_shadowComp.offset.y;
      },
      _drawUnderline: function _drawUnderline(underlinewidth) {
        if (_outlineComp) {
          this._setupOutline();
          _context.strokeRect(_drawUnderlinePos.x, _drawUnderlinePos.y, underlinewidth, _underlineThickness);
        }
        _context.lineWidth = _underlineThickness;
        _context.fillStyle = "rgba(" + _color.r + ", " + _color.g + ", " + _color.b + ", " + _color.a / 255 + ")";
        _context.fillRect(_drawUnderlinePos.x, _drawUnderlinePos.y, underlinewidth, _underlineThickness);
      },
      _updateTexture: function _updateTexture() {
        _context.clearRect(0, 0, _canvas.width, _canvas.height);
        var _fillColor = _outlineComp ? _outlineColor : _color;
        _context.fillStyle = "rgba(" + _fillColor.r + ", " + _fillColor.g + ", " + _fillColor.b + ", " + _invisibleAlpha + ")";
        _context.fillRect(0, 0, _canvas.width, _canvas.height);
        _context.font = _fontDesc;
        var startPosition = this._calculateFillTextStartPosition();
        var lineHeight = this._getLineHeight();
        _context.lineJoin = "round";
        _context.fillStyle = "rgba(" + _color.r + ", " + _color.g + ", " + _color.b + ", 1)";
        var isMultiple = _splitedStrings.length > 1;
        var measureText = this._measureText(_context);
        var drawTextPosX = 0, drawTextPosY = 0;
        _shadowComp && this._setupShadow();
        _outlineComp && this._setupOutline();
        for (var i = 0; i < _splitedStrings.length; ++i) {
          drawTextPosX = startPosition.x;
          drawTextPosY = startPosition.y + i * lineHeight;
          if (_shadowComp && isMultiple) {
            _outlineComp && _context.strokeText(_splitedStrings[i], drawTextPosX, drawTextPosY);
            _context.fillText(_splitedStrings[i], drawTextPosX, drawTextPosY);
          }
          if (_enableUnderline) {
            _drawUnderlineWidth = measureText(_splitedStrings[i]);
            _hAlign === macro.TextAlignment.RIGHT ? _drawUnderlinePos.x = startPosition.x - _drawUnderlineWidth : _hAlign === macro.TextAlignment.CENTER ? _drawUnderlinePos.x = startPosition.x - _drawUnderlineWidth / 2 : _drawUnderlinePos.x = startPosition.x;
            _drawUnderlinePos.y = drawTextPosY;
            this._drawUnderline(_drawUnderlineWidth);
          }
        }
        _shadowComp && isMultiple && (_context.shadowColor = "transparent");
        for (var _i = 0; _i < _splitedStrings.length; ++_i) {
          drawTextPosX = startPosition.x;
          drawTextPosY = startPosition.y + _i * lineHeight;
          _outlineComp && _context.strokeText(_splitedStrings[_i], drawTextPosX, drawTextPosY);
          _context.fillText(_splitedStrings[_i], drawTextPosX, drawTextPosY);
        }
        _shadowComp && (_context.shadowColor = "transparent");
        _texture.handleLoadedTexture();
      },
      _calDynamicAtlas: function _calDynamicAtlas(comp) {
        if (comp.cacheMode !== Label.CacheMode.BITMAP) return;
        var frame = comp._frame;
        deleteFromDynamicAtlas(comp, frame);
        frame._original || frame.setRect(cc.rect(0, 0, _canvas.width, _canvas.height));
        packToDynamicAtlas(comp, frame);
      },
      _updateLabelDimensions: function _updateLabelDimensions() {
        var paragraphedStrings = _string.split("\n");
        if (_overflow === Overflow.RESIZE_HEIGHT) {
          var rawHeight = (_splitedStrings.length + textUtils.BASELINE_RATIO) * this._getLineHeight();
          _canvasSize.height = rawHeight + _canvasPadding.height;
          _nodeContentSize.height = rawHeight + _contentSizeExtend.height;
        } else if (_overflow === Overflow.NONE) {
          _splitedStrings = paragraphedStrings;
          var canvasSizeX = 0;
          var canvasSizeY = 0;
          for (var i = 0; i < paragraphedStrings.length; ++i) {
            var paraLength = textUtils.safeMeasureText(_context, paragraphedStrings[i]);
            canvasSizeX = canvasSizeX > paraLength ? canvasSizeX : paraLength;
          }
          canvasSizeY = (_splitedStrings.length + textUtils.BASELINE_RATIO) * this._getLineHeight();
          var rawWidth = parseFloat(canvasSizeX.toFixed(2));
          var _rawHeight = parseFloat(canvasSizeY.toFixed(2));
          _canvasSize.width = rawWidth + _canvasPadding.width;
          _canvasSize.height = _rawHeight + _canvasPadding.height;
          _nodeContentSize.width = rawWidth + _contentSizeExtend.width;
          _nodeContentSize.height = _rawHeight + _contentSizeExtend.height;
        }
        _canvasSize.width = Math.min(_canvasSize.width, MAX_SIZE);
        _canvasSize.height = Math.min(_canvasSize.height, MAX_SIZE);
        _canvas.width !== _canvasSize.width && (_canvas.width = _canvasSize.width);
        _canvas.height !== _canvasSize.height && (_canvas.height = _canvasSize.height);
      },
      _calculateTextBaseline: function _calculateTextBaseline() {
        var node = this._node;
        var hAlign = void 0;
        hAlign = _hAlign === macro.TextAlignment.RIGHT ? "right" : _hAlign === macro.TextAlignment.CENTER ? "center" : "left";
        _context.textAlign = hAlign;
        _context.textBaseline = "alphabetic";
      },
      _calculateSplitedStrings: function _calculateSplitedStrings() {
        var paragraphedStrings = _string.split("\n");
        if (_isWrapText) {
          _splitedStrings = [];
          var canvasWidthNoMargin = _nodeContentSize.width;
          for (var i = 0; i < paragraphedStrings.length; ++i) {
            var allWidth = textUtils.safeMeasureText(_context, paragraphedStrings[i]);
            var textFragment = textUtils.fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context));
            _splitedStrings = _splitedStrings.concat(textFragment);
          }
        } else _splitedStrings = paragraphedStrings;
      },
      _getFontDesc: function _getFontDesc() {
        var fontDesc = _fontSize.toString() + "px ";
        fontDesc += _fontFamily;
        _enableBold && (fontDesc = "bold " + fontDesc);
        _enableItalic && (fontDesc = "italic " + fontDesc);
        return fontDesc;
      },
      _getLineHeight: function _getLineHeight() {
        var nodeSpacingY = _lineHeight;
        nodeSpacingY = 0 === nodeSpacingY ? _fontSize : nodeSpacingY * _fontSize / _drawFontSize;
        return 0 | nodeSpacingY;
      },
      _calculateParagraphLength: function _calculateParagraphLength(paragraphedStrings, ctx) {
        var paragraphLength = [];
        for (var i = 0; i < paragraphedStrings.length; ++i) {
          var width = textUtils.safeMeasureText(ctx, paragraphedStrings[i]);
          paragraphLength.push(width);
        }
        return paragraphLength;
      },
      _measureText: function _measureText(ctx) {
        return function(string) {
          return textUtils.safeMeasureText(ctx, string);
        };
      },
      _calculateLabelFont: function _calculateLabelFont() {
        _fontDesc = this._getFontDesc();
        _context.font = _fontDesc;
        if (_overflow === Overflow.SHRINK) {
          var paragraphedStrings = _string.split("\n");
          var paragraphLength = this._calculateParagraphLength(paragraphedStrings, _context);
          var i = 0;
          var totalHeight = 0;
          var maxLength = 0;
          if (_isWrapText) {
            var canvasWidthNoMargin = _nodeContentSize.width;
            var canvasHeightNoMargin = _nodeContentSize.height;
            if (canvasWidthNoMargin < 0 || canvasHeightNoMargin < 0) {
              _fontDesc = this._getFontDesc();
              _context.font = _fontDesc;
              return;
            }
            totalHeight = canvasHeightNoMargin + 1;
            maxLength = canvasWidthNoMargin + 1;
            var actualFontSize = _fontSize + 1;
            var textFragment = "";
            var tryDivideByTwo = true;
            var startShrinkFontSize = 0 | actualFontSize;
            while (totalHeight > canvasHeightNoMargin || maxLength > canvasWidthNoMargin) {
              if (tryDivideByTwo) actualFontSize = startShrinkFontSize / 2 | 0; else {
                actualFontSize = startShrinkFontSize - 1;
                startShrinkFontSize = actualFontSize;
              }
              if (actualFontSize <= 0) {
                cc.logID(4003);
                break;
              }
              _fontSize = actualFontSize;
              _fontDesc = this._getFontDesc();
              _context.font = _fontDesc;
              totalHeight = 0;
              for (i = 0; i < paragraphedStrings.length; ++i) {
                var j = 0;
                var allWidth = textUtils.safeMeasureText(_context, paragraphedStrings[i]);
                textFragment = textUtils.fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context));
                while (j < textFragment.length) {
                  maxLength = textUtils.safeMeasureText(_context, textFragment[j]);
                  totalHeight += this._getLineHeight();
                  ++j;
                }
              }
              if (tryDivideByTwo) if (totalHeight > canvasHeightNoMargin) startShrinkFontSize = 0 | actualFontSize; else {
                tryDivideByTwo = false;
                totalHeight = canvasHeightNoMargin + 1;
              }
            }
          } else {
            totalHeight = paragraphedStrings.length * this._getLineHeight();
            for (i = 0; i < paragraphedStrings.length; ++i) maxLength < paragraphLength[i] && (maxLength = paragraphLength[i]);
            var scaleX = (_canvasSize.width - _canvasPadding.width) / maxLength;
            var scaleY = _canvasSize.height / totalHeight;
            _fontSize = _drawFontSize * Math.min(1, scaleX, scaleY) | 0;
            _fontDesc = this._getFontDesc();
            _context.font = _fontDesc;
          }
        }
      }
    };
  }), {
    "../../../components/CCComponent": 39,
    "../../../components/CCLabel": 41,
    "../../../components/CCLabelOutline": 42,
    "../../../components/CCLabelShadow": 43,
    "../../../platform/CCMacro": 109,
    "../../../utils/text-utils": 193,
    "../utils": 155
  } ],
  155: [ (function(require, module, exports) {
    "use strict";
    var dynamicAtlasManager = require("./dynamic-atlas/manager");
    module.exports = {
      packToDynamicAtlas: function packToDynamicAtlas(comp, frame) {
        if (frame && true) {
          if (!frame._original && dynamicAtlasManager) {
            var packedFrame = dynamicAtlasManager.insertSpriteFrame(frame);
            packedFrame && frame._setDynamicAtlasFrame(packedFrame);
          }
          comp.sharedMaterials[0].getProperty("texture") !== frame._texture && comp._activateMaterial(true);
        }
      },
      deleteFromDynamicAtlas: function deleteFromDynamicAtlas(comp, frame) {
        if (frame && true && frame._original && dynamicAtlasManager) {
          dynamicAtlasManager.deleteAtlasTexture(frame);
          frame._resetDynamicAtlasFrame();
        }
      }
    };
  }), {
    "./dynamic-atlas/manager": 150
  } ],
  156: [ (function(require, module, exports) {
    "use strict";
    module.exports = earcut;
    function earcut(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode) return triangles;
      var minX, minY, maxX, maxY, x, y, size;
      hasHoles && (outerNode = eliminateHoles(data, holeIndices, outerNode, dim));
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i = dim; i < outerLen; i += dim) {
          x = data[i];
          y = data[i + 1];
          x < minX && (minX = x);
          y < minY && (minY = y);
          x > maxX && (maxX = x);
          y > maxY && (maxY = y);
        }
        size = Math.max(maxX - minX, maxY - minY);
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, size);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i, last;
      if (clockwise === signedArea(data, start, end, dim) > 0) for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last); else for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
      if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start, end) {
      if (!start) return start;
      end || (end = start);
      var p = start, again;
      do {
        again = false;
        if (p.steiner || !equals(p, p.next) && 0 !== area(p.prev, p, p.next)) p = p.next; else {
          removeNode(p);
          p = end = p.prev;
          if (p === p.next) return null;
          again = true;
        }
      } while (again || p !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
      if (!ear) return;
      !pass && size && indexCurve(ear, minX, minY, size);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
          triangles.push(prev.i / dim);
          triangles.push(ear.i / dim);
          triangles.push(next.i / dim);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (pass) if (1 === pass) {
            ear = cureLocalIntersections(ear, triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, size, 2);
          } else 2 === pass && splitEarcut(ear, triangles, dim, minX, minY, size); else earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
          break;
        }
      }
    }
    function isEar(ear) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0) return false;
      var p = ear.next.next;
      while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, size) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0) return false;
      var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
      var minZ = zOrder(minTX, minTY, minX, minY, size), maxZ = zOrder(maxTX, maxTY, minX, minY, size);
      var p = ear.nextZ;
      while (p && p.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.nextZ;
      }
      p = ear.prevZ;
      while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p = start;
      do {
        var a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
          triangles.push(a.i / dim);
          triangles.push(p.i / dim);
          triangles.push(b.i / dim);
          removeNode(p);
          removeNode(p.next);
          p = start = b;
        }
        p = p.next;
      } while (p !== start);
      return p;
    }
    function splitEarcut(start, triangles, dim, minX, minY, size) {
      var a = start;
      do {
        var b = a.next.next;
        while (b !== a.prev) {
          if (a.i !== b.i && isValidDiagonal(a, b)) {
            var c = splitPolygon(a, b);
            a = filterPoints(a, a.next);
            c = filterPoints(c, c.next);
            earcutLinked(a, triangles, dim, minX, minY, size);
            earcutLinked(c, triangles, dim, minX, minY, size);
            return;
          }
          b = b.next;
        }
        a = a.next;
      } while (a !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i, len, start, end, list;
      for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        list === list.next && (list.steiner = true);
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
      }
      return outerNode;
    }
    function compareX(a, b) {
      return a.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
      outerNode = findHoleBridge(hole, outerNode);
      if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
      }
    }
    function findHoleBridge(hole, outerNode) {
      var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
      do {
        if (hy <= p.y && hy >= p.next.y) {
          var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
          if (x <= hx && x > qx) {
            qx = x;
            if (x === hx) {
              if (hy === p.y) return p;
              if (hy === p.next.y) return p.next;
            }
            m = p.x < p.next.x ? p : p.next;
          }
        }
        p = p.next;
      } while (p !== outerNode);
      if (!m) return null;
      if (hx === qx) return m.prev;
      var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
      p = m.next;
      while (p !== stop) {
        if (hx >= p.x && p.x >= mx && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
          tan = Math.abs(hy - p.y) / (hx - p.x);
          if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
            m = p;
            tanMin = tan;
          }
        }
        p = p.next;
      }
      return m;
    }
    function indexCurve(start, minX, minY, size) {
      var p = start;
      do {
        null === p.z && (p.z = zOrder(p.x, p.y, minX, minY, size));
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
      } while (p !== start);
      p.prevZ.nextZ = null;
      p.prevZ = null;
      sortLinked(p);
    }
    function sortLinked(list) {
      var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
          numMerges++;
          q = p;
          pSize = 0;
          for (i = 0; i < inSize; i++) {
            pSize++;
            q = q.nextZ;
            if (!q) break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (0 === pSize) {
              e = q;
              q = q.nextZ;
              qSize--;
            } else if (0 !== qSize && q) if (p.z <= q.z) {
              e = p;
              p = p.nextZ;
              pSize--;
            } else {
              e = q;
              q = q.nextZ;
              qSize--;
            } else {
              e = p;
              p = p.nextZ;
              pSize--;
            }
            tail ? tail.nextZ = e : list = e;
            e.prevZ = tail;
            tail = e;
          }
          p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x, y, minX, minY, size) {
      x = 32767 * (x - minX) / size;
      y = 32767 * (y - minY) / size;
      x = 16711935 & (x | x << 8);
      x = 252645135 & (x | x << 4);
      x = 858993459 & (x | x << 2);
      x = 1431655765 & (x | x << 1);
      y = 16711935 & (y | y << 8);
      y = 252645135 & (y | y << 4);
      y = 858993459 & (y | y << 2);
      y = 1431655765 & (y | y << 1);
      return x | y << 1;
    }
    function getLeftmost(start) {
      var p = start, leftmost = start;
      do {
        p.x < leftmost.x && (leftmost = p);
        p = p.next;
      } while (p !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    function isValidDiagonal(a, b) {
      return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
    }
    function area(p, q, r) {
      return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    function equals(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) return true;
      return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
    }
    function intersectsPolygon(a, b) {
      var p = a;
      do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
        p = p.next;
      } while (p !== a);
      return false;
    }
    function locallyInside(a, b) {
      return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    function middleInside(a, b) {
      var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
      do {
        p.y > py !== p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x && (inside = !inside);
        p = p.next;
      } while (p !== a);
      return inside;
    }
    function splitPolygon(a, b) {
      var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
      a.next = b;
      b.prev = a;
      a2.next = an;
      an.prev = a2;
      b2.next = a2;
      a2.prev = b2;
      bp.next = b2;
      b2.prev = bp;
      return b2;
    }
    function insertNode(i, x, y, last) {
      var p = new Node(i, x, y);
      if (last) {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
      } else {
        p.prev = p;
        p.next = p;
      }
      return p;
    }
    function removeNode(p) {
      p.next.prev = p.prev;
      p.prev.next = p.next;
      p.prevZ && (p.prevZ.nextZ = p.nextZ);
      p.nextZ && (p.nextZ.prevZ = p.prevZ);
    }
    function Node(i, x, y) {
      this.i = i;
      this.x = x;
      this.y = y;
      this.prev = null;
      this.next = null;
      this.z = null;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) for (var i = 0, len = holeIndices.length; i < len; i++) {
        var start = holeIndices[i] * dim;
        var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        polygonArea -= Math.abs(signedArea(data, start, end, dim));
      }
      var trianglesArea = 0;
      for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
      }
      return 0 === polygonArea && 0 === trianglesArea ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
      }
      return sum;
    }
    earcut.flatten = function(data) {
      var dim = data[0][0].length, result = {
        vertices: [],
        holes: [],
        dimensions: dim
      }, holeIndex = 0;
      for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        if (i > 0) {
          holeIndex += data[i - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }), {} ],
  157: [ (function(require, module, exports) {
    "use strict";
    var _inputAssembler = require("../../../../../renderer/core/input-assembler");
    var _inputAssembler2 = _interopRequireDefault(_inputAssembler);
    var _iaRenderData = require("../../../../../renderer/render-data/ia-render-data");
    var _iaRenderData2 = _interopRequireDefault(_iaRenderData);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Helper = require("../../../../graphics/helper");
    var PointFlags = require("../../../../graphics/types").PointFlags;
    var MeshBuffer = require("../../mesh-buffer");
    var vfmtPosColor = require("../../vertex-format").vfmtPosColor;
    var renderer = require("../../../index");
    var Point = cc.Class({
      name: "cc.GraphicsPoint",
      extends: cc.Vec2,
      ctor: function ctor(x, y) {
        this.reset();
      },
      reset: function reset() {
        this.dx = 0;
        this.dy = 0;
        this.dmx = 0;
        this.dmy = 0;
        this.flags = 0;
        this.len = 0;
      }
    });
    function Path() {
      this.reset();
    }
    cc.js.mixin(Path.prototype, {
      reset: function reset() {
        this.closed = false;
        this.nbevel = 0;
        this.complex = true;
        this.points ? this.points.length = 0 : this.points = [];
      }
    });
    function Impl(graphics) {
      this._tessTol = .25;
      this._distTol = .01;
      this._updatePathOffset = false;
      this._paths = null;
      this._pathLength = 0;
      this._pathOffset = 0;
      this._points = null;
      this._pointsOffset = 0;
      this._commandx = 0;
      this._commandy = 0;
      this._paths = [];
      this._points = [];
      this._renderDatas = [];
      this._dataOffset = 0;
    }
    cc.js.mixin(Impl.prototype, {
      moveTo: function moveTo(x, y) {
        if (this._updatePathOffset) {
          this._pathOffset = this._pathLength;
          this._updatePathOffset = false;
        }
        this._addPath();
        this._addPoint(x, y, PointFlags.PT_CORNER);
        this._commandx = x;
        this._commandy = y;
      },
      lineTo: function lineTo(x, y) {
        this._addPoint(x, y, PointFlags.PT_CORNER);
        this._commandx = x;
        this._commandy = y;
      },
      bezierCurveTo: function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
        var path = this._curPath;
        var last = path.points[path.points.length - 1];
        if (last.x === c1x && last.y === c1y && c2x === x && c2y === y) {
          this.lineTo(x, y);
          return;
        }
        Helper.tesselateBezier(this, last.x, last.y, c1x, c1y, c2x, c2y, x, y, 0, PointFlags.PT_CORNER);
        this._commandx = x;
        this._commandy = y;
      },
      quadraticCurveTo: function quadraticCurveTo(cx, cy, x, y) {
        var x0 = this._commandx;
        var y0 = this._commandy;
        this.bezierCurveTo(x0 + 2 / 3 * (cx - x0), y0 + 2 / 3 * (cy - y0), x + 2 / 3 * (cx - x), y + 2 / 3 * (cy - y), x, y);
      },
      arc: function arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
        Helper.arc(this, cx, cy, r, startAngle, endAngle, counterclockwise);
      },
      ellipse: function ellipse(cx, cy, rx, ry) {
        Helper.ellipse(this, cx, cy, rx, ry);
        this._curPath.complex = false;
      },
      circle: function circle(cx, cy, r) {
        Helper.ellipse(this, cx, cy, r, r);
        this._curPath.complex = false;
      },
      rect: function rect(x, y, w, h) {
        this.moveTo(x, y);
        this.lineTo(x, y + h);
        this.lineTo(x + w, y + h);
        this.lineTo(x + w, y);
        this.close();
        this._curPath.complex = false;
      },
      roundRect: function roundRect(x, y, w, h, r) {
        Helper.roundRect(this, x, y, w, h, r);
        this._curPath.complex = false;
      },
      clear: function clear(comp, clean) {
        this._pathLength = 0;
        this._pathOffset = 0;
        this._pointsOffset = 0;
        this._dataOffset = 0;
        this._curPath = null;
        var datas = this._renderDatas;
        if (clean) {
          this._paths.length = 0;
          this._points.length = 0;
          for (var i = 0, l = datas.length; i < l; i++) {
            var data = datas[i];
            data.meshbuffer.destroy();
            data.meshbuffer = null;
          }
          datas.length = 0;
        } else for (var _i = 0, _l = datas.length; _i < _l; _i++) {
          var _data = datas[_i];
          var meshbuffer = _data.meshbuffer;
          meshbuffer.reset();
        }
      },
      close: function close() {
        this._curPath.closed = true;
      },
      _addPath: function _addPath() {
        var offset = this._pathLength;
        var path = this._paths[offset];
        if (path) path.reset(); else {
          path = new Path();
          this._paths.push(path);
        }
        this._pathLength++;
        this._curPath = path;
        return path;
      },
      _addPoint: function _addPoint(x, y, flags) {
        var path = this._curPath;
        if (!path) return;
        var pt;
        var points = this._points;
        var pathPoints = path.points;
        var offset = this._pointsOffset++;
        pt = points[offset];
        if (pt) {
          pt.x = x;
          pt.y = y;
        } else {
          pt = new Point(x, y);
          points.push(pt);
        }
        pt.flags = flags;
        pathPoints.push(pt);
      },
      requestRenderData: function requestRenderData() {
        var renderData = new _iaRenderData2.default();
        var meshbuffer = new MeshBuffer(renderer._handle, vfmtPosColor);
        renderData.meshbuffer = meshbuffer;
        this._renderDatas.push(renderData);
        var ia = new _inputAssembler2.default();
        ia._vertexBuffer = meshbuffer._vb;
        ia._indexBuffer = meshbuffer._ib;
        ia._start = 0;
        renderData.ia = ia;
        return renderData;
      },
      getRenderDatas: function getRenderDatas() {
        0 === this._renderDatas.length && this.requestRenderData();
        return this._renderDatas;
      }
    });
    module.exports = Impl;
  }), {
    "../../../../../renderer/core/input-assembler": 223,
    "../../../../../renderer/render-data/ia-render-data": 252,
    "../../../../graphics/helper": 77,
    "../../../../graphics/types": 79,
    "../../../index": 147,
    "../../mesh-buffer": 173,
    "../../vertex-format": 177
  } ],
  158: [ (function(require, module, exports) {
    "use strict";
    var Graphics = require("../../../../graphics/graphics");
    var PointFlags = require("../../../../graphics/types").PointFlags;
    var LineJoin = Graphics.LineJoin;
    var LineCap = Graphics.LineCap;
    var Earcut = require("./earcut");
    var Impl = require("./impl");
    var MAX_VERTEX = 65535;
    var MAX_INDICE = 2 * MAX_VERTEX;
    var PI = Math.PI;
    var min = Math.min;
    var max = Math.max;
    var ceil = Math.ceil;
    var acos = Math.acos;
    var cos = Math.cos;
    var sin = Math.sin;
    var atan2 = Math.atan2;
    var abs = Math.abs;
    var _renderData = null;
    var _impl = null;
    var _curColor = 0;
    function curveDivs(r, arc, tol) {
      var da = 2 * acos(r / (r + tol));
      return max(2, ceil(arc / da));
    }
    function clamp(v, min, max) {
      if (v < min) return min;
      if (v > max) return max;
      return v;
    }
    var graphicsAssembler = {
      createImpl: function createImpl(graphics) {
        return new Impl(graphics);
      },
      updateRenderData: function updateRenderData(graphics) {
        var datas = graphics._impl.getRenderDatas();
        for (var i = 0, l = datas.length; i < l; i++) datas[i].material = graphics.sharedMaterials[0];
      },
      fillBuffers: function fillBuffers(graphics, renderer) {
        renderer._flush();
        var tempNode = renderer.node;
        renderer.node = graphics.node;
        this.renderIA(graphics, renderer);
        renderer.node = tempNode;
      },
      renderIA: function renderIA(graphics, renderer) {
        var impl = graphics._impl;
        var renderDatas = impl.getRenderDatas();
        for (var index = 0, length = renderDatas.length; index < length; index++) {
          var renderData = renderDatas[index];
          var meshbuffer = renderData.meshbuffer;
          renderData.ia._count = meshbuffer.indiceStart;
          renderer._flushIA(renderData);
          meshbuffer.uploadData();
        }
      },
      genRenderData: function genRenderData(graphics, cverts) {
        var renderDatas = _impl.getRenderDatas();
        var renderData = renderDatas[_impl._dataOffset];
        var meshbuffer = renderData.meshbuffer;
        var maxVertsCount = meshbuffer.vertexStart + cverts;
        if (maxVertsCount > MAX_VERTEX || 3 * maxVertsCount > MAX_INDICE) {
          ++_impl._dataOffset;
          maxVertsCount = cverts;
          if (_impl._dataOffset < renderDatas.length) renderData = renderDatas[_impl._dataOffset]; else {
            renderData = _impl.requestRenderData(graphics);
            renderDatas[_impl._dataOffset] = renderData;
          }
          renderData.material = graphics.sharedMaterials[0];
          meshbuffer = renderData.meshbuffer;
        }
        maxVertsCount > meshbuffer.vertexOffset && meshbuffer.requestStatic(cverts, 3 * cverts);
        return renderData;
      },
      stroke: function stroke(graphics) {
        _curColor = graphics._strokeColor._val;
        this._flattenPaths(graphics._impl);
        this._expandStroke(graphics);
        graphics._impl._updatePathOffset = true;
      },
      fill: function fill(graphics) {
        _curColor = graphics._fillColor._val;
        this._expandFill(graphics);
        graphics._impl._updatePathOffset = true;
      },
      _expandStroke: function _expandStroke(graphics) {
        var w = .5 * graphics.lineWidth, lineCap = graphics.lineCap, lineJoin = graphics.lineJoin, miterLimit = graphics.miterLimit;
        _impl = graphics._impl;
        var ncap = curveDivs(w, PI, _impl._tessTol);
        this._calculateJoins(_impl, w, lineJoin, miterLimit);
        var paths = _impl._paths;
        var cverts = 0;
        for (var i = _impl._pathOffset, l = _impl._pathLength; i < l; i++) {
          var path = paths[i];
          var pointsLength = path.points.length;
          lineJoin === LineJoin.ROUND ? cverts += 2 * (pointsLength + path.nbevel * (ncap + 2) + 1) : cverts += 2 * (pointsLength + 5 * path.nbevel + 1);
          path.closed || (lineCap === LineCap.ROUND ? cverts += 2 * (2 * ncap + 2) : cverts += 12);
        }
        var renderData = _renderData = this.genRenderData(graphics, cverts), meshbuffer = renderData.meshbuffer, vData = meshbuffer._vData, iData = meshbuffer._iData;
        for (var _i = _impl._pathOffset, _l = _impl._pathLength; _i < _l; _i++) {
          var _path = paths[_i];
          var pts = _path.points;
          var _pointsLength = pts.length;
          var offset = meshbuffer.vertexStart;
          var p0 = void 0, p1 = void 0;
          var start = void 0, end = void 0, loop = void 0;
          loop = _path.closed;
          if (loop) {
            p0 = pts[_pointsLength - 1];
            p1 = pts[0];
            start = 0;
            end = _pointsLength;
          } else {
            p0 = pts[0];
            p1 = pts[1];
            start = 1;
            end = _pointsLength - 1;
          }
          if (!loop) {
            var dPos = p1.sub(p0);
            dPos.normalizeSelf();
            var dx = dPos.x;
            var dy = dPos.y;
            lineCap === LineCap.BUTT ? this._buttCap(p0, dx, dy, w, 0) : lineCap === LineCap.SQUARE ? this._buttCap(p0, dx, dy, w, w) : lineCap === LineCap.ROUND && this._roundCapStart(p0, dx, dy, w, ncap);
          }
          for (var j = start; j < end; ++j) {
            if (lineJoin === LineJoin.ROUND) this._roundJoin(p0, p1, w, w, ncap); else if (0 !== (p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL))) this._bevelJoin(p0, p1, w, w); else {
              this._vset(p1.x + p1.dmx * w, p1.y + p1.dmy * w);
              this._vset(p1.x - p1.dmx * w, p1.y - p1.dmy * w);
            }
            p0 = p1;
            p1 = pts[j + 1];
          }
          if (loop) {
            var vDataoOfset = 3 * offset;
            this._vset(vData[vDataoOfset], vData[vDataoOfset + 1]);
            this._vset(vData[vDataoOfset + 3], vData[vDataoOfset + 4]);
          } else {
            var _dPos = p1.sub(p0);
            _dPos.normalizeSelf();
            var _dx = _dPos.x;
            var _dy = _dPos.y;
            lineCap === LineCap.BUTT ? this._buttCap(p1, _dx, _dy, w, 0) : lineCap === LineCap.BUTT || lineCap === LineCap.SQUARE ? this._buttCap(p1, _dx, _dy, w, w) : lineCap === LineCap.ROUND && this._roundCapEnd(p1, _dx, _dy, w, ncap);
          }
          var indicesOffset = meshbuffer.indiceStart;
          for (var _start = offset + 2, _end = meshbuffer.vertexStart; _start < _end; _start++) {
            iData[indicesOffset++] = _start - 2;
            iData[indicesOffset++] = _start - 1;
            iData[indicesOffset++] = _start;
          }
          meshbuffer.indiceStart = indicesOffset;
        }
        _renderData = null;
        _impl = null;
      },
      _expandFill: function _expandFill(graphics) {
        _impl = graphics._impl;
        var paths = _impl._paths;
        var cverts = 0;
        for (var i = _impl._pathOffset, l = _impl._pathLength; i < l; i++) {
          var path = paths[i];
          var pointsLength = path.points.length;
          cverts += pointsLength;
        }
        var renderData = _renderData = this.genRenderData(graphics, cverts), meshbuffer = renderData.meshbuffer, vData = meshbuffer._vData, iData = meshbuffer._iData;
        for (var _i2 = _impl._pathOffset, _l2 = _impl._pathLength; _i2 < _l2; _i2++) {
          var _path2 = paths[_i2];
          var pts = _path2.points;
          var _pointsLength2 = pts.length;
          if (0 === _pointsLength2) continue;
          var offset = meshbuffer.vertexStart;
          for (var j = 0; j < _pointsLength2; ++j) this._vset(pts[j].x, pts[j].y);
          var indicesOffset = meshbuffer.indiceStart;
          if (_path2.complex) {
            var earcutData = [];
            for (var _j = offset, end = meshbuffer.vertexStart; _j < end; _j++) {
              var vDataOffset = 3 * _j;
              earcutData.push(vData[vDataOffset]);
              earcutData.push(vData[vDataOffset + 1]);
            }
            var newIndices = Earcut(earcutData, null, 2);
            if (!newIndices || 0 === newIndices.length) continue;
            for (var _j2 = 0, nIndices = newIndices.length; _j2 < nIndices; _j2++) iData[indicesOffset++] = newIndices[_j2] + offset;
          } else {
            var first = offset;
            for (var start = offset + 2, _end2 = meshbuffer.vertexStart; start < _end2; start++) {
              iData[indicesOffset++] = first;
              iData[indicesOffset++] = start - 1;
              iData[indicesOffset++] = start;
            }
          }
          meshbuffer.indiceStart = indicesOffset;
        }
        _renderData = null;
        _impl = null;
      },
      _calculateJoins: function _calculateJoins(impl, w, lineJoin, miterLimit) {
        var iw = 0;
        w > 0 && (iw = 1 / w);
        var paths = impl._paths;
        for (var i = impl._pathOffset, l = impl._pathLength; i < l; i++) {
          var path = paths[i];
          var pts = path.points;
          var ptsLength = pts.length;
          var p0 = pts[ptsLength - 1];
          var p1 = pts[0];
          var nleft = 0;
          path.nbevel = 0;
          for (var j = 0; j < ptsLength; j++) {
            var dmr2 = void 0, cross = void 0, limit = void 0;
            var dlx0 = p0.dy;
            var dly0 = -p0.dx;
            var dlx1 = p1.dy;
            var dly1 = -p1.dx;
            p1.dmx = .5 * (dlx0 + dlx1);
            p1.dmy = .5 * (dly0 + dly1);
            dmr2 = p1.dmx * p1.dmx + p1.dmy * p1.dmy;
            if (dmr2 > 1e-6) {
              var scale = 1 / dmr2;
              scale > 600 && (scale = 600);
              p1.dmx *= scale;
              p1.dmy *= scale;
            }
            cross = p1.dx * p0.dy - p0.dx * p1.dy;
            if (cross > 0) {
              nleft++;
              p1.flags |= PointFlags.PT_LEFT;
            }
            limit = max(11, min(p0.len, p1.len) * iw);
            dmr2 * limit * limit < 1 && (p1.flags |= PointFlags.PT_INNERBEVEL);
            p1.flags & PointFlags.PT_CORNER && (dmr2 * miterLimit * miterLimit < 1 || lineJoin === LineJoin.BEVEL || lineJoin === LineJoin.ROUND) && (p1.flags |= PointFlags.PT_BEVEL);
            0 !== (p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) && path.nbevel++;
            p0 = p1;
            p1 = pts[j + 1];
          }
        }
      },
      _flattenPaths: function _flattenPaths(impl) {
        var paths = impl._paths;
        for (var i = impl._pathOffset, l = impl._pathLength; i < l; i++) {
          var path = paths[i];
          var pts = path.points;
          var p0 = pts[pts.length - 1];
          var p1 = pts[0];
          if (p0.equals(p1)) {
            path.closed = true;
            pts.pop();
            p0 = pts[pts.length - 1];
          }
          for (var j = 0, size = pts.length; j < size; j++) {
            var dPos = p1.sub(p0);
            p0.len = dPos.mag();
            (dPos.x || dPos.y) && dPos.normalizeSelf();
            p0.dx = dPos.x;
            p0.dy = dPos.y;
            p0 = p1;
            p1 = pts[j + 1];
          }
        }
      },
      _chooseBevel: function _chooseBevel(bevel, p0, p1, w) {
        var x = p1.x;
        var y = p1.y;
        var x0 = void 0, y0 = void 0, x1 = void 0, y1 = void 0;
        if (0 !== bevel) {
          x0 = x + p0.dy * w;
          y0 = y - p0.dx * w;
          x1 = x + p1.dy * w;
          y1 = y - p1.dx * w;
        } else {
          x0 = x1 = x + p1.dmx * w;
          y0 = y1 = y + p1.dmy * w;
        }
        return [ x0, y0, x1, y1 ];
      },
      _buttCap: function _buttCap(p, dx, dy, w, d) {
        var px = p.x - dx * d;
        var py = p.y - dy * d;
        var dlx = dy;
        var dly = -dx;
        this._vset(px + dlx * w, py + dly * w);
        this._vset(px - dlx * w, py - dly * w);
      },
      _roundCapStart: function _roundCapStart(p, dx, dy, w, ncap) {
        var px = p.x;
        var py = p.y;
        var dlx = dy;
        var dly = -dx;
        for (var i = 0; i < ncap; i++) {
          var a = i / (ncap - 1) * PI;
          var ax = cos(a) * w, ay = sin(a) * w;
          this._vset(px - dlx * ax - dx * ay, py - dly * ax - dy * ay);
          this._vset(px, py);
        }
        this._vset(px + dlx * w, py + dly * w);
        this._vset(px - dlx * w, py - dly * w);
      },
      _roundCapEnd: function _roundCapEnd(p, dx, dy, w, ncap) {
        var px = p.x;
        var py = p.y;
        var dlx = dy;
        var dly = -dx;
        this._vset(px + dlx * w, py + dly * w);
        this._vset(px - dlx * w, py - dly * w);
        for (var i = 0; i < ncap; i++) {
          var a = i / (ncap - 1) * PI;
          var ax = cos(a) * w, ay = sin(a) * w;
          this._vset(px, py);
          this._vset(px - dlx * ax + dx * ay, py - dly * ax + dy * ay);
        }
      },
      _roundJoin: function _roundJoin(p0, p1, lw, rw, ncap) {
        var dlx0 = p0.dy;
        var dly0 = -p0.dx;
        var dlx1 = p1.dy;
        var dly1 = -p1.dx;
        var p1x = p1.x;
        var p1y = p1.y;
        if (0 !== (p1.flags & PointFlags.PT_LEFT)) {
          var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);
          var lx0 = out[0];
          var ly0 = out[1];
          var lx1 = out[2];
          var ly1 = out[3];
          var a0 = atan2(-dly0, -dlx0);
          var a1 = atan2(-dly1, -dlx1);
          a1 > a0 && (a1 -= 2 * PI);
          this._vset(lx0, ly0);
          this._vset(p1x - dlx0 * rw, p1.y - dly0 * rw);
          var n = clamp(ceil((a0 - a1) / PI) * ncap, 2, ncap);
          for (var i = 0; i < n; i++) {
            var u = i / (n - 1);
            var a = a0 + u * (a1 - a0);
            var rx = p1x + cos(a) * rw;
            var ry = p1y + sin(a) * rw;
            this._vset(p1x, p1y);
            this._vset(rx, ry);
          }
          this._vset(lx1, ly1);
          this._vset(p1x - dlx1 * rw, p1y - dly1 * rw);
        } else {
          var _out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);
          var rx0 = _out[0];
          var ry0 = _out[1];
          var rx1 = _out[2];
          var ry1 = _out[3];
          var _a = atan2(dly0, dlx0);
          var _a2 = atan2(dly1, dlx1);
          _a2 < _a && (_a2 += 2 * PI);
          this._vset(p1x + dlx0 * rw, p1y + dly0 * rw);
          this._vset(rx0, ry0);
          var _n = clamp(ceil((_a2 - _a) / PI) * ncap, 2, ncap);
          for (var _i3 = 0; _i3 < _n; _i3++) {
            var _u = _i3 / (_n - 1);
            var _a3 = _a + _u * (_a2 - _a);
            var lx = p1x + cos(_a3) * lw;
            var ly = p1y + sin(_a3) * lw;
            this._vset(lx, ly);
            this._vset(p1x, p1y);
          }
          this._vset(p1x + dlx1 * rw, p1y + dly1 * rw);
          this._vset(rx1, ry1);
        }
      },
      _bevelJoin: function _bevelJoin(p0, p1, lw, rw) {
        var rx0 = void 0, ry0 = void 0, rx1 = void 0, ry1 = void 0;
        var lx0 = void 0, ly0 = void 0, lx1 = void 0, ly1 = void 0;
        var dlx0 = p0.dy;
        var dly0 = -p0.dx;
        var dlx1 = p1.dy;
        var dly1 = -p1.dx;
        if (p1.flags & PointFlags.PT_LEFT) {
          var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);
          lx0 = out[0];
          ly0 = out[1];
          lx1 = out[2];
          ly1 = out[3];
          this._vset(lx0, ly0);
          this._vset(p1.x - dlx0 * rw, p1.y - dly0 * rw);
          this._vset(lx1, ly1);
          this._vset(p1.x - dlx1 * rw, p1.y - dly1 * rw);
        } else {
          var _out2 = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);
          rx0 = _out2[0];
          ry0 = _out2[1];
          rx1 = _out2[2];
          ry1 = _out2[3];
          this._vset(p1.x + dlx0 * lw, p1.y + dly0 * lw);
          this._vset(rx0, ry0);
          this._vset(p1.x + dlx1 * lw, p1.y + dly1 * lw);
          this._vset(rx1, ry1);
        }
      },
      _vset: function _vset(x, y) {
        var meshbuffer = _renderData.meshbuffer;
        var dataOffset = 3 * meshbuffer.vertexStart;
        var vData = meshbuffer._vData;
        var uintVData = meshbuffer._uintVData;
        vData[dataOffset] = x;
        vData[dataOffset + 1] = y;
        uintVData[dataOffset + 2] = _curColor;
        meshbuffer.vertexStart++;
        meshbuffer._dirty = true;
      }
    };
    Graphics._assembler = graphicsAssembler;
    module.exports = graphicsAssembler;
  }), {
    "../../../../graphics/graphics": 76,
    "../../../../graphics/types": 79,
    "./earcut": 156,
    "./impl": 157
  } ],
  159: [ (function(require, module, exports) {
    "use strict";
    require("./sprite");
    require("./mask-assembler");
    require("./graphics");
    require("./label");
    require("./motion-streak");
  }), {
    "./graphics": 158,
    "./label": 163,
    "./mask-assembler": 164,
    "./motion-streak": void 0,
    "./sprite": 171
  } ],
  160: [ (function(require, module, exports) {
    "use strict";
    var js = require("../../../../../platform/js");
    var bmfontUtls = require("../../../../utils/label/bmfont");
    var fillMeshVertices = require("../../utils").fillMeshVertices;
    module.exports = js.addon({
      createData: function createData(comp) {
        return comp.requestRenderData();
      },
      fillBuffers: function fillBuffers(comp, renderer) {
        var node = comp.node;
        fillMeshVertices(node, renderer._meshBuffer, comp._renderData, node._color._val);
      },
      appendQuad: function appendQuad(renderData, texture, rect, rotated, x, y, scale) {
        var dataOffset = renderData.dataLength;
        renderData.dataLength += 4;
        renderData.vertexCount = renderData.dataLength;
        renderData.indiceCount = renderData.dataLength / 2 * 3;
        var data = renderData._data;
        var texw = texture.width, texh = texture.height;
        var rectWidth = rect.width, rectHeight = rect.height;
        var l = void 0, b = void 0, r = void 0, t = void 0;
        if (rotated) {
          l = rect.x / texw;
          r = (rect.x + rectHeight) / texw;
          b = (rect.y + rectWidth) / texh;
          t = rect.y / texh;
          data[dataOffset].u = l;
          data[dataOffset].v = t;
          data[dataOffset + 1].u = l;
          data[dataOffset + 1].v = b;
          data[dataOffset + 2].u = r;
          data[dataOffset + 2].v = t;
          data[dataOffset + 3].u = r;
          data[dataOffset + 3].v = b;
        } else {
          l = rect.x / texw;
          r = (rect.x + rectWidth) / texw;
          b = (rect.y + rectHeight) / texh;
          t = rect.y / texh;
          data[dataOffset].u = l;
          data[dataOffset].v = b;
          data[dataOffset + 1].u = r;
          data[dataOffset + 1].v = b;
          data[dataOffset + 2].u = l;
          data[dataOffset + 2].v = t;
          data[dataOffset + 3].u = r;
          data[dataOffset + 3].v = t;
        }
        data[dataOffset].x = x;
        data[dataOffset].y = y - rectHeight * scale;
        data[dataOffset + 1].x = x + rectWidth * scale;
        data[dataOffset + 1].y = y - rectHeight * scale;
        data[dataOffset + 2].x = x;
        data[dataOffset + 2].y = y;
        data[dataOffset + 3].x = x + rectWidth * scale;
        data[dataOffset + 3].y = y;
      }
    }, bmfontUtls);
  }), {
    "../../../../../platform/js": 124,
    "../../../../utils/label/bmfont": 151,
    "../../utils": 172
  } ],
  161: [ (function(require, module, exports) {
    "use strict";
    var js = require("../../../../../platform/js");
    var bmfontAssembler = require("./bmfont");
    var fontUtils = require("../../../../utils/label/letter-font");
    var fillMeshVertices = require("../../utils").fillMeshVertices;
    var WHITE = cc.color(255, 255, 255, 255);
    module.exports = js.addon({
      createData: function createData(comp) {
        return comp.requestRenderData();
      },
      fillBuffers: function fillBuffers(comp, renderer) {
        var node = comp.node;
        WHITE._fastSetA(node.color.a);
        fillMeshVertices(node, renderer._meshBuffer, comp._renderData, WHITE._val);
      },
      appendQuad: bmfontAssembler.appendQuad
    }, fontUtils);
  }), {
    "../../../../../platform/js": 124,
    "../../../../utils/label/letter-font": 153,
    "../../utils": 172,
    "./bmfont": 160
  } ],
  162: [ (function(require, module, exports) {
    "use strict";
    var js = require("../../../../../platform/js");
    var ttfUtls = require("../../../../utils/label/ttf");
    var LabelShadow = require("../../../../../components/CCLabelShadow");
    var fillMeshVertices = require("../../utils").fillMeshVertices;
    var WHITE = cc.color(255, 255, 255, 255);
    module.exports = js.addon({
      createData: function createData(comp) {
        var renderData = comp.requestRenderData();
        renderData.dataLength = 4;
        renderData.vertexCount = 4;
        renderData.indiceCount = 6;
        return renderData;
      },
      fillBuffers: function fillBuffers(comp, renderer) {
        var node = comp.node;
        WHITE._fastSetA(node.color.a);
        fillMeshVertices(node, renderer._meshBuffer, comp._renderData, WHITE._val);
      },
      _updateVerts: function _updateVerts(comp) {
        var renderData = comp._renderData;
        var uv = comp._frame.uv;
        var node = comp.node, canvasWidth = comp._ttfTexture.width, canvasHeight = comp._ttfTexture.height, appx = node.anchorX * node.width, appy = node.anchorY * node.height;
        var shadow = LabelShadow && comp.getComponent(LabelShadow);
        if (shadow && shadow._enabled) {
          var offsetX = (canvasWidth - node.width) / 2;
          var offsetY = (canvasHeight - node.height) / 2;
          var shadowOffset = shadow.offset;
          -shadowOffset.x > offsetX ? appx += canvasWidth - node.width : offsetX > shadowOffset.x && (appx += offsetX - shadowOffset.x);
          -shadowOffset.y > offsetY ? appy += canvasHeight - node.height : offsetY > shadowOffset.y && (appy += offsetY - shadowOffset.y);
        }
        var data = renderData._data;
        data[0].x = -appx;
        data[0].y = -appy;
        data[1].x = canvasWidth - appx;
        data[1].y = -appy;
        data[2].x = -appx;
        data[2].y = canvasHeight - appy;
        data[3].x = canvasWidth - appx;
        data[3].y = canvasHeight - appy;
        data[0].u = uv[0];
        data[0].v = uv[1];
        data[1].u = uv[2];
        data[1].v = uv[3];
        data[2].u = uv[4];
        data[2].v = uv[5];
        data[3].u = uv[6];
        data[3].v = uv[7];
      }
    }, ttfUtls);
  }), {
    "../../../../../components/CCLabelShadow": 43,
    "../../../../../platform/js": 124,
    "../../../../utils/label/ttf": 154,
    "../../utils": 172
  } ],
  163: [ (function(require, module, exports) {
    "use strict";
    var Label = require("../../../../components/CCLabel");
    var ttfAssembler = require("./2d/ttf");
    var bmfontAssembler = require("./2d/bmfont");
    var letterAssembler = require("./2d/letter");
    var ttfAssembler3D = require("./3d/ttf");
    var bmfontAssembler3D = require("./3d/bmfont");
    var letterAssembler3D = require("./3d/letter");
    var canvasPool = {
      pool: [],
      get: function get() {
        var data = this.pool.pop();
        if (!data) {
          var canvas = document.createElement("canvas");
          var context = canvas.getContext("2d");
          data = {
            canvas: canvas,
            context: context
          };
        }
        return data;
      },
      put: function put(canvas) {
        if (this.pool.length >= 32) return;
        this.pool.push(canvas);
      }
    };
    var labelAssembler = {
      getAssembler: function getAssembler(comp) {
        var is3DNode = comp.node.is3DNode;
        var assembler = is3DNode ? ttfAssembler3D : ttfAssembler;
        comp.font instanceof cc.BitmapFont ? assembler = is3DNode ? bmfontAssembler3D : bmfontAssembler : comp.cacheMode === Label.CacheMode.CHAR && (cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB ? cc.warn("sorry, subdomain does not support CHAR mode currently!") : assembler = is3DNode ? letterAssembler3D : letterAssembler);
        return assembler;
      },
      updateRenderData: function updateRenderData(label) {
        return label.__allocedDatas;
      }
    };
    Label._assembler = labelAssembler;
    Label._canvasPool = canvasPool;
    module.exports = labelAssembler;
  }), {
    "../../../../components/CCLabel": 41,
    "./2d/bmfont": 160,
    "./2d/letter": 161,
    "./2d/ttf": 162,
    "./3d/bmfont": void 0,
    "./3d/letter": void 0,
    "./3d/ttf": void 0
  } ],
  164: [ (function(require, module, exports) {
    "use strict";
    var Mask = require("../../../components/CCMask");
    var RenderFlow = require("../../render-flow");
    var spriteAssembler = require("./sprite/2d/simple");
    var graphicsAssembler = require("./graphics");
    var gfx = require("../../../../renderer/gfx");
    var vfmtPos = require("../vertex-format").vfmtPos;
    var _maxLevel = 8;
    var _maskStack = [];
    function getWriteMask() {
      return 1 << _maskStack.length - 1;
    }
    function getStencilRef() {
      var result = 0;
      for (var i = 0; i < _maskStack.length; ++i) result += 1 << i;
      return result;
    }
    function applyStencil(material, func, failOp, ref, stencilMask, writeMask) {
      var effect = material.effect;
      var technique = effect.getDefaultTechnique();
      var passes = technique.passes;
      var zFailOp = gfx.STENCIL_OP_KEEP, zPassOp = gfx.STENCIL_OP_KEEP;
      for (var i = 0; i < passes.length; ++i) {
        var pass = passes[i];
        pass.setStencilFront(gfx.STENCIL_ENABLE, func, ref, stencilMask, failOp, zFailOp, zPassOp, writeMask);
        pass.setStencilBack(gfx.STENCIL_ENABLE, func, ref, stencilMask, failOp, zFailOp, zPassOp, writeMask);
      }
    }
    function pushMask(mask) {
      _maskStack.length + 1 > _maxLevel && cc.errorID(9e3, _maxLevel);
      _maskStack.push(mask);
    }
    function exitMask(mask, renderer) {
      0 === _maskStack.length && cc.errorID(9001);
      _maskStack.pop();
      0 === _maskStack.length ? renderer._flushMaterial(mask._exitMaterial) : enableMask(renderer);
    }
    function applyClearMask(mask, renderer) {
      var func = gfx.DS_FUNC_NEVER;
      var ref = getWriteMask();
      var stencilMask = ref;
      var writeMask = ref;
      var failOp = mask.inverted ? gfx.STENCIL_OP_REPLACE : gfx.STENCIL_OP_ZERO;
      applyStencil(mask._clearMaterial, func, failOp, ref, stencilMask, writeMask);
      var buffer = renderer.getBuffer("mesh", vfmtPos);
      var offsetInfo = buffer.request(4, 6);
      var indiceOffset = offsetInfo.indiceOffset, vertexOffset = offsetInfo.byteOffset >> 2, vertexId = offsetInfo.vertexOffset, vbuf = buffer._vData, ibuf = buffer._iData;
      vbuf[vertexOffset++] = -1;
      vbuf[vertexOffset++] = -1;
      vbuf[vertexOffset++] = -1;
      vbuf[vertexOffset++] = 1;
      vbuf[vertexOffset++] = 1;
      vbuf[vertexOffset++] = 1;
      vbuf[vertexOffset++] = 1;
      vbuf[vertexOffset++] = -1;
      ibuf[indiceOffset++] = vertexId;
      ibuf[indiceOffset++] = vertexId + 3;
      ibuf[indiceOffset++] = vertexId + 1;
      ibuf[indiceOffset++] = vertexId + 1;
      ibuf[indiceOffset++] = vertexId + 3;
      ibuf[indiceOffset++] = vertexId + 2;
      renderer.node = renderer._dummyNode;
      renderer.material = mask._clearMaterial;
      renderer._flush();
    }
    function applyAreaMask(mask, renderer) {
      var func = gfx.DS_FUNC_NEVER;
      var ref = getWriteMask();
      var stencilMask = ref;
      var writeMask = ref;
      var failOp = mask.inverted ? gfx.STENCIL_OP_ZERO : gfx.STENCIL_OP_REPLACE;
      applyStencil(mask.sharedMaterials[0], func, failOp, ref, stencilMask, writeMask);
      renderer.node = mask.node;
      renderer.material = mask.sharedMaterials[0];
      if (mask._type === Mask.Type.IMAGE_STENCIL) {
        spriteAssembler.fillBuffers(mask, renderer);
        renderer._flush();
      } else graphicsAssembler.fillBuffers(mask._graphics, renderer);
    }
    function enableMask(renderer) {
      var func = gfx.DS_FUNC_EQUAL;
      var failOp = gfx.STENCIL_OP_KEEP;
      var ref = getStencilRef();
      var stencilMask = ref;
      var writeMask = getWriteMask();
      var mask = _maskStack[_maskStack.length - 1];
      applyStencil(mask._enableMaterial, func, failOp, ref, stencilMask, writeMask);
      renderer._flushMaterial(mask._enableMaterial);
    }
    var maskFrontAssembler = {
      updateRenderData: function updateRenderData(mask) {
        mask._renderData || (mask._type === Mask.Type.IMAGE_STENCIL ? mask._renderData = spriteAssembler.createData(mask) : mask._renderData = mask.requestRenderData());
        var renderData = mask._renderData;
        if (mask._type === Mask.Type.IMAGE_STENCIL) if (mask.spriteFrame) {
          var size = mask.node._contentSize;
          var anchor = mask.node._anchorPoint;
          renderData.updateSizeNPivot(size.width, size.height, anchor.x, anchor.y);
          renderData.dataLength = 4;
          spriteAssembler.updateRenderData(mask);
          renderData.material = mask.sharedMaterials[0];
        } else mask.setMaterial(0, null); else {
          mask._graphics.setMaterial(0, mask.sharedMaterials[0]);
          graphicsAssembler.updateRenderData(mask._graphics);
        }
      },
      fillBuffers: function fillBuffers(mask, renderer) {
        if (mask._type !== Mask.Type.IMAGE_STENCIL || mask.spriteFrame) {
          pushMask(mask);
          applyClearMask(mask, renderer);
          applyAreaMask(mask, renderer);
          enableMask(renderer);
        }
        mask.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA;
      }
    };
    var maskEndAssembler = {
      fillBuffers: function fillBuffers(mask, renderer) {
        (mask._type !== Mask.Type.IMAGE_STENCIL || mask.spriteFrame) && exitMask(mask, renderer);
        mask.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA;
      }
    };
    Mask._assembler = maskFrontAssembler;
    Mask._postAssembler = maskEndAssembler;
    module.exports = {
      front: maskFrontAssembler,
      end: maskEndAssembler
    };
  }), {
    "../../../../renderer/gfx": 233,
    "../../../components/CCMask": 45,
    "../../render-flow": 148,
    "../vertex-format": 177,
    "./graphics": 158,
    "./sprite/2d/simple": 168
  } ],
  165: [ (function(require, module, exports) {
    "use strict";
    var Sprite = require("../../../../../components/CCSprite");
    var FillType = Sprite.FillType;
    var packToDynamicAtlas = require("../../../../utils/utils").packToDynamicAtlas;
    var fillVerticesWithoutCalc = require("../../utils").fillVerticesWithoutCalc;
    module.exports = {
      updateRenderData: function updateRenderData(sprite) {
        packToDynamicAtlas(sprite, sprite._spriteFrame);
        var renderData = sprite._renderData;
        if (!renderData || !sprite.spriteFrame) return;
        var uvDirty = renderData.uvDirty, vertDirty = renderData.vertDirty;
        if (!uvDirty && !vertDirty) return sprite.__allocedDatas;
        var fillStart = sprite._fillStart;
        var fillRange = sprite._fillRange;
        if (fillRange < 0) {
          fillStart += fillRange;
          fillRange = -fillRange;
        }
        fillRange = fillStart + fillRange;
        fillStart = fillStart > 1 ? 1 : fillStart;
        fillStart = fillStart < 0 ? 0 : fillStart;
        fillRange = fillRange > 1 ? 1 : fillRange;
        fillRange = fillRange < 0 ? 0 : fillRange;
        fillRange -= fillStart;
        fillRange = fillRange < 0 ? 0 : fillRange;
        var fillEnd = fillStart + fillRange;
        fillEnd = fillEnd > 1 ? 1 : fillEnd;
        uvDirty && this.updateUVs(sprite, fillStart, fillEnd);
        if (vertDirty) {
          this.updateVerts(sprite, fillStart, fillEnd);
          this.updateWorldVerts(sprite);
        }
      },
      updateUVs: function updateUVs(sprite, fillStart, fillEnd) {
        var spriteFrame = sprite._spriteFrame, renderData = sprite._renderData, data = renderData._data;
        var atlasWidth = spriteFrame._texture.width;
        var atlasHeight = spriteFrame._texture.height;
        var textureRect = spriteFrame._rect;
        var ul = void 0, vb = void 0, ur = void 0, vt = void 0;
        var quadUV0 = void 0, quadUV1 = void 0, quadUV2 = void 0, quadUV3 = void 0, quadUV4 = void 0, quadUV5 = void 0, quadUV6 = void 0, quadUV7 = void 0;
        if (spriteFrame._rotated) {
          ul = textureRect.x / atlasWidth;
          vb = (textureRect.y + textureRect.width) / atlasHeight;
          ur = (textureRect.x + textureRect.height) / atlasWidth;
          vt = textureRect.y / atlasHeight;
          quadUV0 = quadUV2 = ul;
          quadUV4 = quadUV6 = ur;
          quadUV3 = quadUV7 = vb;
          quadUV1 = quadUV5 = vt;
        } else {
          ul = textureRect.x / atlasWidth;
          vb = (textureRect.y + textureRect.height) / atlasHeight;
          ur = (textureRect.x + textureRect.width) / atlasWidth;
          vt = textureRect.y / atlasHeight;
          quadUV0 = quadUV4 = ul;
          quadUV2 = quadUV6 = ur;
          quadUV1 = quadUV3 = vb;
          quadUV5 = quadUV7 = vt;
        }
        switch (sprite._fillType) {
         case FillType.HORIZONTAL:
          data[0].u = quadUV0 + (quadUV2 - quadUV0) * fillStart;
          data[0].v = quadUV1 + (quadUV3 - quadUV1) * fillStart;
          data[1].u = quadUV0 + (quadUV2 - quadUV0) * fillEnd;
          data[1].v = quadUV1 + (quadUV3 - quadUV1) * fillEnd;
          data[2].u = quadUV4 + (quadUV6 - quadUV4) * fillStart;
          data[2].v = quadUV5 + (quadUV7 - quadUV5) * fillStart;
          data[3].u = quadUV4 + (quadUV6 - quadUV4) * fillEnd;
          data[3].v = quadUV5 + (quadUV7 - quadUV5) * fillEnd;
          break;

         case FillType.VERTICAL:
          data[0].u = quadUV0 + (quadUV4 - quadUV0) * fillStart;
          data[0].v = quadUV1 + (quadUV5 - quadUV1) * fillStart;
          data[1].u = quadUV2 + (quadUV6 - quadUV2) * fillStart;
          data[1].v = quadUV3 + (quadUV7 - quadUV3) * fillStart;
          data[2].u = quadUV0 + (quadUV4 - quadUV0) * fillEnd;
          data[2].v = quadUV1 + (quadUV5 - quadUV1) * fillEnd;
          data[3].u = quadUV2 + (quadUV6 - quadUV2) * fillEnd;
          data[3].v = quadUV3 + (quadUV7 - quadUV3) * fillEnd;
          break;

         default:
          cc.errorID(2626);
        }
        renderData.uvDirty = false;
      },
      updateVerts: function updateVerts(sprite, fillStart, fillEnd) {
        var renderData = sprite._renderData, data = renderData._data, node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height;
        var l = -appx, b = -appy, r = width - appx, t = height - appy;
        var progressStart = void 0, progressEnd = void 0;
        switch (sprite._fillType) {
         case FillType.HORIZONTAL:
          progressStart = l + (r - l) * fillStart;
          progressEnd = l + (r - l) * fillEnd;
          l = progressStart;
          r = progressEnd;
          break;

         case FillType.VERTICAL:
          progressStart = b + (t - b) * fillStart;
          progressEnd = b + (t - b) * fillEnd;
          b = progressStart;
          t = progressEnd;
          break;

         default:
          cc.errorID(2626);
        }
        data[4].x = l;
        data[4].y = b;
        data[5].x = r;
        data[5].y = b;
        data[6].x = l;
        data[6].y = t;
        data[7].x = r;
        data[7].y = t;
        renderData.vertDirty = false;
      },
      createData: function createData(sprite) {
        var renderData = sprite.requestRenderData();
        renderData.dataLength = 8;
        renderData.vertexCount = 4;
        renderData.indiceCount = 6;
        var data = renderData._data;
        for (var i = 0; i < data.length; i++) data[i].z = 0;
        return renderData;
      },
      updateWorldVerts: function updateWorldVerts(sprite) {
        var node = sprite.node, data = sprite._renderData._data;
        var matrix = node._worldMatrix;
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        for (var i = 0; i < 4; i++) {
          var local = data[i + 4];
          var world = data[i];
          world.x = local.x * a + local.y * c + tx;
          world.y = local.x * b + local.y * d + ty;
        }
      },
      fillBuffers: function fillBuffers(sprite, renderer) {
        renderer.worldMatDirty && this.updateWorldVerts(sprite);
        var buffer = renderer._meshBuffer;
        var node = sprite.node;
        var offsetInfo = fillVerticesWithoutCalc(node, buffer, sprite._renderData, node._color._val);
        var ibuf = buffer._iData, indiceOffset = offsetInfo.indiceOffset, vertexId = offsetInfo.vertexOffset;
        ibuf[indiceOffset++] = vertexId;
        ibuf[indiceOffset++] = vertexId + 1;
        ibuf[indiceOffset++] = vertexId + 2;
        ibuf[indiceOffset++] = vertexId + 1;
        ibuf[indiceOffset++] = vertexId + 3;
        ibuf[indiceOffset++] = vertexId + 2;
      }
    };
  }), {
    "../../../../../components/CCSprite": 51,
    "../../../../utils/utils": 155,
    "../../utils": 172
  } ],
  166: [ (function(require, module, exports) {
    "use strict";
    var fillVerticesWithoutCalc = require("../../utils").fillVerticesWithoutCalc;
    var packToDynamicAtlas = require("../../../../utils/utils").packToDynamicAtlas;
    module.exports = {
      createData: function createData(sprite) {
        return sprite.requestRenderData();
      },
      updateRenderData: function updateRenderData(sprite) {
        packToDynamicAtlas(sprite, sprite._spriteFrame);
        var renderData = sprite._renderData;
        var frame = sprite.spriteFrame;
        if (!renderData || !frame) return;
        var vertices = frame.vertices;
        if (vertices) {
          if (renderData.vertexCount !== vertices.x.length) {
            renderData.vertexCount = vertices.x.length;
            renderData.indiceCount = vertices.triangles.length;
            renderData.dataLength = 2 * renderData.vertexCount;
            renderData.uvDirty = renderData.vertDirty = true;
          }
          renderData.uvDirty && this.updateUVs(sprite);
          var vertDirty = renderData.vertDirty;
          if (vertDirty) {
            this.updateVerts(sprite);
            this.updateWorldVerts(sprite);
          }
        }
      },
      updateUVs: function updateUVs(sprite) {
        var vertices = sprite.spriteFrame.vertices, u = vertices.nu, v = vertices.nv;
        var renderData = sprite._renderData;
        var data = renderData._data;
        for (var i = 0, l = u.length; i < l; i++) {
          var vertice = data[i];
          vertice.u = u[i];
          vertice.v = v[i];
        }
        renderData.uvDirty = false;
      },
      updateVerts: function updateVerts(sprite) {
        var node = sprite.node, contentWidth = Math.abs(node.width), contentHeight = Math.abs(node.height), appx = node.anchorX * contentWidth, appy = node.anchorY * contentHeight;
        var frame = sprite.spriteFrame, vertices = frame.vertices, x = vertices.x, y = vertices.y, originalWidth = frame._originalSize.width, originalHeight = frame._originalSize.height, rectWidth = frame._rect.width, rectHeight = frame._rect.height, offsetX = frame._offset.x, offsetY = frame._offset.y, trimX = offsetX + (originalWidth - rectWidth) / 2, trimY = offsetY + (originalHeight - rectHeight) / 2;
        var scaleX = contentWidth / (sprite.trim ? rectWidth : originalWidth), scaleY = contentHeight / (sprite.trim ? rectHeight : originalHeight);
        var renderData = sprite._renderData;
        var data = renderData._data;
        if (sprite.trim) for (var _i = 0, _l = x.length; _i < _l; _i++) {
          var _vertice = data[_i + _l];
          _vertice.x = (x[_i] - trimX) * scaleX - appx;
          _vertice.y = (originalHeight - y[_i] - trimY) * scaleY - appy;
        } else for (var i = 0, l = x.length; i < l; i++) {
          var vertice = data[i + l];
          vertice.x = x[i] * scaleX - appx;
          vertice.y = (originalHeight - y[i]) * scaleY - appy;
        }
        renderData.vertDirty = false;
      },
      updateWorldVerts: function updateWorldVerts(sprite) {
        var node = sprite.node, renderData = sprite._renderData, data = renderData._data;
        var matrix = node._worldMatrix;
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        for (var i = 0, l = renderData.vertexCount; i < l; i++) {
          var local = data[i + l];
          var world = data[i];
          world.x = local.x * a + local.y * c + tx;
          world.y = local.x * b + local.y * d + ty;
        }
      },
      fillBuffers: function fillBuffers(sprite, renderer) {
        var vertices = sprite.spriteFrame.vertices;
        if (!vertices) return;
        renderer.worldMatDirty && this.updateWorldVerts(sprite);
        var buffer = renderer._meshBuffer;
        var node = sprite.node;
        var offsetInfo = fillVerticesWithoutCalc(node, buffer, sprite._renderData, node._color._val);
        var ibuf = buffer._iData, indiceOffset = offsetInfo.indiceOffset, vertexId = offsetInfo.vertexOffset;
        var triangles = vertices.triangles;
        for (var i = 0, l = triangles.length; i < l; i++) ibuf[indiceOffset++] = vertexId + triangles[i];
      }
    };
  }), {
    "../../../../utils/utils": 155,
    "../../utils": 172
  } ],
  167: [ (function(require, module, exports) {
    "use strict";
    var fillVertices = require("../../utils").fillVertices;
    var packToDynamicAtlas = require("../../../../utils/utils").packToDynamicAtlas;
    var PI_2 = 2 * Math.PI;
    var _vertPos = [ cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0) ];
    var _vertices = [ 0, 0, 0, 0 ];
    var _uvs = [ 0, 0, 0, 0, 0, 0, 0, 0 ];
    var _intersectPoint_1 = [ cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0) ];
    var _intersectPoint_2 = [ cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0) ];
    var _center = cc.v2(0, 0);
    var _triangles = [];
    function _calcInsectedPoints(left, right, bottom, top, center, angle, intersectPoints) {
      var sinAngle = Math.sin(angle);
      var cosAngle = Math.cos(angle);
      var tanAngle = void 0, cotAngle = void 0;
      if (0 !== Math.cos(angle)) {
        tanAngle = sinAngle / cosAngle;
        if ((left - center.x) * cosAngle > 0) {
          var yleft = center.y + tanAngle * (left - center.x);
          intersectPoints[0].x = left;
          intersectPoints[0].y = yleft;
        }
        if ((right - center.x) * cosAngle > 0) {
          var yright = center.y + tanAngle * (right - center.x);
          intersectPoints[2].x = right;
          intersectPoints[2].y = yright;
        }
      }
      if (0 !== Math.sin(angle)) {
        cotAngle = cosAngle / sinAngle;
        if ((top - center.y) * sinAngle > 0) {
          var xtop = center.x + cotAngle * (top - center.y);
          intersectPoints[3].x = xtop;
          intersectPoints[3].y = top;
        }
        if ((bottom - center.y) * sinAngle > 0) {
          var xbottom = center.x + cotAngle * (bottom - center.y);
          intersectPoints[1].x = xbottom;
          intersectPoints[1].y = bottom;
        }
      }
    }
    function _calculateVertices(sprite) {
      var node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height;
      var l = -appx, b = -appy, r = width - appx, t = height - appy;
      var vertices = _vertices;
      vertices[0] = l;
      vertices[1] = b;
      vertices[2] = r;
      vertices[3] = t;
      var fillCenter = sprite._fillCenter, cx = _center.x = Math.min(Math.max(0, fillCenter.x), 1) * (r - l) + l, cy = _center.y = Math.min(Math.max(0, fillCenter.y), 1) * (t - b) + b;
      _vertPos[0].x = _vertPos[3].x = l;
      _vertPos[1].x = _vertPos[2].x = r;
      _vertPos[0].y = _vertPos[1].y = b;
      _vertPos[2].y = _vertPos[3].y = t;
      _triangles.length = 0;
      cx !== vertices[0] && (_triangles[0] = [ 3, 0 ]);
      cx !== vertices[2] && (_triangles[2] = [ 1, 2 ]);
      cy !== vertices[1] && (_triangles[1] = [ 0, 1 ]);
      cy !== vertices[3] && (_triangles[3] = [ 2, 3 ]);
    }
    function _calculateUVs(spriteFrame) {
      var atlasWidth = spriteFrame._texture.width;
      var atlasHeight = spriteFrame._texture.height;
      var textureRect = spriteFrame._rect;
      var u0 = void 0, u1 = void 0, v0 = void 0, v1 = void 0;
      var uvs = _uvs;
      if (spriteFrame._rotated) {
        u0 = textureRect.x / atlasWidth;
        u1 = (textureRect.x + textureRect.height) / atlasWidth;
        v0 = textureRect.y / atlasHeight;
        v1 = (textureRect.y + textureRect.width) / atlasHeight;
        uvs[0] = uvs[2] = u0;
        uvs[4] = uvs[6] = u1;
        uvs[3] = uvs[7] = v1;
        uvs[1] = uvs[5] = v0;
      } else {
        u0 = textureRect.x / atlasWidth;
        u1 = (textureRect.x + textureRect.width) / atlasWidth;
        v0 = textureRect.y / atlasHeight;
        v1 = (textureRect.y + textureRect.height) / atlasHeight;
        uvs[0] = uvs[4] = u0;
        uvs[2] = uvs[6] = u1;
        uvs[1] = uvs[3] = v1;
        uvs[5] = uvs[7] = v0;
      }
    }
    function _getVertAngle(start, end) {
      var placementX = void 0, placementY = void 0;
      placementX = end.x - start.x;
      placementY = end.y - start.y;
      if (0 === placementX && 0 === placementY) return;
      if (0 === placementX) return placementY > 0 ? .5 * Math.PI : 1.5 * Math.PI;
      var angle = Math.atan(placementY / placementX);
      placementX < 0 && (angle += Math.PI);
      return angle;
    }
    function _generateTriangle(data, offset, vert0, vert1, vert2) {
      var vertices = _vertices;
      var v0x = vertices[0];
      var v0y = vertices[1];
      var v1x = vertices[2];
      var v1y = vertices[3];
      data[offset].x = vert0.x;
      data[offset].y = vert0.y;
      data[offset + 1].x = vert1.x;
      data[offset + 1].y = vert1.y;
      data[offset + 2].x = vert2.x;
      data[offset + 2].y = vert2.y;
      var progressX = void 0, progressY = void 0;
      progressX = (vert0.x - v0x) / (v1x - v0x);
      progressY = (vert0.y - v0y) / (v1y - v0y);
      _generateUV(progressX, progressY, data, offset);
      progressX = (vert1.x - v0x) / (v1x - v0x);
      progressY = (vert1.y - v0y) / (v1y - v0y);
      _generateUV(progressX, progressY, data, offset + 1);
      progressX = (vert2.x - v0x) / (v1x - v0x);
      progressY = (vert2.y - v0y) / (v1y - v0y);
      _generateUV(progressX, progressY, data, offset + 2);
    }
    function _generateUV(progressX, progressY, data, offset) {
      var uvs = _uvs;
      var px1 = uvs[0] + (uvs[2] - uvs[0]) * progressX;
      var px2 = uvs[4] + (uvs[6] - uvs[4]) * progressX;
      var py1 = uvs[1] + (uvs[3] - uvs[1]) * progressX;
      var py2 = uvs[5] + (uvs[7] - uvs[5]) * progressX;
      var uv = data[offset];
      uv.u = px1 + (px2 - px1) * progressY;
      uv.v = py1 + (py2 - py1) * progressY;
    }
    module.exports = {
      createData: function createData(sprite) {
        return sprite.requestRenderData();
      },
      updateRenderData: function updateRenderData(sprite) {
        var renderData = sprite._renderData;
        var frame = sprite.spriteFrame;
        if (!renderData || !frame) return;
        if (!renderData.vertDirty && !renderData.uvDirty) return;
        var data = renderData._data;
        packToDynamicAtlas(sprite, frame);
        var fillStart = sprite._fillStart;
        var fillRange = sprite._fillRange;
        if (fillRange < 0) {
          fillStart += fillRange;
          fillRange = -fillRange;
        }
        while (fillStart >= 1) fillStart -= 1;
        while (fillStart < 0) fillStart += 1;
        fillStart *= PI_2;
        fillRange *= PI_2;
        var fillEnd = fillStart + fillRange;
        _calculateVertices(sprite);
        _calculateUVs(frame);
        _calcInsectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart, _intersectPoint_1);
        _calcInsectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart + fillRange, _intersectPoint_2);
        var offset = 0;
        for (var triangleIndex = 0; triangleIndex < 4; ++triangleIndex) {
          var triangle = _triangles[triangleIndex];
          if (!triangle) continue;
          if (fillRange >= PI_2) {
            renderData.dataLength = offset + 3;
            _generateTriangle(data, offset, _center, _vertPos[triangle[0]], _vertPos[triangle[1]]);
            offset += 3;
            continue;
          }
          var startAngle = _getVertAngle(_center, _vertPos[triangle[0]]);
          var endAngle = _getVertAngle(_center, _vertPos[triangle[1]]);
          endAngle < startAngle && (endAngle += PI_2);
          startAngle -= PI_2;
          endAngle -= PI_2;
          for (var testIndex = 0; testIndex < 3; ++testIndex) {
            if (startAngle >= fillEnd) ; else if (startAngle >= fillStart) {
              renderData.dataLength = offset + 3;
              _generateTriangle(data, offset, _center, _vertPos[triangle[0]], endAngle >= fillEnd ? _intersectPoint_2[triangleIndex] : _vertPos[triangle[1]]);
              offset += 3;
            } else if (endAngle <= fillStart) ; else if (endAngle <= fillEnd) {
              renderData.dataLength = offset + 3;
              _generateTriangle(data, offset, _center, _intersectPoint_1[triangleIndex], _vertPos[triangle[1]]);
              offset += 3;
            } else {
              renderData.dataLength = offset + 3;
              _generateTriangle(data, offset, _center, _intersectPoint_1[triangleIndex], _intersectPoint_2[triangleIndex]);
              offset += 3;
            }
            startAngle += PI_2;
            endAngle += PI_2;
          }
        }
        renderData.indiceCount = renderData.vertexCount = offset;
        renderData.vertDirty = renderData.uvDirty = false;
      },
      fillBuffers: function fillBuffers(comp, renderer) {
        var node = comp.node, color = node._color._val, buffer = renderer._meshBuffer, renderData = comp._renderData;
        var offsetInfo = fillVertices(node, buffer, renderData, color);
        var indiceOffset = offsetInfo.indiceOffset, vertexId = offsetInfo.vertexOffset;
        var ibuf = buffer._iData;
        for (var i = 0; i < renderData.dataLength; i++) ibuf[indiceOffset + i] = vertexId + i;
      }
    };
  }), {
    "../../../../utils/utils": 155,
    "../../utils": 172
  } ],
  168: [ (function(require, module, exports) {
    "use strict";
    var packToDynamicAtlas = require("../../../../utils/utils").packToDynamicAtlas;
    module.exports = {
      updateRenderData: function updateRenderData(sprite) {
        packToDynamicAtlas(sprite, sprite._spriteFrame);
        var renderData = sprite._renderData;
        if (!renderData || !sprite.spriteFrame) return;
        renderData.vertDirty && this.updateVerts(sprite);
      },
      fillBuffers: function fillBuffers(sprite, renderer) {
        var data = sprite._renderData._data, node = sprite.node, color = node._color._val, matrix = node._worldMatrix, a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13, buffer = renderer._meshBuffer;
        var offsetInfo = buffer.request(4, 6);
        var indiceOffset = offsetInfo.indiceOffset, vertexOffset = offsetInfo.byteOffset >> 2, vertexId = offsetInfo.vertexOffset, vbuf = buffer._vData, uintbuf = buffer._uintVData, ibuf = buffer._iData;
        var uv = sprite._spriteFrame.uv;
        vbuf[vertexOffset + 2] = uv[0];
        vbuf[vertexOffset + 3] = uv[1];
        vbuf[vertexOffset + 7] = uv[2];
        vbuf[vertexOffset + 8] = uv[3];
        vbuf[vertexOffset + 12] = uv[4];
        vbuf[vertexOffset + 13] = uv[5];
        vbuf[vertexOffset + 17] = uv[6];
        vbuf[vertexOffset + 18] = uv[7];
        var data0 = data[0], data3 = data[3], vl = data0.x, vr = data3.x, vb = data0.y, vt = data3.y;
        var al = a * vl, ar = a * vr, bl = b * vl, br = b * vr, cb = c * vb, ct = c * vt, db = d * vb, dt = d * vt;
        vbuf[vertexOffset] = al + cb + tx;
        vbuf[vertexOffset + 1] = bl + db + ty;
        vbuf[vertexOffset + 5] = ar + cb + tx;
        vbuf[vertexOffset + 6] = br + db + ty;
        vbuf[vertexOffset + 10] = al + ct + tx;
        vbuf[vertexOffset + 11] = bl + dt + ty;
        vbuf[vertexOffset + 15] = ar + ct + tx;
        vbuf[vertexOffset + 16] = br + dt + ty;
        uintbuf[vertexOffset + 4] = color;
        uintbuf[vertexOffset + 9] = color;
        uintbuf[vertexOffset + 14] = color;
        uintbuf[vertexOffset + 19] = color;
        ibuf[indiceOffset++] = vertexId;
        ibuf[indiceOffset++] = vertexId + 1;
        ibuf[indiceOffset++] = vertexId + 2;
        ibuf[indiceOffset++] = vertexId + 1;
        ibuf[indiceOffset++] = vertexId + 3;
        ibuf[indiceOffset++] = vertexId + 2;
      },
      createData: function createData(sprite) {
        var renderData = sprite.requestRenderData();
        renderData.dataLength = 4;
        renderData.vertexCount = 4;
        renderData.indiceCount = 6;
        return renderData;
      },
      updateVerts: function updateVerts(sprite) {
        var renderData = sprite._renderData, node = sprite.node, data = renderData._data, cw = node.width, ch = node.height, appx = node.anchorX * cw, appy = node.anchorY * ch, l = void 0, b = void 0, r = void 0, t = void 0;
        if (sprite.trim) {
          l = -appx;
          b = -appy;
          r = cw - appx;
          t = ch - appy;
        } else {
          var frame = sprite.spriteFrame, ow = frame._originalSize.width, oh = frame._originalSize.height, rw = frame._rect.width, rh = frame._rect.height, offset = frame._offset, scaleX = cw / ow, scaleY = ch / oh;
          var trimLeft = offset.x + (ow - rw) / 2;
          var trimRight = offset.x - (ow - rw) / 2;
          var trimBottom = offset.y + (oh - rh) / 2;
          var trimTop = offset.y - (oh - rh) / 2;
          l = trimLeft * scaleX - appx;
          b = trimBottom * scaleY - appy;
          r = cw + trimRight * scaleX - appx;
          t = ch + trimTop * scaleY - appy;
        }
        data[0].x = l;
        data[0].y = b;
        data[3].x = r;
        data[3].y = t;
        renderData.vertDirty = false;
      }
    };
  }), {
    "../../../../utils/utils": 155
  } ],
  169: [ (function(require, module, exports) {
    "use strict";
    var packToDynamicAtlas = require("../../../../utils/utils").packToDynamicAtlas;
    module.exports = {
      createData: function createData(sprite) {
        var renderData = sprite.requestRenderData();
        renderData.dataLength = 20;
        renderData.vertexCount = 16;
        renderData.indiceCount = 54;
        return renderData;
      },
      updateRenderData: function updateRenderData(sprite) {
        packToDynamicAtlas(sprite, sprite._spriteFrame);
        var renderData = sprite._renderData;
        if (!renderData || !sprite.spriteFrame) return;
        var vertDirty = renderData.vertDirty;
        if (vertDirty) {
          this.updateVerts(sprite);
          this.updateWorldVerts(sprite);
        }
      },
      updateVerts: function updateVerts(sprite) {
        var renderData = sprite._renderData, data = renderData._data, node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height;
        var frame = sprite.spriteFrame;
        var leftWidth = frame.insetLeft;
        var rightWidth = frame.insetRight;
        var topHeight = frame.insetTop;
        var bottomHeight = frame.insetBottom;
        var sizableWidth = width - leftWidth - rightWidth;
        var sizableHeight = height - topHeight - bottomHeight;
        var xScale = width / (leftWidth + rightWidth);
        var yScale = height / (topHeight + bottomHeight);
        xScale = isNaN(xScale) || xScale > 1 ? 1 : xScale;
        yScale = isNaN(yScale) || yScale > 1 ? 1 : yScale;
        sizableWidth = sizableWidth < 0 ? 0 : sizableWidth;
        sizableHeight = sizableHeight < 0 ? 0 : sizableHeight;
        data[0].x = -appx;
        data[0].y = -appy;
        data[1].x = leftWidth * xScale - appx;
        data[1].y = bottomHeight * yScale - appy;
        data[2].x = data[1].x + sizableWidth;
        data[2].y = data[1].y + sizableHeight;
        data[3].x = width - appx;
        data[3].y = height - appy;
        renderData.vertDirty = false;
      },
      fillBuffers: function fillBuffers(sprite, renderer) {
        renderer.worldMatDirty && this.updateWorldVerts(sprite);
        var renderData = sprite._renderData, node = sprite.node, color = node._color._val, data = renderData._data;
        var buffer = renderer._meshBuffer, vertexCount = renderData.vertexCount;
        var uvSliced = sprite.spriteFrame.uvSliced;
        var offsetInfo = buffer.request(vertexCount, renderData.indiceCount);
        var indiceOffset = offsetInfo.indiceOffset, vertexOffset = offsetInfo.byteOffset >> 2, vertexId = offsetInfo.vertexOffset, vbuf = buffer._vData, uintbuf = buffer._uintVData, ibuf = buffer._iData;
        for (var i = 4; i < 20; ++i) {
          var vert = data[i];
          var uvs = uvSliced[i - 4];
          vbuf[vertexOffset++] = vert.x;
          vbuf[vertexOffset++] = vert.y;
          vbuf[vertexOffset++] = uvs.u;
          vbuf[vertexOffset++] = uvs.v;
          uintbuf[vertexOffset++] = color;
        }
        for (var r = 0; r < 3; ++r) for (var c = 0; c < 3; ++c) {
          var start = vertexId + 4 * r + c;
          ibuf[indiceOffset++] = start;
          ibuf[indiceOffset++] = start + 1;
          ibuf[indiceOffset++] = start + 4;
          ibuf[indiceOffset++] = start + 1;
          ibuf[indiceOffset++] = start + 5;
          ibuf[indiceOffset++] = start + 4;
        }
      },
      updateWorldVerts: function updateWorldVerts(sprite) {
        var node = sprite.node, data = sprite._renderData._data;
        var matrix = node._worldMatrix;
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        for (var row = 0; row < 4; ++row) {
          var rowD = data[row];
          for (var col = 0; col < 4; ++col) {
            var colD = data[col];
            var world = data[4 + 4 * row + col];
            world.x = colD.x * a + rowD.y * c + tx;
            world.y = colD.x * b + rowD.y * d + ty;
          }
        }
      }
    };
  }), {
    "../../../../utils/utils": 155
  } ],
  170: [ (function(require, module, exports) {
    "use strict";
    var packToDynamicAtlas = require("../../../../utils/utils").packToDynamicAtlas;
    module.exports = {
      vertexOffset: 5,
      uvOffset: 2,
      colorOffset: 4,
      createData: function createData(sprite) {
        return sprite.requestRenderData();
      },
      updateRenderData: function updateRenderData(sprite) {
        packToDynamicAtlas(sprite, sprite._spriteFrame);
        var renderData = sprite._renderData;
        var frame = sprite.spriteFrame;
        if (!frame || !renderData || !(renderData.uvDirty || renderData.vertDirty)) return;
        var node = sprite.node, contentWidth = Math.abs(node.width), contentHeight = Math.abs(node.height), appx = node.anchorX * contentWidth, appy = node.anchorY * contentHeight;
        var rect = frame._rect, rectWidth = rect.width, rectHeight = rect.height, hRepeat = contentWidth / rectWidth, vRepeat = contentHeight / rectHeight, row = Math.ceil(vRepeat), col = Math.ceil(hRepeat);
        var data = renderData._data;
        renderData.dataLength = Math.max(8, row + 1, col + 1);
        for (var i = 0; i <= col; ++i) data[i].x = Math.min(rectWidth * i, contentWidth) - appx;
        for (var _i = 0; _i <= row; ++_i) data[_i].y = Math.min(rectHeight * _i, contentHeight) - appy;
        renderData.vertexCount = row * col * 4;
        renderData.indiceCount = row * col * 6;
        renderData.uvDirty = false;
        renderData.vertDirty = false;
      },
      fillVertices: function fillVertices(vbuf, vertexOffset, matrix, row, col, data) {
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        var x = void 0, x1 = void 0, y = void 0, y1 = void 0;
        for (var yindex = 0, ylength = row; yindex < ylength; ++yindex) {
          y = data[yindex].y;
          y1 = data[yindex + 1].y;
          for (var xindex = 0, xlength = col; xindex < xlength; ++xindex) {
            x = data[xindex].x;
            x1 = data[xindex + 1].x;
            vbuf[vertexOffset] = x * a + y * c + tx;
            vbuf[vertexOffset + 1] = x * b + y * d + ty;
            vbuf[vertexOffset + 5] = x1 * a + y * c + tx;
            vbuf[vertexOffset + 6] = x1 * b + y * d + ty;
            vbuf[vertexOffset + 10] = x * a + y1 * c + tx;
            vbuf[vertexOffset + 11] = x * b + y1 * d + ty;
            vbuf[vertexOffset + 15] = x1 * a + y1 * c + tx;
            vbuf[vertexOffset + 16] = x1 * b + y1 * d + ty;
            vertexOffset += 20;
          }
        }
      },
      fillBuffers: function fillBuffers(sprite, renderer) {
        var node = sprite.node, is3DNode = node.is3DNode, color = node._color._val, renderData = sprite._renderData, data = renderData._data;
        var buffer = is3DNode ? renderer._meshBuffer3D : renderer._meshBuffer;
        var offsetInfo = buffer.request(renderData.vertexCount, renderData.indiceCount);
        var indiceOffset = offsetInfo.indiceOffset, vertexOffset = offsetInfo.byteOffset >> 2, vertexId = offsetInfo.vertexOffset, vbuf = buffer._vData, uintbuf = buffer._uintVData, ibuf = buffer._iData;
        var rotated = sprite.spriteFrame._rotated;
        var uv = sprite.spriteFrame.uv;
        var rect = sprite.spriteFrame._rect;
        var contentWidth = Math.abs(node.width);
        var contentHeight = Math.abs(node.height);
        var hRepeat = contentWidth / rect.width;
        var vRepeat = contentHeight / rect.height;
        var row = Math.ceil(vRepeat), col = Math.ceil(hRepeat);
        var matrix = node._worldMatrix;
        this.fillVertices(vbuf, vertexOffset, matrix, row, col, data);
        var offset = this.vertexOffset, uvOffset = this.uvOffset, colorOffset = this.colorOffset;
        var offset1 = offset, offset2 = 2 * offset, offset3 = 3 * offset, offset4 = 4 * offset;
        var coefu = void 0, coefv = void 0;
        for (var yindex = 0, ylength = row; yindex < ylength; ++yindex) {
          coefv = Math.min(1, vRepeat - yindex);
          for (var xindex = 0, xlength = col; xindex < xlength; ++xindex) {
            coefu = Math.min(1, hRepeat - xindex);
            var vertexOffsetU = vertexOffset + uvOffset;
            var vertexOffsetV = vertexOffsetU + 1;
            if (rotated) {
              vbuf[vertexOffsetU] = uv[0];
              vbuf[vertexOffsetV] = uv[1];
              vbuf[vertexOffsetU + offset1] = uv[0];
              vbuf[vertexOffsetV + offset1] = uv[1] + (uv[7] - uv[1]) * coefu;
              vbuf[vertexOffsetU + offset2] = uv[0] + (uv[6] - uv[0]) * coefv;
              vbuf[vertexOffsetV + offset2] = uv[1];
              vbuf[vertexOffsetU + offset3] = vbuf[vertexOffsetU + offset2];
              vbuf[vertexOffsetV + offset3] = vbuf[vertexOffsetV + offset1];
            } else {
              vbuf[vertexOffsetU] = uv[0];
              vbuf[vertexOffsetV] = uv[1];
              vbuf[vertexOffsetU + offset1] = uv[0] + (uv[6] - uv[0]) * coefu;
              vbuf[vertexOffsetV + offset1] = uv[1];
              vbuf[vertexOffsetU + offset2] = uv[0];
              vbuf[vertexOffsetV + offset2] = uv[1] + (uv[7] - uv[1]) * coefv;
              vbuf[vertexOffsetU + offset3] = vbuf[vertexOffsetU + offset1];
              vbuf[vertexOffsetV + offset3] = vbuf[vertexOffsetV + offset2];
            }
            uintbuf[vertexOffset + colorOffset] = color;
            uintbuf[vertexOffset + colorOffset + offset1] = color;
            uintbuf[vertexOffset + colorOffset + offset2] = color;
            uintbuf[vertexOffset + colorOffset + offset3] = color;
            vertexOffset += offset4;
          }
        }
        var length = renderData.indiceCount;
        for (var i = 0; i < length; i += 6) {
          ibuf[indiceOffset++] = vertexId;
          ibuf[indiceOffset++] = vertexId + 1;
          ibuf[indiceOffset++] = vertexId + 2;
          ibuf[indiceOffset++] = vertexId + 1;
          ibuf[indiceOffset++] = vertexId + 3;
          ibuf[indiceOffset++] = vertexId + 2;
          vertexId += 4;
        }
      }
    };
  }), {
    "../../../../utils/utils": 155
  } ],
  171: [ (function(require, module, exports) {
    "use strict";
    var Sprite = require("../../../../components/CCSprite");
    var SpriteType = Sprite.Type;
    var FillType = Sprite.FillType;
    var simpleRenderUtil = require("./2d/simple");
    var slicedRenderUtil = require("./2d/sliced");
    var tiledRenderUtil = require("./2d/tiled");
    var radialFilledRenderUtil = require("./2d/radial-filled");
    var barFilledRenderUtil = require("./2d/bar-filled");
    var meshRenderUtil = require("./2d/mesh");
    var simpleRenderUtil3D = require("./3d/simple");
    var slicedRenderUtil3D = require("./3d/sliced");
    var tiledRenderUtil3D = require("./3d/tiled");
    var radialFilledRenderUtil3D = require("./3d/radial-filled");
    var barFilledRenderUtil3D = require("./3d/bar-filled");
    var meshRenderUtil3D = require("./3d/mesh");
    var spriteAssembler = {
      getAssembler: function getAssembler(sprite) {
        var is3DNode = sprite.node.is3DNode;
        var util = is3DNode ? simpleRenderUtil3D : simpleRenderUtil;
        switch (sprite.type) {
         case SpriteType.SLICED:
          util = is3DNode ? slicedRenderUtil3D : slicedRenderUtil;
          break;

         case SpriteType.TILED:
          util = is3DNode ? tiledRenderUtil3D : tiledRenderUtil;
          break;

         case SpriteType.FILLED:
          util = sprite._fillType === FillType.RADIAL ? is3DNode ? radialFilledRenderUtil3D : radialFilledRenderUtil : is3DNode ? barFilledRenderUtil3D : barFilledRenderUtil;
          break;

         case SpriteType.MESH:
          util = is3DNode ? meshRenderUtil3D : meshRenderUtil;
        }
        return util;
      },
      updateRenderData: function updateRenderData(sprite) {
        return sprite.__allocedDatas;
      }
    };
    Sprite._assembler = spriteAssembler;
    module.exports = spriteAssembler;
  }), {
    "../../../../components/CCSprite": 51,
    "./2d/bar-filled": 165,
    "./2d/mesh": 166,
    "./2d/radial-filled": 167,
    "./2d/simple": 168,
    "./2d/sliced": 169,
    "./2d/tiled": 170,
    "./3d/bar-filled": void 0,
    "./3d/mesh": void 0,
    "./3d/radial-filled": void 0,
    "./3d/simple": void 0,
    "./3d/sliced": void 0,
    "./3d/tiled": void 0
  } ],
  172: [ (function(require, module, exports) {
    "use strict";
    var vec3 = cc.vmath.vec3;
    var vec3_temp = vec3.create();
    function fillVertices(node, buffer, renderData, color) {
      var vertexCount = renderData.vertexCount;
      var offsetInfo = buffer.request(vertexCount, renderData.indiceCount);
      var vertexOffset = offsetInfo.byteOffset >> 2, vbuf = buffer._vData, uintbuf = buffer._uintVData;
      var matrix = node._worldMatrix;
      var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
      var data = renderData._data;
      for (var i = 0; i < vertexCount; i++) {
        var vert = data[i];
        vbuf[vertexOffset++] = vert.x * a + vert.y * c + tx;
        vbuf[vertexOffset++] = vert.x * b + vert.y * d + ty;
        vbuf[vertexOffset++] = vert.u;
        vbuf[vertexOffset++] = vert.v;
        uintbuf[vertexOffset++] = color;
      }
      return offsetInfo;
    }
    function fillMeshVertices(node, buffer, renderData, color) {
      var vertexCount = renderData.vertexCount;
      var offsetInfo = buffer.request(vertexCount, renderData.indiceCount);
      var indiceOffset = offsetInfo.indiceOffset, vertexOffset = offsetInfo.byteOffset >> 2, vertexId = offsetInfo.vertexOffset, vbuf = buffer._vData, uintbuf = buffer._uintVData, ibuf = buffer._iData;
      var matrix = node._worldMatrix;
      var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
      var data = renderData._data;
      for (var i = 0; i < vertexCount; i++) {
        var vert = data[i];
        vbuf[vertexOffset++] = vert.x * a + vert.y * c + tx;
        vbuf[vertexOffset++] = vert.x * b + vert.y * d + ty;
        vbuf[vertexOffset++] = vert.u;
        vbuf[vertexOffset++] = vert.v;
        uintbuf[vertexOffset++] = color;
      }
      for (var _i = 0, count = vertexCount / 4; _i < count; _i++) {
        var start = vertexId + 4 * _i;
        ibuf[indiceOffset++] = start;
        ibuf[indiceOffset++] = start + 1;
        ibuf[indiceOffset++] = start + 2;
        ibuf[indiceOffset++] = start + 1;
        ibuf[indiceOffset++] = start + 3;
        ibuf[indiceOffset++] = start + 2;
      }
      return offsetInfo;
    }
    function fillVertices3D(node, buffer, renderData, color) {
      var vertexCount = renderData.vertexCount;
      var offsetInfo = buffer.request(vertexCount, renderData.indiceCount);
      var vertexOffset = offsetInfo.byteOffset >> 2, vbuf = buffer._vData, uintbuf = buffer._uintVData;
      var matrix = node._worldMatrix;
      var data = renderData._data;
      for (var i = 0; i < vertexCount; i++) {
        var vert = data[i];
        vec3.set(vec3_temp, vert.x, vert.y, 0);
        vec3.transformMat4(vec3_temp, vec3_temp, matrix);
        vbuf[vertexOffset++] = vec3_temp.x;
        vbuf[vertexOffset++] = vec3_temp.y;
        vbuf[vertexOffset++] = vec3_temp.z;
        vbuf[vertexOffset++] = vert.u;
        vbuf[vertexOffset++] = vert.v;
        uintbuf[vertexOffset++] = color;
      }
      return offsetInfo;
    }
    function fillMeshVertices3D(node, buffer, renderData, color) {
      var vertexCount = renderData.vertexCount;
      var offsetInfo = buffer.request(vertexCount, renderData.indiceCount);
      var indiceOffset = offsetInfo.indiceOffset, vertexId = offsetInfo.vertexOffset, vertexOffset = offsetInfo.byteOffset >> 2, vbuf = buffer._vData, uintbuf = buffer._uintVData, ibuf = buffer._iData;
      var matrix = node._worldMatrix;
      var data = renderData._data;
      for (var i = 0; i < vertexCount; i++) {
        var vert = data[i];
        vec3.set(vec3_temp, vert.x, vert.y, 0);
        vec3.transformMat4(vec3_temp, vec3_temp, matrix);
        vbuf[vertexOffset++] = vec3_temp.x;
        vbuf[vertexOffset++] = vec3_temp.y;
        vbuf[vertexOffset++] = vec3_temp.z;
        vbuf[vertexOffset++] = vert.u;
        vbuf[vertexOffset++] = vert.v;
        uintbuf[vertexOffset++] = color;
      }
      for (var _i2 = 0, count = vertexCount / 4; _i2 < count; _i2++) {
        var start = vertexId + 4 * _i2;
        ibuf[indiceOffset++] = start;
        ibuf[indiceOffset++] = start + 1;
        ibuf[indiceOffset++] = start + 2;
        ibuf[indiceOffset++] = start + 1;
        ibuf[indiceOffset++] = start + 3;
        ibuf[indiceOffset++] = start + 2;
      }
      return offsetInfo;
    }
    function fillVerticesWithoutCalc(node, buffer, renderData, color) {
      var vertexCount = renderData.vertexCount;
      var offsetInfo = buffer.request(vertexCount, renderData.indiceCount);
      var vertexOffset = offsetInfo.byteOffset >> 2, vbuf = buffer._vData, uintbuf = buffer._uintVData;
      var data = renderData._data;
      for (var i = 0; i < vertexCount; i++) {
        var vert = data[i];
        vbuf[vertexOffset++] = vert.x;
        vbuf[vertexOffset++] = vert.y;
        vbuf[vertexOffset++] = vert.u;
        vbuf[vertexOffset++] = vert.v;
        uintbuf[vertexOffset++] = color;
      }
      return offsetInfo;
    }
    function fillVerticesWithoutCalc3D(node, buffer, renderData, color) {
      var vertexCount = renderData.vertexCount;
      var offsetInfo = buffer.request(vertexCount, renderData.indiceCount);
      var vertexOffset = offsetInfo.byteOffset >> 2, vbuf = buffer._vData, uintbuf = buffer._uintVData;
      var data = renderData._data;
      for (var i = 0; i < vertexCount; i++) {
        var vert = data[i];
        vbuf[vertexOffset++] = vert.x;
        vbuf[vertexOffset++] = vert.y;
        vbuf[vertexOffset++] = vert.z;
        vbuf[vertexOffset++] = vert.u;
        vbuf[vertexOffset++] = vert.v;
        uintbuf[vertexOffset++] = color;
      }
    }
    module.exports = {
      fillVertices: fillVertices,
      fillMeshVertices: fillMeshVertices,
      fillVertices3D: fillVertices3D,
      fillMeshVertices3D: fillMeshVertices3D,
      fillVerticesWithoutCalc: fillVerticesWithoutCalc,
      fillVerticesWithoutCalc3D: fillVerticesWithoutCalc3D
    };
  }), {} ],
  173: [ (function(require, module, exports) {
    "use strict";
    var _gfx = require("../../../renderer/gfx");
    var _gfx2 = _interopRequireDefault(_gfx);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var MeshBuffer = cc.Class({
      name: "cc.MeshBuffer",
      ctor: function ctor(batcher, vertexFormat) {
        this.byteStart = 0;
        this.byteOffset = 0;
        this.indiceStart = 0;
        this.indiceOffset = 0;
        this.vertexStart = 0;
        this.vertexOffset = 0;
        this._vertexFormat = vertexFormat;
        this._vertexBytes = this._vertexFormat._bytes;
        this._arrOffset = 0;
        this._vbArr = [];
        this._vb = new _gfx2.default.VertexBuffer(batcher._device, vertexFormat, _gfx2.default.USAGE_DYNAMIC, new ArrayBuffer(), 0);
        this._vbArr[0] = this._vb;
        this._ibArr = [];
        this._ib = new _gfx2.default.IndexBuffer(batcher._device, _gfx2.default.INDEX_FMT_UINT16, _gfx2.default.USAGE_STATIC, new ArrayBuffer(), 0);
        this._ibArr[0] = this._ib;
        this._vData = null;
        this._uintVData = null;
        this._iData = null;
        this._batcher = batcher;
        this._initVDataCount = 256 * vertexFormat._bytes;
        this._initIDataCount = 1536;
        this._offsetInfo = {
          byteOffset: 0,
          vertexOffset: 0,
          indiceOffset: 0
        };
        this._reallocBuffer();
      },
      uploadData: function uploadData() {
        if (0 === this.byteOffset || !this._dirty) return;
        var vertexsData = new Float32Array(this._vData.buffer, 0, this.byteOffset >> 2);
        var indicesData = new Uint16Array(this._iData.buffer, 0, this.indiceOffset);
        var vb = this._vb;
        vb.update(0, vertexsData);
        var ib = this._ib;
        ib.update(0, indicesData);
        this._dirty = false;
      },
      switchBuffer: function switchBuffer() {
        var offset = ++this._arrOffset;
        this.byteStart = 0;
        this.byteOffset = 0;
        this.vertexStart = 0;
        this.vertexOffset = 0;
        this.indiceStart = 0;
        this.indiceOffset = 0;
        if (offset < this._vbArr.length) {
          this._vb = this._vbArr[offset];
          this._ib = this._ibArr[offset];
        } else {
          this._vb = new _gfx2.default.VertexBuffer(this._batcher._device, this._vertexFormat, _gfx2.default.USAGE_DYNAMIC, new ArrayBuffer(), 0);
          this._vbArr[offset] = this._vb;
          this._vb._bytes = this._vData.byteLength;
          this._ib = new _gfx2.default.IndexBuffer(this._batcher._device, _gfx2.default.INDEX_FMT_UINT16, _gfx2.default.USAGE_STATIC, new ArrayBuffer(), 0);
          this._ibArr[offset] = this._ib;
          this._ib._bytes = this._iData.byteLength;
        }
      },
      checkAndSwitchBuffer: function checkAndSwitchBuffer(vertexCount) {
        if (this.vertexOffset + vertexCount > 65535) {
          this.uploadData();
          this._batcher._flush();
          this.switchBuffer();
        }
      },
      requestStatic: function requestStatic(vertexCount, indiceCount) {
        this.checkAndSwitchBuffer(vertexCount);
        var byteOffset = this.byteOffset + vertexCount * this._vertexBytes;
        var indiceOffset = this.indiceOffset + indiceCount;
        var byteLength = this._vData.byteLength;
        var indiceLength = this._iData.length;
        if (byteOffset > byteLength || indiceOffset > indiceLength) {
          while (byteLength < byteOffset || indiceLength < indiceOffset) {
            this._initVDataCount *= 2;
            this._initIDataCount *= 2;
            byteLength = 4 * this._initVDataCount;
            indiceLength = this._initIDataCount;
          }
          this._reallocBuffer();
        }
        var offsetInfo = this._offsetInfo;
        offsetInfo.vertexOffset = this.vertexOffset;
        this.vertexOffset += vertexCount;
        offsetInfo.indiceOffset = this.indiceOffset;
        this.indiceOffset += indiceCount;
        offsetInfo.byteOffset = this.byteOffset;
        this.byteOffset = byteOffset;
        this._dirty = true;
      },
      request: function request(vertexCount, indiceCount) {
        if (this._batcher._buffer !== this) {
          this._batcher._flush();
          this._batcher._buffer = this;
        }
        this.requestStatic(vertexCount, indiceCount);
        return this._offsetInfo;
      },
      _reallocBuffer: function _reallocBuffer() {
        this._reallocVData(true);
        this._reallocIData(true);
      },
      _reallocVData: function _reallocVData(copyOldData) {
        var oldVData = void 0;
        this._vData && (oldVData = new Uint8Array(this._vData.buffer));
        this._vData = new Float32Array(this._initVDataCount);
        this._uintVData = new Uint32Array(this._vData.buffer);
        var newData = new Uint8Array(this._uintVData.buffer);
        if (oldVData && copyOldData) for (var i = 0, l = oldVData.length; i < l; i++) newData[i] = oldVData[i];
        this._vb._bytes = this._vData.byteLength;
      },
      _reallocIData: function _reallocIData(copyOldData) {
        var oldIData = this._iData;
        this._iData = new Uint16Array(this._initIDataCount);
        if (oldIData && copyOldData) {
          var iData = this._iData;
          for (var i = 0, l = oldIData.length; i < l; i++) iData[i] = oldIData[i];
        }
        this._ib._bytes = this._iData.byteLength;
      },
      reset: function reset() {
        this._arrOffset = 0;
        this._vb = this._vbArr[0];
        this._ib = this._ibArr[0];
        this.byteStart = 0;
        this.byteOffset = 0;
        this.indiceStart = 0;
        this.indiceOffset = 0;
        this.vertexStart = 0;
        this.vertexOffset = 0;
        this._dirty = false;
      },
      destroy: function destroy() {
        for (var i = 0; i < this._vbArr.length; i++) {
          var vb = this._vbArr[i];
          vb.destroy();
        }
        this._vbArr = null;
        for (var _i = 0; _i < this._ibArr.length; _i++) {
          var ib = this._ibArr[_i];
          ib.destroy();
        }
        this._ibArr = null;
        this._ib = null;
        this._vb = null;
      }
    });
    cc.MeshBuffer = module.exports = MeshBuffer;
  }), {
    "../../../renderer/gfx": 233
  } ],
  174: [ (function(require, module, exports) {
    "use strict";
    var _inputAssembler = require("../../../renderer/core/input-assembler");
    var _inputAssembler2 = _interopRequireDefault(_inputAssembler);
    var _recyclePool = require("../../../renderer/memop/recycle-pool");
    var _recyclePool2 = _interopRequireDefault(_recyclePool);
    var _model = require("../../../renderer/scene/model");
    var _model2 = _interopRequireDefault(_model);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var vertexFormat = require("./vertex-format");
    var defaultVertexFormat = vertexFormat.vfmtPosUvColor;
    var vfmt3D = vertexFormat.vfmt3D;
    var QuadBuffer = require("./quad-buffer");
    var MeshBuffer = require("./mesh-buffer");
    var SpineBuffer = require("./spine-buffer");
    var Material = require("../../assets/material/CCMaterial");
    var idGenerater = new (require("../../platform/id-generater"))("VertextFormat");
    var _buffers = {};
    var empty_material = new Material();
    var empty_ia = new _inputAssembler2.default();
    empty_ia._count = 0;
    var ModelBatcher = function ModelBatcher(device, renderScene) {
      this._renderScene = renderScene;
      this._device = device;
      this.walking = false;
      this.material = empty_material;
      this.cullingMask = 1;
      this._iaPool = new _recyclePool2.default(function() {
        return new _inputAssembler2.default();
      }, 16);
      this._modelPool = new _recyclePool2.default(function() {
        return new _model2.default();
      }, 16);
      this._quadBuffer = this.getBuffer("quad", defaultVertexFormat);
      this._meshBuffer = this.getBuffer("mesh", defaultVertexFormat);
      this._quadBuffer3D = this.getBuffer("quad", vfmt3D);
      this._meshBuffer3D = this.getBuffer("mesh", vfmt3D);
      this._buffer = this._quadBuffer;
      this._batchedModels = [];
      this._dummyNode = new cc.Node();
      this._sortKey = 0;
      this.node = this._dummyNode;
      this.parentOpacity = 1;
      this.parentOpacityDirty = 0;
      this.worldMatDirty = 0;
      this.customProperties = null;
    };
    ModelBatcher.prototype = {
      constructor: ModelBatcher,
      reset: function reset() {
        this._iaPool.reset();
        var scene = this._renderScene;
        var models = this._batchedModels;
        for (var i = 0; i < models.length; ++i) {
          models[i].setInputAssembler(null);
          models[i].setEffect(null);
          scene.removeModel(models[i]);
        }
        this._modelPool.reset();
        models.length = 0;
        this._sortKey = 0;
        for (var key in _buffers) _buffers[key].reset();
        this._buffer = this._quadBuffer;
        this.node = this._dummyNode;
        this.material = empty_material;
        this.cullingMask = 1;
        this.parentOpacity = 1;
        this.parentOpacityDirty = 0;
        this.worldMatDirty = 0;
        this.customProperties = null;
      },
      _flushMaterial: function _flushMaterial(material) {
        this.material = material;
        var effect = material.effect;
        if (!effect) return;
        var model = this._modelPool.add();
        this._batchedModels.push(model);
        model.sortKey = this._sortKey++;
        model._cullingMask = this.cullingMask;
        model.setNode(this.node);
        model.setEffect(effect, null);
        model.setInputAssembler(empty_ia);
        this._renderScene.addModel(model);
      },
      _flush: function _flush() {
        var material = this.material, buffer = this._buffer, indiceStart = buffer.indiceStart, indiceOffset = buffer.indiceOffset, indiceCount = indiceOffset - indiceStart;
        if (!this.walking || !material || indiceCount <= 0) return;
        var effect = material.effect;
        if (!effect) return;
        var ia = this._iaPool.add();
        ia._vertexBuffer = buffer._vb;
        ia._indexBuffer = buffer._ib;
        ia._start = indiceStart;
        ia._count = indiceCount;
        var model = this._modelPool.add();
        this._batchedModels.push(model);
        model.sortKey = this._sortKey++;
        model._cullingMask = this.cullingMask;
        model.setNode(this.node);
        model.setEffect(effect, this.customProperties);
        model.setInputAssembler(ia);
        this._renderScene.addModel(model);
        buffer.byteStart = buffer.byteOffset;
        buffer.indiceStart = buffer.indiceOffset;
        buffer.vertexStart = buffer.vertexOffset;
      },
      _flushIA: function _flushIA(iaRenderData) {
        var material = iaRenderData.material;
        if (!iaRenderData.ia || !material) return;
        this.material = material;
        var effect = material.effect;
        if (!effect) return;
        var model = this._modelPool.add();
        this._batchedModels.push(model);
        model.sortKey = this._sortKey++;
        model._cullingMask = this.cullingMask;
        model.setNode(this.node);
        model.setEffect(effect, this.customProperties);
        model.setInputAssembler(iaRenderData.ia);
        this._renderScene.addModel(model);
      },
      _commitComp: function _commitComp(comp, assembler, cullingMask) {
        var material = comp.sharedMaterials[0];
        if (material && material.getHash() !== this.material.getHash() || this.cullingMask !== cullingMask) {
          this._flush();
          this.node = material.getDefine("_USE_MODEL") ? comp.node : this._dummyNode;
          this.material = material;
          this.cullingMask = cullingMask;
        }
        assembler.fillBuffers(comp, this);
      },
      _commitIA: function _commitIA(comp, assembler, cullingMask) {
        this._flush();
        this.cullingMask = cullingMask;
        this.material = comp.sharedMaterials[0] || empty_material;
        this.node = this.material.getDefine("_USE_MODEL") ? comp.node : this._dummyNode;
        assembler.renderIA(comp, this);
      },
      terminate: function terminate() {
        cc.dynamicAtlasManager && cc.dynamicAtlasManager.enabled && cc.dynamicAtlasManager.update();
        this._flush();
        for (var key in _buffers) _buffers[key].uploadData();
      },
      getBuffer: function getBuffer(type, vertextFormat) {
        vertextFormat.name || (vertextFormat.name = idGenerater.getNewId());
        var key = type + vertextFormat.name;
        var buffer = _buffers[key];
        if (!buffer) {
          if ("mesh" === type) buffer = new MeshBuffer(this, vertextFormat); else if ("quad" === type) buffer = new QuadBuffer(this, vertextFormat); else {
            if ("spine" !== type) {
              cc.error("Not support buffer type [" + type + "]");
              return null;
            }
            buffer = new SpineBuffer(this, vertextFormat);
          }
          _buffers[key] = buffer;
        }
        return buffer;
      }
    };
    module.exports = ModelBatcher;
  }), {
    "../../../renderer/core/input-assembler": 223,
    "../../../renderer/memop/recycle-pool": 248,
    "../../../renderer/scene/model": 256,
    "../../assets/material/CCMaterial": 29,
    "../../platform/id-generater": 120,
    "./mesh-buffer": 173,
    "./quad-buffer": 175,
    "./spine-buffer": 176,
    "./vertex-format": 177
  } ],
  175: [ (function(require, module, exports) {
    "use strict";
    var MeshBuffer = require("./mesh-buffer");
    var QuadBuffer = cc.Class({
      name: "cc.QuadBuffer",
      extends: MeshBuffer,
      _fillQuadBuffer: function _fillQuadBuffer() {
        var count = this._initIDataCount / 6;
        var buffer = this._iData;
        for (var i = 0, idx = 0; i < count; i++) {
          var vertextID = 4 * i;
          buffer[idx++] = vertextID;
          buffer[idx++] = vertextID + 1;
          buffer[idx++] = vertextID + 2;
          buffer[idx++] = vertextID + 1;
          buffer[idx++] = vertextID + 3;
          buffer[idx++] = vertextID + 2;
        }
        var indicesData = new Uint16Array(this._iData.buffer, 0, 6 * count);
        this._ib.update(0, indicesData);
      },
      uploadData: function uploadData() {
        if (0 === this.byteOffset || !this._dirty) return;
        var vertexsData = new Float32Array(this._vData.buffer, 0, this.byteOffset >> 2);
        this._vb.update(0, vertexsData);
        this._dirty = false;
      },
      switchBuffer: function switchBuffer() {
        this._super();
        if (this.indiceOffset > 0) {
          var indicesData = new Uint16Array(this._iData.buffer, 0, this.indiceOffset);
          this._ib.update(0, indicesData);
        }
      },
      _reallocBuffer: function _reallocBuffer() {
        this._reallocVData(true);
        this._reallocIData();
        this._fillQuadBuffer();
      }
    });
    cc.QuadBuffer = module.exports = QuadBuffer;
  }), {
    "./mesh-buffer": 173
  } ],
  176: [ (function(require, module, exports) {
    "use strict";
    var SpineBuffer = cc.Class({
      name: "cc.SpineBuffer",
      extends: require("./mesh-buffer"),
      requestStatic: function requestStatic(vertexCount, indiceCount) {
        this.checkAndSwitchBuffer(vertexCount);
        var byteOffset = this.byteOffset + vertexCount * this._vertexBytes;
        var indiceOffset = this.indiceOffset + indiceCount;
        var byteLength = this._vData.byteLength;
        var indiceLength = this._iData.length;
        if (byteOffset > byteLength || indiceOffset > indiceLength) {
          while (byteLength < byteOffset || indiceLength < indiceOffset) {
            this._initVDataCount *= 2;
            this._initIDataCount *= 2;
            byteLength = 4 * this._initVDataCount;
            indiceLength = this._initIDataCount;
          }
          this._reallocBuffer();
        }
        var offsetInfo = this._offsetInfo;
        offsetInfo.vertexOffset = this.vertexOffset;
        offsetInfo.indiceOffset = this.indiceOffset;
        offsetInfo.byteOffset = this.byteOffset;
      },
      adjust: function adjust(vertexCount, indiceCount) {
        this.vertexOffset += vertexCount;
        this.indiceOffset += indiceCount;
        this.byteOffset = this.byteOffset + vertexCount * this._vertexBytes;
        this._dirty = true;
      }
    });
    cc.SpineBuffer = module.exports = SpineBuffer;
  }), {
    "./mesh-buffer": 173
  } ],
  177: [ (function(require, module, exports) {
    "use strict";
    var _gfx = require("../../../renderer/gfx");
    var _gfx2 = _interopRequireDefault(_gfx);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var vfmt3D = new _gfx2.default.VertexFormat([ {
      name: _gfx2.default.ATTR_POSITION,
      type: _gfx2.default.ATTR_TYPE_FLOAT32,
      num: 3
    }, {
      name: _gfx2.default.ATTR_UV0,
      type: _gfx2.default.ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: _gfx2.default.ATTR_COLOR,
      type: _gfx2.default.ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    } ]);
    vfmt3D.name = "vfmt3D";
    _gfx2.default.VertexFormat.XYZ_UV_Color = vfmt3D;
    var vfmtPosUvColor = new _gfx2.default.VertexFormat([ {
      name: _gfx2.default.ATTR_POSITION,
      type: _gfx2.default.ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: _gfx2.default.ATTR_UV0,
      type: _gfx2.default.ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: _gfx2.default.ATTR_COLOR,
      type: _gfx2.default.ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    } ]);
    vfmtPosUvColor.name = "vfmtPosUvColor";
    _gfx2.default.VertexFormat.XY_UV_Color = vfmtPosUvColor;
    var vfmtPosUvTwoColor = new _gfx2.default.VertexFormat([ {
      name: _gfx2.default.ATTR_POSITION,
      type: _gfx2.default.ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: _gfx2.default.ATTR_UV0,
      type: _gfx2.default.ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: _gfx2.default.ATTR_COLOR,
      type: _gfx2.default.ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    }, {
      name: _gfx2.default.ATTR_COLOR0,
      type: _gfx2.default.ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    } ]);
    vfmtPosUvTwoColor.name = "vfmtPosUvTwoColor";
    _gfx2.default.VertexFormat.XY_UV_Two_Color = vfmtPosUvTwoColor;
    var vfmtPosUv = new _gfx2.default.VertexFormat([ {
      name: _gfx2.default.ATTR_POSITION,
      type: _gfx2.default.ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: _gfx2.default.ATTR_UV0,
      type: _gfx2.default.ATTR_TYPE_FLOAT32,
      num: 2
    } ]);
    vfmtPosUv.name = "vfmtPosUv";
    _gfx2.default.VertexFormat.XY_UV = vfmtPosUv;
    var vfmtPosColor = new _gfx2.default.VertexFormat([ {
      name: _gfx2.default.ATTR_POSITION,
      type: _gfx2.default.ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: _gfx2.default.ATTR_COLOR,
      type: _gfx2.default.ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    } ]);
    vfmtPosColor.name = "vfmtPosColor";
    _gfx2.default.VertexFormat.XY_Color = vfmtPosColor;
    var vfmtPos = new _gfx2.default.VertexFormat([ {
      name: _gfx2.default.ATTR_POSITION,
      type: _gfx2.default.ATTR_TYPE_FLOAT32,
      num: 2
    } ]);
    vfmtPos.name = "vfmtPos";
    _gfx2.default.VertexFormat.XY = vfmtPos;
    module.exports = {
      vfmt3D: vfmt3D,
      vfmtPosUvColor: vfmtPosUvColor,
      vfmtPosUvTwoColor: vfmtPosUvTwoColor,
      vfmtPosUv: vfmtPosUv,
      vfmtPosColor: vfmtPosColor,
      vfmtPos: vfmtPos
    };
  }), {
    "../../../renderer/gfx": 233
  } ],
  178: [ (function(require, module, exports) {
    "use strict";
    require("../platform/CCSys");
    var EXTNAME_RE = /(\.[^\.\/\?\\]*)(\?.*)?$/;
    var DIRNAME_RE = /((.*)(\/|\\|\\\\))?(.*?\..*$)?/;
    var NORMALIZE_RE = /[^\.\/]+\/\.\.\//;
    cc.path = {
      join: function join() {
        var l = arguments.length;
        var result = "";
        for (var i = 0; i < l; i++) result = (result + ("" === result ? "" : "/") + arguments[i]).replace(/(\/|\\\\)$/, "");
        return result;
      },
      extname: function extname(pathStr) {
        var temp = EXTNAME_RE.exec(pathStr);
        return temp ? temp[1] : "";
      },
      mainFileName: function mainFileName(fileName) {
        if (fileName) {
          var idx = fileName.lastIndexOf(".");
          if (-1 !== idx) return fileName.substring(0, idx);
        }
        return fileName;
      },
      basename: function basename(pathStr, extname) {
        var index = pathStr.indexOf("?");
        index > 0 && (pathStr = pathStr.substring(0, index));
        var reg = /(\/|\\)([^\/\\]+)$/g;
        var result = reg.exec(pathStr.replace(/(\/|\\)$/, ""));
        if (!result) return null;
        var baseName = result[2];
        if (extname && pathStr.substring(pathStr.length - extname.length).toLowerCase() === extname.toLowerCase()) return baseName.substring(0, baseName.length - extname.length);
        return baseName;
      },
      dirname: function dirname(pathStr) {
        var temp = DIRNAME_RE.exec(pathStr);
        return temp ? temp[2] : "";
      },
      changeExtname: function changeExtname(pathStr, extname) {
        extname = extname || "";
        var index = pathStr.indexOf("?");
        var tempStr = "";
        if (index > 0) {
          tempStr = pathStr.substring(index);
          pathStr = pathStr.substring(0, index);
        }
        index = pathStr.lastIndexOf(".");
        if (index < 0) return pathStr + extname + tempStr;
        return pathStr.substring(0, index) + extname + tempStr;
      },
      changeBasename: function changeBasename(pathStr, basename, isSameExt) {
        if (0 === basename.indexOf(".")) return this.changeExtname(pathStr, basename);
        var index = pathStr.indexOf("?");
        var tempStr = "";
        var ext = isSameExt ? this.extname(pathStr) : "";
        if (index > 0) {
          tempStr = pathStr.substring(index);
          pathStr = pathStr.substring(0, index);
        }
        index = pathStr.lastIndexOf("/");
        index = index <= 0 ? 0 : index + 1;
        return pathStr.substring(0, index) + basename + ext + tempStr;
      },
      _normalize: function _normalize(url) {
        var oldUrl = url = String(url);
        do {
          oldUrl = url;
          url = url.replace(NORMALIZE_RE, "");
        } while (oldUrl.length !== url.length);
        return url;
      },
      sep: cc.sys.os === cc.sys.OS_WINDOWS ? "\\" : "/",
      stripSep: function stripSep(path) {
        return path.replace(/[\/\\]$/, "");
      }
    };
    module.exports = cc.path;
  }), {
    "../platform/CCSys": 113
  } ],
  179: [ (function(require, module, exports) {
    "use strict";
    var AffineTransform = function AffineTransform(a, b, c, d, tx, ty) {
      this.a = a;
      this.b = b;
      this.c = c;
      this.d = d;
      this.tx = tx;
      this.ty = ty;
    };
    AffineTransform.create = function(a, b, c, d, tx, ty) {
      return {
        a: a,
        b: b,
        c: c,
        d: d,
        tx: tx,
        ty: ty
      };
    };
    AffineTransform.identity = function() {
      return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
      };
    };
    AffineTransform.clone = function(t) {
      return {
        a: t.a,
        b: t.b,
        c: t.c,
        d: t.d,
        tx: t.tx,
        ty: t.ty
      };
    };
    AffineTransform.concat = function(out, t1, t2) {
      var a = t1.a, b = t1.b, c = t1.c, d = t1.d, tx = t1.tx, ty = t1.ty;
      out.a = a * t2.a + b * t2.c;
      out.b = a * t2.b + b * t2.d;
      out.c = c * t2.a + d * t2.c;
      out.d = c * t2.b + d * t2.d;
      out.tx = tx * t2.a + ty * t2.c + t2.tx;
      out.ty = tx * t2.b + ty * t2.d + t2.ty;
      return out;
    };
    AffineTransform.invert = function(out, t) {
      var a = t.a, b = t.b, c = t.c, d = t.d;
      var determinant = 1 / (a * d - b * c);
      var tx = t.tx, ty = t.ty;
      out.a = determinant * d;
      out.b = -determinant * b;
      out.c = -determinant * c;
      out.d = determinant * a;
      out.tx = determinant * (c * ty - d * tx);
      out.ty = determinant * (b * tx - a * ty);
      return out;
    };
    AffineTransform.fromMat4 = function(out, mat) {
      out.a = mat.m00;
      out.b = mat.m01;
      out.c = mat.m04;
      out.d = mat.m05;
      out.tx = mat.m12;
      out.ty = mat.m13;
      return out;
    };
    AffineTransform.transformVec2 = function(out, point, transOrY, t) {
      var x, y;
      if (void 0 === t) {
        t = transOrY;
        x = point.x;
        y = point.y;
      } else {
        x = point;
        y = transOrY;
      }
      out.x = t.a * x + t.c * y + t.tx;
      out.y = t.b * x + t.d * y + t.ty;
      return out;
    };
    AffineTransform.transformSize = function(out, size, t) {
      out.width = t.a * size.width + t.c * size.height;
      out.height = t.b * size.width + t.d * size.height;
      return out;
    };
    AffineTransform.transformRect = function(out, rect, t) {
      var ol = rect.x;
      var ob = rect.y;
      var or = ol + rect.width;
      var ot = ob + rect.height;
      var lbx = t.a * ol + t.c * ob + t.tx;
      var lby = t.b * ol + t.d * ob + t.ty;
      var rbx = t.a * or + t.c * ob + t.tx;
      var rby = t.b * or + t.d * ob + t.ty;
      var ltx = t.a * ol + t.c * ot + t.tx;
      var lty = t.b * ol + t.d * ot + t.ty;
      var rtx = t.a * or + t.c * ot + t.tx;
      var rty = t.b * or + t.d * ot + t.ty;
      var minX = Math.min(lbx, rbx, ltx, rtx);
      var maxX = Math.max(lbx, rbx, ltx, rtx);
      var minY = Math.min(lby, rby, lty, rty);
      var maxY = Math.max(lby, rby, lty, rty);
      out.x = minX;
      out.y = minY;
      out.width = maxX - minX;
      out.height = maxY - minY;
      return out;
    };
    AffineTransform.transformObb = function(out_bl, out_tl, out_tr, out_br, rect, anAffineTransform) {
      var x = rect.x;
      var y = rect.y;
      var width = rect.width;
      var height = rect.height;
      var tx = anAffineTransform.a * x + anAffineTransform.c * y + anAffineTransform.tx;
      var ty = anAffineTransform.b * x + anAffineTransform.d * y + anAffineTransform.ty;
      var xa = anAffineTransform.a * width;
      var xb = anAffineTransform.b * width;
      var yc = anAffineTransform.c * height;
      var yd = anAffineTransform.d * height;
      out_tl.x = tx;
      out_tl.y = ty;
      out_tr.x = xa + tx;
      out_tr.y = xb + ty;
      out_bl.x = yc + tx;
      out_bl.y = yd + ty;
      out_br.x = xa + yc + tx;
      out_br.y = xb + yd + ty;
    };
    cc.AffineTransform = module.exports = AffineTransform;
  }), {} ],
  180: [ (function(require, module, exports) {
    "use strict";
    var Flags = require("../platform/CCObject").Flags;
    var misc = require("./misc");
    var js = require("../platform/js");
    var IdGenerater = require("../platform/id-generater");
    var eventManager = require("../event-manager");
    var RenderFlow = require("../renderer/render-flow");
    var Destroying = Flags.Destroying;
    var DontDestroy = Flags.DontDestroy;
    var Deactivating = Flags.Deactivating;
    var CHILD_ADDED = "child-added";
    var CHILD_REMOVED = "child-removed";
    var idGenerater = new IdGenerater("Node");
    function getConstructor(typeOrClassName) {
      if (!typeOrClassName) {
        cc.errorID(3804);
        return null;
      }
      if ("string" === typeof typeOrClassName) return js.getClassByName(typeOrClassName);
      return typeOrClassName;
    }
    function findComponent(node, constructor) {
      if (constructor._sealed) for (var i = 0; i < node._components.length; ++i) {
        var comp = node._components[i];
        if (comp.constructor === constructor) return comp;
      } else for (var _i = 0; _i < node._components.length; ++_i) {
        var _comp = node._components[_i];
        if (_comp instanceof constructor) return _comp;
      }
      return null;
    }
    function findComponents(node, constructor, components) {
      if (constructor._sealed) for (var i = 0; i < node._components.length; ++i) {
        var comp = node._components[i];
        comp.constructor === constructor && components.push(comp);
      } else for (var _i2 = 0; _i2 < node._components.length; ++_i2) {
        var _comp2 = node._components[_i2];
        _comp2 instanceof constructor && components.push(_comp2);
      }
    }
    function findChildComponent(children, constructor) {
      for (var i = 0; i < children.length; ++i) {
        var node = children[i];
        var comp = findComponent(node, constructor);
        if (comp) return comp;
        if (node._children.length > 0) {
          comp = findChildComponent(node._children, constructor);
          if (comp) return comp;
        }
      }
      return null;
    }
    function findChildComponents(children, constructor, components) {
      for (var i = 0; i < children.length; ++i) {
        var node = children[i];
        findComponents(node, constructor, components);
        node._children.length > 0 && findChildComponents(node._children, constructor, components);
      }
    }
    var BaseNode = cc.Class({
      name: "cc._BaseNode",
      extends: cc.Object,
      properties: {
        _parent: null,
        _children: [],
        _active: true,
        _level: 0,
        _components: [],
        _prefab: null,
        _persistNode: {
          get: function get() {
            return (this._objFlags & DontDestroy) > 0;
          },
          set: function set(value) {
            value ? this._objFlags |= DontDestroy : this._objFlags &= ~DontDestroy;
          }
        },
        name: {
          get: function get() {
            return this._name;
          },
          set: function set(value) {
            false;
            this._name = value;
          }
        },
        uuid: {
          get: function get() {
            return this._id;
          }
        },
        children: {
          get: function get() {
            return this._children;
          }
        },
        childrenCount: {
          get: function get() {
            return this._children.length;
          }
        },
        active: {
          get: function get() {
            return this._active;
          },
          set: function set(value) {
            value = !!value;
            if (this._active !== value) {
              this._active = value;
              var parent = this._parent;
              if (parent) {
                var couldActiveInScene = parent._activeInHierarchy;
                couldActiveInScene && cc.director._nodeActivator.activateNode(this, value);
              }
            }
          }
        },
        activeInHierarchy: {
          get: function get() {
            return this._activeInHierarchy;
          }
        }
      },
      ctor: function ctor(name) {
        this._name = void 0 !== name ? name : "New Node";
        this._activeInHierarchy = false;
        this._id = idGenerater.getNewId();
        cc.director._scheduler && cc.director._scheduler.enableForTarget(this);
        this.__eventTargets = [];
        this._renderFlag = RenderFlow.FLAG_TRANSFORM;
      },
      getParent: function getParent() {
        return this._parent;
      },
      setParent: function setParent(value) {
        if (this._parent === value) return;
        false;
        var oldParent = this._parent;
        (true, oldParent) && oldParent._objFlags & Deactivating && cc.errorID(3821);
        this._parent = value || null;
        this._onSetParent(value);
        if (value) {
          (true, value._objFlags & Deactivating) && cc.errorID(3821);
          this._level = value._level + 1;
          eventManager._setDirtyForNode(this);
          value._children.push(this);
          value.emit && value.emit(CHILD_ADDED, this);
          value._renderFlag |= RenderFlow.FLAG_CHILDREN;
        }
        if (oldParent) {
          if (!(oldParent._objFlags & Destroying)) {
            var removeAt = oldParent._children.indexOf(this);
            false;
            oldParent._children.splice(removeAt, 1);
            oldParent.emit && oldParent.emit(CHILD_REMOVED, this);
            this._onHierarchyChanged(oldParent);
            0 === oldParent._children.length && (oldParent._renderFlag &= ~RenderFlow.FLAG_CHILDREN);
          }
        } else value && this._onHierarchyChanged(null);
      },
      attr: function attr(attrs) {
        js.mixin(this, attrs);
      },
      getChildByUuid: function getChildByUuid(uuid) {
        if (!uuid) {
          cc.log("Invalid uuid");
          return null;
        }
        var locChildren = this._children;
        for (var i = 0, len = locChildren.length; i < len; i++) if (locChildren[i]._id === uuid) return locChildren[i];
        return null;
      },
      getChildByName: function getChildByName(name) {
        if (!name) {
          cc.log("Invalid name");
          return null;
        }
        var locChildren = this._children;
        for (var i = 0, len = locChildren.length; i < len; i++) if (locChildren[i]._name === name) return locChildren[i];
        return null;
      },
      addChild: function addChild(child) {
        false;
        cc.assertID(child, 1606);
        cc.assertID(null === child._parent, 1605);
        child.setParent(this);
      },
      insertChild: function insertChild(child, siblingIndex) {
        child.parent = this;
        child.setSiblingIndex(siblingIndex);
      },
      getSiblingIndex: function getSiblingIndex() {
        return this._parent ? this._parent._children.indexOf(this) : 0;
      },
      setSiblingIndex: function setSiblingIndex(index) {
        if (!this._parent) return;
        if (this._parent._objFlags & Deactivating) {
          cc.errorID(3821);
          return;
        }
        var siblings = this._parent._children;
        index = -1 !== index ? index : siblings.length - 1;
        var oldIndex = siblings.indexOf(this);
        if (index !== oldIndex) {
          siblings.splice(oldIndex, 1);
          index < siblings.length ? siblings.splice(index, 0, this) : siblings.push(this);
          this._onSiblingIndexChanged && this._onSiblingIndexChanged(index);
        }
      },
      walk: function walk(prefunc, postfunc) {
        var BaseNode = cc._BaseNode;
        var index = 1;
        var children, child, curr, i, afterChildren;
        var stack = BaseNode._stacks[BaseNode._stackId];
        if (!stack) {
          stack = [];
          BaseNode._stacks.push(stack);
        }
        BaseNode._stackId++;
        stack.length = 0;
        stack[0] = this;
        var parent = null;
        afterChildren = false;
        while (index) {
          index--;
          curr = stack[index];
          if (!curr) continue;
          !afterChildren && prefunc ? prefunc(curr) : afterChildren && postfunc && postfunc(curr);
          stack[index] = null;
          if (!afterChildren) {
            if (curr._children.length > 0) {
              parent = curr;
              children = curr._children;
              i = 0;
              stack[index] = children[i];
              index++;
            } else {
              stack[index] = curr;
              index++;
              afterChildren = true;
            }
            continue;
          }
          afterChildren = false;
          if (children) {
            i++;
            if (children[i]) {
              stack[index] = children[i];
              index++;
            } else if (parent) {
              stack[index] = parent;
              index++;
              afterChildren = true;
              if (parent._parent) {
                children = parent._parent._children;
                i = children.indexOf(parent);
                parent = parent._parent;
              } else {
                parent = null;
                children = null;
              }
              if (i < 0) break;
            }
          }
        }
        stack.length = 0;
        BaseNode._stackId--;
      },
      cleanup: function cleanup() {},
      removeFromParent: function removeFromParent(cleanup) {
        if (this._parent) {
          void 0 === cleanup && (cleanup = true);
          this._parent.removeChild(this, cleanup);
        }
      },
      removeChild: function removeChild(child, cleanup) {
        if (this._children.indexOf(child) > -1) {
          (cleanup || void 0 === cleanup) && child.cleanup();
          child.parent = null;
        }
      },
      removeAllChildren: function removeAllChildren(cleanup) {
        var children = this._children;
        void 0 === cleanup && (cleanup = true);
        for (var i = children.length - 1; i >= 0; i--) {
          var node = children[i];
          if (node) {
            cleanup && node.cleanup();
            node.parent = null;
          }
        }
        this._children.length = 0;
      },
      isChildOf: function isChildOf(parent) {
        var child = this;
        do {
          if (child === parent) return true;
          child = child._parent;
        } while (child);
        return false;
      },
      getComponent: function getComponent(typeOrClassName) {
        var constructor = getConstructor(typeOrClassName);
        if (constructor) return findComponent(this, constructor);
        return null;
      },
      getComponents: function getComponents(typeOrClassName) {
        var constructor = getConstructor(typeOrClassName), components = [];
        constructor && findComponents(this, constructor, components);
        return components;
      },
      getComponentInChildren: function getComponentInChildren(typeOrClassName) {
        var constructor = getConstructor(typeOrClassName);
        if (constructor) return findChildComponent(this._children, constructor);
        return null;
      },
      getComponentsInChildren: function getComponentsInChildren(typeOrClassName) {
        var constructor = getConstructor(typeOrClassName), components = [];
        if (constructor) {
          findComponents(this, constructor, components);
          findChildComponents(this._children, constructor, components);
        }
        return components;
      },
      _checkMultipleComp: false,
      addComponent: function addComponent(typeOrClassName) {
        false;
        var constructor;
        if ("string" === typeof typeOrClassName) {
          constructor = js.getClassByName(typeOrClassName);
          if (!constructor) {
            cc.errorID(3807, typeOrClassName);
            cc._RFpeek() && cc.errorID(3808, typeOrClassName);
            return null;
          }
        } else {
          if (!typeOrClassName) {
            cc.errorID(3804);
            return null;
          }
          constructor = typeOrClassName;
        }
        if ("function" !== typeof constructor) {
          cc.errorID(3809);
          return null;
        }
        if (!js.isChildClassOf(constructor, cc.Component)) {
          cc.errorID(3810);
          return null;
        }
        false;
        var ReqComp = constructor._requireComponent;
        if (ReqComp && !this.getComponent(ReqComp)) {
          var depended = this.addComponent(ReqComp);
          if (!depended) return null;
        }
        var component = new constructor();
        component.node = this;
        this._components.push(component);
        (false, false) && cc.engine && this._id in cc.engine.attachedObjsForEditor && (cc.engine.attachedObjsForEditor[component._id] = component);
        this._activeInHierarchy && cc.director._nodeActivator.activateComp(component);
        return component;
      },
      _addComponentAt: false,
      removeComponent: function removeComponent(component) {
        if (!component) {
          cc.errorID(3813);
          return;
        }
        component instanceof cc.Component || (component = this.getComponent(component));
        component && component.destroy();
      },
      _getDependComponent: false,
      _removeComponent: function _removeComponent(component) {
        if (!component) {
          cc.errorID(3814);
          return;
        }
        if (!(this._objFlags & Destroying)) {
          var i = this._components.indexOf(component);
          if (-1 !== i) {
            this._components.splice(i, 1);
            (false, false) && cc.engine && delete cc.engine.attachedObjsForEditor[component._id];
          } else component.node !== this && cc.errorID(3815);
        }
      },
      destroy: function destroy() {
        cc.Object.prototype.destroy.call(this) && (this.active = false);
      },
      destroyAllChildren: function destroyAllChildren() {
        var children = this._children;
        for (var i = 0; i < children.length; ++i) children[i].destroy();
      },
      _onSetParent: function _onSetParent(value) {},
      _onPostActivated: function _onPostActivated() {},
      _onBatchRestored: function _onBatchRestored() {},
      _onBatchCreated: function _onBatchCreated() {},
      _onHierarchyChanged: function _onHierarchyChanged(oldParent) {
        var newParent = this._parent;
        if (this._persistNode && !(newParent instanceof cc.Scene)) {
          cc.game.removePersistRootNode(this);
          false;
        }
        var scene;
        var inCurrentSceneBefore;
        var inCurrentSceneNow;
        var newPrefabRoot;
        var myPrefabInfo;
        var PrefabUtils;
        false, false;
        var shouldActiveNow = this._active && !!(newParent && newParent._activeInHierarchy);
        this._activeInHierarchy !== shouldActiveNow && cc.director._nodeActivator.activateNode(this, shouldActiveNow);
      },
      _instantiate: function _instantiate(cloned) {
        cloned || (cloned = cc.instantiate._clone(this, this));
        var thisPrefabInfo = this._prefab;
        var PrefabUtils;
        false;
        var syncing = thisPrefabInfo && this === thisPrefabInfo.root && thisPrefabInfo.sync;
        syncing || false;
        cloned._parent = null;
        cloned._onBatchRestored();
        return cloned;
      },
      _registerIfAttached: (false, false) && function(register) {
        var attachedObjsForEditor = cc.engine.attachedObjsForEditor;
        if (register) {
          attachedObjsForEditor[this._id] = this;
          for (var i = 0; i < this._components.length; i++) {
            var comp = this._components[i];
            attachedObjsForEditor[comp._id] = comp;
          }
          cc.engine.emit("node-attach-to-scene", this);
        } else {
          cc.engine.emit("node-detach-from-scene", this);
          delete attachedObjsForEditor[this._id];
          for (var _i3 = 0; _i3 < this._components.length; _i3++) {
            var _comp3 = this._components[_i3];
            delete attachedObjsForEditor[_comp3._id];
          }
        }
        var children = this._children;
        for (var _i4 = 0, len = children.length; _i4 < len; ++_i4) {
          var child = children[_i4];
          child._registerIfAttached(register);
        }
      },
      _onPreDestroy: function _onPreDestroy() {
        var i, len;
        this._objFlags |= Destroying;
        var parent = this._parent;
        var destroyByParent = parent && parent._objFlags & Destroying;
        !destroyByParent && (false, false) && this._registerIfAttached(false);
        var children = this._children;
        for (i = 0, len = children.length; i < len; ++i) children[i]._destroyImmediate();
        for (i = 0, len = this._components.length; i < len; ++i) {
          var component = this._components[i];
          component._destroyImmediate();
        }
        var eventTargets = this.__eventTargets;
        for (i = 0, len = eventTargets.length; i < len; ++i) {
          var target = eventTargets[i];
          target && target.targetOff(this);
        }
        eventTargets.length = 0;
        this._persistNode && cc.game.removePersistRootNode(this);
        if (!destroyByParent && parent) {
          var childIndex = parent._children.indexOf(this);
          parent._children.splice(childIndex, 1);
          parent.emit && parent.emit("child-removed", this);
        }
        return destroyByParent;
      },
      onRestore: false
    });
    BaseNode.idGenerater = idGenerater;
    BaseNode._stacks = [ [] ];
    BaseNode._stackId = 0;
    BaseNode.prototype._onPreDestroyBase = BaseNode.prototype._onPreDestroy;
    false;
    BaseNode.prototype._onHierarchyChangedBase = BaseNode.prototype._onHierarchyChanged;
    false;
    var SameNameGetSets = [ "parent", "name", "children", "childrenCount" ];
    misc.propertyDefine(BaseNode, SameNameGetSets, {});
    false;
    cc._BaseNode = module.exports = BaseNode;
  }), {
    "../event-manager": 70,
    "../platform/CCObject": 110,
    "../platform/id-generater": 120,
    "../platform/js": 124,
    "../renderer/render-flow": 148,
    "./misc": 187
  } ],
  181: [ (function(require, module, exports) {
    "use strict";
    var RenderComponent = require("../components/CCRenderComponent");
    var BlendFactor = require("../platform/CCMacro").BlendFactor;
    var gfx = require("../../renderer/gfx");
    var BlendFunc = cc.Class({
      properties: {
        _srcBlendFactor: BlendFactor.SRC_ALPHA,
        _dstBlendFactor: BlendFactor.ONE_MINUS_SRC_ALPHA,
        srcBlendFactor: {
          get: function get() {
            return this._srcBlendFactor;
          },
          set: function set(value) {
            if (this._srcBlendFactor === value) return;
            this._srcBlendFactor = value;
            this._updateBlendFunc();
          },
          animatable: false,
          type: BlendFactor,
          tooltip: false,
          visible: true
        },
        dstBlendFactor: {
          get: function get() {
            return this._dstBlendFactor;
          },
          set: function set(value) {
            if (this._dstBlendFactor === value) return;
            this._dstBlendFactor = value;
            this._updateBlendFunc();
          },
          animatable: false,
          type: BlendFactor,
          tooltip: false,
          visible: true
        }
      },
      setMaterial: function setMaterial(index, material) {
        RenderComponent.prototype.setMaterial.call(this, index, material);
        material && this._updateMaterialBlendFunc(material);
      },
      _updateBlendFunc: function _updateBlendFunc() {
        var materials = this._materials;
        for (var i = 0; i < materials.length; i++) {
          var material = materials[i];
          this._updateMaterialBlendFunc(material);
        }
      },
      _updateMaterialBlendFunc: function _updateMaterialBlendFunc(material) {
        var passes = material._effect.getDefaultTechnique().passes;
        for (var j = 0; j < passes.length; j++) {
          var pass = passes[j];
          pass.setBlend(true, gfx.BLEND_FUNC_ADD, this._srcBlendFactor, this._dstBlendFactor, gfx.BLEND_FUNC_ADD, this._srcBlendFactor, this._dstBlendFactor);
        }
        material.setDirty(true);
      }
    });
    module.exports = BlendFunc;
  }), {
    "../../renderer/gfx": 233,
    "../components/CCRenderComponent": 47,
    "../platform/CCMacro": 109
  } ],
  182: [ (function(require, module, exports) {
    "use strict";
    var Base64Values = require("./misc").BASE64_VALUES;
    var HexChars = "0123456789abcdef".split("");
    var _t = [ "", "", "", "" ];
    var UuidTemplate = _t.concat(_t, "-", _t, "-", _t, "-", _t, "-", _t, _t, _t);
    var Indices = UuidTemplate.map((function(x, i) {
      return "-" === x ? NaN : i;
    })).filter(isFinite);
    module.exports = function(base64) {
      if (22 !== base64.length) return base64;
      UuidTemplate[0] = base64[0];
      UuidTemplate[1] = base64[1];
      for (var i = 2, j = 2; i < 22; i += 2) {
        var lhs = Base64Values[base64.charCodeAt(i)];
        var rhs = Base64Values[base64.charCodeAt(i + 1)];
        UuidTemplate[Indices[j++]] = HexChars[lhs >> 2];
        UuidTemplate[Indices[j++]] = HexChars[(3 & lhs) << 2 | rhs >> 4];
        UuidTemplate[Indices[j++]] = HexChars[15 & rhs];
      }
      return UuidTemplate.join("");
    };
    false;
  }), {
    "./misc": 187
  } ],
  183: [ (function(require, module, exports) {
    "use strict";
    cc.find = module.exports = function(path, referenceNode) {
      if (null == path) {
        cc.errorID(5600);
        return null;
      }
      if (referenceNode) false; else {
        var scene = cc.director.getScene();
        if (!scene) {
          false;
          return null;
        }
        false;
        referenceNode = scene;
      }
      var match = referenceNode;
      var startIndex = "/" !== path[0] ? 0 : 1;
      var nameList = path.split("/");
      for (var n = startIndex; n < nameList.length; n++) {
        var name = nameList[n];
        var children = match._children;
        match = null;
        for (var t = 0, len = children.length; t < len; ++t) {
          var subChild = children[t];
          if (subChild.name === name) {
            match = subChild;
            break;
          }
        }
        if (!match) return null;
      }
      return match;
    };
  }), {} ],
  184: [ (function(require, module, exports) {
    "use strict";
    var Material = require("../assets/material/CCMaterial");
    function GraySpriteState() {
      this._graySpriteMaterial = null;
      this._spriteMaterial = null;
    }
    GraySpriteState.prototype._switchGrayMaterial = function(useGrayMaterial, renderComp) {
      if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) return;
      var material = void 0;
      if (useGrayMaterial) {
        material = this._graySpriteMaterial;
        material || (material = Material.getBuiltinMaterial("2d-gray-sprite"));
        material = this._graySpriteMaterial = Material.getInstantiatedMaterial(material, renderComp);
      } else {
        material = this._spriteMaterial;
        material || (material = Material.getBuiltinMaterial("2d-sprite", renderComp));
        material = this._spriteMaterial = Material.getInstantiatedMaterial(material, renderComp);
      }
      renderComp.setMaterial(0, material);
    };
    module.exports = GraySpriteState;
  }), {
    "../assets/material/CCMaterial": 29
  } ],
  185: [ (function(require, module, exports) {
    "use strict";
    require("./CCPath");
    true;
    require("./profiler/CCProfiler");
    require("./find");
    require("./mutable-forward-iterator");
  }), {
    "./CCPath": 178,
    "./find": 183,
    "./mutable-forward-iterator": 188,
    "./profiler/CCProfiler": 190
  } ],
  186: [ (function(require, module, exports) {
    "use strict";
    var _vmath = require("../vmath");
    var js = require("../platform/js");
    var mat4Pool = new js.Pool(128);
    mat4Pool.get = function() {
      var matrix = this._get();
      matrix ? _vmath.mat4.identity(matrix) : matrix = _vmath.mat4.create();
      return matrix;
    };
    var quatPool = new js.Pool(64);
    quatPool.get = function() {
      var q = this._get();
      if (q) {
        q.x = q.y = q.z = 0;
        q.w = 1;
      } else q = _vmath.quat.create();
      return q;
    };
    module.exports = {
      mat4: mat4Pool,
      quat: quatPool
    };
  }), {
    "../platform/js": 124,
    "../vmath": 207
  } ],
  187: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    var misc = {};
    misc.propertyDefine = function(ctor, sameNameGetSets, diffNameGetSets) {
      function define(np, propName, getter, setter) {
        var pd = Object.getOwnPropertyDescriptor(np, propName);
        if (pd) {
          pd.get && (np[getter] = pd.get);
          pd.set && setter && (np[setter] = pd.set);
        } else {
          var getterFunc = np[getter];
          var clsName;
          false;
          js.getset(np, propName, getterFunc, np[setter]);
        }
      }
      var propName, np = ctor.prototype;
      for (var i = 0; i < sameNameGetSets.length; i++) {
        propName = sameNameGetSets[i];
        var suffix = propName[0].toUpperCase() + propName.slice(1);
        define(np, propName, "get" + suffix, "set" + suffix);
      }
      for (propName in diffNameGetSets) {
        var getset = diffNameGetSets[propName];
        define(np, propName, getset[0], getset[1]);
      }
    };
    misc.NextPOT = function(x) {
      x -= 1;
      x |= x >> 1;
      x |= x >> 2;
      x |= x >> 4;
      x |= x >> 8;
      x |= x >> 16;
      return x + 1;
    };
    false;
    misc.BUILTIN_CLASSID_RE = /^(?:cc|dragonBones|sp|ccsg)\..+/;
    var BASE64_KEYS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var BASE64_VALUES = new Array(123);
    for (var i = 0; i < 123; ++i) BASE64_VALUES[i] = 64;
    for (var _i = 0; _i < 64; ++_i) BASE64_VALUES[BASE64_KEYS.charCodeAt(_i)] = _i;
    misc.BASE64_VALUES = BASE64_VALUES;
    misc.pushToMap = function(map, key, value, pushFront) {
      var exists = map[key];
      if (exists) if (Array.isArray(exists)) if (pushFront) {
        exists.push(exists[0]);
        exists[0] = value;
      } else exists.push(value); else map[key] = pushFront ? [ value, exists ] : [ exists, value ]; else map[key] = value;
    };
    misc.clampf = function(value, min_inclusive, max_inclusive) {
      if (min_inclusive > max_inclusive) {
        var temp = min_inclusive;
        min_inclusive = max_inclusive;
        max_inclusive = temp;
      }
      return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
    };
    misc.clamp01 = function(value) {
      return value < 0 ? 0 : value < 1 ? value : 1;
    };
    misc.lerp = function(a, b, r) {
      return a + (b - a) * r;
    };
    misc.degreesToRadians = function(angle) {
      return angle * cc.macro.RAD;
    };
    misc.radiansToDegrees = function(angle) {
      return angle * cc.macro.DEG;
    };
    cc.misc = module.exports = misc;
  }), {
    "../platform/js": 124
  } ],
  188: [ (function(require, module, exports) {
    "use strict";
    function MutableForwardIterator(array) {
      this.i = 0;
      this.array = array;
    }
    var proto = MutableForwardIterator.prototype;
    proto.remove = function(value) {
      var index = this.array.indexOf(value);
      index >= 0 && this.removeAt(index);
    };
    proto.removeAt = function(i) {
      this.array.splice(i, 1);
      i <= this.i && --this.i;
    };
    proto.fastRemove = function(value) {
      var index = this.array.indexOf(value);
      index >= 0 && this.fastRemoveAt(index);
    };
    proto.fastRemoveAt = function(i) {
      var array = this.array;
      array[i] = array[array.length - 1];
      --array.length;
      i <= this.i && --this.i;
    };
    proto.push = function(item) {
      this.array.push(item);
    };
    module.exports = MutableForwardIterator;
  }), {} ],
  189: [ (function(require, module, exports) {
    "use strict";
    var _vmath = require("../vmath");
    cc._PrefabInfo = cc.Class({
      name: "cc.PrefabInfo",
      properties: {
        root: null,
        asset: null,
        fileId: "",
        sync: false,
        _synced: {
          default: false,
          serializable: false
        }
      }
    });
    module.exports = {
      syncWithPrefab: function syncWithPrefab(node) {
        var _prefab = node._prefab;
        _prefab._synced = true;
        if (!_prefab.asset) {
          var NodeUtils;
          var PrefabUtils;
          false;
          cc.errorID(3701, node.name);
          node._prefab = null;
          return;
        }
        var _objFlags = node._objFlags;
        var _parent = node._parent;
        var _id = node._id;
        var _name = node._name;
        var _active = node._active;
        var x = node._position.x;
        var y = node._position.y;
        var _quat = node._quat;
        var _localZOrder = node._localZOrder;
        var _globalZOrder = node._globalZOrder;
        cc.game._isCloning = true;
        var prefabRoot;
        true;
        _prefab.asset._doInstantiate(node);
        cc.game._isCloning = false;
        node._objFlags = _objFlags;
        node._parent = _parent;
        node._id = _id;
        node._prefab = _prefab;
        node._name = _name;
        node._active = _active;
        node._position.x = x;
        node._position.y = y;
        _vmath.quat.copy(node._quat, _quat);
        node._localZOrder = _localZOrder;
        node._globalZOrder = _globalZOrder;
      }
    };
  }), {
    "../vmath": 207
  } ],
  190: [ (function(require, module, exports) {
    "use strict";
    var macro = require("../../platform/CCMacro");
    var PerfCounter = require("./perf-counter");
    var _showFPS = false;
    var _fontSize = 15;
    var _atlas = null;
    var _stats = null;
    var _rootNode = null;
    var _label = null;
    function generateAtlas() {
      if (_atlas) return;
      var textureWidth = 256, textureHeight = 256;
      var canvas = document.createElement("canvas");
      canvas.width = textureWidth;
      canvas.height = textureHeight;
      canvas.style.width = textureWidth + "px";
      canvas.style.height = textureHeight + "px";
      var ctx = canvas.getContext("2d");
      ctx.font = _fontSize + "px Arial";
      ctx.textBaseline = "top";
      ctx.textAlign = "left";
      ctx.fillStyle = "#fff";
      var space = 2;
      var x = space;
      var y = space;
      var lineHeight = _fontSize;
      _atlas = new cc.LabelAtlas();
      _atlas._fntConfig = {
        atlasName: "profiler-arial",
        commonHeight: lineHeight,
        fontSize: _fontSize,
        kerningDict: {},
        fontDefDictionary: {}
      };
      _atlas._name = "profiler-arial";
      _atlas.fontSize = _fontSize;
      var dict = _atlas._fntConfig.fontDefDictionary;
      for (var i = 32; i <= 126; i++) {
        var char = String.fromCharCode(i);
        var width = ctx.measureText(char).width;
        if (x + width >= textureWidth) {
          x = space;
          y += lineHeight + space;
        }
        ctx.fillText(char, x, y);
        dict[i] = {
          xAdvance: width,
          xOffset: 0,
          yOffset: 0,
          rect: {
            x: x,
            y: y,
            width: width,
            height: lineHeight
          }
        };
        x += width + space;
      }
      var texture = new cc.Texture2D();
      texture.initWithElement(canvas);
      var spriteFrame = new cc.SpriteFrame();
      spriteFrame.setTexture(texture);
      _atlas.spriteFrame = spriteFrame;
    }
    function generateStats() {
      if (_stats) return;
      _stats = {
        frame: {
          desc: "Frame time (ms)",
          min: 0,
          max: 50,
          average: 500
        },
        fps: {
          desc: "Framerate (FPS)",
          below: 30,
          average: 500
        },
        draws: {
          desc: "Draw call"
        },
        logic: {
          desc: "Game Logic (ms)",
          min: 0,
          max: 50,
          average: 500,
          color: "#080"
        },
        render: {
          desc: "Renderer (ms)",
          min: 0,
          max: 50,
          average: 500,
          color: "#f90"
        },
        mode: {
          desc: cc.game.renderType === cc.game.RENDER_TYPE_WEBGL ? "WebGL" : "Canvas",
          min: 1
        }
      };
      var now = performance.now();
      for (var id in _stats) _stats[id]._counter = new PerfCounter(id, _stats[id], now);
    }
    function generateNode() {
      if (_rootNode && _rootNode.isValid) return;
      _rootNode = new cc.Node("PROFILER-NODE");
      _rootNode.x = _rootNode.y = 10;
      _rootNode.groupIndex = cc.Node.BuiltinGroupIndex.DEBUG;
      cc.Camera._setupDebugCamera();
      _rootNode.zIndex = macro.MAX_ZINDEX;
      cc.game.addPersistRootNode(_rootNode);
      var left = new cc.Node("LEFT-PANEL");
      left.anchorX = left.anchorY = 0;
      left.parent = _rootNode;
      var leftLabel = left.addComponent(cc.Label);
      leftLabel.font = _atlas;
      leftLabel.fontSize = _fontSize;
      leftLabel.lineHeight = _fontSize;
      var right = new cc.Node("RIGHT-PANEL");
      right.anchorX = 1;
      right.anchorY = 0;
      right.x = 200;
      right.parent = _rootNode;
      var rightLabel = right.addComponent(cc.Label);
      rightLabel.horizontalAlign = cc.Label.HorizontalAlign.RIGHT;
      rightLabel.font = _atlas;
      rightLabel.fontSize = _fontSize;
      rightLabel.lineHeight = _fontSize;
      _label = {
        left: leftLabel,
        right: rightLabel
      };
    }
    function beforeUpdate() {
      generateNode();
      var now = cc.director._lastUpdate;
      _stats["frame"]._counter.start(now);
      _stats["logic"]._counter.start(now);
    }
    function afterUpdate() {
      var now = performance.now();
      cc.director.isPaused() ? _stats["frame"]._counter.start(now) : _stats["logic"]._counter.end(now);
      _stats["render"]._counter.start(now);
    }
    function updateLabel(stat) {
      var length = 20;
      var desc = stat.desc;
      var value = stat._counter.human() + "";
      stat.label.string = stat.desc + "  " + stat._counter.human();
    }
    function afterDraw() {
      var now = performance.now();
      _stats["render"]._counter.end(now);
      _stats["draws"]._counter.value = cc.renderer.drawCalls;
      _stats["frame"]._counter.end(now);
      _stats["fps"]._counter.frame(now);
      var left = "";
      var right = "";
      for (var id in _stats) {
        var stat = _stats[id];
        stat._counter.sample(now);
        left += stat.desc + "\n";
        right += stat._counter.human() + "\n";
      }
      _label.left.string = left;
      _label.right.string = right;
    }
    cc.profiler = module.exports = {
      isShowingStats: function isShowingStats() {
        return _showFPS;
      },
      hideStats: function hideStats() {
        if (_showFPS) {
          _rootNode && (_rootNode.active = false);
          cc.director.off(cc.Director.EVENT_BEFORE_UPDATE, beforeUpdate);
          cc.director.off(cc.Director.EVENT_AFTER_UPDATE, afterUpdate);
          cc.director.off(cc.Director.EVENT_AFTER_DRAW, afterDraw);
          _showFPS = false;
        }
      },
      showStats: function showStats() {
        if (!_showFPS) {
          generateAtlas();
          generateStats();
          _rootNode && (_rootNode.active = true);
          cc.director.on(cc.Director.EVENT_BEFORE_UPDATE, beforeUpdate);
          cc.director.on(cc.Director.EVENT_AFTER_UPDATE, afterUpdate);
          cc.director.on(cc.Director.EVENT_AFTER_DRAW, afterDraw);
          _showFPS = true;
        }
      }
    };
  }), {
    "../../platform/CCMacro": 109,
    "./perf-counter": 192
  } ],
  191: [ (function(require, module, exports) {
    "use strict";
    var Counter = cc.Class({
      name: "cc.Counter",
      ctor: function ctor(id, opts, now) {
        this._id = id;
        this._opts = opts || {};
        this._value = 0;
        this._total = 0;
        this._averageValue = 0;
        this._accumValue = 0;
        this._accumSamples = 0;
        this._accumStart = now;
      },
      properties: {
        value: {
          get: function get() {
            return this._value;
          },
          set: function set(v) {
            this._value = v;
          }
        }
      },
      _average: function _average(v, now) {
        if (this._opts.average) {
          this._accumValue += v;
          ++this._accumSamples;
          var t = now;
          if (t - this._accumStart >= this._opts.average) {
            this._averageValue = this._accumValue / this._accumSamples;
            this._accumValue = 0;
            this._accumStart = t;
            this._accumSamples = 0;
          }
        }
      },
      sample: function sample(now) {
        this._average(this._value, now);
      },
      human: function human() {
        var v = this._opts.average ? this._averageValue : this._value;
        return Math.round(100 * v) / 100;
      },
      alarm: function alarm() {
        return this._opts.below && this._value < this._opts.below || this._opts.over && this._value > this._opts.over;
      }
    });
    module.exports = Counter;
  }), {} ],
  192: [ (function(require, module, exports) {
    "use strict";
    var Counter = require("./counter");
    var PerfCounter = cc.Class({
      name: "cc.PerfCounter",
      extends: Counter,
      ctor: function ctor(id, opts, now) {
        this._time = now;
      },
      start: function start(now) {
        this._time = now;
      },
      end: function end(now) {
        this._value = now - this._time;
        this._average(this._value);
      },
      tick: function tick() {
        this.end();
        this.start();
      },
      frame: function frame(now) {
        var t = now;
        var e = t - this._time;
        this._total++;
        var avg = this._opts.average || 1e3;
        if (e > avg) {
          this._value = 1e3 * this._total / e;
          this._total = 0;
          this._time = t;
          this._average(this._value);
        }
      }
    });
    module.exports = PerfCounter;
  }), {
    "./counter": 191
  } ],
  193: [ (function(require, module, exports) {
    "use strict";
    var _BASELINE_RATIO = .26;
    false;
    var textUtils = {
      BASELINE_RATIO: _BASELINE_RATIO,
      MIDDLE_RATIO: (_BASELINE_RATIO + 1) / 2 - _BASELINE_RATIO,
      label_wordRex: /([a-zA-Z0-9\xc4\xd6\xdc\xe4\xf6\xfc\xdf\xe9\xe8\xe7\xe0\xf9\xea\xe2\xee\xf4\xfb\u0430-\u044f\u0410-\u042f\u0401\u0451]+|\S)/,
      label_symbolRex: /^[!,.:;'}\]%\?>\u3001\u2018\u201c\u300b\uff1f\u3002\uff0c\uff01]/,
      label_lastWordRex: /([a-zA-Z0-9\xc4\xd6\xdc\xe4\xf6\xfc\xdf\xe9\xe8\xe7\xe0\xf9\xea\xe2\xee\xf4\xfb\u0430\xed\xec\xcd\xcc\xef\xc1\xc0\xe1\xe0\xc9\xc8\xd2\xd3\xf2\xf3\u0150\u0151\xd9\xda\u0170\xfa\u0171\xf1\xd1\xe6\xc6\u0153\u0152\xc3\xc2\xe3\xd4\xf5\u011b\u0161\u010d\u0159\u017e\xfd\xe1\xed\xe9\xf3\xfa\u016f\u0165\u010f\u0148\u011a\u0160\u010c\u0158\u017d\xc1\xcd\xc9\xd3\xda\u0164\u017c\u017a\u015b\xf3\u0144\u0142\u0119\u0107\u0105\u017b\u0179\u015a\xd3\u0143\u0141\u0118\u0106\u0104-\u044f\u0410-\u042f\u0401\u0451]+|\S)$/,
      label_lastEnglish: /[a-zA-Z0-9\xc4\xd6\xdc\xe4\xf6\xfc\xdf\xe9\xe8\xe7\xe0\xf9\xea\xe2\xee\xf4\xfb\u0430\xed\xec\xcd\xcc\xef\xc1\xc0\xe1\xe0\xc9\xc8\xd2\xd3\xf2\xf3\u0150\u0151\xd9\xda\u0170\xfa\u0171\xf1\xd1\xe6\xc6\u0153\u0152\xc3\xc2\xe3\xd4\xf5\u011b\u0161\u010d\u0159\u017e\xfd\xe1\xed\xe9\xf3\xfa\u016f\u0165\u010f\u0148\u011a\u0160\u010c\u0158\u017d\xc1\xcd\xc9\xd3\xda\u0164\u017c\u017a\u015b\xf3\u0144\u0142\u0119\u0107\u0105\u017b\u0179\u015a\xd3\u0143\u0141\u0118\u0106\u0104-\u044f\u0410-\u042f\u0401\u0451]+$/,
      label_firstEnglish: /^[a-zA-Z0-9\xc4\xd6\xdc\xe4\xf6\xfc\xdf\xe9\xe8\xe7\xe0\xf9\xea\xe2\xee\xf4\xfb\u0430\xed\xec\xcd\xcc\xef\xc1\xc0\xe1\xe0\xc9\xc8\xd2\xd3\xf2\xf3\u0150\u0151\xd9\xda\u0170\xfa\u0171\xf1\xd1\xe6\xc6\u0153\u0152\xc3\xc2\xe3\xd4\xf5\u011b\u0161\u010d\u0159\u017e\xfd\xe1\xed\xe9\xf3\xfa\u016f\u0165\u010f\u0148\u011a\u0160\u010c\u0158\u017d\xc1\xcd\xc9\xd3\xda\u0164\u017c\u017a\u015b\xf3\u0144\u0142\u0119\u0107\u0105\u017b\u0179\u015a\xd3\u0143\u0141\u0118\u0106\u0104-\u044f\u0410-\u042f\u0401\u0451]/,
      label_firstEmoji: /^[\uD83C\uDF00-\uDFFF\uDC00-\uDE4F]/,
      label_lastEmoji: /([\uDF00-\uDFFF\uDC00-\uDE4F]+|\S)$/,
      label_wrapinspection: true,
      __CHINESE_REG: /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/,
      __JAPANESE_REG: /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g,
      __KOREAN_REG: /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/,
      isUnicodeCJK: function isUnicodeCJK(ch) {
        return this.__CHINESE_REG.test(ch) || this.__JAPANESE_REG.test(ch) || this.__KOREAN_REG.test(ch);
      },
      isUnicodeSpace: function isUnicodeSpace(ch) {
        ch = ch.charCodeAt(0);
        return ch >= 9 && ch <= 13 || 32 === ch || 133 === ch || 160 === ch || 5760 === ch || ch >= 8192 && ch <= 8202 || 8232 === ch || 8233 === ch || 8239 === ch || 8287 === ch || 12288 === ch;
      },
      safeMeasureText: function safeMeasureText(ctx, string) {
        var metric = ctx.measureText(string);
        return metric && metric.width || 0;
      },
      fragmentText: function fragmentText(stringToken, allWidth, maxWidth, measureText) {
        var wrappedWords = [];
        if (0 === stringToken.length || maxWidth < 0) {
          wrappedWords.push("");
          return wrappedWords;
        }
        var text = stringToken;
        while (allWidth > maxWidth && text.length > 1) {
          var fuzzyLen = text.length * (maxWidth / allWidth) | 0;
          var tmpText = text.substr(fuzzyLen);
          var width = allWidth - measureText(tmpText);
          var sLine = tmpText;
          var pushNum = 0;
          var checkWhile = 0;
          var checkCount = 10;
          while (width > maxWidth && checkWhile++ < checkCount) {
            fuzzyLen *= maxWidth / width;
            fuzzyLen |= 0;
            tmpText = text.substr(fuzzyLen);
            width = allWidth - measureText(tmpText);
          }
          checkWhile = 0;
          while (width <= maxWidth && checkWhile++ < checkCount) {
            if (tmpText) {
              var exec = this.label_wordRex.exec(tmpText);
              pushNum = exec ? exec[0].length : 1;
              sLine = tmpText;
            }
            fuzzyLen += pushNum;
            tmpText = text.substr(fuzzyLen);
            width = allWidth - measureText(tmpText);
          }
          fuzzyLen -= pushNum;
          if (0 === fuzzyLen) {
            fuzzyLen = 1;
            sLine = sLine.substr(1);
          }
          var sText = text.substr(0, fuzzyLen), result;
          if (this.label_wrapinspection && this.label_symbolRex.test(sLine || tmpText)) {
            result = this.label_lastWordRex.exec(sText);
            fuzzyLen -= result ? result[0].length : 0;
            0 === fuzzyLen && (fuzzyLen = 1);
            sLine = text.substr(fuzzyLen);
            sText = text.substr(0, fuzzyLen);
          }
          if (this.label_firstEmoji.test(sLine)) {
            result = this.label_lastEmoji.exec(sText);
            if (result && sText !== result[0]) {
              fuzzyLen -= result[0].length;
              sLine = text.substr(fuzzyLen);
              sText = text.substr(0, fuzzyLen);
            }
          }
          if (this.label_firstEnglish.test(sLine)) {
            result = this.label_lastEnglish.exec(sText);
            if (result && sText !== result[0]) {
              fuzzyLen -= result[0].length;
              sLine = text.substr(fuzzyLen);
              sText = text.substr(0, fuzzyLen);
            }
          }
          if (0 === wrappedWords.length) wrappedWords.push(sText); else {
            sText = sText.trim();
            sText.length > 0 && wrappedWords.push(sText);
          }
          text = sLine || tmpText;
          allWidth = measureText(text);
        }
        if (0 === wrappedWords.length) wrappedWords.push(text); else {
          text = text.trim();
          text.length > 0 && wrappedWords.push(text);
        }
        return wrappedWords;
      }
    };
    module.exports = textUtils;
  }), {} ],
  194: [ (function(require, module, exports) {
    "use strict";
    var Texture2D = require("../assets/CCTexture2D");
    var textureUtil = {
      loadImage: function loadImage(url, cb, target) {
        cc.assertID(url, 3103);
        var tex = cc.loader.getRes(url);
        if (tex) {
          if (tex.loaded) {
            cb && cb.call(target, null, tex);
            return tex;
          }
          tex.once("load", (function() {
            cb && cb.call(target, null, tex);
          }), target);
          return tex;
        }
        tex = new Texture2D();
        tex.url = url;
        cc.loader.load({
          url: url,
          texture: tex
        }, (function(err, texture) {
          if (err) return cb && cb.call(target, err || new Error("Unknown error"));
          texture.handleLoadedTexture();
          cb && cb.call(target, null, texture);
        }));
        return tex;
      },
      cacheImage: function cacheImage(url, image) {
        if (url && image) {
          var tex = new Texture2D();
          tex.initWithElement(image);
          var item = {
            id: url,
            url: url,
            error: null,
            content: tex,
            complete: false
          };
          cc.loader.flowOut(item);
          return tex;
        }
      },
      postLoadTexture: function postLoadTexture(texture, callback) {
        if (texture.loaded) {
          callback && callback();
          return;
        }
        if (!texture.url) {
          callback && callback();
          return;
        }
        cc.loader.load({
          url: texture.url,
          skips: [ "Loader" ]
        }, (function(err, image) {
          if (image) {
            if (true, image instanceof cc.Texture2D) return cc.error("internal error: loader handle pipe must be skipped");
            texture.loaded || (texture._nativeAsset = image);
          }
          callback && callback(err);
        }));
      }
    };
    cc.textureUtil = module.exports = textureUtil;
  }), {
    "../assets/CCTexture2D": 27
  } ],
  195: [ (function(require, module, exports) {
    "use strict";
    var ValueType = require("./value-type");
    var js = require("../platform/js");
    var Color = (function() {
      function Color(r, g, b, a) {
        if ("object" === typeof r) {
          g = r.g;
          b = r.b;
          a = r.a;
          r = r.r;
        }
        r = r || 0;
        g = g || 0;
        b = b || 0;
        a = "number" === typeof a ? a : 255;
        this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + r;
      }
      js.extend(Color, ValueType);
      require("../platform/CCClass").fastDefine("cc.Color", Color, {
        r: 0,
        g: 0,
        b: 0,
        a: 255
      });
      var DefaultColors = {
        WHITE: [ 255, 255, 255, 255 ],
        BLACK: [ 0, 0, 0, 255 ],
        TRANSPARENT: [ 0, 0, 0, 0 ],
        GRAY: [ 127.5, 127.5, 127.5 ],
        RED: [ 255, 0, 0 ],
        GREEN: [ 0, 255, 0 ],
        BLUE: [ 0, 0, 255 ],
        YELLOW: [ 255, 235, 4 ],
        ORANGE: [ 255, 127, 0 ],
        CYAN: [ 0, 255, 255 ],
        MAGENTA: [ 255, 0, 255 ]
      };
      for (var colorName in DefaultColors) js.get(Color, colorName, (function(rgba) {
        return function() {
          return new Color(rgba[0], rgba[1], rgba[2], rgba[3]);
        };
      })(DefaultColors[colorName]));
      var proto = Color.prototype;
      proto.clone = function() {
        var ret = new Color();
        ret._val = this._val;
        return ret;
      };
      proto.equals = function(other) {
        return other && this._val === other._val;
      };
      proto.lerp = function(to, ratio, out) {
        out = out || new Color();
        var r = this.r;
        var g = this.g;
        var b = this.b;
        var a = this.a;
        out.r = r + (to.r - r) * ratio;
        out.g = g + (to.g - g) * ratio;
        out.b = b + (to.b - b) * ratio;
        out.a = a + (to.a - a) * ratio;
        return out;
      };
      proto.toString = function() {
        return "rgba(" + this.r.toFixed() + ", " + this.g.toFixed() + ", " + this.b.toFixed() + ", " + this.a.toFixed() + ")";
      };
      proto.getR = function() {
        return 255 & this._val;
      };
      proto.setR = function(red) {
        red = ~~cc.misc.clampf(red, 0, 255);
        this._val = (4294967040 & this._val | red) >>> 0;
        return this;
      };
      proto.getG = function() {
        return (65280 & this._val) >> 8;
      };
      proto.setG = function(green) {
        green = ~~cc.misc.clampf(green, 0, 255);
        this._val = (4294902015 & this._val | green << 8) >>> 0;
        return this;
      };
      proto.getB = function() {
        return (16711680 & this._val) >> 16;
      };
      proto.setB = function(blue) {
        blue = ~~cc.misc.clampf(blue, 0, 255);
        this._val = (4278255615 & this._val | blue << 16) >>> 0;
        return this;
      };
      proto.getA = function() {
        return (4278190080 & this._val) >>> 24;
      };
      proto.setA = function(alpha) {
        alpha = ~~cc.misc.clampf(alpha, 0, 255);
        this._val = (16777215 & this._val | alpha << 24) >>> 0;
        return this;
      };
      proto._fastSetA = function(alpha) {
        this._val = (16777215 & this._val | alpha << 24) >>> 0;
      };
      js.getset(proto, "r", proto.getR, proto.setR, true);
      js.getset(proto, "g", proto.getG, proto.setG, true);
      js.getset(proto, "b", proto.getB, proto.setB, true);
      js.getset(proto, "a", proto.getA, proto.setA, true);
      proto.toCSS = function(opt) {
        return "rgba" === opt ? "rgba(" + (0 | this.r) + "," + (0 | this.g) + "," + (0 | this.b) + "," + (this.a / 255).toFixed(2) + ")" : "rgb" === opt ? "rgb(" + (0 | this.r) + "," + (0 | this.g) + "," + (0 | this.b) + ")" : "#" + this.toHEX(opt);
      };
      proto.fromHEX = function(hexString) {
        hexString = 0 === hexString.indexOf("#") ? hexString.substring(1) : hexString;
        var r = parseInt(hexString.substr(0, 2), 16) || 0;
        var g = parseInt(hexString.substr(2, 2), 16) || 0;
        var b = parseInt(hexString.substr(4, 2), 16) || 0;
        var a = parseInt(hexString.substr(6, 2), 16) || 255;
        this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + r;
        return this;
      };
      proto.toHEX = function(fmt) {
        var prefix = "0";
        var hex = [ (this.r < 16 ? prefix : "") + (0 | this.r).toString(16), (this.g < 16 ? prefix : "") + (0 | this.g).toString(16), (this.b < 16 ? prefix : "") + (0 | this.b).toString(16) ];
        var i = -1;
        if ("#rgb" === fmt) for (i = 0; i < hex.length; ++i) hex[i].length > 1 && (hex[i] = hex[i][0]); else if ("#rrggbb" === fmt) for (i = 0; i < hex.length; ++i) 1 === hex[i].length && (hex[i] = "0" + hex[i]); else "#rrggbbaa" === fmt && hex.push((this.a < 16 ? prefix : "") + (0 | this.a).toString(16));
        return hex.join("");
      };
      proto.toRGBValue = function() {
        return 16777215 & this._val;
      };
      proto.fromHSV = function(h, s, v) {
        var r, g, b;
        if (0 === s) r = g = b = v; else if (0 === v) r = g = b = 0; else {
          1 === h && (h = 0);
          h *= 6;
          s = s;
          v = v;
          var i = Math.floor(h);
          var f = h - i;
          var p = v * (1 - s);
          var q = v * (1 - s * f);
          var t = v * (1 - s * (1 - f));
          switch (i) {
           case 0:
            r = v;
            g = t;
            b = p;
            break;

           case 1:
            r = q;
            g = v;
            b = p;
            break;

           case 2:
            r = p;
            g = v;
            b = t;
            break;

           case 3:
            r = p;
            g = q;
            b = v;
            break;

           case 4:
            r = t;
            g = p;
            b = v;
            break;

           case 5:
            r = v;
            g = p;
            b = q;
          }
        }
        r *= 255;
        g *= 255;
        b *= 255;
        this._val = (this.a << 24 >>> 0) + (b << 16) + (g << 8) + r;
        return this;
      };
      proto.toHSV = function() {
        var r = this.r / 255;
        var g = this.g / 255;
        var b = this.b / 255;
        var hsv = {
          h: 0,
          s: 0,
          v: 0
        };
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var delta = 0;
        hsv.v = max;
        hsv.s = max ? (max - min) / max : 0;
        if (hsv.s) {
          delta = max - min;
          hsv.h = r === max ? (g - b) / delta : g === max ? 2 + (b - r) / delta : 4 + (r - g) / delta;
          hsv.h /= 6;
          hsv.h < 0 && (hsv.h += 1);
        } else hsv.h = 0;
        return hsv;
      };
      proto.set = function(color) {
        if (color._val) this._val = color._val; else {
          this.r = color.r;
          this.g = color.g;
          this.b = color.b;
          this.a = color.a;
        }
      };
      return Color;
    })();
    cc.Color = Color;
    cc.color = function color(r, g, b, a) {
      if ("string" === typeof r) {
        var result = new cc.Color();
        return result.fromHEX(r);
      }
      if ("object" === typeof r) return new cc.Color(r.r, r.g, r.b, r.a);
      return new cc.Color(r, g, b, a);
    };
    module.exports = cc.Color;
  }), {
    "../platform/CCClass": 104,
    "../platform/js": 124,
    "./value-type": 201
  } ],
  196: [ (function(require, module, exports) {
    "use strict";
    require("./value-type");
    cc.vmath = require("../vmath").default;
    module.exports = {
      Vec2: require("./vec2"),
      Vec3: require("./vec3"),
      Vec4: require("./vec4"),
      Quat: require("./quat"),
      Mat4: require("./mat4"),
      Size: require("./size"),
      Rect: require("./rect"),
      Color: require("./color")
    };
  }), {
    "../vmath": 207,
    "./color": 195,
    "./mat4": 197,
    "./quat": 198,
    "./rect": 199,
    "./size": 200,
    "./value-type": 201,
    "./vec2": 202,
    "./vec3": 203,
    "./vec4": 204
  } ],
  197: [ (function(require, module, exports) {
    "use strict";
    var _vmath = require("../vmath");
    var ValueType = require("./value-type");
    var js = require("../platform/js");
    var CCClass = require("../platform/CCClass");
    function Mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      var t = this;
      t.m00 = m00;
      t.m01 = m01;
      t.m02 = m02;
      t.m03 = m03;
      t.m04 = m10;
      t.m05 = m11;
      t.m06 = m12;
      t.m07 = m13;
      t.m08 = m20;
      t.m09 = m21;
      t.m10 = m22;
      t.m11 = m23;
      t.m12 = m30;
      t.m13 = m31;
      t.m14 = m32;
      t.m15 = m33;
    }
    js.extend(Mat4, ValueType);
    CCClass.fastDefine("cc.Mat4", Mat4, {
      m00: 1,
      m01: 0,
      m02: 0,
      m03: 0,
      m04: 0,
      m05: 1,
      m06: 0,
      m07: 0,
      m08: 0,
      m09: 0,
      m10: 1,
      m11: 0,
      m12: 0,
      m13: 0,
      m14: 0,
      m15: 1
    });
    js.mixin(Mat4.prototype, {
      clone: function clone() {
        var t = this;
        return new Mat4(t.m00, t.m01, t.m02, t.m03, t.m04, t.m05, t.m06, t.m07, t.m08, t.m09, t.m10, t.m11, t.m12, t.m13, t.m14, t.m15);
      },
      set: function set(s) {
        var t = this;
        t.m00 = s.m00;
        t.m01 = s.m01;
        t.m02 = s.m02;
        t.m03 = s.m03;
        t.m04 = s.m04;
        t.m05 = s.m05;
        t.m06 = s.m06;
        t.m07 = s.m07;
        t.m08 = s.m08;
        t.m09 = s.m09;
        t.m10 = s.m10;
        t.m11 = s.m11;
        t.m12 = s.m12;
        t.m13 = s.m13;
        t.m14 = s.m14;
        t.m15 = s.m15;
        return this;
      },
      equals: function equals(other) {
        return _vmath.mat4.exactEquals(this, other);
      },
      fuzzyEquals: function fuzzyEquals(other) {
        return _vmath.mat4.equals(this, other);
      },
      toString: function toString() {
        var t = this;
        return "[\n" + t.m00 + ", " + t.m01 + ", " + t.m02 + ", " + t.m03 + ",\n" + t.m04 + ", " + t.m05 + ", " + t.m06 + ", " + t.m07 + ",\n" + t.m08 + ", " + t.m09 + ", " + t.m10 + ", " + t.m11 + ",\n" + t.m12 + ", " + t.m13 + ", " + t.m14 + ", " + t.m15 + "\n]";
      },
      identity: function identity() {
        return _vmath.mat4.identity(this);
      },
      transpose: function transpose(out) {
        out = out || new cc.Mat4();
        return _vmath.mat4.transpose(out, this);
      },
      invert: function invert(out) {
        out = out || new cc.Mat4();
        return _vmath.mat4.invert(out, this);
      },
      adjoint: function adjoint(out) {
        out = out || new cc.Mat4();
        return _vmath.mat4.adjoint(out, this);
      },
      determinant: function determinant() {
        return _vmath.mat4.determinant(this);
      },
      add: function add(other, out) {
        out = out || new cc.Mat4();
        return _vmath.mat4.add(out, this, other);
      },
      sub: function sub(other, out) {
        out = out || new cc.Mat4();
        return _vmath.mat4.subtract(out, this, other);
      },
      mul: function mul(other, out) {
        out = out || new cc.Mat4();
        return _vmath.mat4.multiply(out, this, other);
      },
      mulScalar: function mulScalar(number, out) {
        out = out || new cc.Mat4();
        return _vmath.mat4.mulScalar(out, this, number);
      },
      translate: function translate(v, out) {
        out = out || new cc.Mat4();
        return _vmath.mat4.translate(out, this, v);
      },
      scale: function scale(v, out) {
        out = out || new cc.Mat4();
        return _vmath.mat4.scale(out, this, v);
      },
      rotate: function rotate(rad, axis, out) {
        out = out || new cc.Mat4();
        return _vmath.mat4.rotate(out, this, rad, axis);
      },
      getTranslation: function getTranslation(out) {
        out = out || new cc.Vec3();
        return _vmath.mat4.getTranslation(out, this);
      },
      getScale: function getScale(out) {
        out = out || new cc.Vec3();
        return _vmath.mat4.getScaling(out, this);
      },
      getRotation: function getRotation(out) {
        out = out || new cc.Quat();
        return _vmath.mat4.getRotation(out, this);
      },
      fromRTS: function fromRTS(q, v, s) {
        return _vmath.mat4.fromRTS(this, q, v, s);
      },
      fromQuat: function fromQuat(quat) {
        return _vmath.mat4.fromQuat(this, quat);
      }
    });
    cc.mat4 = function mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      return new Mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    };
    module.exports = cc.Mat4 = Mat4;
  }), {
    "../platform/CCClass": 104,
    "../platform/js": 124,
    "../vmath": 207,
    "./value-type": 201
  } ],
  198: [ (function(require, module, exports) {
    "use strict";
    var ValueType = require("./value-type");
    var js = require("../platform/js");
    var CCClass = require("../platform/CCClass");
    var quat = require("../vmath/quat");
    function Quat(x, y, z, w) {
      if (x && "object" === typeof x) {
        z = x.z;
        y = x.y;
        w = x.w;
        x = x.x;
      }
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
      this.w = w || 1;
    }
    js.extend(Quat, ValueType);
    CCClass.fastDefine("cc.Quat", Quat, {
      x: 0,
      y: 0,
      z: 0,
      w: 1
    });
    var proto = Quat.prototype;
    proto.clone = function() {
      return new Quat(this.x, this.y, this.z, this.w);
    };
    proto.set = function(newValue) {
      this.x = newValue.x;
      this.y = newValue.y;
      this.z = newValue.z;
      this.w = newValue.w;
      return this;
    };
    proto.equals = function(other) {
      return other && this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
    };
    proto.toEuler = function(out) {
      quat.toEuler(out, this);
      return out;
    };
    proto.fromEuler = function(euler) {
      quat.fromEuler(this, euler.x, euler.y, euler.z);
      return this;
    };
    proto.lerp = function(to, ratio, out) {
      out = out || new cc.Quat();
      quat.slerp(out, this, to, ratio);
      return out;
    };
    proto.mul = function(other, out) {
      out = out || new cc.Quat();
      quat.mul(out, this, other);
      return out;
    };
    cc.quat = function quat(x, y, z, w) {
      return new Quat(x, y, z, w);
    };
    module.exports = cc.Quat = Quat;
  }), {
    "../platform/CCClass": 104,
    "../platform/js": 124,
    "../vmath/quat": 212,
    "./value-type": 201
  } ],
  199: [ (function(require, module, exports) {
    "use strict";
    var ValueType = require("./value-type");
    var js = require("../platform/js");
    function Rect(x, y, w, h) {
      if (x && "object" === typeof x) {
        y = x.y;
        w = x.width;
        h = x.height;
        x = x.x;
      }
      this.x = x || 0;
      this.y = y || 0;
      this.width = w || 0;
      this.height = h || 0;
    }
    js.extend(Rect, ValueType);
    require("../platform/CCClass").fastDefine("cc.Rect", Rect, {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    });
    Rect.fromMinMax = function(v1, v2) {
      var min_x = Math.min(v1.x, v2.x);
      var min_y = Math.min(v1.y, v2.y);
      var max_x = Math.max(v1.x, v2.x);
      var max_y = Math.max(v1.y, v2.y);
      return new Rect(min_x, min_y, max_x - min_x, max_y - min_y);
    };
    var proto = Rect.prototype;
    proto.clone = function() {
      return new Rect(this.x, this.y, this.width, this.height);
    };
    proto.equals = function(other) {
      return other && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
    };
    proto.lerp = function(to, ratio, out) {
      out = out || new Rect();
      var x = this.x;
      var y = this.y;
      var width = this.width;
      var height = this.height;
      out.x = x + (to.x - x) * ratio;
      out.y = y + (to.y - y) * ratio;
      out.width = width + (to.width - width) * ratio;
      out.height = height + (to.height - height) * ratio;
      return out;
    };
    proto.set = function(source) {
      this.x = source.x;
      this.y = source.y;
      this.width = source.width;
      this.height = source.height;
    };
    proto.intersects = function(rect) {
      var maxax = this.x + this.width, maxay = this.y + this.height, maxbx = rect.x + rect.width, maxby = rect.y + rect.height;
      return !(maxax < rect.x || maxbx < this.x || maxay < rect.y || maxby < this.y);
    };
    proto.intersection = function(out, rectB) {
      var axMin = this.x, ayMin = this.y, axMax = this.x + this.width, ayMax = this.y + this.height;
      var bxMin = rectB.x, byMin = rectB.y, bxMax = rectB.x + rectB.width, byMax = rectB.y + rectB.height;
      out.x = Math.max(axMin, bxMin);
      out.y = Math.max(ayMin, byMin);
      out.width = Math.min(axMax, bxMax) - out.x;
      out.height = Math.min(ayMax, byMax) - out.y;
      return out;
    };
    proto.contains = function(point) {
      return this.x <= point.x && this.x + this.width >= point.x && this.y <= point.y && this.y + this.height >= point.y;
    };
    proto.containsRect = function(rect) {
      return this.x <= rect.x && this.x + this.width >= rect.x + rect.width && this.y <= rect.y && this.y + this.height >= rect.y + rect.height;
    };
    proto.union = function(out, rectB) {
      var ax = this.x, ay = this.y, aw = this.width, ah = this.height;
      var bx = rectB.x, by = rectB.y, bw = rectB.width, bh = rectB.height;
      out.x = Math.min(ax, bx);
      out.y = Math.min(ay, by);
      out.width = Math.max(ax + aw, bx + bw) - out.x;
      out.height = Math.max(ay + ah, by + bh) - out.y;
      return out;
    };
    proto.transformMat4 = function(out, mat) {
      var ol = this.x;
      var ob = this.y;
      var or = ol + this.width;
      var ot = ob + this.height;
      var lbx = mat.m00 * ol + mat.m04 * ob + mat.m12;
      var lby = mat.m01 * ol + mat.m05 * ob + mat.m13;
      var rbx = mat.m00 * or + mat.m04 * ob + mat.m12;
      var rby = mat.m01 * or + mat.m05 * ob + mat.m13;
      var ltx = mat.m00 * ol + mat.m04 * ot + mat.m12;
      var lty = mat.m01 * ol + mat.m05 * ot + mat.m13;
      var rtx = mat.m00 * or + mat.m04 * ot + mat.m12;
      var rty = mat.m01 * or + mat.m05 * ot + mat.m13;
      var minX = Math.min(lbx, rbx, ltx, rtx);
      var maxX = Math.max(lbx, rbx, ltx, rtx);
      var minY = Math.min(lby, rby, lty, rty);
      var maxY = Math.max(lby, rby, lty, rty);
      out.x = minX;
      out.y = minY;
      out.width = maxX - minX;
      out.height = maxY - minY;
      return out;
    };
    proto.toString = function() {
      return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ", " + this.width.toFixed(2) + ", " + this.height.toFixed(2) + ")";
    };
    js.getset(proto, "xMin", (function() {
      return this.x;
    }), (function(value) {
      this.width += this.x - value;
      this.x = value;
    }));
    js.getset(proto, "yMin", (function() {
      return this.y;
    }), (function(value) {
      this.height += this.y - value;
      this.y = value;
    }));
    js.getset(proto, "xMax", (function() {
      return this.x + this.width;
    }), (function(value) {
      this.width = value - this.x;
    }));
    js.getset(proto, "yMax", (function() {
      return this.y + this.height;
    }), (function(value) {
      this.height = value - this.y;
    }));
    js.getset(proto, "center", (function() {
      return new cc.Vec2(this.x + .5 * this.width, this.y + .5 * this.height);
    }), (function(value) {
      this.x = value.x - .5 * this.width;
      this.y = value.y - .5 * this.height;
    }));
    js.getset(proto, "origin", (function() {
      return new cc.Vec2(this.x, this.y);
    }), (function(value) {
      this.x = value.x;
      this.y = value.y;
    }));
    js.getset(proto, "size", (function() {
      return new cc.Size(this.width, this.height);
    }), (function(value) {
      this.width = value.width;
      this.height = value.height;
    }));
    cc.Rect = Rect;
    cc.rect = function rect(x, y, w, h) {
      return new Rect(x, y, w, h);
    };
    module.exports = cc.Rect;
  }), {
    "../platform/CCClass": 104,
    "../platform/js": 124,
    "./value-type": 201
  } ],
  200: [ (function(require, module, exports) {
    "use strict";
    var ValueType = require("./value-type");
    var js = require("../platform/js");
    function Size(width, height) {
      if (width && "object" === typeof width) {
        height = width.height;
        width = width.width;
      }
      this.width = width || 0;
      this.height = height || 0;
    }
    js.extend(Size, ValueType);
    require("../platform/CCClass").fastDefine("cc.Size", Size, {
      width: 0,
      height: 0
    });
    js.get(Size, "ZERO", (function() {
      return new Size(0, 0);
    }));
    var proto = Size.prototype;
    proto.clone = function() {
      return new Size(this.width, this.height);
    };
    proto.equals = function(other) {
      return other && this.width === other.width && this.height === other.height;
    };
    proto.lerp = function(to, ratio, out) {
      out = out || new Size();
      var width = this.width;
      var height = this.height;
      out.width = width + (to.width - width) * ratio;
      out.height = height + (to.height - height) * ratio;
      return out;
    };
    proto.set = function(source) {
      this.width = source.width;
      this.height = source.height;
    };
    proto.toString = function() {
      return "(" + this.width.toFixed(2) + ", " + this.height.toFixed(2) + ")";
    };
    cc.size = function(w, h) {
      return new Size(w, h);
    };
    cc.Size = module.exports = Size;
  }), {
    "../platform/CCClass": 104,
    "../platform/js": 124,
    "./value-type": 201
  } ],
  201: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    function ValueType() {}
    js.setClassName("cc.ValueType", ValueType);
    var proto = ValueType.prototype;
    false;
    proto.toString = function() {
      return "" + {};
    };
    cc.ValueType = module.exports = ValueType;
  }), {
    "../platform/js": 124
  } ],
  202: [ (function(require, module, exports) {
    "use strict";
    var _vmath = require("../vmath");
    var ValueType = require("./value-type");
    var js = require("../platform/js");
    var CCClass = require("../platform/CCClass");
    var misc = require("../utils/misc");
    function Vec2(x, y) {
      if (x && "object" === typeof x) {
        y = x.y;
        x = x.x;
      }
      this.x = x || 0;
      this.y = y || 0;
    }
    js.extend(Vec2, ValueType);
    CCClass.fastDefine("cc.Vec2", Vec2, {
      x: 0,
      y: 0
    });
    var proto = Vec2.prototype;
    js.value(proto, "z", 0, true);
    proto.clone = function() {
      return new Vec2(this.x, this.y);
    };
    proto.set = function(newValue) {
      this.x = newValue.x;
      this.y = newValue.y;
      return this;
    };
    proto.equals = function(other) {
      return other && this.x === other.x && this.y === other.y;
    };
    proto.fuzzyEquals = function(other, variance) {
      if (this.x - variance <= other.x && other.x <= this.x + variance && this.y - variance <= other.y && other.y <= this.y + variance) return true;
      return false;
    };
    proto.toString = function() {
      return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ")";
    };
    proto.lerp = function(to, ratio, out) {
      out = out || new Vec2();
      var x = this.x;
      var y = this.y;
      out.x = x + (to.x - x) * ratio;
      out.y = y + (to.y - y) * ratio;
      return out;
    };
    proto.clampf = function(min_inclusive, max_inclusive) {
      this.x = misc.clampf(this.x, min_inclusive.x, max_inclusive.x);
      this.y = misc.clampf(this.y, min_inclusive.y, max_inclusive.y);
      return this;
    };
    proto.addSelf = function(vector) {
      this.x += vector.x;
      this.y += vector.y;
      return this;
    };
    proto.add = function(vector, out) {
      out = out || new Vec2();
      out.x = this.x + vector.x;
      out.y = this.y + vector.y;
      return out;
    };
    proto.subSelf = function(vector) {
      this.x -= vector.x;
      this.y -= vector.y;
      return this;
    };
    proto.sub = function(vector, out) {
      out = out || new Vec2();
      out.x = this.x - vector.x;
      out.y = this.y - vector.y;
      return out;
    };
    proto.mulSelf = function(num) {
      this.x *= num;
      this.y *= num;
      return this;
    };
    proto.mul = function(num, out) {
      out = out || new Vec2();
      out.x = this.x * num;
      out.y = this.y * num;
      return out;
    };
    proto.scaleSelf = function(vector) {
      this.x *= vector.x;
      this.y *= vector.y;
      return this;
    };
    proto.scale = function(vector, out) {
      out = out || new Vec2();
      out.x = this.x * vector.x;
      out.y = this.y * vector.y;
      return out;
    };
    proto.divSelf = function(num) {
      this.x /= num;
      this.y /= num;
      return this;
    };
    proto.div = function(num, out) {
      out = out || new Vec2();
      out.x = this.x / num;
      out.y = this.y / num;
      return out;
    };
    proto.negSelf = function() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    };
    proto.neg = function(out) {
      out = out || new Vec2();
      out.x = -this.x;
      out.y = -this.y;
      return out;
    };
    proto.dot = function(vector) {
      return this.x * vector.x + this.y * vector.y;
    };
    proto.cross = function(vector) {
      return this.x * vector.y - this.y * vector.x;
    };
    proto.mag = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    };
    proto.magSqr = function() {
      return this.x * this.x + this.y * this.y;
    };
    proto.normalizeSelf = function() {
      var magSqr = this.x * this.x + this.y * this.y;
      if (1 === magSqr) return this;
      if (0 === magSqr) return this;
      var invsqrt = 1 / Math.sqrt(magSqr);
      this.x *= invsqrt;
      this.y *= invsqrt;
      return this;
    };
    proto.normalize = function(out) {
      out = out || new Vec2();
      out.x = this.x;
      out.y = this.y;
      out.normalizeSelf();
      return out;
    };
    proto.angle = function(vector) {
      var magSqr1 = this.magSqr();
      var magSqr2 = vector.magSqr();
      if (0 === magSqr1 || 0 === magSqr2) {
        console.warn("Can't get angle between zero vector");
        return 0;
      }
      var dot = this.dot(vector);
      var theta = dot / Math.sqrt(magSqr1 * magSqr2);
      theta = misc.clampf(theta, -1, 1);
      return Math.acos(theta);
    };
    proto.signAngle = function(vector) {
      var angle = this.angle(vector);
      return this.cross(vector) < 0 ? -angle : angle;
    };
    proto.rotate = function(radians, out) {
      out = out || new Vec2();
      out.x = this.x;
      out.y = this.y;
      return out.rotateSelf(radians);
    };
    proto.rotateSelf = function(radians) {
      var sin = Math.sin(radians);
      var cos = Math.cos(radians);
      var x = this.x;
      this.x = cos * x - sin * this.y;
      this.y = sin * x + cos * this.y;
      return this;
    };
    proto.project = function(vector) {
      return vector.mul(this.dot(vector) / vector.dot(vector));
    };
    proto.transformMat4 = function(m, out) {
      out = out || new Vec2();
      _vmath.vec2.transformMat4(out, this, m);
    };
    js.get(Vec2, "ONE", (function() {
      return new Vec2(1, 1);
    }));
    js.get(Vec2, "ZERO", (function() {
      return new Vec2(0, 0);
    }));
    js.get(Vec2, "UP", (function() {
      return new Vec2(0, 1);
    }));
    js.get(Vec2, "RIGHT", (function() {
      return new Vec2(1, 0);
    }));
    cc.Vec2 = Vec2;
    cc.v2 = function v2(x, y) {
      return new Vec2(x, y);
    };
    cc.p = cc.v2;
    module.exports = cc.Vec2;
  }), {
    "../platform/CCClass": 104,
    "../platform/js": 124,
    "../utils/misc": 187,
    "../vmath": 207,
    "./value-type": 201
  } ],
  203: [ (function(require, module, exports) {
    "use strict";
    var _vmath = require("../vmath");
    var ValueType = require("./value-type");
    var js = require("../platform/js");
    var CCClass = require("../platform/CCClass");
    var misc = require("../utils/misc");
    var v2Proto = require("./vec2").prototype;
    function Vec3(x, y, z) {
      if (x && "object" === typeof x) {
        z = x.z;
        y = x.y;
        x = x.x;
      }
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
    }
    js.extend(Vec3, ValueType);
    CCClass.fastDefine("cc.Vec3", Vec3, {
      x: 0,
      y: 0,
      z: 0
    });
    var proto = Vec3.prototype;
    proto.clone = function() {
      return new Vec3(this.x, this.y, this.z);
    };
    proto.set = function(newValue) {
      this.x = newValue.x;
      this.y = newValue.y;
      this.z = newValue.z;
      return this;
    };
    proto.equals = function(other) {
      return other && this.x === other.x && this.y === other.y && this.z === other.z;
    };
    proto.fuzzyEquals = function(other, variance) {
      if (this.x - variance <= other.x && other.x <= this.x + variance && this.y - variance <= other.y && other.y <= this.y + variance && this.z - variance <= other.z && other.z <= this.z + variance) return true;
      return false;
    };
    proto.toString = function() {
      return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ", " + this.z.toFixed(2) + ")";
    };
    proto.lerp = function(to, ratio, out) {
      out = out || new Vec3();
      _vmath.vec3.lerp(out, this, to, ratio);
      return out;
    };
    proto.clampf = function(min_inclusive, max_inclusive) {
      this.x = misc.clampf(this.x, min_inclusive.x, max_inclusive.x);
      this.y = misc.clampf(this.y, min_inclusive.y, max_inclusive.y);
      this.z = misc.clampf(this.z, min_inclusive.z, max_inclusive.z);
      return this;
    };
    proto.addSelf = function(vector) {
      this.x += vector.x;
      this.y += vector.y;
      this.z += vector.z;
      return this;
    };
    proto.add = function(vector, out) {
      out = out || new Vec3();
      out.x = this.x + vector.x;
      out.y = this.y + vector.y;
      out.z = this.z + vector.z;
      return out;
    };
    proto.subSelf = function(vector) {
      this.x -= vector.x;
      this.y -= vector.y;
      this.z -= vector.z;
      return this;
    };
    proto.sub = function(vector, out) {
      out = out || new Vec3();
      out.x = this.x - vector.x;
      out.y = this.y - vector.y;
      out.z = this.z - vector.z;
      return out;
    };
    proto.mulSelf = function(num) {
      this.x *= num;
      this.y *= num;
      this.z *= num;
      return this;
    };
    proto.mul = function(num, out) {
      out = out || new Vec3();
      out.x = this.x * num;
      out.y = this.y * num;
      out.z = this.z * num;
      return out;
    };
    proto.scaleSelf = function(vector) {
      this.x *= vector.x;
      this.y *= vector.y;
      this.z *= vector.z;
      return this;
    };
    proto.scale = function(vector, out) {
      out = out || new Vec3();
      out.x = this.x * vector.x;
      out.y = this.y * vector.y;
      out.z = this.z * vector.z;
      return out;
    };
    proto.divSelf = function(num) {
      this.x /= num;
      this.y /= num;
      this.z /= num;
      return this;
    };
    proto.div = function(num, out) {
      out = out || new Vec3();
      out.x = this.x / num;
      out.y = this.y / num;
      out.z = this.z / num;
      return out;
    };
    proto.negSelf = function() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    };
    proto.neg = function(out) {
      out = out || new Vec3();
      out.x = -this.x;
      out.y = -this.y;
      out.z = -this.z;
      return out;
    };
    proto.dot = function(vector) {
      return this.x * vector.x + this.y * vector.y + this.z * vector.z;
    };
    proto.cross = function(vector, out) {
      out = out || new Vec3();
      _vmath.vec3.cross(out, this, vector);
      return out;
    };
    proto.mag = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    };
    proto.magSqr = function() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    };
    proto.normalizeSelf = function() {
      _vmath.vec3.normalize(this, this);
      return this;
    };
    proto.normalize = function(out) {
      out = out || new Vec3();
      _vmath.vec3.normalize(out, this);
      return out;
    };
    proto.transformMat4 = function(m, out) {
      out = out || new Vec3();
      _vmath.vec3.transformMat4(out, this, m);
    };
    proto.angle = v2Proto.angle;
    proto.project = v2Proto.project;
    proto.signAngle = function(vector) {
      cc.warnID(1408, "vec3.signAngle", "v2.1", "cc.v2(selfVector).signAngle(vector)");
      var vec1 = new cc.Vec2(this.x, this.y);
      var vec2 = new cc.Vec2(vector.x, vector.y);
      return vec1.signAngle(vec2);
    };
    proto.rotate = function(radians, out) {
      cc.warnID(1408, "vec3.rotate", "v2.1", "cc.v2(selfVector).rotate(radians, out)");
      return v2Proto.rotate.call(this, radians, out);
    };
    proto.rotateSelf = function(radians) {
      cc.warnID(1408, "vec3.rotateSelf", "v2.1", "cc.v2(selfVector).rotateSelf(radians)");
      return v2Proto.rotateSelf.call(this, radians);
    };
    js.get(Vec3, "ONE", (function() {
      return new Vec3(1, 1, 1);
    }));
    js.get(Vec3, "ZERO", (function() {
      return new Vec3(0, 0, 0);
    }));
    js.get(Vec3, "UP", (function() {
      return new Vec3(0, 1, 0);
    }));
    js.get(Vec3, "RIGHT", (function() {
      return new Vec3(1, 0, 0);
    }));
    js.get(Vec3, "FRONT", (function() {
      return new Vec3(0, 0, 1);
    }));
    cc.v3 = function v3(x, y, z) {
      return new Vec3(x, y, z);
    };
    module.exports = cc.Vec3 = Vec3;
  }), {
    "../platform/CCClass": 104,
    "../platform/js": 124,
    "../utils/misc": 187,
    "../vmath": 207,
    "./value-type": 201,
    "./vec2": 202
  } ],
  204: [ (function(require, module, exports) {
    "use strict";
    var _valueType = require("./value-type");
    var _valueType2 = _interopRequireDefault(_valueType);
    var _CCClass = require("../platform/CCClass");
    var _CCClass2 = _interopRequireDefault(_CCClass);
    var _vmath = require("../vmath");
    var _misc = require("../utils/misc");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !call || "object" !== typeof call && "function" !== typeof call ? self : call;
    }
    function _inherits(subClass, superClass) {
      if ("function" !== typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
    }
    var Vec4 = (function(_ValueType) {
      _inherits(Vec4, _ValueType);
      function Vec4(x, y, z, w) {
        _classCallCheck(this, Vec4);
        var _this = _possibleConstructorReturn(this, _ValueType.call(this));
        if (x && "object" === typeof x) {
          w = x.w;
          z = x.z;
          y = x.y;
          x = x.x;
        }
        _this.x = x || 0;
        _this.y = y || 0;
        _this.z = z || 0;
        _this.w = w || 0;
        return _this;
      }
      Vec4.prototype.clone = function clone() {
        return new Vec4(this.x, this.y, this.z, this.w);
      };
      Vec4.prototype.set = function set(newValue) {
        this.x = newValue.x;
        this.y = newValue.y;
        this.z = newValue.z;
        this.w = newValue.w;
        return this;
      };
      Vec4.prototype.equals = function equals(other) {
        return other && this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
      };
      Vec4.prototype.fuzzyEquals = function fuzzyEquals(other, variance) {
        if (this.x - variance <= other.x && other.x <= this.x + variance && this.y - variance <= other.y && other.y <= this.y + variance && this.z - variance <= other.z && other.z <= this.z + variance && this.w - variance <= other.w && other.w <= this.w + variance) return true;
        return false;
      };
      Vec4.prototype.toString = function toString() {
        return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ", " + this.z.toFixed(2) + ", " + this.w.toFixed(2) + ")";
      };
      Vec4.prototype.lerp = function lerp(to, ratio, out) {
        out = out || new Vec4();
        _vmath.vec4.lerp(out, this, to, ratio);
        return out;
      };
      Vec4.prototype.clampf = function clampf(min_inclusive, max_inclusive) {
        this.x = (0, _misc.clampf)(this.x, min_inclusive.x, max_inclusive.x);
        this.y = (0, _misc.clampf)(this.y, min_inclusive.y, max_inclusive.y);
        this.z = (0, _misc.clampf)(this.z, min_inclusive.z, max_inclusive.z);
        this.w = (0, _misc.clampf)(this.w, min_inclusive.w, max_inclusive.w);
        return this;
      };
      Vec4.prototype.addSelf = function addSelf(vector) {
        this.x += vector.x;
        this.y += vector.y;
        this.z += vector.z;
        this.w += vector.w;
        return this;
      };
      Vec4.prototype.add = function add(vector, out) {
        out = out || new Vec4();
        out.x = this.x + vector.x;
        out.y = this.y + vector.y;
        out.z = this.z + vector.z;
        out.w = this.w + vector.w;
        return out;
      };
      Vec4.prototype.subSelf = function subSelf(vector) {
        this.x -= vector.x;
        this.y -= vector.y;
        this.z -= vector.z;
        this.w -= vector.w;
        return this;
      };
      Vec4.prototype.sub = function sub(vector, out) {
        out = out || new Vec4();
        out.x = this.x - vector.x;
        out.y = this.y - vector.y;
        out.z = this.z - vector.z;
        out.w = this.w - vector.w;
        return out;
      };
      Vec4.prototype.mulSelf = function mulSelf(num) {
        this.x *= num;
        this.y *= num;
        this.z *= num;
        this.w *= num;
        return this;
      };
      Vec4.prototype.mul = function mul(num, out) {
        out = out || new Vec4();
        out.x = this.x * num;
        out.y = this.y * num;
        out.z = this.z * num;
        out.w = this.w * num;
        return out;
      };
      Vec4.prototype.scaleSelf = function scaleSelf(vector) {
        this.x *= vector.x;
        this.y *= vector.y;
        this.z *= vector.z;
        this.w *= vector.w;
        return this;
      };
      Vec4.prototype.scale = function scale(vector, out) {
        out = out || new Vec4();
        out.x = this.x * vector.x;
        out.y = this.y * vector.y;
        out.z = this.z * vector.z;
        out.w = this.w * vector.w;
        return out;
      };
      Vec4.prototype.divSelf = function divSelf(num) {
        this.x /= num;
        this.y /= num;
        this.z /= num;
        this.w /= num;
        return this;
      };
      Vec4.prototype.div = function div(num, out) {
        out = out || new Vec4();
        out.x = this.x / num;
        out.y = this.y / num;
        out.z = this.z / num;
        out.w = this.w / num;
        return out;
      };
      Vec4.prototype.negSelf = function negSelf() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
      };
      Vec4.prototype.neg = function neg(out) {
        out = out || new Vec4();
        out.x = -this.x;
        out.y = -this.y;
        out.z = -this.z;
        out.w = -this.w;
        return out;
      };
      Vec4.prototype.dot = function dot(vector) {
        return this.x * vector.x + this.y * vector.y + this.z * vector.z + this.w * vector.w;
      };
      Vec4.prototype.cross = function cross(vector, out) {
        out = out || new Vec4();
        _vmath.vec4.cross(out, this, vector);
        return out;
      };
      Vec4.prototype.mag = function mag() {
        var x = this.x, y = this.y, z = this.z, w = this.w;
        return Math.sqrt(x * x + y * y + z * z + w * w);
      };
      Vec4.prototype.magSqr = function magSqr() {
        var x = this.x, y = this.y, z = this.z, w = this.w;
        return x * x + y * y + z * z + w * w;
      };
      Vec4.prototype.normalizeSelf = function normalizeSelf() {
        _vmath.vec4.normalize(this, this);
        return this;
      };
      Vec4.prototype.normalize = function normalize(out) {
        out = out || new Vec4();
        _vmath.vec4.normalize(out, this);
        return out;
      };
      Vec4.prototype.transformMat4 = function transformMat4(m, out) {
        out = out || new Vec4();
        _vmath.vec4.transformMat4(out, this, m);
        return out;
      };
      return Vec4;
    })(_valueType2.default);
    _CCClass2.default.fastDefine("cc.Vec4", Vec4, {
      x: 0,
      y: 0,
      z: 0,
      w: 0
    });
    cc.v4 = function v4(x, y, z, w) {
      return new Vec4(x, y, z, w);
    };
    module.exports = cc.Vec4 = Vec4;
  }), {
    "../platform/CCClass": 104,
    "../utils/misc": 187,
    "../vmath": 207,
    "./value-type": 201
  } ],
  205: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _utils = require("./utils");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var color3 = (function() {
      function color3() {
        var r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
        var g = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
        var b = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
        _classCallCheck(this, color3);
        this.r = r;
        this.g = g;
        this.b = b;
      }
      color3.create = function create() {
        var r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
        var g = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
        var b = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
        return new color3(r, g, b);
      };
      color3.clone = function clone(a) {
        return new color3(a.r, a.g, a.b);
      };
      color3.copy = function copy(out, a) {
        out.r = a.r;
        out.g = a.g;
        out.b = a.b;
        return out;
      };
      color3.set = function set(out, r, g, b) {
        out.r = r;
        out.g = g;
        out.b = b;
        return out;
      };
      color3.fromHex = function fromHex(out, hex) {
        var r = (hex >> 16) / 255;
        var g = (hex >> 8 & 255) / 255;
        var b = (255 & hex) / 255;
        out.r = r;
        out.g = g;
        out.b = b;
        return out;
      };
      color3.add = function add(out, a, b) {
        out.r = a.r + b.r;
        out.g = a.g + b.g;
        out.b = a.b + b.b;
        return out;
      };
      color3.subtract = function subtract(out, a, b) {
        out.r = a.r - b.r;
        out.g = a.g - b.g;
        out.b = a.b - b.b;
        return out;
      };
      color3.sub = function sub(out, a, b) {
        return color3.subtract(out, a, b);
      };
      color3.multiply = function multiply(out, a, b) {
        out.r = a.r * b.r;
        out.g = a.g * b.g;
        out.b = a.b * b.b;
        return out;
      };
      color3.mul = function mul(out, a, b) {
        return color3.multiply(out, a, b);
      };
      color3.divide = function divide(out, a, b) {
        out.r = a.r / b.r;
        out.g = a.g / b.g;
        out.b = a.b / b.b;
        return out;
      };
      color3.div = function div(out, a, b) {
        return color3.divide(out, a, b);
      };
      color3.scale = function scale(out, a, b) {
        out.r = a.r * b;
        out.g = a.g * b;
        out.b = a.b * b;
        return out;
      };
      color3.lerp = function lerp(out, a, b, t) {
        var ar = a.r, ag = a.g, ab = a.b;
        out.r = ar + t * (b.r - ar);
        out.g = ag + t * (b.g - ag);
        out.b = ab + t * (b.b - ab);
        return out;
      };
      color3.str = function str(a) {
        return "color3(" + a.r + ", " + a.g + ", " + a.b + ")";
      };
      color3.array = function array(out, a) {
        var scale = a instanceof cc.Color ? 1 / 255 : 1;
        out[0] = a.r * scale;
        out[1] = a.g * scale;
        out[2] = a.b * scale;
        return out;
      };
      color3.exactEquals = function exactEquals(a, b) {
        return a.r === b.r && a.g === b.g && a.b === b.b;
      };
      color3.equals = function equals(a, b) {
        var a0 = a.r, a1 = a.g, a2 = a.b;
        var b0 = b.r, b1 = b.g, b2 = b.b;
        return Math.abs(a0 - b0) <= _utils.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _utils.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _utils.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
      };
      color3.hex = function hex(a) {
        return 255 * a.r << 16 | 255 * a.g << 8 | 255 * a.b;
      };
      return color3;
    })();
    exports.default = color3;
    module.exports = exports["default"];
  }), {
    "./utils": 213
  } ],
  206: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _utils = require("./utils");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var color4 = (function() {
      function color4() {
        var r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
        var g = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
        var b = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
        var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        _classCallCheck(this, color4);
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
      }
      color4.create = function create() {
        var r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
        var g = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
        var b = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
        var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        return new color4(r, g, b, a);
      };
      color4.clone = function clone(a) {
        return new color4(a.r, a.g, a.b, a.a);
      };
      color4.copy = function copy(out, a) {
        out.r = a.r;
        out.g = a.g;
        out.b = a.b;
        out.a = a.a;
        return out;
      };
      color4.set = function set(out, r, g, b, a) {
        out.r = r;
        out.g = g;
        out.b = b;
        out.a = a;
        return out;
      };
      color4.fromHex = function fromHex(out, hex) {
        var r = (hex >> 24) / 255;
        var g = (hex >> 16 & 255) / 255;
        var b = (hex >> 8 & 255) / 255;
        var a = (255 & hex) / 255;
        out.r = r;
        out.g = g;
        out.b = b;
        out.a = a;
        return out;
      };
      color4.add = function add(out, a, b) {
        out.r = a.r + b.r;
        out.g = a.g + b.g;
        out.b = a.b + b.b;
        out.a = a.a + b.a;
        return out;
      };
      color4.subtract = function subtract(out, a, b) {
        out.r = a.r - b.r;
        out.g = a.g - b.g;
        out.b = a.b - b.b;
        out.a = a.a - b.a;
        return out;
      };
      color4.sub = function sub(out, a, b) {
        return color4.subtract(out, a, b);
      };
      color4.multiply = function multiply(out, a, b) {
        out.r = a.r * b.r;
        out.g = a.g * b.g;
        out.b = a.b * b.b;
        out.a = a.a * b.a;
        return out;
      };
      color4.mul = function mul(out, a, b) {
        return color4.multiply(out, a, b);
      };
      color4.divide = function divide(out, a, b) {
        out.r = a.r / b.r;
        out.g = a.g / b.g;
        out.b = a.b / b.b;
        out.a = a.a / b.a;
        return out;
      };
      color4.div = function div(out, a, b) {
        return color4.divide(out, a, b);
      };
      color4.scale = function scale(out, a, b) {
        out.r = a.r * b;
        out.g = a.g * b;
        out.b = a.b * b;
        out.a = a.a * b;
        return out;
      };
      color4.lerp = function lerp(out, a, b, t) {
        var ar = a.r, ag = a.g, ab = a.b, aa = a.a;
        out.r = ar + t * (b.r - ar);
        out.g = ag + t * (b.g - ag);
        out.b = ab + t * (b.b - ab);
        out.a = aa + t * (b.a - aa);
        return out;
      };
      color4.str = function str(a) {
        return "color4(" + a.r + ", " + a.g + ", " + a.b + ", " + a.a + ")";
      };
      color4.array = function array(out, a) {
        var scale = a instanceof cc.Color || a.a > 1 ? 1 / 255 : 1;
        out[0] = a.r * scale;
        out[1] = a.g * scale;
        out[2] = a.b * scale;
        out[3] = a.a * scale;
        return out;
      };
      color4.exactEquals = function exactEquals(a, b) {
        return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
      };
      color4.equals = function equals(a, b) {
        var a0 = a.r, a1 = a.g, a2 = a.b, a3 = a.a;
        var b0 = b.r, b1 = b.g, b2 = b.b, b3 = b.a;
        return Math.abs(a0 - b0) <= _utils.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _utils.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _utils.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _utils.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
      };
      color4.hex = function hex(a) {
        return (255 * a.r << 24 | 255 * a.g << 16 | 255 * a.b << 8 | 255 * a.a) >>> 0;
      };
      return color4;
    })();
    exports.default = color4;
    module.exports = exports["default"];
  }), {
    "./utils": 213
  } ],
  207: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.color4 = exports.color3 = exports.mat4 = exports.mat3 = exports.mat23 = exports.mat2 = exports.quat = exports.vec4 = exports.vec3 = exports.vec2 = void 0;
    var _utils = require("./utils");
    Object.keys(_utils).forEach((function(key) {
      if ("default" === key || "__esModule" === key) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _utils[key];
        }
      });
    }));
    var _vec = require("./vec2");
    var _vec2 = _interopRequireDefault(_vec);
    var _vec3 = require("./vec3");
    var _vec4 = _interopRequireDefault(_vec3);
    var _vec5 = require("./vec4");
    var _vec6 = _interopRequireDefault(_vec5);
    var _quat = require("./quat");
    var _quat2 = _interopRequireDefault(_quat);
    var _mat = require("./mat2");
    var _mat2 = _interopRequireDefault(_mat);
    var _mat3 = require("./mat23");
    var _mat4 = _interopRequireDefault(_mat3);
    var _mat5 = require("./mat3");
    var _mat6 = _interopRequireDefault(_mat5);
    var _mat7 = require("./mat4");
    var _mat8 = _interopRequireDefault(_mat7);
    var _color = require("./color3");
    var _color2 = _interopRequireDefault(_color);
    var _color3 = require("./color4");
    var _color4 = _interopRequireDefault(_color3);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    exports.vec2 = _vec2.default;
    exports.vec3 = _vec4.default;
    exports.vec4 = _vec6.default;
    exports.quat = _quat2.default;
    exports.mat2 = _mat2.default;
    exports.mat23 = _mat4.default;
    exports.mat3 = _mat6.default;
    exports.mat4 = _mat8.default;
    exports.color3 = _color2.default;
    exports.color4 = _color4.default;
    exports.default = {
      vec2: _vec2.default,
      vec3: _vec4.default,
      vec4: _vec6.default,
      quat: _quat2.default,
      mat2: _mat2.default,
      mat23: _mat4.default,
      mat3: _mat6.default,
      mat4: _mat8.default,
      color3: _color2.default,
      color4: _color4.default
    };
  }), {
    "./color3": 205,
    "./color4": 206,
    "./mat2": 208,
    "./mat23": 209,
    "./mat3": 210,
    "./mat4": 211,
    "./quat": 212,
    "./utils": 213,
    "./vec2": 214,
    "./vec3": 215,
    "./vec4": 216
  } ],
  208: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _utils = require("./utils");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var mat2 = (function() {
      function mat2() {
        var m00 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
        var m01 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        var m02 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        var m03 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        _classCallCheck(this, mat2);
        this.m00 = m00;
        this.m01 = m01;
        this.m02 = m02;
        this.m03 = m03;
      }
      mat2.create = function create() {
        var m00 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
        var m01 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        var m02 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        var m03 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        return new mat2(m00, m01, m02, m03);
      };
      mat2.clone = function clone(a) {
        return new mat2(a.m00, a.m01, a.m02, a.m03);
      };
      mat2.copy = function copy(out, a) {
        out.m00 = a.m00;
        out.m01 = a.m01;
        out.m02 = a.m02;
        out.m03 = a.m03;
        return out;
      };
      mat2.identity = function identity(out) {
        out.m00 = 1;
        out.m01 = 0;
        out.m02 = 0;
        out.m03 = 1;
        return out;
      };
      mat2.set = function set(out, m00, m01, m10, m11) {
        out.m00 = m00;
        out.m01 = m01;
        out.m02 = m10;
        out.m03 = m11;
        return out;
      };
      mat2.transpose = function transpose(out, a) {
        if (out === a) {
          var a1 = a.m01;
          out.m01 = a.m02;
          out.m02 = a1;
        } else {
          out.m00 = a.m00;
          out.m01 = a.m02;
          out.m02 = a.m01;
          out.m03 = a.m03;
        }
        return out;
      };
      mat2.invert = function invert(out, a) {
        var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03;
        var det = a0 * a3 - a2 * a1;
        if (!det) return null;
        det = 1 / det;
        out.m00 = a3 * det;
        out.m01 = -a1 * det;
        out.m02 = -a2 * det;
        out.m03 = a0 * det;
        return out;
      };
      mat2.adjoint = function adjoint(out, a) {
        var a0 = a.m00;
        out.m00 = a.m03;
        out.m01 = -a.m01;
        out.m02 = -a.m02;
        out.m03 = a0;
        return out;
      };
      mat2.determinant = function determinant(a) {
        return a.m00 * a.m03 - a.m02 * a.m01;
      };
      mat2.multiply = function multiply(out, a, b) {
        var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03;
        var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03;
        out.m00 = a0 * b0 + a2 * b1;
        out.m01 = a1 * b0 + a3 * b1;
        out.m02 = a0 * b2 + a2 * b3;
        out.m03 = a1 * b2 + a3 * b3;
        return out;
      };
      mat2.mul = function mul(out, a, b) {
        return mat2.multiply(out, a, b);
      };
      mat2.rotate = function rotate(out, a, rad) {
        var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, s = Math.sin(rad), c = Math.cos(rad);
        out.m00 = a0 * c + a2 * s;
        out.m01 = a1 * c + a3 * s;
        out.m02 = a0 * -s + a2 * c;
        out.m03 = a1 * -s + a3 * c;
        return out;
      };
      mat2.scale = function scale(out, a, v) {
        var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, v0 = v.x, v1 = v.y;
        out.m00 = a0 * v0;
        out.m01 = a1 * v0;
        out.m02 = a2 * v1;
        out.m03 = a3 * v1;
        return out;
      };
      mat2.fromRotation = function fromRotation(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);
        out.m00 = c;
        out.m01 = s;
        out.m02 = -s;
        out.m03 = c;
        return out;
      };
      mat2.fromScaling = function fromScaling(out, v) {
        out.m00 = v.x;
        out.m01 = 0;
        out.m02 = 0;
        out.m03 = v.y;
        return out;
      };
      mat2.str = function str(a) {
        return "mat2(" + a.m00 + ", " + a.m01 + ", " + a.m02 + ", " + a.m03 + ")";
      };
      mat2.array = function array(out, m) {
        out[0] = m.m00;
        out[1] = m.m01;
        out[2] = m.m02;
        out[3] = m.m03;
        return out;
      };
      mat2.frob = function frob(a) {
        return Math.sqrt(Math.pow(a.m00, 2) + Math.pow(a.m01, 2) + Math.pow(a.m02, 2) + Math.pow(a.m03, 2));
      };
      mat2.LDU = function LDU(L, D, U, a) {
        L.m02 = a.m02 / a.m00;
        U.m00 = a.m00;
        U.m01 = a.m01;
        U.m03 = a.m03 - L.m02 * U.m01;
      };
      mat2.add = function add(out, a, b) {
        out.m00 = a.m00 + b.m00;
        out.m01 = a.m01 + b.m01;
        out.m02 = a.m02 + b.m02;
        out.m03 = a.m03 + b.m03;
        return out;
      };
      mat2.subtract = function subtract(out, a, b) {
        out.m00 = a.m00 - b.m00;
        out.m01 = a.m01 - b.m01;
        out.m02 = a.m02 - b.m02;
        out.m03 = a.m03 - b.m03;
        return out;
      };
      mat2.sub = function sub(out, a, b) {
        return mat2.subtract(out, a, b);
      };
      mat2.exactEquals = function exactEquals(a, b) {
        return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03;
      };
      mat2.equals = function equals(a, b) {
        var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03;
        var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03;
        return Math.abs(a0 - b0) <= _utils.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _utils.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _utils.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _utils.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
      };
      mat2.multiplyScalar = function multiplyScalar(out, a, b) {
        out.m00 = a.m00 * b;
        out.m01 = a.m01 * b;
        out.m02 = a.m02 * b;
        out.m03 = a.m03 * b;
        return out;
      };
      mat2.multiplyScalarAndAdd = function multiplyScalarAndAdd(out, a, b, scale) {
        out.m00 = a.m00 + b.m00 * scale;
        out.m01 = a.m01 + b.m01 * scale;
        out.m02 = a.m02 + b.m02 * scale;
        out.m03 = a.m03 + b.m03 * scale;
        return out;
      };
      return mat2;
    })();
    exports.default = mat2;
    module.exports = exports["default"];
  }), {
    "./utils": 213
  } ],
  209: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _utils = require("./utils");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var mat23 = (function() {
      function mat23() {
        var m00 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
        var m01 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        var m02 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        var m03 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        var m04 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
        var m05 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
        _classCallCheck(this, mat23);
        this.m00 = m00;
        this.m01 = m01;
        this.m02 = m02;
        this.m03 = m03;
        this.m04 = m04;
        this.m05 = m05;
      }
      mat23.create = function create() {
        var m00 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
        var m01 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        var m02 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        var m03 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        var m04 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
        var m05 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
        return new mat23(m00, m01, m02, m03, m04, m05);
      };
      mat23.clone = function clone(a) {
        return new mat23(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05);
      };
      mat23.copy = function copy(out, a) {
        out.m00 = a.m00;
        out.m01 = a.m01;
        out.m02 = a.m02;
        out.m03 = a.m03;
        out.m04 = a.m04;
        out.m05 = a.m05;
        return out;
      };
      mat23.identity = function identity(out) {
        out.m00 = 1;
        out.m01 = 0;
        out.m02 = 0;
        out.m03 = 1;
        out.m04 = 0;
        out.m05 = 0;
        return out;
      };
      mat23.set = function set(out, a, b, c, d, tx, ty) {
        out.m00 = a;
        out.m01 = b;
        out.m02 = c;
        out.m03 = d;
        out.m04 = tx;
        out.m05 = ty;
        return out;
      };
      mat23.invert = function invert(out, a) {
        var aa = a.m00, ab = a.m01, ac = a.m02, ad = a.m03, atx = a.m04, aty = a.m05;
        var det = aa * ad - ab * ac;
        if (!det) return null;
        det = 1 / det;
        out.m00 = ad * det;
        out.m01 = -ab * det;
        out.m02 = -ac * det;
        out.m03 = aa * det;
        out.m04 = (ac * aty - ad * atx) * det;
        out.m05 = (ab * atx - aa * aty) * det;
        return out;
      };
      mat23.determinant = function determinant(a) {
        return a.m00 * a.m03 - a.m01 * a.m02;
      };
      mat23.multiply = function multiply(out, a, b) {
        var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05, b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03, b4 = b.m04, b5 = b.m05;
        out.m00 = a0 * b0 + a2 * b1;
        out.m01 = a1 * b0 + a3 * b1;
        out.m02 = a0 * b2 + a2 * b3;
        out.m03 = a1 * b2 + a3 * b3;
        out.m04 = a0 * b4 + a2 * b5 + a4;
        out.m05 = a1 * b4 + a3 * b5 + a5;
        return out;
      };
      mat23.mul = function mul(out, a, b) {
        return mat23.multiply(out, a, b);
      };
      mat23.rotate = function rotate(out, a, rad) {
        var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05, s = Math.sin(rad), c = Math.cos(rad);
        out.m00 = a0 * c + a2 * s;
        out.m01 = a1 * c + a3 * s;
        out.m02 = a0 * -s + a2 * c;
        out.m03 = a1 * -s + a3 * c;
        out.m04 = a4;
        out.m05 = a5;
        return out;
      };
      mat23.scale = function scale(out, a, v) {
        var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05, v0 = v.x, v1 = v.y;
        out.m00 = a0 * v0;
        out.m01 = a1 * v0;
        out.m02 = a2 * v1;
        out.m03 = a3 * v1;
        out.m04 = a4;
        out.m05 = a5;
        return out;
      };
      mat23.translate = function translate(out, a, v) {
        var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05, v0 = v.x, v1 = v.y;
        out.m00 = a0;
        out.m01 = a1;
        out.m02 = a2;
        out.m03 = a3;
        out.m04 = a0 * v0 + a2 * v1 + a4;
        out.m05 = a1 * v0 + a3 * v1 + a5;
        return out;
      };
      mat23.fromRotation = function fromRotation(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);
        out.m00 = c;
        out.m01 = s;
        out.m02 = -s;
        out.m03 = c;
        out.m04 = 0;
        out.m05 = 0;
        return out;
      };
      mat23.fromScaling = function fromScaling(out, v) {
        out.m00 = v.m00;
        out.m01 = 0;
        out.m02 = 0;
        out.m03 = v.m01;
        out.m04 = 0;
        out.m05 = 0;
        return out;
      };
      mat23.fromTranslation = function fromTranslation(out, v) {
        out.m00 = 1;
        out.m01 = 0;
        out.m02 = 0;
        out.m03 = 1;
        out.m04 = v.x;
        out.m05 = v.y;
        return out;
      };
      mat23.fromRTS = function fromRTS(out, r, t, s) {
        var sr = Math.sin(r), cr = Math.cos(r);
        out.m00 = cr * s.x;
        out.m01 = sr * s.x;
        out.m02 = -sr * s.y;
        out.m03 = cr * s.y;
        out.m04 = t.x;
        out.m05 = t.y;
        return out;
      };
      mat23.str = function str(a) {
        return "mat23(" + a.m00 + ", " + a.m01 + ", " + a.m02 + ", " + a.m03 + ", " + a.m04 + ", " + a.m05 + ")";
      };
      mat23.array = function array(out, m) {
        out[0] = m.m00;
        out[1] = m.m01;
        out[2] = m.m02;
        out[3] = m.m03;
        out[4] = m.m04;
        out[5] = m.m05;
        return out;
      };
      mat23.array4x4 = function array4x4(out, m) {
        out[0] = m.m00;
        out[1] = m.m01;
        out[2] = 0;
        out[3] = 0;
        out[4] = m.m02;
        out[5] = m.m03;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = m.m04;
        out[13] = m.m05;
        out[14] = 0;
        out[15] = 1;
        return out;
      };
      mat23.frob = function frob(a) {
        return Math.sqrt(Math.pow(a.m00, 2) + Math.pow(a.m01, 2) + Math.pow(a.m02, 2) + Math.pow(a.m03, 2) + Math.pow(a.m04, 2) + Math.pow(a.m05, 2) + 1);
      };
      mat23.add = function add(out, a, b) {
        out.m00 = a.m00 + b.m00;
        out.m01 = a.m01 + b.m01;
        out.m02 = a.m02 + b.m02;
        out.m03 = a.m03 + b.m03;
        out.m04 = a.m04 + b.m04;
        out.m05 = a.m05 + b.m05;
        return out;
      };
      mat23.subtract = function subtract(out, a, b) {
        out.m00 = a.m00 - b.m00;
        out.m01 = a.m01 - b.m01;
        out.m02 = a.m02 - b.m02;
        out.m03 = a.m03 - b.m03;
        out.m04 = a.m04 - b.m04;
        out.m05 = a.m05 - b.m05;
        return out;
      };
      mat23.sub = function sub(out, a, b) {
        return mat23.subtract(out, a, b);
      };
      mat23.multiplyScalar = function multiplyScalar(out, a, b) {
        out.m00 = a.m00 * b;
        out.m01 = a.m01 * b;
        out.m02 = a.m02 * b;
        out.m03 = a.m03 * b;
        out.m04 = a.m04 * b;
        out.m05 = a.m05 * b;
        return out;
      };
      mat23.multiplyScalarAndAdd = function multiplyScalarAndAdd(out, a, b, scale) {
        out.m00 = a.m00 + b.m00 * scale;
        out.m01 = a.m01 + b.m01 * scale;
        out.m02 = a.m02 + b.m02 * scale;
        out.m03 = a.m03 + b.m03 * scale;
        out.m04 = a.m04 + b.m04 * scale;
        out.m05 = a.m05 + b.m05 * scale;
        return out;
      };
      mat23.exactEquals = function exactEquals(a, b) {
        return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05;
      };
      mat23.equals = function equals(a, b) {
        var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05;
        var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03, b4 = b.m04, b5 = b.m05;
        return Math.abs(a0 - b0) <= _utils.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _utils.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _utils.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _utils.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _utils.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _utils.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5));
      };
      return mat23;
    })();
    exports.default = mat23;
    module.exports = exports["default"];
  }), {
    "./utils": 213
  } ],
  210: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _utils = require("./utils");
    var _vec = require("./vec3");
    var _vec2 = _interopRequireDefault(_vec);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var mat3 = (function() {
      function mat3() {
        var m00 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
        var m01 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        var m02 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        var m03 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
        var m04 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1;
        var m05 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
        var m06 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0;
        var m07 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0;
        var m08 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 1;
        _classCallCheck(this, mat3);
        this.m00 = m00;
        this.m01 = m01;
        this.m02 = m02;
        this.m03 = m03;
        this.m04 = m04;
        this.m05 = m05;
        this.m06 = m06;
        this.m07 = m07;
        this.m08 = m08;
      }
      mat3.create = function create() {
        var m00 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
        var m01 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        var m02 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        var m03 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
        var m04 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1;
        var m05 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
        var m06 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0;
        var m07 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0;
        var m08 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 1;
        return new mat3(m00, m01, m02, m03, m04, m05, m06, m07, m08);
      };
      mat3.clone = function clone(a) {
        return new mat3(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08);
      };
      mat3.copy = function copy(out, a) {
        out.m00 = a.m00;
        out.m01 = a.m01;
        out.m02 = a.m02;
        out.m03 = a.m03;
        out.m04 = a.m04;
        out.m05 = a.m05;
        out.m06 = a.m06;
        out.m07 = a.m07;
        out.m08 = a.m08;
        return out;
      };
      mat3.set = function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
        out.m00 = m00;
        out.m01 = m01;
        out.m02 = m02;
        out.m03 = m10;
        out.m04 = m11;
        out.m05 = m12;
        out.m06 = m20;
        out.m07 = m21;
        out.m08 = m22;
        return out;
      };
      mat3.identity = function identity(out) {
        out.m00 = 1;
        out.m01 = 0;
        out.m02 = 0;
        out.m03 = 0;
        out.m04 = 1;
        out.m05 = 0;
        out.m06 = 0;
        out.m07 = 0;
        out.m08 = 1;
        return out;
      };
      mat3.transpose = function transpose(out, a) {
        if (out === a) {
          var a01 = a.m01, a02 = a.m02, a12 = a.m05;
          out.m01 = a.m03;
          out.m02 = a.m06;
          out.m03 = a01;
          out.m05 = a.m07;
          out.m06 = a02;
          out.m07 = a12;
        } else {
          out.m00 = a.m00;
          out.m01 = a.m03;
          out.m02 = a.m06;
          out.m03 = a.m01;
          out.m04 = a.m04;
          out.m05 = a.m07;
          out.m06 = a.m02;
          out.m07 = a.m05;
          out.m08 = a.m08;
        }
        return out;
      };
      mat3.invert = function invert(out, a) {
        var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08;
        var b01 = a22 * a11 - a12 * a21;
        var b11 = -a22 * a10 + a12 * a20;
        var b21 = a21 * a10 - a11 * a20;
        var det = a00 * b01 + a01 * b11 + a02 * b21;
        if (!det) return null;
        det = 1 / det;
        out.m00 = b01 * det;
        out.m01 = (-a22 * a01 + a02 * a21) * det;
        out.m02 = (a12 * a01 - a02 * a11) * det;
        out.m03 = b11 * det;
        out.m04 = (a22 * a00 - a02 * a20) * det;
        out.m05 = (-a12 * a00 + a02 * a10) * det;
        out.m06 = b21 * det;
        out.m07 = (-a21 * a00 + a01 * a20) * det;
        out.m08 = (a11 * a00 - a01 * a10) * det;
        return out;
      };
      mat3.adjoint = function adjoint(out, a) {
        var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08;
        out.m00 = a11 * a22 - a12 * a21;
        out.m01 = a02 * a21 - a01 * a22;
        out.m02 = a01 * a12 - a02 * a11;
        out.m03 = a12 * a20 - a10 * a22;
        out.m04 = a00 * a22 - a02 * a20;
        out.m05 = a02 * a10 - a00 * a12;
        out.m06 = a10 * a21 - a11 * a20;
        out.m07 = a01 * a20 - a00 * a21;
        out.m08 = a00 * a11 - a01 * a10;
        return out;
      };
      mat3.determinant = function determinant(a) {
        var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08;
        return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
      };
      mat3.multiply = function multiply(out, a, b) {
        var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08;
        var b00 = b.m00, b01 = b.m01, b02 = b.m02;
        var b10 = b.m03, b11 = b.m04, b12 = b.m05;
        var b20 = b.m06, b21 = b.m07, b22 = b.m08;
        out.m00 = b00 * a00 + b01 * a10 + b02 * a20;
        out.m01 = b00 * a01 + b01 * a11 + b02 * a21;
        out.m02 = b00 * a02 + b01 * a12 + b02 * a22;
        out.m03 = b10 * a00 + b11 * a10 + b12 * a20;
        out.m04 = b10 * a01 + b11 * a11 + b12 * a21;
        out.m05 = b10 * a02 + b11 * a12 + b12 * a22;
        out.m06 = b20 * a00 + b21 * a10 + b22 * a20;
        out.m07 = b20 * a01 + b21 * a11 + b22 * a21;
        out.m08 = b20 * a02 + b21 * a12 + b22 * a22;
        return out;
      };
      mat3.mul = function mul(out, a, b) {
        return mat3.multiply(out, a, b);
      };
      mat3.translate = function translate(out, a, v) {
        var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08;
        var x = v.x, y = v.y;
        out.m00 = a00;
        out.m01 = a01;
        out.m02 = a02;
        out.m03 = a10;
        out.m04 = a11;
        out.m05 = a12;
        out.m06 = x * a00 + y * a10 + a20;
        out.m07 = x * a01 + y * a11 + a21;
        out.m08 = x * a02 + y * a12 + a22;
        return out;
      };
      mat3.rotate = function rotate(out, a, rad) {
        var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08;
        var s = Math.sin(rad);
        var c = Math.cos(rad);
        out.m00 = c * a00 + s * a10;
        out.m01 = c * a01 + s * a11;
        out.m02 = c * a02 + s * a12;
        out.m03 = c * a10 - s * a00;
        out.m04 = c * a11 - s * a01;
        out.m05 = c * a12 - s * a02;
        out.m06 = a20;
        out.m07 = a21;
        out.m08 = a22;
        return out;
      };
      mat3.scale = function scale(out, a, v) {
        var x = v.x, y = v.y;
        out.m00 = x * a.m00;
        out.m01 = x * a.m01;
        out.m02 = x * a.m02;
        out.m03 = y * a.m03;
        out.m04 = y * a.m04;
        out.m05 = y * a.m05;
        out.m06 = a.m06;
        out.m07 = a.m07;
        out.m08 = a.m08;
        return out;
      };
      mat3.fromMat4 = function fromMat4(out, a) {
        out.m00 = a.m00;
        out.m01 = a.m01;
        out.m02 = a.m02;
        out.m03 = a.m04;
        out.m04 = a.m05;
        out.m05 = a.m06;
        out.m06 = a.m08;
        out.m07 = a.m09;
        out.m08 = a.m10;
        return out;
      };
      mat3.fromTranslation = function fromTranslation(out, v) {
        out.m00 = 1;
        out.m01 = 0;
        out.m02 = 0;
        out.m03 = 0;
        out.m04 = 1;
        out.m05 = 0;
        out.m06 = v.x;
        out.m07 = v.y;
        out.m08 = 1;
        return out;
      };
      mat3.fromRotation = function fromRotation(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);
        out.m00 = c;
        out.m01 = s;
        out.m02 = 0;
        out.m03 = -s;
        out.m04 = c;
        out.m05 = 0;
        out.m06 = 0;
        out.m07 = 0;
        out.m08 = 1;
        return out;
      };
      mat3.fromScaling = function fromScaling(out, v) {
        out.m00 = v.x;
        out.m01 = 0;
        out.m02 = 0;
        out.m03 = 0;
        out.m04 = v.y;
        out.m05 = 0;
        out.m06 = 0;
        out.m07 = 0;
        out.m08 = 1;
        return out;
      };
      mat3.fromMat2d = function fromMat2d(out, a) {
        out.m00 = a.m00;
        out.m01 = a.m01;
        out.m02 = 0;
        out.m03 = a.m02;
        out.m04 = a.m03;
        out.m05 = 0;
        out.m06 = a.m04;
        out.m07 = a.m05;
        out.m08 = 1;
        return out;
      };
      mat3.fromQuat = function fromQuat(out, q) {
        var x = q.x, y = q.y, z = q.z, w = q.w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var yx = y * x2;
        var yy = y * y2;
        var zx = z * x2;
        var zy = z * y2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        out.m00 = 1 - yy - zz;
        out.m03 = yx - wz;
        out.m06 = zx + wy;
        out.m01 = yx + wz;
        out.m04 = 1 - xx - zz;
        out.m07 = zy - wx;
        out.m02 = zx - wy;
        out.m05 = zy + wx;
        out.m08 = 1 - xx - yy;
        return out;
      };
      mat3.fromViewUp = function fromViewUp(out, view, up) {
        var _fromViewUpIIFE = (function() {
          var default_up = _vec2.default.create(0, 1, 0);
          var x = _vec2.default.create(0, 0, 0);
          var y = _vec2.default.create(0, 0, 0);
          return function(out, view, up) {
            if (_vec2.default.sqrMag(view) < _utils.EPSILON * _utils.EPSILON) {
              mat3.identity(out);
              return out;
            }
            up = up || default_up;
            _vec2.default.normalize(x, _vec2.default.cross(x, up, view));
            if (_vec2.default.sqrMag(x) < _utils.EPSILON * _utils.EPSILON) {
              mat3.identity(out);
              return out;
            }
            _vec2.default.cross(y, view, x);
            mat3.set(out, x.x, x.y, x.z, y.x, y.y, y.z, view.x, view.y, view.z);
            return out;
          };
        })();
        return _fromViewUpIIFE(out, view, up);
      };
      mat3.normalFromMat4 = function normalFromMat4(out, a) {
        var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15;
        var b00 = a00 * a11 - a01 * a10;
        var b01 = a00 * a12 - a02 * a10;
        var b02 = a00 * a13 - a03 * a10;
        var b03 = a01 * a12 - a02 * a11;
        var b04 = a01 * a13 - a03 * a11;
        var b05 = a02 * a13 - a03 * a12;
        var b06 = a20 * a31 - a21 * a30;
        var b07 = a20 * a32 - a22 * a30;
        var b08 = a20 * a33 - a23 * a30;
        var b09 = a21 * a32 - a22 * a31;
        var b10 = a21 * a33 - a23 * a31;
        var b11 = a22 * a33 - a23 * a32;
        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (!det) return null;
        det = 1 / det;
        out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
        out.m03 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        out.m04 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        out.m05 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
        out.m06 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        out.m07 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        out.m08 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
        return out;
      };
      mat3.str = function str(a) {
        return "mat3(" + a.m00 + ", " + a.m01 + ", " + a.m02 + ", " + a.m03 + ", " + a.m04 + ", " + a.m05 + ", " + a.m06 + ", " + a.m07 + ", " + a.m08 + ")";
      };
      mat3.array = function array(out, m) {
        out[0] = m.m00;
        out[1] = m.m01;
        out[2] = m.m02;
        out[3] = m.m03;
        out[4] = m.m04;
        out[5] = m.m05;
        out[6] = m.m06;
        out[7] = m.m07;
        out[8] = m.m08;
        return out;
      };
      mat3.frob = function frob(a) {
        return Math.sqrt(Math.pow(a.m00, 2) + Math.pow(a.m01, 2) + Math.pow(a.m02, 2) + Math.pow(a.m03, 2) + Math.pow(a.m04, 2) + Math.pow(a.m05, 2) + Math.pow(a.m06, 2) + Math.pow(a.m07, 2) + Math.pow(a.m08, 2));
      };
      mat3.add = function add(out, a, b) {
        out.m00 = a.m00 + b.m00;
        out.m01 = a.m01 + b.m01;
        out.m02 = a.m02 + b.m02;
        out.m03 = a.m03 + b.m03;
        out.m04 = a.m04 + b.m04;
        out.m05 = a.m05 + b.m05;
        out.m06 = a.m06 + b.m06;
        out.m07 = a.m07 + b.m07;
        out.m08 = a.m08 + b.m08;
        return out;
      };
      mat3.subtract = function subtract(out, a, b) {
        out.m00 = a.m00 - b.m00;
        out.m01 = a.m01 - b.m01;
        out.m02 = a.m02 - b.m02;
        out.m03 = a.m03 - b.m03;
        out.m04 = a.m04 - b.m04;
        out.m05 = a.m05 - b.m05;
        out.m06 = a.m06 - b.m06;
        out.m07 = a.m07 - b.m07;
        out.m08 = a.m08 - b.m08;
        return out;
      };
      mat3.sub = function sub(out, a, b) {
        return mat3.subtract(out, a, b);
      };
      mat3.multiplyScalar = function multiplyScalar(out, a, b) {
        out.m00 = a.m00 * b;
        out.m01 = a.m01 * b;
        out.m02 = a.m02 * b;
        out.m03 = a.m03 * b;
        out.m04 = a.m04 * b;
        out.m05 = a.m05 * b;
        out.m06 = a.m06 * b;
        out.m07 = a.m07 * b;
        out.m08 = a.m08 * b;
        return out;
      };
      mat3.multiplyScalarAndAdd = function multiplyScalarAndAdd(out, a, b, scale) {
        out.m00 = a.m00 + b.m00 * scale;
        out.m01 = a.m01 + b.m01 * scale;
        out.m02 = a.m02 + b.m02 * scale;
        out.m03 = a.m03 + b.m03 * scale;
        out.m04 = a.m04 + b.m04 * scale;
        out.m05 = a.m05 + b.m05 * scale;
        out.m06 = a.m06 + b.m06 * scale;
        out.m07 = a.m07 + b.m07 * scale;
        out.m08 = a.m08 + b.m08 * scale;
        return out;
      };
      mat3.exactEquals = function exactEquals(a, b) {
        return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08;
      };
      mat3.equals = function equals(a, b) {
        var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05, a6 = a.m06, a7 = a.m07, a8 = a.m08;
        var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03, b4 = b.m04, b5 = b.m05, b6 = b.m06, b7 = b.m07, b8 = b.m08;
        return Math.abs(a0 - b0) <= _utils.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _utils.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _utils.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _utils.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _utils.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _utils.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _utils.EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _utils.EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _utils.EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
      };
      return mat3;
    })();
    exports.default = mat3;
    module.exports = exports["default"];
  }), {
    "./utils": 213,
    "./vec3": 215
  } ],
  211: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _utils = require("./utils");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var mat4 = (function() {
      function mat4() {
        var m00 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
        var m01 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        var m02 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        var m03 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
        var m04 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
        var m05 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1;
        var m06 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0;
        var m07 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0;
        var m08 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0;
        var m09 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0;
        var m10 = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : 1;
        var m11 = arguments.length > 11 && void 0 !== arguments[11] ? arguments[11] : 0;
        var m12 = arguments.length > 12 && void 0 !== arguments[12] ? arguments[12] : 0;
        var m13 = arguments.length > 13 && void 0 !== arguments[13] ? arguments[13] : 0;
        var m14 = arguments.length > 14 && void 0 !== arguments[14] ? arguments[14] : 0;
        var m15 = arguments.length > 15 && void 0 !== arguments[15] ? arguments[15] : 1;
        _classCallCheck(this, mat4);
        this.m00 = m00;
        this.m01 = m01;
        this.m02 = m02;
        this.m03 = m03;
        this.m04 = m04;
        this.m05 = m05;
        this.m06 = m06;
        this.m07 = m07;
        this.m08 = m08;
        this.m09 = m09;
        this.m10 = m10;
        this.m11 = m11;
        this.m12 = m12;
        this.m13 = m13;
        this.m14 = m14;
        this.m15 = m15;
      }
      mat4.create = function create() {
        var m00 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
        var m01 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        var m02 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        var m03 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
        var m04 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
        var m05 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1;
        var m06 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0;
        var m07 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0;
        var m08 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0;
        var m09 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0;
        var m10 = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : 1;
        var m11 = arguments.length > 11 && void 0 !== arguments[11] ? arguments[11] : 0;
        var m12 = arguments.length > 12 && void 0 !== arguments[12] ? arguments[12] : 0;
        var m13 = arguments.length > 13 && void 0 !== arguments[13] ? arguments[13] : 0;
        var m14 = arguments.length > 14 && void 0 !== arguments[14] ? arguments[14] : 0;
        var m15 = arguments.length > 15 && void 0 !== arguments[15] ? arguments[15] : 1;
        return new mat4(m00, m01, m02, m03, m04, m05, m06, m07, m08, m09, m10, m11, m12, m13, m14, m15);
      };
      mat4.clone = function clone(a) {
        return new mat4(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08, a.m09, a.m10, a.m11, a.m12, a.m13, a.m14, a.m15);
      };
      mat4.copy = function copy(out, a) {
        out.m00 = a.m00;
        out.m01 = a.m01;
        out.m02 = a.m02;
        out.m03 = a.m03;
        out.m04 = a.m04;
        out.m05 = a.m05;
        out.m06 = a.m06;
        out.m07 = a.m07;
        out.m08 = a.m08;
        out.m09 = a.m09;
        out.m10 = a.m10;
        out.m11 = a.m11;
        out.m12 = a.m12;
        out.m13 = a.m13;
        out.m14 = a.m14;
        out.m15 = a.m15;
        return out;
      };
      mat4.set = function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        out.m00 = m00;
        out.m01 = m01;
        out.m02 = m02;
        out.m03 = m03;
        out.m04 = m10;
        out.m05 = m11;
        out.m06 = m12;
        out.m07 = m13;
        out.m08 = m20;
        out.m09 = m21;
        out.m10 = m22;
        out.m11 = m23;
        out.m12 = m30;
        out.m13 = m31;
        out.m14 = m32;
        out.m15 = m33;
        return out;
      };
      mat4.identity = function identity(out) {
        out.m00 = 1;
        out.m01 = 0;
        out.m02 = 0;
        out.m03 = 0;
        out.m04 = 0;
        out.m05 = 1;
        out.m06 = 0;
        out.m07 = 0;
        out.m08 = 0;
        out.m09 = 0;
        out.m10 = 1;
        out.m11 = 0;
        out.m12 = 0;
        out.m13 = 0;
        out.m14 = 0;
        out.m15 = 1;
        return out;
      };
      mat4.transpose = function transpose(out, a) {
        if (out === a) {
          var a01 = a.m01, a02 = a.m02, a03 = a.m03, a12 = a.m06, a13 = a.m07, a23 = a.m11;
          out.m01 = a.m04;
          out.m02 = a.m08;
          out.m03 = a.m12;
          out.m04 = a01;
          out.m06 = a.m09;
          out.m07 = a.m13;
          out.m08 = a02;
          out.m09 = a12;
          out.m11 = a.m14;
          out.m12 = a03;
          out.m13 = a13;
          out.m14 = a23;
        } else {
          out.m00 = a.m00;
          out.m01 = a.m04;
          out.m02 = a.m08;
          out.m03 = a.m12;
          out.m04 = a.m01;
          out.m05 = a.m05;
          out.m06 = a.m09;
          out.m07 = a.m13;
          out.m08 = a.m02;
          out.m09 = a.m06;
          out.m10 = a.m10;
          out.m11 = a.m14;
          out.m12 = a.m03;
          out.m13 = a.m07;
          out.m14 = a.m11;
          out.m15 = a.m15;
        }
        return out;
      };
      mat4.invert = function invert(out, a) {
        var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15;
        var b00 = a00 * a11 - a01 * a10;
        var b01 = a00 * a12 - a02 * a10;
        var b02 = a00 * a13 - a03 * a10;
        var b03 = a01 * a12 - a02 * a11;
        var b04 = a01 * a13 - a03 * a11;
        var b05 = a02 * a13 - a03 * a12;
        var b06 = a20 * a31 - a21 * a30;
        var b07 = a20 * a32 - a22 * a30;
        var b08 = a20 * a33 - a23 * a30;
        var b09 = a21 * a32 - a22 * a31;
        var b10 = a21 * a33 - a23 * a31;
        var b11 = a22 * a33 - a23 * a32;
        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (!det) return null;
        det = 1 / det;
        out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        out.m01 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        out.m02 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        out.m03 = (a22 * b04 - a21 * b05 - a23 * b03) * det;
        out.m04 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        out.m06 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        out.m07 = (a20 * b05 - a22 * b02 + a23 * b01) * det;
        out.m08 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
        out.m09 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
        out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
        out.m11 = (a21 * b02 - a20 * b04 - a23 * b00) * det;
        out.m12 = (a11 * b07 - a10 * b09 - a12 * b06) * det;
        out.m13 = (a00 * b09 - a01 * b07 + a02 * b06) * det;
        out.m14 = (a31 * b01 - a30 * b03 - a32 * b00) * det;
        out.m15 = (a20 * b03 - a21 * b01 + a22 * b00) * det;
        return out;
      };
      mat4.adjoint = function adjoint(out, a) {
        var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15;
        out.m00 = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
        out.m01 = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
        out.m02 = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
        out.m03 = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
        out.m04 = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
        out.m05 = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
        out.m06 = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
        out.m07 = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
        out.m08 = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
        out.m09 = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
        out.m10 = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
        out.m11 = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
        out.m12 = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
        out.m13 = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
        out.m14 = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
        out.m15 = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
        return out;
      };
      mat4.determinant = function determinant(a) {
        var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15;
        var b00 = a00 * a11 - a01 * a10;
        var b01 = a00 * a12 - a02 * a10;
        var b02 = a00 * a13 - a03 * a10;
        var b03 = a01 * a12 - a02 * a11;
        var b04 = a01 * a13 - a03 * a11;
        var b05 = a02 * a13 - a03 * a12;
        var b06 = a20 * a31 - a21 * a30;
        var b07 = a20 * a32 - a22 * a30;
        var b08 = a20 * a33 - a23 * a30;
        var b09 = a21 * a32 - a22 * a31;
        var b10 = a21 * a33 - a23 * a31;
        var b11 = a22 * a33 - a23 * a32;
        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      };
      mat4.multiply = function multiply(out, a, b) {
        var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15;
        var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03;
        out.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b.m04;
        b1 = b.m05;
        b2 = b.m06;
        b3 = b.m07;
        out.m04 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out.m05 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out.m06 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out.m07 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b.m08;
        b1 = b.m09;
        b2 = b.m10;
        b3 = b.m11;
        out.m08 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out.m09 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out.m10 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out.m11 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b.m12;
        b1 = b.m13;
        b2 = b.m14;
        b3 = b.m15;
        out.m12 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out.m13 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out.m14 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out.m15 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        return out;
      };
      mat4.mul = function mul(out, a, b) {
        return mat4.multiply(out, a, b);
      };
      mat4.translate = function translate(out, a, v) {
        var x = v.x, y = v.y, z = v.z, a00 = void 0, a01 = void 0, a02 = void 0, a03 = void 0, a10 = void 0, a11 = void 0, a12 = void 0, a13 = void 0, a20 = void 0, a21 = void 0, a22 = void 0, a23 = void 0;
        if (a === out) {
          out.m12 = a.m00 * x + a.m04 * y + a.m08 * z + a.m12;
          out.m13 = a.m01 * x + a.m05 * y + a.m09 * z + a.m13;
          out.m14 = a.m02 * x + a.m06 * y + a.m10 * z + a.m14;
          out.m15 = a.m03 * x + a.m07 * y + a.m11 * z + a.m15;
        } else {
          a00 = a.m00;
          a01 = a.m01;
          a02 = a.m02;
          a03 = a.m03;
          a10 = a.m04;
          a11 = a.m05;
          a12 = a.m06;
          a13 = a.m07;
          a20 = a.m08;
          a21 = a.m09;
          a22 = a.m10;
          a23 = a.m11;
          out.m00 = a00;
          out.m01 = a01;
          out.m02 = a02;
          out.m03 = a03;
          out.m04 = a10;
          out.m05 = a11;
          out.m06 = a12;
          out.m07 = a13;
          out.m08 = a20;
          out.m09 = a21;
          out.m10 = a22;
          out.m11 = a23;
          out.m12 = a00 * x + a10 * y + a20 * z + a.m12;
          out.m13 = a01 * x + a11 * y + a21 * z + a.m13;
          out.m14 = a02 * x + a12 * y + a22 * z + a.m14;
          out.m15 = a03 * x + a13 * y + a23 * z + a.m15;
        }
        return out;
      };
      mat4.scale = function scale(out, a, v) {
        var x = v.x, y = v.y, z = v.z;
        out.m00 = a.m00 * x;
        out.m01 = a.m01 * x;
        out.m02 = a.m02 * x;
        out.m03 = a.m03 * x;
        out.m04 = a.m04 * y;
        out.m05 = a.m05 * y;
        out.m06 = a.m06 * y;
        out.m07 = a.m07 * y;
        out.m08 = a.m08 * z;
        out.m09 = a.m09 * z;
        out.m10 = a.m10 * z;
        out.m11 = a.m11 * z;
        out.m12 = a.m12;
        out.m13 = a.m13;
        out.m14 = a.m14;
        out.m15 = a.m15;
        return out;
      };
      mat4.rotate = function rotate(out, a, rad, axis) {
        var x = axis.x, y = axis.y, z = axis.z;
        var s = void 0, c = void 0, t = void 0, a00 = void 0, a01 = void 0, a02 = void 0, a03 = void 0, a10 = void 0, a11 = void 0, a12 = void 0, a13 = void 0, a20 = void 0, a21 = void 0, a22 = void 0, a23 = void 0, b00 = void 0, b01 = void 0, b02 = void 0, b10 = void 0, b11 = void 0, b12 = void 0, b20 = void 0, b21 = void 0, b22 = void 0;
        var len = Math.sqrt(x * x + y * y + z * z);
        if (Math.abs(len) < _utils.EPSILON) return null;
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        s = Math.sin(rad);
        c = Math.cos(rad);
        t = 1 - c;
        a00 = a.m00;
        a01 = a.m01;
        a02 = a.m02;
        a03 = a.m03;
        a10 = a.m04;
        a11 = a.m05;
        a12 = a.m06;
        a13 = a.m07;
        a20 = a.m08;
        a21 = a.m09;
        a22 = a.m10;
        a23 = a.m11;
        b00 = x * x * t + c;
        b01 = y * x * t + z * s;
        b02 = z * x * t - y * s;
        b10 = x * y * t - z * s;
        b11 = y * y * t + c;
        b12 = z * y * t + x * s;
        b20 = x * z * t + y * s;
        b21 = y * z * t - x * s;
        b22 = z * z * t + c;
        out.m00 = a00 * b00 + a10 * b01 + a20 * b02;
        out.m01 = a01 * b00 + a11 * b01 + a21 * b02;
        out.m02 = a02 * b00 + a12 * b01 + a22 * b02;
        out.m03 = a03 * b00 + a13 * b01 + a23 * b02;
        out.m04 = a00 * b10 + a10 * b11 + a20 * b12;
        out.m05 = a01 * b10 + a11 * b11 + a21 * b12;
        out.m06 = a02 * b10 + a12 * b11 + a22 * b12;
        out.m07 = a03 * b10 + a13 * b11 + a23 * b12;
        out.m08 = a00 * b20 + a10 * b21 + a20 * b22;
        out.m09 = a01 * b20 + a11 * b21 + a21 * b22;
        out.m10 = a02 * b20 + a12 * b21 + a22 * b22;
        out.m11 = a03 * b20 + a13 * b21 + a23 * b22;
        if (a !== out) {
          out.m12 = a.m12;
          out.m13 = a.m13;
          out.m14 = a.m14;
          out.m15 = a.m15;
        }
        return out;
      };
      mat4.rotateX = function rotateX(out, a, rad) {
        var s = Math.sin(rad), c = Math.cos(rad), a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11;
        if (a !== out) {
          out.m00 = a.m00;
          out.m01 = a.m01;
          out.m02 = a.m02;
          out.m03 = a.m03;
          out.m12 = a.m12;
          out.m13 = a.m13;
          out.m14 = a.m14;
          out.m15 = a.m15;
        }
        out.m04 = a10 * c + a20 * s;
        out.m05 = a11 * c + a21 * s;
        out.m06 = a12 * c + a22 * s;
        out.m07 = a13 * c + a23 * s;
        out.m08 = a20 * c - a10 * s;
        out.m09 = a21 * c - a11 * s;
        out.m10 = a22 * c - a12 * s;
        out.m11 = a23 * c - a13 * s;
        return out;
      };
      mat4.rotateY = function rotateY(out, a, rad) {
        var s = Math.sin(rad), c = Math.cos(rad), a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11;
        if (a !== out) {
          out.m04 = a.m04;
          out.m05 = a.m05;
          out.m06 = a.m06;
          out.m07 = a.m07;
          out.m12 = a.m12;
          out.m13 = a.m13;
          out.m14 = a.m14;
          out.m15 = a.m15;
        }
        out.m00 = a00 * c - a20 * s;
        out.m01 = a01 * c - a21 * s;
        out.m02 = a02 * c - a22 * s;
        out.m03 = a03 * c - a23 * s;
        out.m08 = a00 * s + a20 * c;
        out.m09 = a01 * s + a21 * c;
        out.m10 = a02 * s + a22 * c;
        out.m11 = a03 * s + a23 * c;
        return out;
      };
      mat4.rotateZ = function rotateZ(out, a, rad) {
        var s = Math.sin(rad), c = Math.cos(rad), a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07;
        if (a !== out) {
          out.m08 = a.m08;
          out.m09 = a.m09;
          out.m10 = a.m10;
          out.m11 = a.m11;
          out.m12 = a.m12;
          out.m13 = a.m13;
          out.m14 = a.m14;
          out.m15 = a.m15;
        }
        out.m00 = a00 * c + a10 * s;
        out.m01 = a01 * c + a11 * s;
        out.m02 = a02 * c + a12 * s;
        out.m03 = a03 * c + a13 * s;
        out.m04 = a10 * c - a00 * s;
        out.m05 = a11 * c - a01 * s;
        out.m06 = a12 * c - a02 * s;
        out.m07 = a13 * c - a03 * s;
        return out;
      };
      mat4.fromTranslation = function fromTranslation(out, v) {
        out.m00 = 1;
        out.m01 = 0;
        out.m02 = 0;
        out.m03 = 0;
        out.m04 = 0;
        out.m05 = 1;
        out.m06 = 0;
        out.m07 = 0;
        out.m08 = 0;
        out.m09 = 0;
        out.m10 = 1;
        out.m11 = 0;
        out.m12 = v.x;
        out.m13 = v.y;
        out.m14 = v.z;
        out.m15 = 1;
        return out;
      };
      mat4.fromScaling = function fromScaling(out, v) {
        out.m00 = v.x;
        out.m01 = 0;
        out.m02 = 0;
        out.m03 = 0;
        out.m04 = 0;
        out.m05 = v.y;
        out.m06 = 0;
        out.m07 = 0;
        out.m08 = 0;
        out.m09 = 0;
        out.m10 = v.z;
        out.m11 = 0;
        out.m12 = 0;
        out.m13 = 0;
        out.m14 = 0;
        out.m15 = 1;
        return out;
      };
      mat4.fromRotation = function fromRotation(out, rad, axis) {
        var x = axis.x, y = axis.y, z = axis.z;
        var len = Math.sqrt(x * x + y * y + z * z);
        var s = void 0, c = void 0, t = void 0;
        if (Math.abs(len) < _utils.EPSILON) return null;
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        s = Math.sin(rad);
        c = Math.cos(rad);
        t = 1 - c;
        out.m00 = x * x * t + c;
        out.m01 = y * x * t + z * s;
        out.m02 = z * x * t - y * s;
        out.m03 = 0;
        out.m04 = x * y * t - z * s;
        out.m05 = y * y * t + c;
        out.m06 = z * y * t + x * s;
        out.m07 = 0;
        out.m08 = x * z * t + y * s;
        out.m09 = y * z * t - x * s;
        out.m10 = z * z * t + c;
        out.m11 = 0;
        out.m12 = 0;
        out.m13 = 0;
        out.m14 = 0;
        out.m15 = 1;
        return out;
      };
      mat4.fromXRotation = function fromXRotation(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);
        out.m00 = 1;
        out.m01 = 0;
        out.m02 = 0;
        out.m03 = 0;
        out.m04 = 0;
        out.m05 = c;
        out.m06 = s;
        out.m07 = 0;
        out.m08 = 0;
        out.m09 = -s;
        out.m10 = c;
        out.m11 = 0;
        out.m12 = 0;
        out.m13 = 0;
        out.m14 = 0;
        out.m15 = 1;
        return out;
      };
      mat4.fromYRotation = function fromYRotation(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);
        out.m00 = c;
        out.m01 = 0;
        out.m02 = -s;
        out.m03 = 0;
        out.m04 = 0;
        out.m05 = 1;
        out.m06 = 0;
        out.m07 = 0;
        out.m08 = s;
        out.m09 = 0;
        out.m10 = c;
        out.m11 = 0;
        out.m12 = 0;
        out.m13 = 0;
        out.m14 = 0;
        out.m15 = 1;
        return out;
      };
      mat4.fromZRotation = function fromZRotation(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);
        out.m00 = c;
        out.m01 = s;
        out.m02 = 0;
        out.m03 = 0;
        out.m04 = -s;
        out.m05 = c;
        out.m06 = 0;
        out.m07 = 0;
        out.m08 = 0;
        out.m09 = 0;
        out.m10 = 1;
        out.m11 = 0;
        out.m12 = 0;
        out.m13 = 0;
        out.m14 = 0;
        out.m15 = 1;
        return out;
      };
      mat4.fromRT = function fromRT(out, q, v) {
        var x = q.x, y = q.y, z = q.z, w = q.w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;
        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        out.m00 = 1 - (yy + zz);
        out.m01 = xy + wz;
        out.m02 = xz - wy;
        out.m03 = 0;
        out.m04 = xy - wz;
        out.m05 = 1 - (xx + zz);
        out.m06 = yz + wx;
        out.m07 = 0;
        out.m08 = xz + wy;
        out.m09 = yz - wx;
        out.m10 = 1 - (xx + yy);
        out.m11 = 0;
        out.m12 = v.x;
        out.m13 = v.y;
        out.m14 = v.z;
        out.m15 = 1;
        return out;
      };
      mat4.getTranslation = function getTranslation(out, mat) {
        out.x = mat.m12;
        out.y = mat.m13;
        out.z = mat.m14;
        return out;
      };
      mat4.getScaling = function getScaling(out, mat) {
        var m11 = mat.m00, m12 = mat.m01, m13 = mat.m02, m21 = mat.m04, m22 = mat.m05, m23 = mat.m06, m31 = mat.m08, m32 = mat.m09, m33 = mat.m10;
        out.x = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
        out.y = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
        out.z = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
        return out;
      };
      mat4.getRotation = function getRotation(out, mat) {
        var trace = mat.m00 + mat.m05 + mat.m10;
        var S = 0;
        if (trace > 0) {
          S = 2 * Math.sqrt(trace + 1);
          out.w = .25 * S;
          out.x = (mat.m06 - mat.m09) / S;
          out.y = (mat.m08 - mat.m02) / S;
          out.z = (mat.m01 - mat.m04) / S;
        } else if (mat.m00 > mat.m05 & mat.m00 > mat.m10) {
          S = 2 * Math.sqrt(1 + mat.m00 - mat.m05 - mat.m10);
          out.w = (mat.m06 - mat.m09) / S;
          out.x = .25 * S;
          out.y = (mat.m01 + mat.m04) / S;
          out.z = (mat.m08 + mat.m02) / S;
        } else if (mat.m05 > mat.m10) {
          S = 2 * Math.sqrt(1 + mat.m05 - mat.m00 - mat.m10);
          out.w = (mat.m08 - mat.m02) / S;
          out.x = (mat.m01 + mat.m04) / S;
          out.y = .25 * S;
          out.z = (mat.m06 + mat.m09) / S;
        } else {
          S = 2 * Math.sqrt(1 + mat.m10 - mat.m00 - mat.m05);
          out.w = (mat.m01 - mat.m04) / S;
          out.x = (mat.m08 + mat.m02) / S;
          out.y = (mat.m06 + mat.m09) / S;
          out.z = .25 * S;
        }
        return out;
      };
      mat4.fromRTS = function fromRTS(out, q, v, s) {
        var x = q.x, y = q.y, z = q.z, w = q.w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;
        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        var sx = s.x;
        var sy = s.y;
        var sz = s.z;
        out.m00 = (1 - (yy + zz)) * sx;
        out.m01 = (xy + wz) * sx;
        out.m02 = (xz - wy) * sx;
        out.m03 = 0;
        out.m04 = (xy - wz) * sy;
        out.m05 = (1 - (xx + zz)) * sy;
        out.m06 = (yz + wx) * sy;
        out.m07 = 0;
        out.m08 = (xz + wy) * sz;
        out.m09 = (yz - wx) * sz;
        out.m10 = (1 - (xx + yy)) * sz;
        out.m11 = 0;
        out.m12 = v.x;
        out.m13 = v.y;
        out.m14 = v.z;
        out.m15 = 1;
        return out;
      };
      mat4.fromRTSOrigin = function fromRTSOrigin(out, q, v, s, o) {
        var x = q.x, y = q.y, z = q.z, w = q.w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;
        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        var sx = s.x;
        var sy = s.y;
        var sz = s.z;
        var ox = o.x;
        var oy = o.y;
        var oz = o.z;
        out.m00 = (1 - (yy + zz)) * sx;
        out.m01 = (xy + wz) * sx;
        out.m02 = (xz - wy) * sx;
        out.m03 = 0;
        out.m04 = (xy - wz) * sy;
        out.m05 = (1 - (xx + zz)) * sy;
        out.m06 = (yz + wx) * sy;
        out.m07 = 0;
        out.m08 = (xz + wy) * sz;
        out.m09 = (yz - wx) * sz;
        out.m10 = (1 - (xx + yy)) * sz;
        out.m11 = 0;
        out.m12 = v.x + ox - (out.m00 * ox + out.m04 * oy + out.m08 * oz);
        out.m13 = v.y + oy - (out.m01 * ox + out.m05 * oy + out.m09 * oz);
        out.m14 = v.z + oz - (out.m02 * ox + out.m06 * oy + out.m10 * oz);
        out.m15 = 1;
        return out;
      };
      mat4.fromQuat = function fromQuat(out, q) {
        var x = q.x, y = q.y, z = q.z, w = q.w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var yx = y * x2;
        var yy = y * y2;
        var zx = z * x2;
        var zy = z * y2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        out.m00 = 1 - yy - zz;
        out.m01 = yx + wz;
        out.m02 = zx - wy;
        out.m03 = 0;
        out.m04 = yx - wz;
        out.m05 = 1 - xx - zz;
        out.m06 = zy + wx;
        out.m07 = 0;
        out.m08 = zx + wy;
        out.m09 = zy - wx;
        out.m10 = 1 - xx - yy;
        out.m11 = 0;
        out.m12 = 0;
        out.m13 = 0;
        out.m14 = 0;
        out.m15 = 1;
        return out;
      };
      mat4.frustum = function frustum(out, left, right, bottom, top, near, far) {
        var rl = 1 / (right - left);
        var tb = 1 / (top - bottom);
        var nf = 1 / (near - far);
        out.m00 = 2 * near * rl;
        out.m01 = 0;
        out.m02 = 0;
        out.m03 = 0;
        out.m04 = 0;
        out.m05 = 2 * near * tb;
        out.m06 = 0;
        out.m07 = 0;
        out.m08 = (right + left) * rl;
        out.m09 = (top + bottom) * tb;
        out.m10 = (far + near) * nf;
        out.m11 = -1;
        out.m12 = 0;
        out.m13 = 0;
        out.m14 = far * near * 2 * nf;
        out.m15 = 0;
        return out;
      };
      mat4.perspective = function perspective(out, fovy, aspect, near, far) {
        var f = 1 / Math.tan(fovy / 2);
        var nf = 1 / (near - far);
        out.m00 = f / aspect;
        out.m01 = 0;
        out.m02 = 0;
        out.m03 = 0;
        out.m04 = 0;
        out.m05 = f;
        out.m06 = 0;
        out.m07 = 0;
        out.m08 = 0;
        out.m09 = 0;
        out.m10 = (far + near) * nf;
        out.m11 = -1;
        out.m12 = 0;
        out.m13 = 0;
        out.m14 = 2 * far * near * nf;
        out.m15 = 0;
        return out;
      };
      mat4.perspectiveFromFieldOfView = function perspectiveFromFieldOfView(out, fov, near, far) {
        var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
        var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
        var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
        var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
        var xScale = 2 / (leftTan + rightTan);
        var yScale = 2 / (upTan + downTan);
        out.m00 = xScale;
        out.m01 = 0;
        out.m02 = 0;
        out.m03 = 0;
        out.m04 = 0;
        out.m05 = yScale;
        out.m06 = 0;
        out.m07 = 0;
        out.m08 = -(leftTan - rightTan) * xScale * .5;
        out.m09 = (upTan - downTan) * yScale * .5;
        out.m10 = far / (near - far);
        out.m11 = -1;
        out.m12 = 0;
        out.m13 = 0;
        out.m14 = far * near / (near - far);
        out.m15 = 0;
        return out;
      };
      mat4.ortho = function ortho(out, left, right, bottom, top, near, far) {
        var lr = 1 / (left - right);
        var bt = 1 / (bottom - top);
        var nf = 1 / (near - far);
        out.m00 = -2 * lr;
        out.m01 = 0;
        out.m02 = 0;
        out.m03 = 0;
        out.m04 = 0;
        out.m05 = -2 * bt;
        out.m06 = 0;
        out.m07 = 0;
        out.m08 = 0;
        out.m09 = 0;
        out.m10 = 2 * nf;
        out.m11 = 0;
        out.m12 = (left + right) * lr;
        out.m13 = (top + bottom) * bt;
        out.m14 = (far + near) * nf;
        out.m15 = 1;
        return out;
      };
      mat4.lookAt = function lookAt(out, eye, center, up) {
        var x0 = void 0, x1 = void 0, x2 = void 0, y0 = void 0, y1 = void 0, y2 = void 0, z0 = void 0, z1 = void 0, z2 = void 0, len = void 0;
        var eyex = eye.x;
        var eyey = eye.y;
        var eyez = eye.z;
        var upx = up.x;
        var upy = up.y;
        var upz = up.z;
        var centerx = center.x;
        var centery = center.y;
        var centerz = center.z;
        z0 = eyex - centerx;
        z1 = eyey - centery;
        z2 = eyez - centerz;
        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;
        x0 = upy * z2 - upz * z1;
        x1 = upz * z0 - upx * z2;
        x2 = upx * z1 - upy * z0;
        len = 1 / Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
        x0 *= len;
        x1 *= len;
        x2 *= len;
        y0 = z1 * x2 - z2 * x1;
        y1 = z2 * x0 - z0 * x2;
        y2 = z0 * x1 - z1 * x0;
        out.m00 = x0;
        out.m01 = y0;
        out.m02 = z0;
        out.m03 = 0;
        out.m04 = x1;
        out.m05 = y1;
        out.m06 = z1;
        out.m07 = 0;
        out.m08 = x2;
        out.m09 = y2;
        out.m10 = z2;
        out.m11 = 0;
        out.m12 = -(x0 * eyex + x1 * eyey + x2 * eyez);
        out.m13 = -(y0 * eyex + y1 * eyey + y2 * eyez);
        out.m14 = -(z0 * eyex + z1 * eyey + z2 * eyez);
        out.m15 = 1;
        return out;
      };
      mat4.str = function str(a) {
        return "mat4(" + a.m00 + ", " + a.m01 + ", " + a.m02 + ", " + a.m03 + ", " + a.m04 + ", " + a.m05 + ", " + a.m06 + ", " + a.m07 + ", " + a.m08 + ", " + a.m09 + ", " + a.m10 + ", " + a.m11 + ", " + a.m12 + ", " + a.m13 + ", " + a.m14 + ", " + a.m15 + ")";
      };
      mat4.array = function array(out, m) {
        out[0] = m.m00;
        out[1] = m.m01;
        out[2] = m.m02;
        out[3] = m.m03;
        out[4] = m.m04;
        out[5] = m.m05;
        out[6] = m.m06;
        out[7] = m.m07;
        out[8] = m.m08;
        out[9] = m.m09;
        out[10] = m.m10;
        out[11] = m.m11;
        out[12] = m.m12;
        out[13] = m.m13;
        out[14] = m.m14;
        out[15] = m.m15;
        return out;
      };
      mat4.frob = function frob(a) {
        return Math.sqrt(Math.pow(a.m00, 2) + Math.pow(a.m01, 2) + Math.pow(a.m02, 2) + Math.pow(a.m03, 2) + Math.pow(a.m04, 2) + Math.pow(a.m05, 2) + Math.pow(a.m06, 2) + Math.pow(a.m07, 2) + Math.pow(a.m08, 2) + Math.pow(a.m09, 2) + Math.pow(a.m10, 2) + Math.pow(a.m11, 2) + Math.pow(a.m12, 2) + Math.pow(a.m13, 2) + Math.pow(a.m14, 2) + Math.pow(a.m15, 2));
      };
      mat4.add = function add(out, a, b) {
        out.m00 = a.m00 + b.m00;
        out.m01 = a.m01 + b.m01;
        out.m02 = a.m02 + b.m02;
        out.m03 = a.m03 + b.m03;
        out.m04 = a.m04 + b.m04;
        out.m05 = a.m05 + b.m05;
        out.m06 = a.m06 + b.m06;
        out.m07 = a.m07 + b.m07;
        out.m08 = a.m08 + b.m08;
        out.m09 = a.m09 + b.m09;
        out.m10 = a.m10 + b.m10;
        out.m11 = a.m11 + b.m11;
        out.m12 = a.m12 + b.m12;
        out.m13 = a.m13 + b.m13;
        out.m14 = a.m14 + b.m14;
        out.m15 = a.m15 + b.m15;
        return out;
      };
      mat4.subtract = function subtract(out, a, b) {
        out.m00 = a.m00 - b.m00;
        out.m01 = a.m01 - b.m01;
        out.m02 = a.m02 - b.m02;
        out.m03 = a.m03 - b.m03;
        out.m04 = a.m04 - b.m04;
        out.m05 = a.m05 - b.m05;
        out.m06 = a.m06 - b.m06;
        out.m07 = a.m07 - b.m07;
        out.m08 = a.m08 - b.m08;
        out.m09 = a.m09 - b.m09;
        out.m10 = a.m10 - b.m10;
        out.m11 = a.m11 - b.m11;
        out.m12 = a.m12 - b.m12;
        out.m13 = a.m13 - b.m13;
        out.m14 = a.m14 - b.m14;
        out.m15 = a.m15 - b.m15;
        return out;
      };
      mat4.sub = function sub(out, a, b) {
        return mat4.subtract(out, a, b);
      };
      mat4.multiplyScalar = function multiplyScalar(out, a, b) {
        out.m00 = a.m00 * b;
        out.m01 = a.m01 * b;
        out.m02 = a.m02 * b;
        out.m03 = a.m03 * b;
        out.m04 = a.m04 * b;
        out.m05 = a.m05 * b;
        out.m06 = a.m06 * b;
        out.m07 = a.m07 * b;
        out.m08 = a.m08 * b;
        out.m09 = a.m09 * b;
        out.m10 = a.m10 * b;
        out.m11 = a.m11 * b;
        out.m12 = a.m12 * b;
        out.m13 = a.m13 * b;
        out.m14 = a.m14 * b;
        out.m15 = a.m15 * b;
        return out;
      };
      mat4.multiplyScalarAndAdd = function multiplyScalarAndAdd(out, a, b, scale) {
        out.m00 = a.m00 + b.m00 * scale;
        out.m01 = a.m01 + b.m01 * scale;
        out.m02 = a.m02 + b.m02 * scale;
        out.m03 = a.m03 + b.m03 * scale;
        out.m04 = a.m04 + b.m04 * scale;
        out.m05 = a.m05 + b.m05 * scale;
        out.m06 = a.m06 + b.m06 * scale;
        out.m07 = a.m07 + b.m07 * scale;
        out.m08 = a.m08 + b.m08 * scale;
        out.m09 = a.m09 + b.m09 * scale;
        out.m10 = a.m10 + b.m10 * scale;
        out.m11 = a.m11 + b.m11 * scale;
        out.m12 = a.m12 + b.m12 * scale;
        out.m13 = a.m13 + b.m13 * scale;
        out.m14 = a.m14 + b.m14 * scale;
        out.m15 = a.m15 + b.m15 * scale;
        return out;
      };
      mat4.exactEquals = function exactEquals(a, b) {
        return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08 && a.m09 === b.m09 && a.m10 === b.m10 && a.m11 === b.m11 && a.m12 === b.m12 && a.m13 === b.m13 && a.m14 === b.m14 && a.m15 === b.m15;
      };
      mat4.equals = function equals(a, b) {
        var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05, a6 = a.m06, a7 = a.m07, a8 = a.m08, a9 = a.m09, a10 = a.m10, a11 = a.m11, a12 = a.m12, a13 = a.m13, a14 = a.m14, a15 = a.m15;
        var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03, b4 = b.m04, b5 = b.m05, b6 = b.m06, b7 = b.m07, b8 = b.m08, b9 = b.m09, b10 = b.m10, b11 = b.m11, b12 = b.m12, b13 = b.m13, b14 = b.m14, b15 = b.m15;
        return Math.abs(a0 - b0) <= _utils.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _utils.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _utils.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _utils.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _utils.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _utils.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _utils.EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _utils.EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _utils.EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _utils.EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _utils.EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _utils.EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _utils.EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _utils.EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _utils.EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _utils.EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
      };
      return mat4;
    })();
    exports.default = mat4;
    module.exports = exports["default"];
  }), {
    "./utils": 213
  } ],
  212: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _vec = require("./vec3");
    var _vec2 = _interopRequireDefault(_vec);
    var _vec3 = require("./vec4");
    var _vec4 = _interopRequireDefault(_vec3);
    var _mat = require("./mat3");
    var _mat2 = _interopRequireDefault(_mat);
    var _utils = require("./utils");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var halfToRad = .5 * Math.PI / 180;
    var quat = (function() {
      function quat() {
        var x = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
        var y = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        var z = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        var w = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        _classCallCheck(this, quat);
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
      }
      quat.create = function create() {
        var x = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
        var y = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        var z = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        var w = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        return new quat(x, y, z, w);
      };
      quat.clone = function clone(a) {
        return new quat(a.x, a.y, a.z, a.w);
      };
      quat.copy = function copy(out, a) {
        return _vec4.default.copy(out, a);
      };
      quat.set = function set(out, x, y, z, w) {
        out.x = x;
        out.y = y;
        out.z = z;
        out.w = w;
        return out;
      };
      quat.identity = function identity(out) {
        out.x = 0;
        out.y = 0;
        out.z = 0;
        out.w = 1;
        return out;
      };
      quat.rotationTo = function rotationTo(out, a, b) {
        var rotationToIIFE = (function() {
          var tmpvec3 = _vec2.default.create(0, 0, 0);
          var xUnitVec3 = _vec2.default.create(1, 0, 0);
          var yUnitVec3 = _vec2.default.create(0, 1, 0);
          return function(out, a, b) {
            var dot = _vec2.default.dot(a, b);
            if (dot < -.999999) {
              _vec2.default.cross(tmpvec3, xUnitVec3, a);
              _vec2.default.magnitude(tmpvec3) < 1e-6 && _vec2.default.cross(tmpvec3, yUnitVec3, a);
              _vec2.default.normalize(tmpvec3, tmpvec3);
              quat.fromAxisAngle(out, tmpvec3, Math.PI);
              return out;
            }
            if (dot > .999999) {
              out.x = 0;
              out.y = 0;
              out.z = 0;
              out.w = 1;
              return out;
            }
            _vec2.default.cross(tmpvec3, a, b);
            out.x = tmpvec3.x;
            out.y = tmpvec3.y;
            out.z = tmpvec3.z;
            out.w = 1 + dot;
            return quat.normalize(out, out);
          };
        })();
        return rotationToIIFE(out, a, b);
      };
      quat.getAxisAngle = function getAxisAngle(out_axis, q) {
        var rad = 2 * Math.acos(q.w);
        var s = Math.sin(rad / 2);
        if (0 != s) {
          out_axis.x = q.x / s;
          out_axis.y = q.y / s;
          out_axis.z = q.z / s;
        } else {
          out_axis.x = 1;
          out_axis.y = 0;
          out_axis.z = 0;
        }
        return rad;
      };
      quat.multiply = function multiply(out, a, b) {
        var ax = a.x, ay = a.y, az = a.z, aw = a.w, bx = b.x, by = b.y, bz = b.z, bw = b.w;
        out.x = ax * bw + aw * bx + ay * bz - az * by;
        out.y = ay * bw + aw * by + az * bx - ax * bz;
        out.z = az * bw + aw * bz + ax * by - ay * bx;
        out.w = aw * bw - ax * bx - ay * by - az * bz;
        return out;
      };
      quat.mul = function mul(out, a, b) {
        return quat.multiply(out, a, b);
      };
      quat.scale = function scale(out, a, b) {
        out.x = a.x * b;
        out.y = a.y * b;
        out.z = a.z * b;
        out.w = a.w * b;
        return out;
      };
      quat.rotateX = function rotateX(out, a, rad) {
        rad *= .5;
        var ax = a.x, ay = a.y, az = a.z, aw = a.w, bx = Math.sin(rad), bw = Math.cos(rad);
        out.x = ax * bw + aw * bx;
        out.y = ay * bw + az * bx;
        out.z = az * bw - ay * bx;
        out.w = aw * bw - ax * bx;
        return out;
      };
      quat.rotateY = function rotateY(out, a, rad) {
        rad *= .5;
        var ax = a.x, ay = a.y, az = a.z, aw = a.w, by = Math.sin(rad), bw = Math.cos(rad);
        out.x = ax * bw - az * by;
        out.y = ay * bw + aw * by;
        out.z = az * bw + ax * by;
        out.w = aw * bw - ay * by;
        return out;
      };
      quat.rotateZ = function rotateZ(out, a, rad) {
        rad *= .5;
        var ax = a.x, ay = a.y, az = a.z, aw = a.w, bz = Math.sin(rad), bw = Math.cos(rad);
        out.x = ax * bw + ay * bz;
        out.y = ay * bw - ax * bz;
        out.z = az * bw + aw * bz;
        out.w = aw * bw - az * bz;
        return out;
      };
      quat.rotateAround = function rotateAround(out, rot, axis, rad) {
        var rotateAroundIIFE = (function() {
          var v3_tmp = _vec2.default.create(0, 0, 0);
          var q_tmp = quat.create();
          return function(out, rot, axis, rad) {
            quat.invert(q_tmp, rot);
            _vec2.default.transformQuat(v3_tmp, axis, q_tmp);
            quat.fromAxisAngle(q_tmp, v3_tmp, rad);
            quat.mul(out, rot, q_tmp);
            return out;
          };
        })();
        return rotateAroundIIFE(out, rot, axis, rad);
      };
      quat.rotateAroundLocal = function rotateAroundLocal(out, rot, axis, rad) {
        var rotateAroundLocalIIFE = (function() {
          var q_tmp = quat.create();
          return function(out, rot, axis, rad) {
            quat.fromAxisAngle(q_tmp, axis, rad);
            quat.mul(out, rot, q_tmp);
            return out;
          };
        })();
        return rotateAroundLocalIIFE(out, rot, axis, rad);
      };
      quat.calculateW = function calculateW(out, a) {
        var x = a.x, y = a.y, z = a.z;
        out.x = x;
        out.y = y;
        out.z = z;
        out.w = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
        return out;
      };
      quat.dot = function dot(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
      };
      quat.lerp = function lerp(out, a, b, t) {
        var ax = a.x, ay = a.y, az = a.z, aw = a.w;
        out.x = ax + t * (b.x - ax);
        out.y = ay + t * (b.y - ay);
        out.z = az + t * (b.z - az);
        out.w = aw + t * (b.w - aw);
        return out;
      };
      quat.slerp = function slerp(out, a, b, t) {
        var ax = a.x, ay = a.y, az = a.z, aw = a.w, bx = b.x, by = b.y, bz = b.z, bw = b.w;
        var omega = void 0, cosom = void 0, sinom = void 0, scale0 = void 0, scale1 = void 0;
        cosom = ax * bx + ay * by + az * bz + aw * bw;
        if (cosom < 0) {
          cosom = -cosom;
          bx = -bx;
          by = -by;
          bz = -bz;
          bw = -bw;
        }
        if (1 - cosom > 1e-6) {
          omega = Math.acos(cosom);
          sinom = Math.sin(omega);
          scale0 = Math.sin((1 - t) * omega) / sinom;
          scale1 = Math.sin(t * omega) / sinom;
        } else {
          scale0 = 1 - t;
          scale1 = t;
        }
        out.x = scale0 * ax + scale1 * bx;
        out.y = scale0 * ay + scale1 * by;
        out.z = scale0 * az + scale1 * bz;
        out.w = scale0 * aw + scale1 * bw;
        return out;
      };
      quat.sqlerp = function sqlerp(out, a, b, c, d, t) {
        var sqlerpIIFE = (function() {
          var temp1 = quat.create();
          var temp2 = quat.create();
          return function(out, a, b, c, d, t) {
            quat.slerp(temp1, a, d, t);
            quat.slerp(temp2, b, c, t);
            quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
            return out;
          };
        })();
        return sqlerpIIFE(out, a, b, c, d, t);
      };
      quat.invert = function invert(out, a) {
        var a0 = a.x, a1 = a.y, a2 = a.z, a3 = a.w;
        var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
        var invDot = dot ? 1 / dot : 0;
        out.x = -a0 * invDot;
        out.y = -a1 * invDot;
        out.z = -a2 * invDot;
        out.w = a3 * invDot;
        return out;
      };
      quat.conjugate = function conjugate(out, a) {
        out.x = -a.x;
        out.y = -a.y;
        out.z = -a.z;
        out.w = a.w;
        return out;
      };
      quat.magnitude = function magnitude(a) {
        var x = a.x, y = a.y, z = a.z, w = a.w;
        return Math.sqrt(x * x + y * y + z * z + w * w);
      };
      quat.mag = function mag(a) {
        return quat.magnitude(a);
      };
      quat.squaredMagnitude = function squaredMagnitude(a) {
        var x = a.x, y = a.y, z = a.z, w = a.w;
        return x * x + y * y + z * z + w * w;
      };
      quat.sqrMag = function sqrMag(a) {
        return quat.squaredMagnitude(a);
      };
      quat.normalize = function normalize(out, a) {
        var x = a.x, y = a.y, z = a.z, w = a.w;
        var len = x * x + y * y + z * z + w * w;
        if (len > 0) {
          len = 1 / Math.sqrt(len);
          out.x = x * len;
          out.y = y * len;
          out.z = z * len;
          out.w = w * len;
        }
        return out;
      };
      quat.fromAxes = function fromAxes(out, xAxis, yAxis, zAxis) {
        var fromAxesIIFE = (function() {
          var matr = _mat2.default.create();
          return function(out, xAxis, yAxis, zAxis) {
            _mat2.default.set(matr, xAxis.x, xAxis.y, xAxis.z, yAxis.x, yAxis.y, yAxis.z, zAxis.x, zAxis.y, zAxis.z);
            return quat.normalize(out, quat.fromMat3(out, matr));
          };
        })();
        return fromAxesIIFE(out, xAxis, yAxis, zAxis);
      };
      quat.fromViewUp = function fromViewUp(out, view, up) {
        var fromViewUpIIFE = (function() {
          var matr = _mat2.default.create();
          return function(out, view, up) {
            _mat2.default.fromViewUp(matr, view, up);
            if (!matr) return null;
            return quat.normalize(out, quat.fromMat3(out, matr));
          };
        })();
        return fromViewUpIIFE(out, view, up);
      };
      quat.fromAxisAngle = function fromAxisAngle(out, axis, rad) {
        rad *= .5;
        var s = Math.sin(rad);
        out.x = s * axis.x;
        out.y = s * axis.y;
        out.z = s * axis.z;
        out.w = Math.cos(rad);
        return out;
      };
      quat.fromMat3 = function fromMat3(out, m) {
        var m00 = m.m00, m01 = m.m03, m02 = m.m06, m10 = m.m01, m11 = m.m04, m12 = m.m07, m20 = m.m02, m21 = m.m05, m22 = m.m08;
        var trace = m00 + m11 + m22;
        if (trace > 0) {
          var s = .5 / Math.sqrt(trace + 1);
          out.w = .25 / s;
          out.x = (m21 - m12) * s;
          out.y = (m02 - m20) * s;
          out.z = (m10 - m01) * s;
        } else if (m00 > m11 && m00 > m22) {
          var _s = 2 * Math.sqrt(1 + m00 - m11 - m22);
          out.w = (m21 - m12) / _s;
          out.x = .25 * _s;
          out.y = (m01 + m10) / _s;
          out.z = (m02 + m20) / _s;
        } else if (m11 > m22) {
          var _s2 = 2 * Math.sqrt(1 + m11 - m00 - m22);
          out.w = (m02 - m20) / _s2;
          out.x = (m01 + m10) / _s2;
          out.y = .25 * _s2;
          out.z = (m12 + m21) / _s2;
        } else {
          var _s3 = 2 * Math.sqrt(1 + m22 - m00 - m11);
          out.w = (m10 - m01) / _s3;
          out.x = (m02 + m20) / _s3;
          out.y = (m12 + m21) / _s3;
          out.z = .25 * _s3;
        }
        return out;
      };
      quat.fromEuler = function fromEuler(out, x, y, z) {
        x *= halfToRad;
        y *= halfToRad;
        z *= halfToRad;
        var sx = Math.sin(x);
        var cx = Math.cos(x);
        var sy = Math.sin(y);
        var cy = Math.cos(y);
        var sz = Math.sin(z);
        var cz = Math.cos(z);
        out.x = sx * cy * cz + cx * sy * sz;
        out.y = cx * sy * cz + sx * cy * sz;
        out.z = cx * cy * sz - sx * sy * cz;
        out.w = cx * cy * cz - sx * sy * sz;
        return out;
      };
      quat.fromAngleZ = function fromAngleZ(out, z) {
        z *= halfToRad;
        out.x = out.y = 0;
        out.z = Math.sin(z);
        out.w = Math.cos(z);
      };
      quat.toEuler = function toEuler(out, q) {
        var x = q.x, y = q.y, z = q.z, w = q.w;
        var heading = void 0, attitude = void 0, bank = void 0;
        var test = x * y + z * w;
        if (test > .499) {
          heading = 2 * Math.atan2(x, w);
          attitude = Math.PI / 2;
          bank = 0;
        }
        if (test < -.499) {
          heading = -2 * Math.atan2(x, w);
          attitude = -Math.PI / 2;
          bank = 0;
        }
        if (isNaN(heading)) {
          var sqx = x * x;
          var sqy = y * y;
          var sqz = z * z;
          heading = Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz);
          attitude = Math.asin(2 * test);
          bank = Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz);
        }
        out.y = (0, _utils.toDegree)(heading);
        out.z = (0, _utils.toDegree)(attitude);
        out.x = (0, _utils.toDegree)(bank);
        return out;
      };
      quat.str = function str(a) {
        return "quat(" + a.x + ", " + a.y + ", " + a.z + ", " + a.w + ")";
      };
      quat.array = function array(out, q) {
        out[0] = q.x;
        out[1] = q.y;
        out[2] = q.z;
        out[3] = q.w;
        return out;
      };
      quat.exactEquals = function exactEquals(a, b) {
        return _vec4.default.exactEquals(a, b);
      };
      quat.equals = function equals(a, b) {
        return _vec4.default.equals(a, b);
      };
      return quat;
    })();
    exports.default = quat;
    module.exports = exports["default"];
  }), {
    "./mat3": 210,
    "./utils": 213,
    "./vec3": 215,
    "./vec4": 216
  } ],
  213: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.equals = equals;
    exports.approx = approx;
    exports.clamp = clamp;
    exports.clamp01 = clamp01;
    exports.lerp = lerp;
    exports.toRadian = toRadian;
    exports.toDegree = toDegree;
    exports.randomRange = randomRange;
    exports.randomRangeInt = randomRangeInt;
    exports.pseudoRandom = pseudoRandom;
    exports.pseudoRandomRange = pseudoRandomRange;
    exports.pseudoRandomRangeInt = pseudoRandomRangeInt;
    exports.nextPow2 = nextPow2;
    exports.repeat = repeat;
    exports.pingPong = pingPong;
    exports.inverseLerp = inverseLerp;
    var _d2r = Math.PI / 180;
    var _r2d = 180 / Math.PI;
    var EPSILON = exports.EPSILON = 1e-6;
    function equals(a, b) {
      return Math.abs(a - b) <= EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
    }
    function approx(a, b, maxDiff) {
      maxDiff = maxDiff || EPSILON;
      return Math.abs(a - b) <= maxDiff;
    }
    function clamp(val, min, max) {
      return val < min ? min : val > max ? max : val;
    }
    function clamp01(val) {
      return val < 0 ? 0 : val > 1 ? 1 : val;
    }
    function lerp(from, to, ratio) {
      return from + (to - from) * ratio;
    }
    function toRadian(a) {
      return a * _d2r;
    }
    function toDegree(a) {
      return a * _r2d;
    }
    var random = exports.random = Math.random;
    function randomRange(min, max) {
      return Math.random() * (max - min) + min;
    }
    function randomRangeInt(min, max) {
      return Math.floor(randomRange(min, max));
    }
    function pseudoRandom(seed) {
      seed = (9301 * seed + 49297) % 233280;
      return seed / 233280;
    }
    function pseudoRandomRange(seed, min, max) {
      return pseudoRandom(seed) * (max - min) + min;
    }
    function pseudoRandomRangeInt(seed, min, max) {
      return Math.floor(pseudoRandomRange(seed, min, max));
    }
    function nextPow2(val) {
      --val;
      val |= val >> 1;
      val |= val >> 2;
      val |= val >> 4;
      val |= val >> 8;
      val |= val >> 16;
      ++val;
      return val;
    }
    function repeat(t, length) {
      return t - Math.floor(t / length) * length;
    }
    function pingPong(t, length) {
      t = repeat(t, 2 * length);
      t = length - Math.abs(t - length);
      return t;
    }
    function inverseLerp(from, to, value) {
      return (value - from) / (to - from);
    }
  }), {} ],
  214: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _utils = require("./utils");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var vec2 = (function() {
      function vec2() {
        var x = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
        var y = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        _classCallCheck(this, vec2);
        this.x = x;
        this.y = y;
      }
      vec2.create = function create() {
        var x = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
        var y = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        return new vec2(x, y);
      };
      vec2.zero = function zero(out) {
        out.x = 0;
        out.y = 0;
        return out;
      };
      vec2.clone = function clone(a) {
        return new vec2(a.x, a.y);
      };
      vec2.copy = function copy(out, a) {
        out.x = a.x;
        out.y = a.y;
        return out;
      };
      vec2.set = function set(out, x, y) {
        out.x = x;
        out.y = y;
        return out;
      };
      vec2.add = function add(out, a, b) {
        out.x = a.x + b.x;
        out.y = a.y + b.y;
        return out;
      };
      vec2.subtract = function subtract(out, a, b) {
        out.x = a.x - b.x;
        out.y = a.y - b.y;
        return out;
      };
      vec2.sub = function sub(out, a, b) {
        return vec2.subtract(out, a, b);
      };
      vec2.multiply = function multiply(out, a, b) {
        out.x = a.x * b.x;
        out.y = a.y * b.y;
        return out;
      };
      vec2.mul = function mul(out, a, b) {
        return vec2.multiply(out, a, b);
      };
      vec2.divide = function divide(out, a, b) {
        out.x = a.x / b.x;
        out.y = a.y / b.y;
        return out;
      };
      vec2.div = function div(out, a, b) {
        return vec2.divide(out, a, b);
      };
      vec2.ceil = function ceil(out, a) {
        out.x = Math.ceil(a.x);
        out.y = Math.ceil(a.y);
        return out;
      };
      vec2.floor = function floor(out, a) {
        out.x = Math.floor(a.x);
        out.y = Math.floor(a.y);
        return out;
      };
      vec2.min = function min(out, a, b) {
        out.x = Math.min(a.x, b.x);
        out.y = Math.min(a.y, b.y);
        return out;
      };
      vec2.max = function max(out, a, b) {
        out.x = Math.max(a.x, b.x);
        out.y = Math.max(a.y, b.y);
        return out;
      };
      vec2.round = function round(out, a) {
        out.x = Math.round(a.x);
        out.y = Math.round(a.y);
        return out;
      };
      vec2.scale = function scale(out, a, b) {
        out.x = a.x * b;
        out.y = a.y * b;
        return out;
      };
      vec2.scaleAndAdd = function scaleAndAdd(out, a, b, scale) {
        out.x = a.x + b.x * scale;
        out.y = a.y + b.y * scale;
        return out;
      };
      vec2.distance = function distance(a, b) {
        var x = b.x - a.x, y = b.y - a.y;
        return Math.sqrt(x * x + y * y);
      };
      vec2.dist = function dist(a, b) {
        return vec2.distance(a, b);
      };
      vec2.squaredDistance = function squaredDistance(a, b) {
        var x = b.x - a.x, y = b.y - a.y;
        return x * x + y * y;
      };
      vec2.sqrDist = function sqrDist(a, b) {
        return vec2.squaredDistance(a, b);
      };
      vec2.magnitude = function magnitude(a) {
        var x = a.x, y = a.y;
        return Math.sqrt(x * x + y * y);
      };
      vec2.mag = function mag(a) {
        return vec2.magnitude(a);
      };
      vec2.squaredMagnitude = function squaredMagnitude(a) {
        var x = a.x, y = a.y;
        return x * x + y * y;
      };
      vec2.sqrMag = function sqrMag(a) {
        return vec2.squaredMagnitude(a);
      };
      vec2.negate = function negate(out, a) {
        out.x = -a.x;
        out.y = -a.y;
        return out;
      };
      vec2.inverse = function inverse(out, a) {
        out.x = 1 / a.x;
        out.y = 1 / a.y;
        return out;
      };
      vec2.inverseSafe = function inverseSafe(out, a) {
        var x = a.x, y = a.y;
        Math.abs(x) < _utils.EPSILON ? out.x = 0 : out.x = 1 / x;
        Math.abs(y) < _utils.EPSILON ? out.y = 0 : out.y = 1 / a.y;
        return out;
      };
      vec2.normalize = function normalize(out, a) {
        var x = a.x, y = a.y;
        var len = x * x + y * y;
        if (len > 0) {
          len = 1 / Math.sqrt(len);
          out.x = a.x * len;
          out.y = a.y * len;
        }
        return out;
      };
      vec2.dot = function dot(a, b) {
        return a.x * b.x + a.y * b.y;
      };
      vec2.cross = function cross(out, a, b) {
        var z = a.x * b.y - a.y * b.x;
        out.x = out.y = 0;
        out.z = z;
        return out;
      };
      vec2.lerp = function lerp(out, a, b, t) {
        var ax = a.x, ay = a.y;
        out.x = ax + t * (b.x - ax);
        out.y = ay + t * (b.y - ay);
        return out;
      };
      vec2.random = function random(out, scale) {
        scale = scale || 1;
        var r = 2 * (0, _utils.random)() * Math.PI;
        out.x = Math.cos(r) * scale;
        out.y = Math.sin(r) * scale;
        return out;
      };
      vec2.transformMat2 = function transformMat2(out, a, m) {
        var x = a.x, y = a.y;
        out.x = m.m00 * x + m.m02 * y;
        out.y = m.m01 * x + m.m03 * y;
        return out;
      };
      vec2.transformMat23 = function transformMat23(out, a, m) {
        var x = a.x, y = a.y;
        out.x = m.m00 * x + m.m02 * y + m.m04;
        out.y = m.m01 * x + m.m03 * y + m.m05;
        return out;
      };
      vec2.transformMat3 = function transformMat3(out, a, m) {
        var x = a.x, y = a.y;
        out.x = m.m00 * x + m.m03 * y + m.m06;
        out.y = m.m01 * x + m.m04 * y + m.m07;
        return out;
      };
      vec2.transformMat4 = function transformMat4(out, a, m) {
        var x = a.x, y = a.y;
        out.x = m.m00 * x + m.m04 * y + m.m12;
        out.y = m.m01 * x + m.m05 * y + m.m13;
        return out;
      };
      vec2.forEach = function forEach(a, stride, offset, count, fn, arg) {
        return vec2._forEach(a, stride, offset, count, fn, arg);
      };
      vec2.str = function str(a) {
        return "vec2(" + a.x + ", " + a.y + ")";
      };
      vec2.array = function array(out, v) {
        out[0] = v.x;
        out[1] = v.y;
        return out;
      };
      vec2.exactEquals = function exactEquals(a, b) {
        return a.x === b.x && a.y === b.y;
      };
      vec2.equals = function equals(a, b) {
        var a0 = a.x, a1 = a.y;
        var b0 = b.x, b1 = b.y;
        return Math.abs(a0 - b0) <= _utils.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _utils.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
      };
      vec2.angle = function angle(a, b) {
        return vec2._angle(a, b);
      };
      return vec2;
    })();
    vec2._forEach = (function() {
      var vec = vec2.create(0, 0);
      return function(a, stride, offset, count, fn, arg) {
        var i = void 0, l = void 0;
        stride || (stride = 2);
        offset || (offset = 0);
        l = count ? Math.min(count * stride + offset, a.length) : a.length;
        for (i = offset; i < l; i += stride) {
          vec.x = a[i];
          vec.y = a[i + 1];
          fn(vec, vec, arg);
          a[i] = vec.x;
          a[i + 1] = vec.y;
        }
        return a;
      };
    })();
    vec2._angle = (function() {
      var tempA = vec2.create(0, 0);
      var tempB = vec2.create(0, 0);
      return function(a, b) {
        vec2.normalize(tempA, a);
        vec2.normalize(tempB, b);
        var cosine = vec2.dot(tempA, tempB);
        if (cosine > 1) return 0;
        if (cosine < -1) return Math.PI;
        return Math.acos(cosine);
      };
    })();
    exports.default = vec2;
    module.exports = exports["default"];
  }), {
    "./utils": 213
  } ],
  215: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _utils = require("./utils");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var vec3 = (function() {
      function vec3() {
        var x = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
        var y = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        var z = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        _classCallCheck(this, vec3);
        this.x = x;
        this.y = y;
        this.z = z;
      }
      vec3.create = function create() {
        var x = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
        var y = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        var z = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return new vec3(x, y, z);
      };
      vec3.zero = function zero(out) {
        out.x = 0;
        out.y = 0;
        out.z = 0;
        return out;
      };
      vec3.clone = function clone(a) {
        return new vec3(a.x, a.y, a.z);
      };
      vec3.copy = function copy(out, a) {
        out.x = a.x;
        out.y = a.y;
        out.z = a.z;
        return out;
      };
      vec3.set = function set(out, x, y, z) {
        out.x = x;
        out.y = y;
        out.z = z;
        return out;
      };
      vec3.add = function add(out, a, b) {
        out.x = a.x + b.x;
        out.y = a.y + b.y;
        out.z = a.z + b.z;
        return out;
      };
      vec3.subtract = function subtract(out, a, b) {
        out.x = a.x - b.x;
        out.y = a.y - b.y;
        out.z = a.z - b.z;
        return out;
      };
      vec3.sub = function sub(out, a, b) {
        return vec3.subtract(out, a, b);
      };
      vec3.multiply = function multiply(out, a, b) {
        out.x = a.x * b.x;
        out.y = a.y * b.y;
        out.z = a.z * b.z;
        return out;
      };
      vec3.mul = function mul(out, a, b) {
        return vec3.multiply(out, a, b);
      };
      vec3.divide = function divide(out, a, b) {
        out.x = a.x / b.x;
        out.y = a.y / b.y;
        out.z = a.z / b.z;
        return out;
      };
      vec3.div = function div(out, a, b) {
        return vec3.divide(out, a, b);
      };
      vec3.ceil = function ceil(out, a) {
        out.x = Math.ceil(a.x);
        out.y = Math.ceil(a.y);
        out.z = Math.ceil(a.z);
        return out;
      };
      vec3.floor = function floor(out, a) {
        out.x = Math.floor(a.x);
        out.y = Math.floor(a.y);
        out.z = Math.floor(a.z);
        return out;
      };
      vec3.min = function min(out, a, b) {
        out.x = Math.min(a.x, b.x);
        out.y = Math.min(a.y, b.y);
        out.z = Math.min(a.z, b.z);
        return out;
      };
      vec3.max = function max(out, a, b) {
        out.x = Math.max(a.x, b.x);
        out.y = Math.max(a.y, b.y);
        out.z = Math.max(a.z, b.z);
        return out;
      };
      vec3.round = function round(out, a) {
        out.x = Math.round(a.x);
        out.y = Math.round(a.y);
        out.z = Math.round(a.z);
        return out;
      };
      vec3.scale = function scale(out, a, b) {
        out.x = a.x * b;
        out.y = a.y * b;
        out.z = a.z * b;
        return out;
      };
      vec3.scaleAndAdd = function scaleAndAdd(out, a, b, scale) {
        out.x = a.x + b.x * scale;
        out.y = a.y + b.y * scale;
        out.z = a.z + b.z * scale;
        return out;
      };
      vec3.distance = function distance(a, b) {
        var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z;
        return Math.sqrt(x * x + y * y + z * z);
      };
      vec3.dist = function dist(a, b) {
        return vec3.distance(a, b);
      };
      vec3.squaredDistance = function squaredDistance(a, b) {
        var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z;
        return x * x + y * y + z * z;
      };
      vec3.sqrDist = function sqrDist(a, b) {
        return vec3.squaredDistance(a, b);
      };
      vec3.magnitude = function magnitude(a) {
        var x = a.x, y = a.y, z = a.z;
        return Math.sqrt(x * x + y * y + z * z);
      };
      vec3.mag = function mag(a) {
        return vec3.magnitude(a);
      };
      vec3.squaredMagnitude = function squaredMagnitude(a) {
        var x = a.x, y = a.y, z = a.z;
        return x * x + y * y + z * z;
      };
      vec3.sqrMag = function sqrMag(a) {
        return vec3.squaredMagnitude(a);
      };
      vec3.negate = function negate(out, a) {
        out.x = -a.x;
        out.y = -a.y;
        out.z = -a.z;
        return out;
      };
      vec3.inverse = function inverse(out, a) {
        out.x = 1 / a.x;
        out.y = 1 / a.y;
        out.z = 1 / a.z;
        return out;
      };
      vec3.inverseSafe = function inverseSafe(out, a) {
        var x = a.x, y = a.y, z = a.z;
        Math.abs(x) < _utils.EPSILON ? out.x = 0 : out.x = 1 / x;
        Math.abs(y) < _utils.EPSILON ? out.y = 0 : out.y = 1 / y;
        Math.abs(z) < _utils.EPSILON ? out.z = 0 : out.z = 1 / z;
        return out;
      };
      vec3.normalize = function normalize(out, a) {
        var x = a.x, y = a.y, z = a.z;
        var len = x * x + y * y + z * z;
        if (len > 0) {
          len = 1 / Math.sqrt(len);
          out.x = x * len;
          out.y = y * len;
          out.z = z * len;
        }
        return out;
      };
      vec3.dot = function dot(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z;
      };
      vec3.cross = function cross(out, a, b) {
        var ax = a.x, ay = a.y, az = a.z, bx = b.x, by = b.y, bz = b.z;
        out.x = ay * bz - az * by;
        out.y = az * bx - ax * bz;
        out.z = ax * by - ay * bx;
        return out;
      };
      vec3.lerp = function lerp(out, a, b, t) {
        var ax = a.x, ay = a.y, az = a.z;
        out.x = ax + t * (b.x - ax);
        out.y = ay + t * (b.y - ay);
        out.z = az + t * (b.z - az);
        return out;
      };
      vec3.hermite = function hermite(out, a, b, c, d, t) {
        var factorTimes2 = t * t, factor1 = factorTimes2 * (2 * t - 3) + 1, factor2 = factorTimes2 * (t - 2) + t, factor3 = factorTimes2 * (t - 1), factor4 = factorTimes2 * (3 - 2 * t);
        out.x = a.x * factor1 + b.x * factor2 + c.x * factor3 + d.x * factor4;
        out.y = a.y * factor1 + b.y * factor2 + c.y * factor3 + d.y * factor4;
        out.z = a.z * factor1 + b.z * factor2 + c.z * factor3 + d.z * factor4;
        return out;
      };
      vec3.bezier = function bezier(out, a, b, c, d, t) {
        var inverseFactor = 1 - t, inverseFactorTimesTwo = inverseFactor * inverseFactor, factorTimes2 = t * t, factor1 = inverseFactorTimesTwo * inverseFactor, factor2 = 3 * t * inverseFactorTimesTwo, factor3 = 3 * factorTimes2 * inverseFactor, factor4 = factorTimes2 * t;
        out.x = a.x * factor1 + b.x * factor2 + c.x * factor3 + d.x * factor4;
        out.y = a.y * factor1 + b.y * factor2 + c.y * factor3 + d.y * factor4;
        out.z = a.z * factor1 + b.z * factor2 + c.z * factor3 + d.z * factor4;
        return out;
      };
      vec3.random = function random(out, scale) {
        scale = scale || 1;
        var phi = 2 * (0, _utils.random)() * Math.PI;
        var theta = Math.acos(2 * (0, _utils.random)() - 1);
        out.x = Math.sin(theta) * Math.cos(phi) * scale;
        out.y = Math.sin(theta) * Math.sin(phi) * scale;
        out.z = Math.cos(theta) * scale;
        return out;
      };
      vec3.transformMat4 = function transformMat4(out, a, m) {
        var x = a.x, y = a.y, z = a.z, rhw = m.m03 * x + m.m07 * y + m.m11 * z + m.m15;
        rhw = rhw ? 1 / rhw : 1;
        out.x = (m.m00 * x + m.m04 * y + m.m08 * z + m.m12) * rhw;
        out.y = (m.m01 * x + m.m05 * y + m.m09 * z + m.m13) * rhw;
        out.z = (m.m02 * x + m.m06 * y + m.m10 * z + m.m14) * rhw;
        return out;
      };
      vec3.transformMat4Normal = function transformMat4Normal(out, a, m) {
        var x = a.x, y = a.y, z = a.z, rhw = m.m03 * x + m.m07 * y + m.m11 * z;
        rhw = rhw ? 1 / rhw : 1;
        out.x = (m.m00 * x + m.m04 * y + m.m08 * z) * rhw;
        out.y = (m.m01 * x + m.m05 * y + m.m09 * z) * rhw;
        out.z = (m.m02 * x + m.m06 * y + m.m10 * z) * rhw;
        return out;
      };
      vec3.transformMat3 = function transformMat3(out, a, m) {
        var x = a.x, y = a.y, z = a.z;
        out.x = x * m.m00 + y * m.m03 + z * m.m06;
        out.y = x * m.m01 + y * m.m04 + z * m.m07;
        out.z = x * m.m02 + y * m.m05 + z * m.m08;
        return out;
      };
      vec3.transformQuat = function transformQuat(out, a, q) {
        var x = a.x, y = a.y, z = a.z;
        var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;
        out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return out;
      };
      vec3.rotateX = function rotateX(out, a, b, c) {
        var px = a.x - b.x;
        var py = a.y - b.y;
        var pz = a.z - b.z;
        var rx = px;
        var ry = py * Math.cos(c) - pz * Math.sin(c);
        var rz = py * Math.sin(c) + pz * Math.cos(c);
        out.x = rx + b.x;
        out.y = ry + b.y;
        out.z = rz + b.z;
        return out;
      };
      vec3.rotateY = function rotateY(out, a, b, c) {
        var px = a.x - b.x;
        var py = a.y - b.y;
        var pz = a.z - b.z;
        var rx = pz * Math.sin(c) + px * Math.cos(c);
        var ry = py;
        var rz = pz * Math.cos(c) - px * Math.sin(c);
        out.x = rx + b.x;
        out.y = ry + b.y;
        out.z = rz + b.z;
        return out;
      };
      vec3.rotateZ = function rotateZ(out, a, b, c) {
        var px = a.x - b.x;
        var py = a.y - b.y;
        var pz = a.z - b.z;
        var rx = px * Math.cos(c) - py * Math.sin(c);
        var ry = px * Math.sin(c) + py * Math.cos(c);
        var rz = pz;
        out.x = rx + b.x;
        out.y = ry + b.y;
        out.z = rz + b.z;
        return out;
      };
      vec3.str = function str(a) {
        return "vec3(" + a.x + ", " + a.y + ", " + a.z + ")";
      };
      vec3.array = function array(out, v) {
        out[0] = v.x;
        out[1] = v.y;
        out[2] = v.z;
        return out;
      };
      vec3.exactEquals = function exactEquals(a, b) {
        return a.x === b.x && a.y === b.y && a.z === b.z;
      };
      vec3.equals = function equals(a, b) {
        var a0 = a.x, a1 = a.y, a2 = a.z;
        var b0 = b.x, b1 = b.y, b2 = b.z;
        return Math.abs(a0 - b0) <= _utils.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _utils.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _utils.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
      };
      vec3.forEach = function forEach(a, stride, offset, count, fn, arg) {
        return vec3._forEach(a, stride, offset, count, fn, arg);
      };
      vec3.angle = function angle(a, b) {
        return vec3._angle(a, b);
      };
      vec3.projectOnPlane = function projectOnPlane(out, a, n) {
        return vec3.sub(out, a, vec3.project(out, a, n));
      };
      vec3.project = function project(out, a, b) {
        var sqrLen = vec3.squaredMagnitude(b);
        return sqrLen < 1e-6 ? vec3.set(out, 0, 0, 0) : vec3.scale(out, b, vec3.dot(a, b) / sqrLen);
      };
      return vec3;
    })();
    vec3._forEach = (function() {
      var vec = vec3.create(0, 0, 0);
      return function(a, stride, offset, count, fn, arg) {
        var i = void 0, l = void 0;
        stride || (stride = 3);
        offset || (offset = 0);
        l = count ? Math.min(count * stride + offset, a.length) : a.length;
        for (i = offset; i < l; i += stride) {
          vec.x = a[i];
          vec.y = a[i + 1];
          vec.z = a[i + 2];
          fn(vec, vec, arg);
          a[i] = vec.x;
          a[i + 1] = vec.y;
          a[i + 2] = vec.z;
        }
        return a;
      };
    })();
    vec3._angle = (function() {
      var tempA = vec3.create(0, 0, 0);
      var tempB = vec3.create(0, 0, 0);
      return function(a, b) {
        vec3.copy(tempA, a);
        vec3.copy(tempB, b);
        vec3.normalize(tempA, tempA);
        vec3.normalize(tempB, tempB);
        var cosine = vec3.dot(tempA, tempB);
        if (cosine > 1) return 0;
        if (cosine < -1) return Math.PI;
        return Math.acos(cosine);
      };
    })();
    exports.default = vec3;
    module.exports = exports["default"];
  }), {
    "./utils": 213
  } ],
  216: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _utils = require("./utils");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var vec4 = (function() {
      function vec4() {
        var x = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
        var y = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        var z = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        var w = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        _classCallCheck(this, vec4);
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
      }
      vec4.create = function create() {
        var x = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
        var y = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        var z = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        var w = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        return new vec4(x, y, z, w);
      };
      vec4.zero = function zero(out) {
        out.x = 0;
        out.y = 0;
        out.z = 0;
        out.w = 0;
        return out;
      };
      vec4.clone = function clone(a) {
        return new vec4(a.x, a.y, a.z, a.w);
      };
      vec4.copy = function copy(out, a) {
        out.x = a.x;
        out.y = a.y;
        out.z = a.z;
        out.w = a.w;
        return out;
      };
      vec4.set = function set(out, x, y, z, w) {
        out.x = x;
        out.y = y;
        out.z = z;
        out.w = w;
        return out;
      };
      vec4.add = function add(out, a, b) {
        out.x = a.x + b.x;
        out.y = a.y + b.y;
        out.z = a.z + b.z;
        out.w = a.w + b.w;
        return out;
      };
      vec4.subtract = function subtract(out, a, b) {
        out.x = a.x - b.x;
        out.y = a.y - b.y;
        out.z = a.z - b.z;
        out.w = a.w - b.w;
        return out;
      };
      vec4.sub = function sub(out, a, b) {
        return vec4.subtract(out, a, b);
      };
      vec4.multiply = function multiply(out, a, b) {
        out.x = a.x * b.x;
        out.y = a.y * b.y;
        out.z = a.z * b.z;
        out.w = a.w * b.w;
        return out;
      };
      vec4.mul = function mul(out, a, b) {
        return vec4.multiply(out, a, b);
      };
      vec4.divide = function divide(out, a, b) {
        out.x = a.x / b.x;
        out.y = a.y / b.y;
        out.z = a.z / b.z;
        out.w = a.w / b.w;
        return out;
      };
      vec4.div = function div(out, a, b) {
        return vec4.divide(out, a, b);
      };
      vec4.ceil = function ceil(out, a) {
        out.x = Math.ceil(a.x);
        out.y = Math.ceil(a.y);
        out.z = Math.ceil(a.z);
        out.w = Math.ceil(a.w);
        return out;
      };
      vec4.floor = function floor(out, a) {
        out.x = Math.floor(a.x);
        out.y = Math.floor(a.y);
        out.z = Math.floor(a.z);
        out.w = Math.floor(a.w);
        return out;
      };
      vec4.min = function min(out, a, b) {
        out.x = Math.min(a.x, b.x);
        out.y = Math.min(a.y, b.y);
        out.z = Math.min(a.z, b.z);
        out.w = Math.min(a.w, b.w);
        return out;
      };
      vec4.max = function max(out, a, b) {
        out.x = Math.max(a.x, b.x);
        out.y = Math.max(a.y, b.y);
        out.z = Math.max(a.z, b.z);
        out.w = Math.max(a.w, b.w);
        return out;
      };
      vec4.round = function round(out, a) {
        out.x = Math.round(a.x);
        out.y = Math.round(a.y);
        out.z = Math.round(a.z);
        out.w = Math.round(a.w);
        return out;
      };
      vec4.scale = function scale(out, a, b) {
        out.x = a.x * b;
        out.y = a.y * b;
        out.z = a.z * b;
        out.w = a.w * b;
        return out;
      };
      vec4.scaleAndAdd = function scaleAndAdd(out, a, b, scale) {
        out.x = a.x + b.x * scale;
        out.y = a.y + b.y * scale;
        out.z = a.z + b.z * scale;
        out.w = a.w + b.w * scale;
        return out;
      };
      vec4.distance = function distance(a, b) {
        var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z, w = b.w - a.w;
        return Math.sqrt(x * x + y * y + z * z + w * w);
      };
      vec4.dist = function dist(a, b) {
        return vec4.distance(a, b);
      };
      vec4.squaredDistance = function squaredDistance(a, b) {
        var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z, w = b.w - a.w;
        return x * x + y * y + z * z + w * w;
      };
      vec4.sqrDist = function sqrDist(a, b) {
        return vec4.squaredDistance(a, b);
      };
      vec4.magnitude = function magnitude(a) {
        var x = a.x, y = a.y, z = a.z, w = a.w;
        return Math.sqrt(x * x + y * y + z * z + w * w);
      };
      vec4.mag = function mag(a) {
        return vec4.magnitude(a);
      };
      vec4.squaredMagnitude = function squaredMagnitude(a) {
        var x = a.x, y = a.y, z = a.z, w = a.w;
        return x * x + y * y + z * z + w * w;
      };
      vec4.sqrMag = function sqrMag(a) {
        return vec4.squaredMagnitude(a);
      };
      vec4.negate = function negate(out, a) {
        out.x = -a.x;
        out.y = -a.y;
        out.z = -a.z;
        out.w = -a.w;
        return out;
      };
      vec4.inverse = function inverse(out, a) {
        out.x = 1 / a.x;
        out.y = 1 / a.y;
        out.z = 1 / a.z;
        out.w = 1 / a.w;
        return out;
      };
      vec4.inverseSafe = function inverseSafe(out, a) {
        var x = a.x, y = a.y, z = a.z, w = a.w;
        Math.abs(x) < _utils.EPSILON ? out.x = 0 : out.x = 1 / x;
        Math.abs(y) < _utils.EPSILON ? out.y = 0 : out.y = 1 / y;
        Math.abs(z) < _utils.EPSILON ? out.z = 0 : out.z = 1 / z;
        Math.abs(w) < _utils.EPSILON ? out.w = 0 : out.w = 1 / w;
        return out;
      };
      vec4.normalize = function normalize(out, a) {
        var x = a.x, y = a.y, z = a.z, w = a.w;
        var len = x * x + y * y + z * z + w * w;
        if (len > 0) {
          len = 1 / Math.sqrt(len);
          out.x = x * len;
          out.y = y * len;
          out.z = z * len;
          out.w = w * len;
        }
        return out;
      };
      vec4.dot = function dot(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
      };
      vec4.lerp = function lerp(out, a, b, t) {
        var ax = a.x, ay = a.y, az = a.z, aw = a.w;
        out.x = ax + t * (b.x - ax);
        out.y = ay + t * (b.y - ay);
        out.z = az + t * (b.z - az);
        out.w = aw + t * (b.w - aw);
        return out;
      };
      vec4.random = function random(out, scale) {
        scale = scale || 1;
        var phi = 2 * (0, _utils.random)() * Math.PI;
        var theta = Math.acos(2 * (0, _utils.random)() - 1);
        out.x = Math.sin(theta) * Math.cos(phi) * scale;
        out.y = Math.sin(theta) * Math.sin(phi) * scale;
        out.z = Math.cos(theta) * scale;
        out.w = 0;
        return out;
      };
      vec4.transformMat4 = function transformMat4(out, a, m) {
        var x = a.x, y = a.y, z = a.z, w = a.w;
        out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12 * w;
        out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13 * w;
        out.z = m.m02 * x + m.m06 * y + m.m10 * z + m.m14 * w;
        out.w = m.m03 * x + m.m07 * y + m.m11 * z + m.m15 * w;
        return out;
      };
      vec4.transformQuat = function transformQuat(out, a, q) {
        var x = a.x, y = a.y, z = a.z;
        var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;
        out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        out.w = a.w;
        return out;
      };
      vec4.str = function str(a) {
        return "vec4(" + a.x + ", " + a.y + ", " + a.z + ", " + a.w + ")";
      };
      vec4.array = function array(out, v) {
        out[0] = v.x;
        out[1] = v.y;
        out[2] = v.z;
        out[3] = v.w;
        return out;
      };
      vec4.exactEquals = function exactEquals(a, b) {
        return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
      };
      vec4.equals = function equals(a, b) {
        var a0 = a.x, a1 = a.y, a2 = a.z, a3 = a.w;
        var b0 = b.x, b1 = b.y, b2 = b.z, b3 = b.w;
        return Math.abs(a0 - b0) <= _utils.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _utils.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _utils.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _utils.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
      };
      vec4.forEach = function forEach(a, stride, offset, count, fn, arg) {
        return vec4._forEach(a, stride, offset, count, fn, arg);
      };
      return vec4;
    })();
    vec4._forEach = (function() {
      var vec = vec4.create(0, 0, 0, 0);
      return function(a, stride, offset, count, fn, arg) {
        var i = void 0, l = void 0;
        stride || (stride = 4);
        offset || (offset = 0);
        l = count ? Math.min(count * stride + offset, a.length) : a.length;
        for (i = offset; i < l; i += stride) {
          vec.x = a[i];
          vec.y = a[i + 1];
          vec.z = a[i + 2];
          vec.w = a[i + 3];
          fn(vec, vec, arg);
          a[i] = vec.x;
          a[i + 1] = vec.y;
          a[i + 2] = vec.z;
          a[i + 3] = vec.w;
        }
        return a;
      };
    })();
    exports.default = vec4;
    module.exports = exports["default"];
  }), {
    "./utils": 213
  } ],
  217: [ (function(require, module, exports) {
    "use strict";
    var js = cc.js;
    true;
    var deprecateEnum = function deprecateEnum(obj, oldPath, newPath, hasTypePrefixBefore) {
      false;
      hasTypePrefixBefore = false !== hasTypePrefixBefore;
      var enumDef = Function("return " + newPath)();
      var entries = cc.Enum.getList(enumDef);
      var delimiter = hasTypePrefixBefore ? "_" : ".";
      for (var i = 0; i < entries.length; i++) {
        var entry = entries[i].name;
        var oldPropName;
        if (hasTypePrefixBefore) {
          var oldTypeName = oldPath.split(".").slice(-1)[0];
          oldPropName = oldTypeName + "_" + entry;
        } else oldPropName = entry;
        js.get(obj, oldPropName, function(entry) {
          cc.errorID(1400, oldPath + delimiter + entry, newPath + "." + entry);
          return enumDef[entry];
        }.bind(null, entry));
      }
    };
    var markAsRemoved = function markAsRemoved(ownerCtor, removedProps, ownerName) {
      if (!ownerCtor) return;
      ownerName = ownerName || js.getClassName(ownerCtor);
      removedProps.forEach((function(prop) {
        function error() {
          cc.errorID(1406, ownerName, prop);
        }
        js.getset(ownerCtor.prototype, prop, error, error);
      }));
    };
    var markAsDeprecated = function markAsDeprecated(ownerCtor, deprecatedProps, ownerName) {
      if (!ownerCtor) return;
      ownerName = ownerName || js.getClassName(ownerCtor);
      var descriptors = Object.getOwnPropertyDescriptors(ownerCtor.prototype);
      deprecatedProps.forEach((function(prop) {
        var deprecatedProp = prop[0];
        var newProp = prop[1];
        var descriptor = descriptors[deprecatedProp];
        js.getset(ownerCtor.prototype, deprecatedProp, (function() {
          cc.warnID(1400, ownerName + "." + deprecatedProp, ownerName + "." + newProp);
          return descriptor.get.call(this);
        }), (function(v) {
          cc.warnID(1400, ownerName + "." + deprecatedProp, ownerName + "." + newProp);
          descriptor.set.call(this, v);
        }));
      }));
    };
    var markAsRemovedInObject = function markAsRemovedInObject(ownerObj, removedProps, ownerName) {
      if (!ownerObj) return;
      removedProps.forEach((function(prop) {
        function error() {
          cc.errorID(1406, ownerName, prop);
        }
        js.getset(ownerObj, prop, error);
      }));
    };
    var provideClearError = function provideClearError(owner, obj, ownerName) {
      if (!owner) return;
      var className = ownerName || cc.js.getClassName(owner);
      var Info = "Sorry, " + className + ".%s is removed, please use %s instead.";
      var _loop = function _loop() {
        function define(prop, getset) {
          function accessor(newProp) {
            cc.error(Info, prop, newProp);
          }
          Array.isArray(getset) || (getset = getset.split(",").map((function(x) {
            return x.trim();
          })));
          try {
            js.getset(owner, prop, accessor.bind(null, getset[0]), getset[1] && accessor.bind(null, getset[1]));
          } catch (e) {}
        }
        getset = obj[prop];
        if ("*" === prop[0]) {
          etProp = prop.slice(1);
          define("g" + etProp, getset);
          define("s" + etProp, getset);
        } else prop.split(",").map((function(x) {
          return x.trim();
        })).forEach((function(x) {
          define(x, getset);
        }));
      };
      for (var prop in obj) {
        var getset;
        var etProp;
        _loop();
      }
    };
    var markFunctionWarning = function markFunctionWarning(ownerCtor, obj, ownerName) {
      if (!ownerCtor) return;
      ownerName = ownerName || js.getClassName(ownerCtor);
      for (var prop in obj) (function() {
        var propName = prop;
        var originFunc = ownerCtor[propName];
        if (!originFunc) return;
        function warn() {
          cc.warn("Sorry, %s.%s is deprecated. Please use %s instead", ownerName, propName, obj[propName]);
          return originFunc.apply(this, arguments);
        }
        ownerCtor[propName] = warn;
      })();
    };
    js.get(cc, "info", (function() {
      cc.warnID(1400, "cc.info", "cc.log");
      return cc.log;
    }));
    js.get(cc, "spriteFrameCache", (function() {
      cc.errorID(1404);
    }));
    js.get(cc.SpriteFrame.prototype, "_textureLoaded", (function() {
      cc.errorID(1400, "spriteFrame._textureLoaded", "spriteFrame.textureLoaded()");
      return this.textureLoaded();
    }));
    markAsRemoved(cc.SpriteFrame, [ "addLoadedEventListener" ]);
    markFunctionWarning(cc.Sprite.prototype, {
      setState: "cc.Sprite.setMaterial",
      getState: "cc.Sprite.getMaterial"
    }, "cc.Sprite");
    js.get(cc, "textureCache", (function() {
      cc.errorID(1406, "cc", "textureCache");
    }));
    var Texture2D = cc.Texture2D;
    js.obsolete(Texture2D.prototype, "texture.releaseTexture", "texture.destroy");
    js.get(Texture2D.prototype, "getName", (function() {
      cc.warnID(1400, "texture.getName()", "texture._glID");
      return function() {
        return this._glID || null;
      };
    }));
    js.get(Texture2D.prototype, "isLoaded", (function() {
      cc.errorID(1400, "texture.isLoaded function", "texture.loaded property");
      return function() {
        return this.loaded;
      };
    }));
    js.get(Texture2D.prototype, "setAntiAliasTexParameters", (function() {
      cc.warnID(1400, "texture.setAntiAliasTexParameters()", "texture.setFilters(cc.Texture2D.Filter.LINEAR, cc.Texture2D.Filter.LINEAR)");
      return function() {
        this.setFilters(Texture2D.Filter.LINEAR, Texture2D.Filter.LINEAR);
      };
    }));
    js.get(Texture2D.prototype, "setAliasTexParameters", (function() {
      cc.warnID(1400, "texture.setAntiAliasTexParameters()", "texture.setFilters(cc.Texture2D.Filter.NEAREST, cc.Texture2D.Filter.NEAREST)");
      return function() {
        this.setFilters(Texture2D.Filter.NEAREST, Texture2D.Filter.NEAREST);
      };
    }));
    markAsRemovedInObject(cc.macro, [ "ENABLE_GL_STATE_CACHE", "FIX_ARTIFACTS_BY_STRECHING_TEXEL" ], "cc.macro");
    provideClearError(cc.macro, {
      PI: "Math.PI",
      PI2: "Math.PI*2",
      FLT_MAX: "Number.MAX_VALUE",
      FLT_MIN: "Number.MIN_VALUE",
      UINT_MAX: "Number.MAX_SAFE_INTEGER"
    }, "cc.macro");
    markAsRemovedInObject(cc.game, [ "CONFIG_KEY" ], "cc.game");
    markAsRemovedInObject(cc.sys, [ "dumpRoot", "cleanScript" ], "cc.sys");
    provideClearError(cc.Director, {
      EVENT_PROJECTION_CHANGED: "",
      EVENT_BEFORE_VISIT: "EVENT_AFTER_UPDATE",
      EVENT_AFTER_VISIT: "EVENT_BEFORE_DRAW"
    }, "cc.Director");
    markFunctionWarning(cc.Director.prototype, {
      convertToGL: "cc.view.convertToLocationInView",
      convertToUI: "",
      getWinSize: "cc.winSize",
      getWinSizeInPixels: "cc.winSize",
      getVisibleSize: "cc.view.getVisibleSize",
      getVisibleOrigin: "cc.view.getVisibleOrigin",
      purgeCachedData: "cc.loader.releaseAll",
      setDepthTest: "cc.Camera.main.depth",
      setClearColor: "cc.Camera.main.backgroundColor",
      getRunningScene: "cc.director.getScene",
      getAnimationInterval: "cc.game.getFrameRate",
      setAnimationInterval: "cc.game.setFrameRate",
      isDisplayStats: "cc.debug.isDisplayStats",
      setDisplayStats: "cc.debug.setDisplayStats",
      stopAnimation: "cc.game.pause",
      startAnimation: "cc.game.resume"
    }, "cc.Director");
    markAsRemoved(cc.Director, [ "pushScene", "popScene", "popToRootScene", "popToSceneStackLevel", "setProjection", "getProjection" ], "cc.Director");
    provideClearError(cc.Scheduler, {
      scheduleCallbackForTarget: "schedule",
      scheduleUpdateForTarget: "scheduleUpdate",
      unscheduleCallbackForTarget: "unschedule",
      unscheduleUpdateForTarget: "unscheduleUpdate",
      unscheduleAllCallbacksForTarget: "unscheduleAllForTarget",
      unscheduleAllCallbacks: "unscheduleAll",
      unscheduleAllCallbacksWithMinPriority: "unscheduleAllWithMinPriority"
    }, "cc.Scheduler");
    provideClearError(cc.view, {
      adjustViewPort: "adjustViewportMeta",
      setViewPortInPoints: "setViewportInPoints",
      getViewPortRect: "getViewportRect"
    }, "cc.view");
    markAsRemovedInObject(cc.view, [ "isViewReady", "setTargetDensityDPI", "getTargetDensityDPI", "setFrameZoomFactor", "canSetContentScaleFactor", "setContentTranslateLeftTop", "getContentTranslateLeftTop", "setViewName", "getViewName" ], "cc.view");
    markAsRemoved(cc.Pipeline, [ "flowInDeps", "getItems" ], "cc.loader");
    markAsRemoved(cc.PhysicsManager, [ "attachDebugDrawToCamera", "detachDebugDrawFromCamera" ]);
    markAsRemoved(cc.CollisionManager, [ "attachDebugDrawToCamera", "detachDebugDrawFromCamera" ]);
    provideClearError(cc._BaseNode.prototype, {
      tag: "name",
      getTag: "name",
      setTag: "name",
      getChildByTag: "getChildByName",
      removeChildByTag: "getChildByName(name).destroy()"
    });
    markAsRemoved(cc.Node, [ "_cascadeColorEnabled", "cascadeColor", "isCascadeColorEnabled", "setCascadeColorEnabled", "_cascadeOpacityEnabled", "cascadeOpacity", "isCascadeOpacityEnabled", "setCascadeOpacityEnabled", "opacityModifyRGB", "isOpacityModifyRGB", "setOpacityModifyRGB", "ignoreAnchor", "isIgnoreAnchorPointForPosition", "ignoreAnchorPointForPosition", "isRunning", "_sgNode" ]);
    markFunctionWarning(cc.Node.prototype, {
      getNodeToParentTransform: "getLocalMatrix",
      getNodeToParentTransformAR: "getLocalMatrix",
      getNodeToWorldTransform: "getWorldMatrix",
      getNodeToWorldTransformAR: "getWorldMatrix",
      getParentToNodeTransform: "getLocalMatrix",
      getWorldToNodeTransform: "getWorldMatrix",
      convertTouchToNodeSpace: "convertToNodeSpace",
      convertTouchToNodeSpaceAR: "convertToNodeSpaceAR"
    });
    provideClearError(cc.Node.prototype, {
      getRotationX: "rotationX",
      setRotationX: "rotationX",
      getRotationY: "rotationY",
      setRotationY: "rotationY",
      getPositionX: "x",
      setPositionX: "x",
      getPositionY: "y",
      setPositionY: "y",
      getSkewX: "skewX",
      setSkewX: "skewX",
      getSkewY: "skewY",
      setSkewY: "skewY",
      getScaleX: "scaleX",
      setScaleX: "scaleX",
      getScaleY: "scaleY",
      setScaleY: "scaleY",
      getOpacity: "opacity",
      setOpacity: "opacity",
      getColor: "color",
      setColor: "color",
      getLocalZOrder: "zIndex",
      setLocalZOrder: "zIndex"
    });
    markAsRemoved(cc.Component, [ "isRunning" ]);
    provideClearError(cc.Sprite.prototype, {
      setInsetLeft: "cc.SpriteFrame insetLeft",
      setInsetRight: "cc.SpriteFrame insetRight",
      setInsetTop: "cc.SpriteFrame insetTop",
      setInsetBottom: "cc.SpriteFrame insetBottom"
    });
    markFunctionWarning(cc.Camera.prototype, {
      getNodeToCameraTransform: "getWorldToCameraMatrix"
    });
    markAsRemoved(cc.Camera, [ "addTarget", "removeTarget", "getTargets" ]);
    var ERR = '"%s" is not defined in the Scene, it is only defined in normal nodes.';
    false, Object.defineProperties(cc.Scene.prototype, {
      active: {
        get: function get() {
          cc.error(ERR, "active");
          return true;
        },
        set: function set() {
          cc.error(ERR, "active");
        }
      },
      activeInHierarchy: {
        get: function get() {
          cc.error(ERR, "activeInHierarchy");
          return true;
        }
      },
      getComponent: {
        get: function get() {
          cc.error(ERR, "getComponent");
          return function() {
            return null;
          };
        }
      },
      addComponent: {
        get: function get() {
          cc.error(ERR, "addComponent");
          return function() {
            return null;
          };
        }
      }
    });
    provideClearError(cc, {
      affineTransformMake: "cc.AffineTransform.create",
      affineTransformMakeIdentity: "cc.AffineTransform.identity",
      affineTransformClone: "cc.AffineTransform.clone",
      affineTransformConcat: "cc.AffineTransform.concat",
      affineTransformConcatIn: "cc.AffineTransform.concat",
      affineTransformInvert: "cc.AffineTransform.invert",
      affineTransformInvertIn: "cc.AffineTransform.invert",
      affineTransformInvertOut: "cc.AffineTransform.invert",
      affineTransformEqualToTransform: "cc.AffineTransform.equal",
      pointApplyAffineTransform: "cc.AffineTransform.transformVec2",
      sizeApplyAffineTransform: "cc.AffineTransform.transformSize",
      rectApplyAffineTransform: "cc.AffineTransform.transformRect",
      obbApplyAffineTransform: "cc.AffineTransform.transformObb",
      pointEqualToPoint: "cc.Vec2 equals",
      sizeEqualToSize: "cc.Size equals",
      rectEqualToRect: "rectA.equals(rectB)",
      rectContainsRect: "rectA.containsRect(rectB)",
      rectContainsPoint: "rect.contains(vec2)",
      rectOverlapsRect: "rectA.intersects(rectB)",
      rectIntersectsRect: "rectA.intersects(rectB)",
      rectIntersection: "rectA.intersection(intersection, rectB)",
      rectUnion: "rectA.union(union, rectB)",
      rectGetMaxX: "rect.xMax",
      rectGetMidX: "rect.center.x",
      rectGetMinX: "rect.xMin",
      rectGetMaxY: "rect.yMax",
      rectGetMidY: "rect.center.y",
      rectGetMinY: "rect.yMin",
      colorEqual: "colorA.equals(colorB)",
      hexToColor: "color.fromHEX(hexColor)",
      colorToHex: "color.toHEX()",
      TextAlignment: "cc.macro.TextAlignment",
      VerticalTextAlignment: "cc.macro.VerticalTextAlignment",
      pNeg: "p.neg()",
      pAdd: "p1.add(p2)",
      pSub: "p1.sub(p2)",
      pMult: "p.mul(factor)",
      pMidpoint: "p1.add(p2).mul(0.5)",
      pDot: "p1.dot(p2)",
      pCross: "p1.cross(p2)",
      pPerp: "p.rotate(-90 * Math.PI / 180)",
      pRPerp: "p.rotate(90 * Math.PI / 180)",
      pProject: "p1.project(p2)",
      pLengthSQ: "p.magSqr()",
      pDistanceSQ: "p1.sub(p2).magSqr()",
      pLength: "p.mag()",
      pDistance: "p1.sub(p2).mag()",
      pNormalize: "p.normalize()",
      pForAngle: "cc.v2(Math.cos(a), Math.sin(a))",
      pToAngle: "Math.atan2(v.y, v.x)",
      pZeroIn: "p.x = p.y = 0",
      pIn: "p1.set(p2)",
      pMultIn: "p.mulSelf(factor)",
      pSubIn: "p1.subSelf(p2)",
      pAddIn: "p1.addSelf(p2)",
      pNormalizeIn: "p.normalizeSelf()",
      pSameAs: "p1.equals(p2)",
      pAngle: "v1.angle(v2)",
      pAngleSigned: "v1.signAngle(v2)",
      pRotateByAngle: "p.rotate(radians)",
      pCompMult: "v1.dot(v2)",
      pFuzzyEqual: "v1.fuzzyEquals(v2, tolerance)",
      pLerp: "p.lerp(endPoint, ratio)",
      pClamp: "p.clampf(min_inclusive, max_inclusive)",
      rand: "Math.random() * 0xffffff",
      randomMinus1To1: "(Math.random() - 0.5) * 2",
      container: "cc.game.container",
      _canvas: "cc.game.canvas",
      _renderType: "cc.game.renderType",
      _getError: "cc.debug.getError",
      _initDebugSetting: "cc.debug._resetDebugSetting",
      DebugMode: "cc.debug.DebugMode",
      BlendFunc: "cc.macro.BlendFactor"
    }, "cc");
    markAsRemovedInObject(cc, [ "blendFuncDisable", "pFromSize", "pCompOp", "pIntersectPoint", "pSegmentIntersect", "pLineIntersect", "obbApplyMatrix", "getImageFormatByData", "initEngine" ], "cc");
    markFunctionWarning(cc, {
      p: "cc.v2"
    }, "cc");
    provideClearError(cc.Rect, {
      contain: "rectA.contains(rectB)",
      transformMat4: "rect.transformMat4(out, mat4)"
    });
    provideClearError(cc.Color, {
      rgb2hsv: "color.toHSV()",
      hsv2rgb: "color.fromHSV(h, s, v)"
    });
    js.get(cc, "lerp", (function() {
      cc.warnID(1400, "cc.lerp", "cc.misc.lerp");
      return cc.misc.lerp;
    }));
    js.get(cc, "random0To1", (function() {
      cc.warnID(1400, "cc.random0To1", "Math.random");
      return Math.random;
    }));
    js.get(cc, "degreesToRadians", (function() {
      cc.warnID(1400, "cc.degreesToRadians", "cc.misc.degreesToRadians");
      return cc.misc.degreesToRadians;
    }));
    js.get(cc, "radiansToDegrees", (function() {
      cc.warnID(1400, "cc.radiansToDegrees", "cc.misc.radiansToDegrees");
      return cc.misc.radiansToDegrees;
    }));
    js.get(cc, "clampf", (function() {
      cc.warnID(1400, "cc.clampf", "cc.misc.clampf");
      return cc.misc.clampf;
    }));
    js.get(cc, "clamp01", (function() {
      cc.warnID(1400, "cc.clamp01", "cc.misc.clamp01");
      return cc.misc.clamp01;
    }));
    js.get(cc, "ImageFormat", (function() {
      cc.warnID(1400, "cc.ImageFormat", "cc.macro.ImageFormat");
      return cc.macro.ImageFormat;
    }));
    js.get(cc, "KEY", (function() {
      cc.warnID(1400, "cc.KEY", "cc.macro.KEY");
      return cc.macro.KEY;
    }));
    js.get(cc, "Easing", (function() {
      cc.warnID(1400, "cc.Easing", "cc.easing");
      return cc.easing;
    }));
    js.get(cc, "pool", (function() {
      cc.errorID(1407);
      return js.Pool;
    }));
    js.get(cc, "isChildClassOf", (function() {
      cc.errorID(1400, "cc.isChildClassOf", "cc.js.isChildClassOf");
      return cc.js.isChildClassOf;
    }));
    "undefined" !== typeof dragonBones && js.obsolete(dragonBones.CCFactory, "dragonBones.CCFactory.getFactory", "getInstance");
    cc.renderer.renderEngine = {
      get gfx() {
        cc.warnID(1400, "cc.renderer.renderEngine.gfx", "cc.gfx");
        return cc.gfx;
      },
      get math() {
        cc.warnID(1400, "cc.renderer.renderEngine.math", "cc.vmath");
        return cc.vmath;
      },
      get InputAssembler() {
        cc.warnID(1400, "cc.renderer.renderEngine.InputAssembler", "cc.renderer.InputAssembler");
        return cc.renderer.InputAssembler;
      }
    };
  }), {} ],
  218: [ (function(require, module, exports) {
    "use strict";
    require("./core/CCGame");
    require("./actions");
  }), {
    "./actions": void 0,
    "./core/CCGame": 5
  } ],
  219: [ (function(require, module, exports) {
    "use strict";
    var Asset = require("../core/assets/CCAsset");
    var CCSpriteFrame = require("../core/assets/CCSpriteFrame");
    var ParticleAsset = cc.Class({
      name: "cc.ParticleAsset",
      extends: Asset,
      properties: {
        spriteFrame: {
          default: null,
          type: CCSpriteFrame
        }
      }
    });
    cc.ParticleAsset = module.exports = ParticleAsset;
  }), {
    "../core/assets/CCAsset": 10,
    "../core/assets/CCSpriteFrame": 24
  } ],
  220: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _stageOffset = 0;
    var _name2stageID = {};
    exports.default = {
      addStage: function addStage(name) {
        if (void 0 !== _name2stageID[name]) return;
        var stageID = 1 << _stageOffset;
        _name2stageID[name] = stageID;
        _stageOffset += 1;
      },
      stageID: function stageID(name) {
        var id = _name2stageID[name];
        if (void 0 === id) return -1;
        return id;
      },
      stageIDs: function stageIDs(nameList) {
        var key = 0;
        for (var i = 0; i < nameList.length; ++i) {
          var id = _name2stageID[nameList[i]];
          void 0 !== id && (key |= id);
        }
        return key;
      }
    };
    module.exports = exports["default"];
  }), {} ],
  221: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _type2uniformValue2, _type2uniformArrayVal;
    var _memop = require("../memop");
    var _enums = require("../enums");
    var _enums2 = _interopRequireDefault(_enums);
    var _vmath = require("../../core/vmath");
    var _programLib = require("./program-lib");
    var _programLib2 = _interopRequireDefault(_programLib);
    var _view = require("./view");
    var _view2 = _interopRequireDefault(_view);
    var _gfx = require("../gfx");
    var _gfx2 = _interopRequireDefault(_gfx);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _m3_tmp = _vmath.mat3.create();
    var _m4_tmp = _vmath.mat4.create();
    var _stageInfos = new _memop.RecyclePool(function() {
      return {
        stage: null,
        items: null
      };
    }, 8);
    var _float2_pool = new _memop.RecyclePool(function() {
      return new Float32Array(2);
    }, 8);
    var _float3_pool = new _memop.RecyclePool(function() {
      return new Float32Array(3);
    }, 8);
    var _float4_pool = new _memop.RecyclePool(function() {
      return new Float32Array(4);
    }, 8);
    var _float9_pool = new _memop.RecyclePool(function() {
      return new Float32Array(9);
    }, 8);
    var _float16_pool = new _memop.RecyclePool(function() {
      return new Float32Array(16);
    }, 8);
    var _float64_pool = new _memop.RecyclePool(function() {
      return new Float32Array(64);
    }, 8);
    var _int2_pool = new _memop.RecyclePool(function() {
      return new Int32Array(2);
    }, 8);
    var _int3_pool = new _memop.RecyclePool(function() {
      return new Int32Array(3);
    }, 8);
    var _int4_pool = new _memop.RecyclePool(function() {
      return new Int32Array(4);
    }, 8);
    var _int64_pool = new _memop.RecyclePool(function() {
      return new Int32Array(64);
    }, 8);
    var _type2uniformValue = (_type2uniformValue2 = {}, _type2uniformValue2[_enums2.default.PARAM_INT] = function(value) {
      return value;
    }, _type2uniformValue2[_enums2.default.PARAM_INT2] = function(value) {
      return _vmath.vec2.array(_int2_pool.add(), value);
    }, _type2uniformValue2[_enums2.default.PARAM_INT3] = function(value) {
      return _vmath.vec3.array(_int3_pool.add(), value);
    }, _type2uniformValue2[_enums2.default.PARAM_INT4] = function(value) {
      return _vmath.vec4.array(_int4_pool.add(), value);
    }, _type2uniformValue2[_enums2.default.PARAM_FLOAT] = function(value) {
      return value;
    }, _type2uniformValue2[_enums2.default.PARAM_FLOAT2] = function(value) {
      return _vmath.vec2.array(_float2_pool.add(), value);
    }, _type2uniformValue2[_enums2.default.PARAM_FLOAT3] = function(value) {
      return _vmath.vec3.array(_float3_pool.add(), value);
    }, _type2uniformValue2[_enums2.default.PARAM_FLOAT4] = function(value) {
      return _vmath.vec4.array(_float4_pool.add(), value);
    }, _type2uniformValue2[_enums2.default.PARAM_COLOR3] = function(value) {
      return _vmath.color3.array(_float3_pool.add(), value);
    }, _type2uniformValue2[_enums2.default.PARAM_COLOR4] = function(value) {
      return _vmath.color4.array(_float4_pool.add(), value);
    }, _type2uniformValue2[_enums2.default.PARAM_MAT2] = function(value) {
      return _vmath.mat2.array(_float4_pool.add(), value);
    }, _type2uniformValue2[_enums2.default.PARAM_MAT3] = function(value) {
      return _vmath.mat3.array(_float9_pool.add(), value);
    }, _type2uniformValue2[_enums2.default.PARAM_MAT4] = function(value) {
      return _vmath.mat4.array(_float16_pool.add(), value);
    }, _type2uniformValue2);
    var _type2uniformArrayValue = (_type2uniformArrayVal = {}, _type2uniformArrayVal[_enums2.default.PARAM_INT] = {
      func: function func(values) {
        var result = _int64_pool.add();
        for (var i = 0; i < values.length; ++i) result[i] = values[i];
        return result;
      },
      size: 1
    }, _type2uniformArrayVal[_enums2.default.PARAM_INT2] = {
      func: function func(values) {
        var result = _int64_pool.add();
        for (var i = 0; i < values.length; ++i) {
          result[2 * i] = values[i].x;
          result[2 * i + 1] = values[i].y;
        }
        return result;
      },
      size: 2
    }, _type2uniformArrayVal[_enums2.default.PARAM_INT3] = {
      func: void 0,
      size: 3
    }, _type2uniformArrayVal[_enums2.default.PARAM_INT4] = {
      func: function func(values) {
        var result = _int64_pool.add();
        for (var i = 0; i < values.length; ++i) {
          var v = values[i];
          result[4 * i] = v.x;
          result[4 * i + 1] = v.y;
          result[4 * i + 2] = v.z;
          result[4 * i + 3] = v.w;
        }
        return result;
      },
      size: 4
    }, _type2uniformArrayVal[_enums2.default.PARAM_FLOAT] = {
      func: function func(values) {
        var result = _float64_pool.add();
        for (var i = 0; i < values.length; ++i) result[i] = values[i];
        return result;
      },
      size: 1
    }, _type2uniformArrayVal[_enums2.default.PARAM_FLOAT2] = {
      func: function func(values) {
        var result = _float64_pool.add();
        for (var i = 0; i < values.length; ++i) {
          result[2 * i] = values[i].x;
          result[2 * i + 1] = values[i].y;
        }
        return result;
      },
      size: 2
    }, _type2uniformArrayVal[_enums2.default.PARAM_FLOAT3] = {
      func: void 0,
      size: 3
    }, _type2uniformArrayVal[_enums2.default.PARAM_FLOAT4] = {
      func: function func(values) {
        var result = _float64_pool.add();
        for (var i = 0; i < values.length; ++i) {
          var v = values[i];
          result[4 * i] = v.x;
          result[4 * i + 1] = v.y;
          result[4 * i + 2] = v.z;
          result[4 * i + 3] = v.w;
        }
        return result;
      },
      size: 4
    }, _type2uniformArrayVal[_enums2.default.PARAM_COLOR3] = {
      func: void 0,
      size: 3
    }, _type2uniformArrayVal[_enums2.default.PARAM_COLOR4] = {
      func: function func(values) {
        var result = _float64_pool.add();
        for (var i = 0; i < values.length; ++i) {
          var v = values[i];
          result[4 * i] = v.r;
          result[4 * i + 1] = v.g;
          result[4 * i + 2] = v.b;
          result[4 * i + 3] = v.a;
        }
        return result;
      },
      size: 4
    }, _type2uniformArrayVal[_enums2.default.PARAM_MAT2] = {
      func: function func(values) {
        var result = _float64_pool.add();
        for (var i = 0; i < values.length; ++i) {
          var v = values[i];
          result[4 * i] = v.m00;
          result[4 * i + 1] = v.m01;
          result[4 * i + 2] = v.m02;
          result[4 * i + 3] = v.m03;
        }
        return result;
      },
      size: 4
    }, _type2uniformArrayVal[_enums2.default.PARAM_MAT3] = {
      func: void 0,
      size: 9
    }, _type2uniformArrayVal[_enums2.default.PARAM_MAT4] = {
      func: function func(values) {
        var result = _float64_pool.add();
        for (var i = 0; i < values.length; ++i) {
          var v = values[i];
          result[16 * i] = v.m00;
          result[16 * i + 1] = v.m01;
          result[16 * i + 2] = v.m02;
          result[16 * i + 3] = v.m03;
          result[16 * i + 4] = v.m04;
          result[16 * i + 5] = v.m05;
          result[16 * i + 6] = v.m06;
          result[16 * i + 7] = v.m07;
          result[16 * i + 8] = v.m08;
          result[16 * i + 9] = v.m09;
          result[16 * i + 10] = v.m10;
          result[16 * i + 11] = v.m11;
          result[16 * i + 12] = v.m12;
          result[16 * i + 13] = v.m13;
          result[16 * i + 14] = v.m14;
          result[16 * i + 15] = v.m15;
        }
        return result;
      },
      size: 16
    }, _type2uniformArrayVal);
    var Base = (function() {
      function Base(device, opts) {
        var _type2defaultValue;
        _classCallCheck(this, Base);
        this._device = device;
        this._programLib = new _programLib2.default(device);
        this._opts = opts;
        this._type2defaultValue = (_type2defaultValue = {}, _type2defaultValue[_enums2.default.PARAM_INT] = 0, 
        _type2defaultValue[_enums2.default.PARAM_INT2] = _vmath.vec2.create(0, 0), _type2defaultValue[_enums2.default.PARAM_INT3] = _vmath.vec3.create(0, 0, 0), 
        _type2defaultValue[_enums2.default.PARAM_INT4] = _vmath.vec4.create(0, 0, 0, 0), 
        _type2defaultValue[_enums2.default.PARAM_FLOAT] = 0, _type2defaultValue[_enums2.default.PARAM_FLOAT2] = _vmath.vec2.create(0, 0), 
        _type2defaultValue[_enums2.default.PARAM_FLOAT3] = _vmath.vec3.create(0, 0, 0), 
        _type2defaultValue[_enums2.default.PARAM_FLOAT4] = _vmath.vec4.create(0, 0, 0, 0), 
        _type2defaultValue[_enums2.default.PARAM_COLOR3] = _vmath.color3.create(0, 0, 0), 
        _type2defaultValue[_enums2.default.PARAM_COLOR4] = _vmath.color4.create(0, 0, 0, 1), 
        _type2defaultValue[_enums2.default.PARAM_MAT2] = _vmath.mat2.create(), _type2defaultValue[_enums2.default.PARAM_MAT3] = _vmath.mat3.create(), 
        _type2defaultValue[_enums2.default.PARAM_MAT4] = _vmath.mat4.create(), _type2defaultValue[_enums2.default.PARAM_TEXTURE_2D] = opts.defaultTexture, 
        _type2defaultValue[_enums2.default.PARAM_TEXTURE_CUBE] = opts.defaultTextureCube, 
        _type2defaultValue);
        this._stage2fn = {};
        this._usedTextureUnits = 0;
        this._viewPools = new _memop.RecyclePool(function() {
          return new _view2.default();
        }, 8);
        this._drawItemsPools = new _memop.RecyclePool(function() {
          return {
            model: null,
            node: null,
            ia: null,
            effect: null,
            defines: null,
            uniforms: null
          };
        }, 100);
        this._stageItemsPools = new _memop.RecyclePool(function() {
          return new _memop.RecyclePool(function() {
            return {
              model: null,
              node: null,
              ia: null,
              effect: null,
              defines: null,
              technique: null,
              sortKey: -1,
              uniforms: null
            };
          }, 100);
        }, 16);
      }
      Base.prototype._resetTextuerUnit = function _resetTextuerUnit() {
        this._usedTextureUnits = 0;
      };
      Base.prototype._allocTextureUnit = function _allocTextureUnit() {
        var device = this._device;
        var unit = this._usedTextureUnits;
        unit >= device._caps.maxTextureUnits && console.warn("Trying to use " + unit + " texture units while this GPU supports only " + device._caps.maxTextureUnits);
        this._usedTextureUnits += 1;
        return unit;
      };
      Base.prototype._registerStage = function _registerStage(name, fn) {
        this._stage2fn[name] = fn;
      };
      Base.prototype.clear = function clear() {
        this._programLib.clear();
        this.reset();
      };
      Base.prototype.reset = function reset() {
        this._viewPools.reset();
        this._stageItemsPools.reset();
      };
      Base.prototype._requestView = function _requestView() {
        return this._viewPools.add();
      };
      Base.prototype._render = function _render(view, scene) {
        var device = this._device;
        device.setFrameBuffer(view._framebuffer);
        device.setViewport(view._rect.x, view._rect.y, view._rect.w, view._rect.h);
        var clearOpts = {};
        view._clearFlags & _enums2.default.CLEAR_COLOR && (clearOpts.color = [ view._color.r, view._color.g, view._color.b, view._color.a ]);
        view._clearFlags & _enums2.default.CLEAR_DEPTH && (clearOpts.depth = view._depth);
        view._clearFlags & _enums2.default.CLEAR_STENCIL && (clearOpts.stencil = view._stencil);
        device.clear(clearOpts);
        this._drawItemsPools.reset();
        for (var i = 0; i < scene._models.length; ++i) {
          var model = scene._models.data[i];
          if (0 === (model._cullingMask & view._cullingMask)) continue;
          var drawItem = this._drawItemsPools.add();
          model.extractDrawItem(drawItem);
        }
        _stageInfos.reset();
        for (var _i = 0; _i < view._stages.length; ++_i) {
          var stage = view._stages[_i];
          var stageItems = this._stageItemsPools.add();
          stageItems.reset();
          for (var j = 0; j < this._drawItemsPools.length; ++j) {
            var _drawItem = this._drawItemsPools.data[j];
            var tech = _drawItem.effect.getTechnique(stage);
            if (tech) {
              var stageItem = stageItems.add();
              stageItem.model = _drawItem.model;
              stageItem.node = _drawItem.node;
              stageItem.ia = _drawItem.ia;
              stageItem.effect = _drawItem.effect;
              stageItem.defines = _drawItem.defines;
              stageItem.technique = tech;
              stageItem.sortKey = -1;
              stageItem.uniforms = _drawItem.uniforms;
            }
          }
          var stageInfo = _stageInfos.add();
          stageInfo.stage = stage;
          stageInfo.items = stageItems;
        }
        for (var _i2 = 0; _i2 < _stageInfos.length; ++_i2) {
          var info = _stageInfos.data[_i2];
          var fn = this._stage2fn[info.stage];
          fn(view, info.items);
        }
      };
      Base.prototype._setProperty = function _setProperty(prop) {
        var device = this._device;
        var param = prop.value;
        void 0 === param && (param = prop.val);
        void 0 === param && (param = this._type2defaultValue[prop.type]);
        if (void 0 === param) {
          console.warn("Failed to set technique property " + prop.name + ", value not found.");
          return;
        }
        if (prop.type === _enums2.default.PARAM_TEXTURE_2D || prop.type === _enums2.default.PARAM_TEXTURE_CUBE) if (void 0 !== prop.size) {
          if (prop.size !== param.length) {
            console.error("The length of texture array (" + param.length + ") is not corrent(expect " + prop.size + ").");
            return;
          }
          var slots = _int64_pool.add();
          for (var index = 0; index < param.length; ++index) slots[index] = this._allocTextureUnit();
          device.setTextureArray(prop.name, param, slots);
        } else device.setTexture(prop.name, param, this._allocTextureUnit()); else {
          var convertedValue = void 0;
          if (param instanceof Float32Array || param instanceof Int32Array) {
            device.setUniformDirectly(prop.name, param);
            return;
          }
          if (void 0 !== prop.size) {
            var convertArray = _type2uniformArrayValue[prop.type];
            if (void 0 === convertArray.func) {
              console.error("Uniform array of color3/int3/float3/mat3 can not be supportted!");
              return;
            }
            if (prop.size * convertArray.size > 64) {
              console.error("Uniform array is too long!");
              return;
            }
            convertedValue = convertArray.func(param);
          } else {
            var convertFn = _type2uniformValue[prop.type];
            convertedValue = convertFn(param);
          }
          device.setUniform(prop.name, convertedValue);
        }
      };
      Base.prototype._draw = function _draw(item) {
        var device = this._device;
        var programLib = this._programLib;
        var node = item.node, ia = item.ia, uniforms = item.uniforms, technique = item.technique, defines = item.defines, effect = item.effect;
        _float2_pool.reset();
        _float3_pool.reset();
        _float4_pool.reset();
        _float9_pool.reset();
        _float16_pool.reset();
        _float64_pool.reset();
        _int2_pool.reset();
        _int3_pool.reset();
        _int4_pool.reset();
        _int64_pool.reset();
        node.getWorldMatrix(_m4_tmp);
        device.setUniform("cc_matWorld", _vmath.mat4.array(_float16_pool.add(), _m4_tmp));
        var inverse = _vmath.mat3.invert(_m3_tmp, _vmath.mat3.fromMat4(_m3_tmp, _m4_tmp));
        if (inverse) {
          _vmath.mat3.transpose(_m3_tmp, inverse);
          device.setUniform("cc_matWorldIT", _vmath.mat3.array(_float9_pool.add(), _m3_tmp));
        }
        for (var i = 0; i < uniforms.length; i++) {
          var typeUniforms = uniforms[i];
          for (var key in typeUniforms) this._setProperty(typeUniforms[key]);
        }
        for (var _i3 = 0; _i3 < technique._passes.length; ++_i3) {
          var pass = technique._passes[_i3];
          var count = ia.count;
          ia._vertexBuffer && device.setVertexBuffer(0, ia._vertexBuffer);
          ia._indexBuffer && device.setIndexBuffer(ia._indexBuffer);
          device.setPrimitiveType(ia._primitiveType);
          var program = programLib.getProgram(pass._programName, defines, effect._name);
          device.setProgram(program);
          device.setCullMode(pass._cullMode);
          if (pass._blend) {
            device.enableBlend();
            device.setBlendFuncSep(pass._blendSrc, pass._blendDst, pass._blendSrcAlpha, pass._blendDstAlpha);
            device.setBlendEqSep(pass._blendEq, pass._blendAlphaEq);
            device.setBlendColor32(pass._blendColor);
          }
          if (pass._depthTest) {
            device.enableDepthTest();
            device.setDepthFunc(pass._depthFunc);
          }
          pass._depthWrite && device.enableDepthWrite();
          device.setStencilTest(pass._stencilTest);
          if (pass._stencilTest === _gfx2.default.STENCIL_ENABLE) {
            device.setStencilFuncFront(pass._stencilFuncFront, pass._stencilRefFront, pass._stencilMaskFront);
            device.setStencilOpFront(pass._stencilFailOpFront, pass._stencilZFailOpFront, pass._stencilZPassOpFront, pass._stencilWriteMaskFront);
            device.setStencilFuncBack(pass._stencilFuncBack, pass._stencilRefBack, pass._stencilMaskBack);
            device.setStencilOpBack(pass._stencilFailOpBack, pass._stencilZFailOpBack, pass._stencilZPassOpBack, pass._stencilWriteMaskBack);
          }
          device.draw(ia._start, count);
          this._resetTextuerUnit();
        }
      };
      return Base;
    })();
    exports.default = Base;
    module.exports = exports["default"];
  }), {
    "../../core/vmath": 207,
    "../enums": 228,
    "../gfx": 233,
    "../memop": 245,
    "./program-lib": 225,
    "./view": 227
  } ],
  222: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _config = require("../config");
    var _config2 = _interopRequireDefault(_config);
    var _pass = require("../core/pass");
    var _pass2 = _interopRequireDefault(_pass);
    var _technique = require("../core/technique");
    var _technique2 = _interopRequireDefault(_technique);
    var _types = require("../types");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var getInstanceType = function getInstanceType(t) {
      return _types.enums2ctor[t] || _types.enums2ctor.default;
    };
    var typeCheck = function typeCheck(value, type) {
      var instanceType = getInstanceType(type);
      switch (typeof value) {
       case "object":
        return null === value || value instanceof instanceType;

       case "number":
        return instanceType === Number;

       default:
        return false;
      }
    };
    var Effect = (function() {
      function Effect(name, techniques) {
        var properties = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        var defines = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
        var dependencies = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [];
        _classCallCheck(this, Effect);
        this._name = name;
        this._techniques = techniques;
        this._properties = properties;
        this._defines = defines;
        this._dependencies = dependencies;
      }
      Effect.prototype.clear = function clear() {
        this._techniques.length = 0;
        this._properties = {};
        this._defines = {};
      };
      Effect.prototype.getDefaultTechnique = function getDefaultTechnique() {
        return this._techniques[0];
      };
      Effect.prototype.getTechnique = function getTechnique(stage) {
        var stageID = _config2.default.stageID(stage);
        if (-1 === stageID) return null;
        for (var i = 0; i < this._techniques.length; ++i) {
          var tech = this._techniques[i];
          if (tech.stageIDs & stageID) return tech;
        }
        return null;
      };
      Effect.prototype.getProperty = function getProperty(name) {
        if (!this._properties[name]) {
          cc.warn(this._name + " : Failed to get property " + name + ", property not found.");
          return null;
        }
        return this._properties[name].value;
      };
      Effect.prototype.setProperty = function setProperty(name, value) {
        var prop = this._properties[name];
        if (!prop) {
          cc.warn(this._name + " : Failed to set property " + name + ", property not found.");
          return;
        }
        this._properties[name].value = value;
      };
      Effect.prototype.getDefine = function getDefine(name) {
        var def = this._defines[name];
        void 0 === def && cc.warn(this._name + " : Failed to get define " + name + ", define not found.");
        return def;
      };
      Effect.prototype.define = function define(name, value) {
        var def = this._defines[name];
        if (void 0 === def) {
          cc.warn(this._name + " : Failed to set define " + name + ", define not found.");
          return;
        }
        this._defines[name] = value;
      };
      Effect.prototype.extractProperties = function extractProperties() {
        var out = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        Object.assign(out, this._properties);
        return out;
      };
      Effect.prototype.extractDefines = function extractDefines() {
        var out = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        Object.assign(out, this._defines);
        return out;
      };
      Effect.prototype.extractDependencies = function extractDependencies() {
        var out = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        for (var i = 0; i < this._dependencies.length; ++i) {
          var dep = this._dependencies[i];
          out[dep.define] = dep.extension;
        }
        return out;
      };
      return Effect;
    })();
    var cloneObjArray = function cloneObjArray(val) {
      return val.map((function(obj) {
        return Object.assign({}, obj);
      }));
    };
    var getInstanceCtor = function getInstanceCtor(t) {
      return _types.ctor2default[getInstanceType(t)];
    };
    var getInvolvedPrograms = function getInvolvedPrograms(json) {
      var programs = [], lib = cc.renderer._forward._programLib;
      json.techniques.forEach((function(tech) {
        tech.passes.forEach((function(pass) {
          programs.push(lib.getTemplate(pass.program));
        }));
      }));
      return programs;
    };
    var parseProperties = (function() {
      function genPropInfo(displayName, type, value) {
        return {
          type: type,
          displayName: displayName,
          instanceType: getInstanceType(type),
          value: getInstanceCtor(type)(value)
        };
      }
      return function(json, programs) {
        var props = {};
        programs.forEach((function(pg) {
          pg.uniforms.forEach((function(prop) {
            if (!prop.property) return;
            props[prop.name] = genPropInfo(prop.displayName, prop.type, prop.value);
          }));
        }));
        var _loop = function _loop(prop) {
          var propInfo = json.properties[prop], uniformInfo = void 0;
          if (void 0 !== propInfo.tech && void 0 !== propInfo.pass) {
            var pname = json.techniques[propInfo.tech].passes[propInfo.pass].program;
            var program = programs.find((function(p) {
              return p.name === pname;
            }));
            uniformInfo = program.uniforms.find((function(u) {
              return u.name === prop;
            }));
          } else for (var i = 0; i < programs.length; i++) {
            uniformInfo = programs[i].uniforms.find((function(u) {
              return u.name === prop;
            }));
            if (uniformInfo) break;
          }
          if (!uniformInfo) {
            cc.warn(json.name + " : illegal property: " + prop);
            return "continue";
          }
          props[prop] = genPropInfo(propInfo.displayName || uniformInfo.displayName, propInfo.type || uniformInfo.type, propInfo.value || uniformInfo.value);
        };
        for (var prop in json.properties) {
          var _ret = _loop(prop);
          if ("continue" === _ret) continue;
        }
        return props;
      };
    })();
    Effect.parseEffect = function(effect) {
      var techNum = effect.techniques.length;
      var techniques = new Array(techNum);
      for (var j = 0; j < techNum; ++j) {
        var tech = effect.techniques[j];
        var passNum = tech.passes.length;
        var passes = new Array(passNum);
        for (var k = 0; k < passNum; ++k) {
          var pass = tech.passes[k];
          passes[k] = new _pass2.default(pass.program);
          passes[k].setDepth(pass.depthTest, pass.depthWrite, pass.depthFunc);
          passes[k].setCullMode(pass.cullMode);
          passes[k].setBlend(pass.blend, pass.blendEq, pass.blendSrc, pass.blendDst, pass.blendAlphaEq, pass.blendSrcAlpha, pass.blendDstAlpha, pass.blendColor);
          passes[k].setStencilFront(pass.stencilTest, pass.stencilFuncFront, pass.stencilRefFront, pass.stencilMaskFront, pass.stencilFailOpFront, pass.stencilZFailOpFront, pass.stencilZPassOpFront, pass.stencilWriteMaskFront);
          passes[k].setStencilBack(pass.stencilTest, pass.stencilFuncBack, pass.stencilRefBack, pass.stencilMaskBack, pass.stencilFailOpBack, pass.stencilZFailOpBack, pass.stencilZPassOpBack, pass.stencilWriteMaskBack);
        }
        techniques[j] = new _technique2.default(tech.stages, passes, tech.layer);
      }
      var programs = getInvolvedPrograms(effect);
      var props = parseProperties(effect, programs), uniforms = {}, defines = {};
      programs.forEach((function(p) {
        p.uniforms.forEach((function(u) {
          var name = u.name, uniform = uniforms[name] = Object.assign({}, u);
          uniform.value = getInstanceCtor(u.type)(u.value);
          if (props[name]) {
            uniform.type = props[name].type;
            uniform.value = props[name].value;
          }
        }));
        p.defines.forEach((function(d) {
          defines[d.name] = getInstanceCtor(d.type)();
        }));
      }));
      var extensions = programs.reduce((function(acc, cur) {
        return acc.concat(cur.extensions);
      }), []);
      extensions = cloneObjArray(extensions);
      return new Effect(effect.name, techniques, uniforms, defines, extensions);
    };
    false;
    exports.default = Effect;
    cc.Effect = Effect;
    module.exports = exports["default"];
  }), {
    "../config": 220,
    "../core/pass": 224,
    "../core/technique": 226,
    "../types": 258
  } ],
  223: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          "value" in descriptor && (descriptor.writable = true);
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        protoProps && defineProperties(Constructor.prototype, protoProps);
        staticProps && defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _gfx = require("../gfx");
    var _gfx2 = _interopRequireDefault(_gfx);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var InputAssembler = (function() {
      function InputAssembler(vb, ib) {
        var pt = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : _gfx2.default.PT_TRIANGLES;
        _classCallCheck(this, InputAssembler);
        this._vertexBuffer = vb;
        this._indexBuffer = ib;
        this._primitiveType = pt;
        this._start = 0;
        this._count = -1;
      }
      _createClass(InputAssembler, [ {
        key: "count",
        get: function get() {
          if (-1 !== this._count) return this._count;
          if (this._indexBuffer) return this._indexBuffer.count;
          return this._vertexBuffer.count;
        }
      } ]);
      return InputAssembler;
    })();
    exports.default = InputAssembler;
    module.exports = exports["default"];
  }), {
    "../gfx": 233
  } ],
  224: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _gfx = require("../gfx");
    var _gfx2 = _interopRequireDefault(_gfx);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var Pass = (function() {
      function Pass(name) {
        _classCallCheck(this, Pass);
        this._programName = name;
        this._cullMode = _gfx2.default.CULL_BACK;
        this._blend = false;
        this._blendEq = _gfx2.default.BLEND_FUNC_ADD;
        this._blendAlphaEq = _gfx2.default.BLEND_FUNC_ADD;
        this._blendSrc = _gfx2.default.BLEND_SRC_ALPHA;
        this._blendDst = _gfx2.default.BLEND_ONE_MINUS_SRC_ALPHA;
        this._blendSrcAlpha = _gfx2.default.BLEND_SRC_ALPHA;
        this._blendDstAlpha = _gfx2.default.BLEND_ONE_MINUS_SRC_ALPHA;
        this._blendColor = 4294967295;
        this._depthTest = false;
        this._depthWrite = false;
        this._depthFunc = _gfx2.default.DS_FUNC_LESS, this._stencilTest = _gfx2.default.STENCIL_INHERIT;
        this._stencilFuncFront = _gfx2.default.DS_FUNC_ALWAYS;
        this._stencilRefFront = 0;
        this._stencilMaskFront = 255;
        this._stencilFailOpFront = _gfx2.default.STENCIL_OP_KEEP;
        this._stencilZFailOpFront = _gfx2.default.STENCIL_OP_KEEP;
        this._stencilZPassOpFront = _gfx2.default.STENCIL_OP_KEEP;
        this._stencilWriteMaskFront = 255;
        this._stencilFuncBack = _gfx2.default.DS_FUNC_ALWAYS;
        this._stencilRefBack = 0;
        this._stencilMaskBack = 255;
        this._stencilFailOpBack = _gfx2.default.STENCIL_OP_KEEP;
        this._stencilZFailOpBack = _gfx2.default.STENCIL_OP_KEEP;
        this._stencilZPassOpBack = _gfx2.default.STENCIL_OP_KEEP;
        this._stencilWriteMaskBack = 255;
      }
      Pass.prototype.setCullMode = function setCullMode() {
        var cullMode = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _gfx2.default.CULL_BACK;
        this._cullMode = cullMode;
      };
      Pass.prototype.setBlend = function setBlend() {
        var enabled = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        var blendEq = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : _gfx2.default.BLEND_FUNC_ADD;
        var blendSrc = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : _gfx2.default.BLEND_SRC_ALPHA;
        var blendDst = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : _gfx2.default.BLEND_ONE_MINUS_SRC_ALPHA;
        var blendAlphaEq = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : _gfx2.default.BLEND_FUNC_ADD;
        var blendSrcAlpha = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : _gfx2.default.BLEND_SRC_ALPHA;
        var blendDstAlpha = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : _gfx2.default.BLEND_ONE_MINUS_SRC_ALPHA;
        var blendColor = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 4294967295;
        this._blend = enabled;
        this._blendEq = blendEq;
        this._blendSrc = blendSrc;
        this._blendDst = blendDst;
        this._blendAlphaEq = blendAlphaEq;
        this._blendSrcAlpha = blendSrcAlpha;
        this._blendDstAlpha = blendDstAlpha;
        this._blendColor = blendColor;
      };
      Pass.prototype.setDepth = function setDepth() {
        var depthTest = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        var depthWrite = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        var depthFunc = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : _gfx2.default.DS_FUNC_LESS;
        this._depthTest = depthTest;
        this._depthWrite = depthWrite;
        this._depthFunc = depthFunc;
      };
      Pass.prototype.setStencilFront = function setStencilFront() {
        var enabled = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _gfx2.default.STENCIL_INHERIT;
        var stencilFunc = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : _gfx2.default.DS_FUNC_ALWAYS;
        var stencilRef = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        var stencilMask = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 255;
        var stencilFailOp = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : _gfx2.default.STENCIL_OP_KEEP;
        var stencilZFailOp = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : _gfx2.default.STENCIL_OP_KEEP;
        var stencilZPassOp = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : _gfx2.default.STENCIL_OP_KEEP;
        var stencilWriteMask = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 255;
        this._stencilTest = enabled;
        this._stencilFuncFront = stencilFunc;
        this._stencilRefFront = stencilRef;
        this._stencilMaskFront = stencilMask;
        this._stencilFailOpFront = stencilFailOp;
        this._stencilZFailOpFront = stencilZFailOp;
        this._stencilZPassOpFront = stencilZPassOp;
        this._stencilWriteMaskFront = stencilWriteMask;
      };
      Pass.prototype.setStencilEnabled = function setStencilEnabled() {
        var enabled = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _gfx2.default.STENCIL_INHERIT;
        this._stencilTest = enabled;
      };
      Pass.prototype.setStencilBack = function setStencilBack() {
        var enabled = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _gfx2.default.STENCIL_INHERIT;
        var stencilFunc = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : _gfx2.default.DS_FUNC_ALWAYS;
        var stencilRef = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        var stencilMask = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 255;
        var stencilFailOp = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : _gfx2.default.STENCIL_OP_KEEP;
        var stencilZFailOp = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : _gfx2.default.STENCIL_OP_KEEP;
        var stencilZPassOp = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : _gfx2.default.STENCIL_OP_KEEP;
        var stencilWriteMask = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 255;
        this._stencilTest = enabled;
        this._stencilFuncBack = stencilFunc;
        this._stencilRefBack = stencilRef;
        this._stencilMaskBack = stencilMask;
        this._stencilFailOpBack = stencilFailOp;
        this._stencilZFailOpBack = stencilZFailOp;
        this._stencilZPassOpBack = stencilZPassOp;
        this._stencilWriteMaskBack = stencilWriteMask;
      };
      return Pass;
    })();
    exports.default = Pass;
    module.exports = exports["default"];
  }), {
    "../gfx": 233
  } ],
  225: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _gfx = require("../gfx");
    var _gfx2 = _interopRequireDefault(_gfx);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _shdID = 0;
    function _generateDefines(defineList) {
      var defines = [];
      var cache = {};
      for (var i = defineList.length - 1; i >= 0; i--) {
        var defs = defineList[i];
        for (var def in defs) {
          var result = defs[def];
          if (void 0 === result) continue;
          if (void 0 !== cache[def]) continue;
          "number" !== typeof result && (result = result ? 1 : 0);
          cache[def] = result;
          defines.push("#define " + def + " " + result);
        }
      }
      return defines.join("\n") + "\n";
    }
    function _replaceMacroNums(string, defineList) {
      var cache = {};
      var tmp = string;
      for (var i = defineList.length - 1; i >= 0; i--) {
        var defs = defineList[i];
        for (var def in defs) {
          var result = defs[def];
          if (void 0 === result) continue;
          if (void 0 !== cache[def]) continue;
          Number.isInteger(result) && (cache[def] = result);
        }
      }
      for (var _def in cache) {
        var reg = new RegExp(_def, "g");
        tmp = tmp.replace(reg, cache[_def]);
      }
      return tmp;
    }
    function _unrollLoops(string) {
      var pattern = /#pragma for (\w+) in range\(\s*(\d+)\s*,\s*(\d+)\s*\)([\s\S]+?)#pragma endFor/g;
      function replace(match, index, begin, end, snippet) {
        var unroll = "";
        var parsedBegin = parseInt(begin);
        var parsedEnd = parseInt(end);
        (parsedBegin.isNaN || parsedEnd.isNaN) && console.error("Unroll For Loops Error: begin and end of range must be an int num.");
        for (var i = parsedBegin; i < parsedEnd; ++i) unroll += snippet.replace(new RegExp("{" + index + "}", "g"), i);
        return unroll;
      }
      return string.replace(pattern, replace);
    }
    var ProgramLib = (function() {
      function ProgramLib(device) {
        _classCallCheck(this, ProgramLib);
        this._device = device;
        this._templates = {};
        this._cache = {};
      }
      ProgramLib.prototype.clear = function clear() {
        this._templates = {};
        this._cache = {};
      };
      ProgramLib.prototype.define = function define(prog) {
        var name = prog.name, vert = prog.vert, frag = prog.frag, defines = prog.defines, extensions = prog.extensions;
        if (this._templates[name]) return;
        var id = ++_shdID;
        var offset = 0;
        for (var i = 0; i < defines.length; ++i) {
          var def = defines[i];
          var cnt = 1;
          if ("number" === def.type) {
            var range = def.range || [];
            def.min = range[0] || 0;
            def.max = range[1] || 4;
            cnt = Math.ceil(Math.log2(def.max - def.min));
            def._map = function(value) {
              return value - this.min << this._offset;
            }.bind(def);
          } else def._map = function(value) {
            if (value) return 1 << this._offset;
            return 0;
          }.bind(def);
          offset += cnt;
          def._offset = offset;
        }
        this._templates[name] = {
          id: id,
          name: name,
          vert: vert,
          frag: frag,
          defines: defines,
          attributes: prog.attributes,
          uniforms: prog.uniforms,
          extensions: prog.extensions
        };
      };
      ProgramLib.prototype.getTemplate = function getTemplate(name) {
        return this._templates[name];
      };
      ProgramLib.prototype.hasProgram = function hasProgram(name) {
        return void 0 !== this._templates[name];
      };
      ProgramLib.prototype.getKey = function getKey(name, defineList) {
        var tmpl = this._templates[name];
        var key = 0;
        for (var i = 0; i < tmpl.defines.length; ++i) {
          var tmplDefs = tmpl.defines[i];
          var value = this._getValueFromDefineList(tmplDefs.name, defineList);
          if (void 0 === value) continue;
          key |= tmplDefs._map(value);
        }
        return tmpl.id + ":" + key;
      };
      ProgramLib.prototype.getProgram = function getProgram(name, defineList, errPrefix) {
        var key = this.getKey(name, defineList);
        var program = this._cache[key];
        if (program) return program;
        var tmpl = this._templates[name];
        var customDef = _generateDefines(defineList);
        var vert = _replaceMacroNums(tmpl.vert, defineList);
        vert = customDef + _unrollLoops(vert);
        var frag = _replaceMacroNums(tmpl.frag, defineList);
        frag = customDef + _unrollLoops(frag);
        program = new _gfx2.default.Program(this._device, {
          vert: vert,
          frag: frag
        });
        var errors = program.link();
        if (errors) {
          var vertLines = vert.split("\n");
          var fragLines = frag.split("\n");
          var defineLength = Object.keys(defineList).length;
          errors.forEach((function(err) {
            var line = err.line - 1;
            var originLine = err.line - defineLength;
            var lines = "vs" === err.type ? vertLines : fragLines;
            var source = lines[line];
            var info = err.info || "Failed to compile " + err.type + " " + err.fileID + " (ln " + originLine + "): \n " + err.message + ": \n  " + source;
            cc.error(errPrefix + " : " + info);
          }));
        }
        this._cache[key] = program;
        return program;
      };
      ProgramLib.prototype._getValueFromDefineList = function _getValueFromDefineList(name, defineList) {
        var value = void 0;
        for (var i = defineList.length - 1; i >= 0; i--) {
          value = defineList[i][name];
          if (void 0 !== value) return value;
        }
      };
      return ProgramLib;
    })();
    exports.default = ProgramLib;
    module.exports = exports["default"];
  }), {
    "../gfx": 233
  } ],
  226: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          "value" in descriptor && (descriptor.writable = true);
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        protoProps && defineProperties(Constructor.prototype, protoProps);
        staticProps && defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _config = require("../config");
    var _config2 = _interopRequireDefault(_config);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _genID = 0;
    var Technique = (function() {
      function Technique(stages, passes) {
        var layer = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        _classCallCheck(this, Technique);
        this._id = _genID++;
        this._stageIDs = _config2.default.stageIDs(stages);
        this._passes = passes;
        this._layer = layer;
      }
      Technique.prototype.setStages = function setStages(stages) {
        this._stageIDs = _config2.default.stageIDs(stages);
      };
      _createClass(Technique, [ {
        key: "passes",
        get: function get() {
          return this._passes;
        }
      }, {
        key: "stageIDs",
        get: function get() {
          return this._stageIDs;
        }
      } ]);
      return Technique;
    })();
    exports.default = Technique;
    module.exports = exports["default"];
  }), {
    "../config": 220
  } ],
  227: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _vmath = require("../../core/vmath");
    var _enums = require("../enums");
    var _enums2 = _interopRequireDefault(_enums);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _m4_tmp = _vmath.mat4.create();
    var _genID = 0;
    var View = (function() {
      function View() {
        _classCallCheck(this, View);
        this._id = _genID++;
        this._priority = 0;
        this._rect = {
          x: 0,
          y: 0,
          w: 1,
          h: 1
        };
        this._color = _vmath.color4.create(.3, .3, .3, 1);
        this._depth = 1;
        this._stencil = 0;
        this._clearFlags = _enums2.default.CLEAR_COLOR | _enums2.default.CLEAR_DEPTH;
        this._clearModel = null;
        this._matView = _vmath.mat4.create();
        this._matProj = _vmath.mat4.create();
        this._matViewProj = _vmath.mat4.create();
        this._matInvViewProj = _vmath.mat4.create();
        this._stages = [];
        this._cullingByID = false;
        this._framebuffer = null;
        this._shadowLight = null;
        this._cullingMask = 4294967295;
      }
      View.prototype.getForward = function getForward(out) {
        return _vmath.vec3.set(out, -this._matView.m02, -this._matView.m06, -this._matView.m10);
      };
      View.prototype.getPosition = function getPosition(out) {
        _vmath.mat4.invert(_m4_tmp, this._matView);
        return _vmath.mat4.getTranslation(out, _m4_tmp);
      };
      return View;
    })();
    exports.default = View;
    module.exports = exports["default"];
  }), {
    "../../core/vmath": 207,
    "../enums": 228
  } ],
  228: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = {
      PROJ_PERSPECTIVE: 0,
      PROJ_ORTHO: 1,
      LIGHT_DIRECTIONAL: 0,
      LIGHT_POINT: 1,
      LIGHT_SPOT: 2,
      SHADOW_NONE: 0,
      SHADOW_HARD: 1,
      SHADOW_SOFT: 2,
      PARAM_INT: 0,
      PARAM_INT2: 1,
      PARAM_INT3: 2,
      PARAM_INT4: 3,
      PARAM_FLOAT: 4,
      PARAM_FLOAT2: 5,
      PARAM_FLOAT3: 6,
      PARAM_FLOAT4: 7,
      PARAM_COLOR3: 8,
      PARAM_COLOR4: 9,
      PARAM_MAT2: 10,
      PARAM_MAT3: 11,
      PARAM_MAT4: 12,
      PARAM_TEXTURE_2D: 13,
      PARAM_TEXTURE_CUBE: 14,
      CLEAR_COLOR: 1,
      CLEAR_DEPTH: 2,
      CLEAR_STENCIL: 4,
      CLEAR_SKYBOX: 8,
      BUFFER_VIEW_INT8: 0,
      BUFFER_VIEW_UINT8: 1,
      BUFFER_VIEW_INT16: 2,
      BUFFER_VIEW_UINT16: 3,
      BUFFER_VIEW_INT32: 4,
      BUFFER_VIEW_UINT32: 5,
      BUFFER_VIEW_FLOAT32: 6
    };
    module.exports = exports["default"];
  }), {} ],
  229: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _type2uniformCommit2, _type2uniformArrayCom;
    var _state = require("./state");
    var _state2 = _interopRequireDefault(_state);
    var _enums = require("./enums");
    var _texture2d = require("./texture-2d");
    var _texture2d2 = _interopRequireDefault(_texture2d);
    var _textureCube = require("./texture-cube");
    var _textureCube2 = _interopRequireDefault(_textureCube);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var GL_INT = 5124;
    var GL_FLOAT = 5126;
    var GL_FLOAT_VEC2 = 35664;
    var GL_FLOAT_VEC3 = 35665;
    var GL_FLOAT_VEC4 = 35666;
    var GL_INT_VEC2 = 35667;
    var GL_INT_VEC3 = 35668;
    var GL_INT_VEC4 = 35669;
    var GL_BOOL = 35670;
    var GL_BOOL_VEC2 = 35671;
    var GL_BOOL_VEC3 = 35672;
    var GL_BOOL_VEC4 = 35673;
    var GL_FLOAT_MAT2 = 35674;
    var GL_FLOAT_MAT3 = 35675;
    var GL_FLOAT_MAT4 = 35676;
    var GL_SAMPLER_2D = 35678;
    var GL_SAMPLER_CUBE = 35680;
    var _type2uniformCommit = (_type2uniformCommit2 = {}, _type2uniformCommit2[GL_INT] = function(gl, id, value) {
      gl.uniform1i(id, value);
    }, _type2uniformCommit2[GL_FLOAT] = function(gl, id, value) {
      gl.uniform1f(id, value);
    }, _type2uniformCommit2[GL_FLOAT_VEC2] = function(gl, id, value) {
      gl.uniform2fv(id, value);
    }, _type2uniformCommit2[GL_FLOAT_VEC3] = function(gl, id, value) {
      gl.uniform3fv(id, value);
    }, _type2uniformCommit2[GL_FLOAT_VEC4] = function(gl, id, value) {
      gl.uniform4fv(id, value);
    }, _type2uniformCommit2[GL_INT_VEC2] = function(gl, id, value) {
      gl.uniform2iv(id, value);
    }, _type2uniformCommit2[GL_INT_VEC3] = function(gl, id, value) {
      gl.uniform3iv(id, value);
    }, _type2uniformCommit2[GL_INT_VEC4] = function(gl, id, value) {
      gl.uniform4iv(id, value);
    }, _type2uniformCommit2[GL_BOOL] = function(gl, id, value) {
      gl.uniform1i(id, value);
    }, _type2uniformCommit2[GL_BOOL_VEC2] = function(gl, id, value) {
      gl.uniform2iv(id, value);
    }, _type2uniformCommit2[GL_BOOL_VEC3] = function(gl, id, value) {
      gl.uniform3iv(id, value);
    }, _type2uniformCommit2[GL_BOOL_VEC4] = function(gl, id, value) {
      gl.uniform4iv(id, value);
    }, _type2uniformCommit2[GL_FLOAT_MAT2] = function(gl, id, value) {
      gl.uniformMatrix2fv(id, false, value);
    }, _type2uniformCommit2[GL_FLOAT_MAT3] = function(gl, id, value) {
      gl.uniformMatrix3fv(id, false, value);
    }, _type2uniformCommit2[GL_FLOAT_MAT4] = function(gl, id, value) {
      gl.uniformMatrix4fv(id, false, value);
    }, _type2uniformCommit2[GL_SAMPLER_2D] = function(gl, id, value) {
      gl.uniform1i(id, value);
    }, _type2uniformCommit2[GL_SAMPLER_CUBE] = function(gl, id, value) {
      gl.uniform1i(id, value);
    }, _type2uniformCommit2);
    var _type2uniformArrayCommit = (_type2uniformArrayCom = {}, _type2uniformArrayCom[GL_INT] = function(gl, id, value) {
      gl.uniform1iv(id, value);
    }, _type2uniformArrayCom[GL_FLOAT] = function(gl, id, value) {
      gl.uniform1fv(id, value);
    }, _type2uniformArrayCom[GL_FLOAT_VEC2] = function(gl, id, value) {
      gl.uniform2fv(id, value);
    }, _type2uniformArrayCom[GL_FLOAT_VEC3] = function(gl, id, value) {
      gl.uniform3fv(id, value);
    }, _type2uniformArrayCom[GL_FLOAT_VEC4] = function(gl, id, value) {
      gl.uniform4fv(id, value);
    }, _type2uniformArrayCom[GL_INT_VEC2] = function(gl, id, value) {
      gl.uniform2iv(id, value);
    }, _type2uniformArrayCom[GL_INT_VEC3] = function(gl, id, value) {
      gl.uniform3iv(id, value);
    }, _type2uniformArrayCom[GL_INT_VEC4] = function(gl, id, value) {
      gl.uniform4iv(id, value);
    }, _type2uniformArrayCom[GL_BOOL] = function(gl, id, value) {
      gl.uniform1iv(id, value);
    }, _type2uniformArrayCom[GL_BOOL_VEC2] = function(gl, id, value) {
      gl.uniform2iv(id, value);
    }, _type2uniformArrayCom[GL_BOOL_VEC3] = function(gl, id, value) {
      gl.uniform3iv(id, value);
    }, _type2uniformArrayCom[GL_BOOL_VEC4] = function(gl, id, value) {
      gl.uniform4iv(id, value);
    }, _type2uniformArrayCom[GL_FLOAT_MAT2] = function(gl, id, value) {
      gl.uniformMatrix2fv(id, false, value);
    }, _type2uniformArrayCom[GL_FLOAT_MAT3] = function(gl, id, value) {
      gl.uniformMatrix3fv(id, false, value);
    }, _type2uniformArrayCom[GL_FLOAT_MAT4] = function(gl, id, value) {
      gl.uniformMatrix4fv(id, false, value);
    }, _type2uniformArrayCom[GL_SAMPLER_2D] = function(gl, id, value) {
      gl.uniform1iv(id, value);
    }, _type2uniformArrayCom[GL_SAMPLER_CUBE] = function(gl, id, value) {
      gl.uniform1iv(id, value);
    }, _type2uniformArrayCom);
    function _commitBlendStates(gl, cur, next) {
      if (cur.blend !== next.blend) {
        if (!next.blend) {
          gl.disable(gl.BLEND);
          return;
        }
        gl.enable(gl.BLEND);
        next.blendSrc !== _enums.enums.BLEND_CONSTANT_COLOR && next.blendSrc !== _enums.enums.BLEND_ONE_MINUS_CONSTANT_COLOR && next.blendDst !== _enums.enums.BLEND_CONSTANT_COLOR && next.blendDst !== _enums.enums.BLEND_ONE_MINUS_CONSTANT_COLOR || gl.blendColor((next.blendColor >> 24) / 255, (next.blendColor >> 16 & 255) / 255, (next.blendColor >> 8 & 255) / 255, (255 & next.blendColor) / 255);
        if (next.blendSep) {
          gl.blendFuncSeparate(next.blendSrc, next.blendDst, next.blendSrcAlpha, next.blendDstAlpha);
          gl.blendEquationSeparate(next.blendEq, next.blendAlphaEq);
        } else {
          gl.blendFunc(next.blendSrc, next.blendDst);
          gl.blendEquation(next.blendEq);
        }
        return;
      }
      if (false === next.blend) return;
      cur.blendColor !== next.blendColor && gl.blendColor((next.blendColor >> 24) / 255, (next.blendColor >> 16 & 255) / 255, (next.blendColor >> 8 & 255) / 255, (255 & next.blendColor) / 255);
      if (cur.blendSep !== next.blendSep) {
        if (next.blendSep) {
          gl.blendFuncSeparate(next.blendSrc, next.blendDst, next.blendSrcAlpha, next.blendDstAlpha);
          gl.blendEquationSeparate(next.blendEq, next.blendAlphaEq);
        } else {
          gl.blendFunc(next.blendSrc, next.blendDst);
          gl.blendEquation(next.blendEq);
        }
        return;
      }
      if (next.blendSep) {
        cur.blendSrc === next.blendSrc && cur.blendDst === next.blendDst && cur.blendSrcAlpha === next.blendSrcAlpha && cur.blendDstAlpha === next.blendDstAlpha || gl.blendFuncSeparate(next.blendSrc, next.blendDst, next.blendSrcAlpha, next.blendDstAlpha);
        cur.blendEq === next.blendEq && cur.blendAlphaEq === next.blendAlphaEq || gl.blendEquationSeparate(next.blendEq, next.blendAlphaEq);
      } else {
        cur.blendSrc === next.blendSrc && cur.blendDst === next.blendDst || gl.blendFunc(next.blendSrc, next.blendDst);
        cur.blendEq !== next.blendEq && gl.blendEquation(next.blendEq);
      }
    }
    function _commitDepthStates(gl, cur, next) {
      if (cur.depthTest !== next.depthTest) {
        if (!next.depthTest) {
          gl.disable(gl.DEPTH_TEST);
          return;
        }
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(next.depthFunc);
        gl.depthMask(next.depthWrite);
        return;
      }
      cur.depthWrite !== next.depthWrite && gl.depthMask(next.depthWrite);
      if (false === next.depthTest) {
        if (next.depthWrite) {
          next.depthTest = true;
          next.depthFunc = _enums.enums.DS_FUNC_ALWAYS;
          gl.enable(gl.DEPTH_TEST);
          gl.depthFunc(next.depthFunc);
        }
        return;
      }
      cur.depthFunc !== next.depthFunc && gl.depthFunc(next.depthFunc);
    }
    function _commitStencilStates(gl, cur, next) {
      if (next.stencilTest === _enums.enums.STENCIL_INHERIT) return;
      if (next.stencilTest !== cur.stencilTest) {
        if (next.stencilTest === _enums.enums.STENCIL_DISABLE) {
          gl.disable(gl.STENCIL_TEST);
          return;
        }
        gl.enable(gl.STENCIL_TEST);
        if (next.stencilSep) {
          gl.stencilFuncSeparate(gl.FRONT, next.stencilFuncFront, next.stencilRefFront, next.stencilMaskFront);
          gl.stencilMaskSeparate(gl.FRONT, next.stencilWriteMaskFront);
          gl.stencilOpSeparate(gl.FRONT, next.stencilFailOpFront, next.stencilZFailOpFront, next.stencilZPassOpFront);
          gl.stencilFuncSeparate(gl.BACK, next.stencilFuncBack, next.stencilRefBack, next.stencilMaskBack);
          gl.stencilMaskSeparate(gl.BACK, next.stencilWriteMaskBack);
          gl.stencilOpSeparate(gl.BACK, next.stencilFailOpBack, next.stencilZFailOpBack, next.stencilZPassOpBack);
        } else {
          gl.stencilFunc(next.stencilFuncFront, next.stencilRefFront, next.stencilMaskFront);
          gl.stencilMask(next.stencilWriteMaskFront);
          gl.stencilOp(next.stencilFailOpFront, next.stencilZFailOpFront, next.stencilZPassOpFront);
        }
        return;
      }
      if (next.stencilTest === _enums.enums.STENCIL_DISABLE) return;
      if (cur.stencilSep !== next.stencilSep) {
        if (next.stencilSep) {
          gl.stencilFuncSeparate(gl.FRONT, next.stencilFuncFront, next.stencilRefFront, next.stencilMaskFront);
          gl.stencilMaskSeparate(gl.FRONT, next.stencilWriteMaskFront);
          gl.stencilOpSeparate(gl.FRONT, next.stencilFailOpFront, next.stencilZFailOpFront, next.stencilZPassOpFront);
          gl.stencilFuncSeparate(gl.BACK, next.stencilFuncBack, next.stencilRefBack, next.stencilMaskBack);
          gl.stencilMaskSeparate(gl.BACK, next.stencilWriteMaskBack);
          gl.stencilOpSeparate(gl.BACK, next.stencilFailOpBack, next.stencilZFailOpBack, next.stencilZPassOpBack);
        } else {
          gl.stencilFunc(next.stencilFuncFront, next.stencilRefFront, next.stencilMaskFront);
          gl.stencilMask(next.stencilWriteMaskFront);
          gl.stencilOp(next.stencilFailOpFront, next.stencilZFailOpFront, next.stencilZPassOpFront);
        }
        return;
      }
      if (next.stencilSep) {
        cur.stencilFuncFront === next.stencilFuncFront && cur.stencilRefFront === next.stencilRefFront && cur.stencilMaskFront === next.stencilMaskFront || gl.stencilFuncSeparate(gl.FRONT, next.stencilFuncFront, next.stencilRefFront, next.stencilMaskFront);
        cur.stencilWriteMaskFront !== next.stencilWriteMaskFront && gl.stencilMaskSeparate(gl.FRONT, next.stencilWriteMaskFront);
        cur.stencilFailOpFront === next.stencilFailOpFront && cur.stencilZFailOpFront === next.stencilZFailOpFront && cur.stencilZPassOpFront === next.stencilZPassOpFront || gl.stencilOpSeparate(gl.FRONT, next.stencilFailOpFront, next.stencilZFailOpFront, next.stencilZPassOpFront);
        cur.stencilFuncBack === next.stencilFuncBack && cur.stencilRefBack === next.stencilRefBack && cur.stencilMaskBack === next.stencilMaskBack || gl.stencilFuncSeparate(gl.BACK, next.stencilFuncBack, next.stencilRefBack, next.stencilMaskBack);
        cur.stencilWriteMaskBack !== next.stencilWriteMaskBack && gl.stencilMaskSeparate(gl.BACK, next.stencilWriteMaskBack);
        cur.stencilFailOpBack === next.stencilFailOpBack && cur.stencilZFailOpBack === next.stencilZFailOpBack && cur.stencilZPassOpBack === next.stencilZPassOpBack || gl.stencilOpSeparate(gl.BACK, next.stencilFailOpBack, next.stencilZFailOpBack, next.stencilZPassOpBack);
      } else {
        cur.stencilFuncFront === next.stencilFuncFront && cur.stencilRefFront === next.stencilRefFront && cur.stencilMaskFront === next.stencilMaskFront || gl.stencilFunc(next.stencilFuncFront, next.stencilRefFront, next.stencilMaskFront);
        cur.stencilWriteMaskFront !== next.stencilWriteMaskFront && gl.stencilMask(next.stencilWriteMaskFront);
        cur.stencilFailOpFront === next.stencilFailOpFront && cur.stencilZFailOpFront === next.stencilZFailOpFront && cur.stencilZPassOpFront === next.stencilZPassOpFront || gl.stencilOp(next.stencilFailOpFront, next.stencilZFailOpFront, next.stencilZPassOpFront);
      }
    }
    function _commitCullMode(gl, cur, next) {
      if (cur.cullMode === next.cullMode) return;
      if (next.cullMode === _enums.enums.CULL_NONE) {
        gl.disable(gl.CULL_FACE);
        return;
      }
      gl.enable(gl.CULL_FACE);
      gl.cullFace(next.cullMode);
    }
    function _commitVertexBuffers(device, gl, cur, next) {
      var attrsDirty = false;
      if (-1 === next.maxStream) return;
      if (cur.maxStream !== next.maxStream) attrsDirty = true; else if (cur.program !== next.program) attrsDirty = true; else for (var i = 0; i < next.maxStream + 1; ++i) if (cur.vertexBuffers[i] !== next.vertexBuffers[i] || cur.vertexBufferOffsets[i] !== next.vertexBufferOffsets[i]) {
        attrsDirty = true;
        break;
      }
      if (attrsDirty) {
        for (var _i = 0; _i < device._caps.maxVertexAttribs; ++_i) device._newAttributes[_i] = 0;
        for (var _i2 = 0; _i2 < next.maxStream + 1; ++_i2) {
          var vb = next.vertexBuffers[_i2];
          var vbOffset = next.vertexBufferOffsets[_i2];
          if (!vb || -1 === vb._glID) continue;
          gl.bindBuffer(gl.ARRAY_BUFFER, vb._glID);
          for (var j = 0; j < next.program._attributes.length; ++j) {
            var attr = next.program._attributes[j];
            var el = vb._format.element(attr.name);
            if (!el) {
              console.warn("Can not find vertex attribute: " + attr.name);
              continue;
            }
            if (0 === device._enabledAttributes[attr.location]) {
              gl.enableVertexAttribArray(attr.location);
              device._enabledAttributes[attr.location] = 1;
            }
            device._newAttributes[attr.location] = 1;
            gl.vertexAttribPointer(attr.location, el.num, el.type, el.normalize, el.stride, el.offset + vbOffset * el.stride);
          }
        }
        for (var _i3 = 0; _i3 < device._caps.maxVertexAttribs; ++_i3) if (device._enabledAttributes[_i3] !== device._newAttributes[_i3]) {
          gl.disableVertexAttribArray(_i3);
          device._enabledAttributes[_i3] = 0;
        }
      }
    }
    function _commitTextures(gl, cur, next) {
      for (var i = 0; i < next.maxTextureSlot + 1; ++i) if (cur.textureUnits[i] !== next.textureUnits[i]) {
        var texture = next.textureUnits[i];
        if (texture && -1 !== texture._glID) {
          gl.activeTexture(gl.TEXTURE0 + i);
          gl.bindTexture(texture._target, texture._glID);
        }
      }
    }
    function _attach(gl, location, attachment) {
      var face = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
      attachment instanceof _texture2d2.default ? gl.framebufferTexture2D(gl.FRAMEBUFFER, location, gl.TEXTURE_2D, attachment._glID, 0) : attachment instanceof _textureCube2.default ? gl.framebufferTexture2D(gl.FRAMEBUFFER, location, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, attachment._glID, 0) : gl.framebufferRenderbuffer(gl.FRAMEBUFFER, location, gl.RENDERBUFFER, attachment._glID);
    }
    var Device = (function() {
      function Device(canvasEL, opts) {
        _classCallCheck(this, Device);
        var gl = void 0;
        opts = opts || {};
        void 0 === opts.alpha && (opts.alpha = false);
        void 0 === opts.stencil && (opts.stencil = true);
        void 0 === opts.depth && (opts.depth = true);
        void 0 === opts.antialias && (opts.antialias = false);
        void 0 === opts.preserveDrawingBuffer && (opts.preserveDrawingBuffer = false);
        try {
          gl = canvasEL.getContext("webgl", opts) || canvasEL.getContext("experimental-webgl", opts) || canvasEL.getContext("webkit-3d", opts) || canvasEL.getContext("moz-webgl", opts);
        } catch (err) {
          console.error(err);
          return;
        }
        gl || console.error("This device does not support webgl");
        this._gl = gl;
        this._extensions = {};
        this._caps = {};
        this._stats = {
          texture: 0,
          vb: 0,
          ib: 0,
          drawcalls: 0
        };
        this._initExtensions([ "EXT_texture_filter_anisotropic", "EXT_shader_texture_lod", "OES_standard_derivatives", "OES_texture_float", "OES_texture_float_linear", "OES_texture_half_float", "OES_texture_half_float_linear", "OES_vertex_array_object", "WEBGL_compressed_texture_atc", "WEBGL_compressed_texture_etc", "WEBGL_compressed_texture_etc1", "WEBGL_compressed_texture_pvrtc", "WEBGL_compressed_texture_s3tc", "WEBGL_depth_texture", "WEBGL_draw_buffers" ]);
        this._initCaps();
        this._initStates();
        _state2.default.initDefault(this);
        this._current = new _state2.default(this);
        this._next = new _state2.default(this);
        this._uniforms = {};
        this._vx = this._vy = this._vw = this._vh = 0;
        this._sx = this._sy = this._sw = this._sh = 0;
        this._framebuffer = null;
        this._enabledAttributes = new Array(this._caps.maxVertexAttribs);
        this._newAttributes = new Array(this._caps.maxVertexAttribs);
        for (var i = 0; i < this._caps.maxVertexAttribs; ++i) {
          this._enabledAttributes[i] = 0;
          this._newAttributes[i] = 0;
        }
      }
      Device.prototype._initExtensions = function _initExtensions(extensions) {
        var gl = this._gl;
        for (var i = 0; i < extensions.length; ++i) {
          var name = extensions[i];
          var vendorPrefixes = [ "", "WEBKIT_", "MOZ_" ];
          for (var j = 0; j < vendorPrefixes.length; j++) try {
            var ext = gl.getExtension(vendorPrefixes[j] + name);
            if (ext) {
              this._extensions[name] = ext;
              break;
            }
          } catch (e) {
            console.error(e);
          }
        }
      };
      Device.prototype._initCaps = function _initCaps() {
        var gl = this._gl;
        var extDrawBuffers = this.ext("WEBGL_draw_buffers");
        this._caps.maxVertexStreams = 4;
        this._caps.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        this._caps.maxFragUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
        this._caps.maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        this._caps.maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        this._caps.maxDrawBuffers = extDrawBuffers ? gl.getParameter(extDrawBuffers.MAX_DRAW_BUFFERS_WEBGL) : 1;
        this._caps.maxColorAttachments = extDrawBuffers ? gl.getParameter(extDrawBuffers.MAX_COLOR_ATTACHMENTS_WEBGL) : 1;
      };
      Device.prototype._initStates = function _initStates() {
        var gl = this._gl;
        gl.disable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ZERO);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendColor(1, 1, 1, 1);
        gl.colorMask(true, true, true, true);
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);
        gl.disable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LESS);
        gl.depthMask(false);
        gl.disable(gl.POLYGON_OFFSET_FILL);
        gl.depthRange(0, 1);
        gl.disable(gl.STENCIL_TEST);
        gl.stencilFunc(gl.ALWAYS, 0, 255);
        gl.stencilMask(255);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        gl.clearDepth(1);
        gl.clearColor(0, 0, 0, 0);
        gl.clearStencil(0);
        gl.disable(gl.SCISSOR_TEST);
      };
      Device.prototype._restoreTexture = function _restoreTexture(unit) {
        var gl = this._gl;
        var texture = this._current.textureUnits[unit];
        texture && -1 !== texture._glID ? gl.bindTexture(texture._target, texture._glID) : gl.bindTexture(gl.TEXTURE_2D, null);
      };
      Device.prototype._restoreIndexBuffer = function _restoreIndexBuffer() {
        var gl = this._gl;
        var ib = this._current.indexBuffer;
        ib && -1 !== ib._glID ? gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib._glID) : gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      };
      Device.prototype.ext = function ext(name) {
        return this._extensions[name];
      };
      Device.prototype.allowFloatTexture = function allowFloatTexture() {
        return null != this.ext("OES_texture_float");
      };
      Device.prototype.setFrameBuffer = function setFrameBuffer(fb) {
        if (this._framebuffer === fb) return;
        this._framebuffer = fb;
        var gl = this._gl;
        if (null === fb) {
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          return;
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb._glID);
        var numColors = fb._colors.length;
        for (var i = 0; i < numColors; ++i) {
          var colorBuffer = fb._colors[i];
          _attach(gl, gl.COLOR_ATTACHMENT0 + i, colorBuffer);
        }
        for (var _i4 = numColors; _i4 < this._caps.maxColorAttachments; ++_i4) gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + _i4, gl.TEXTURE_2D, null, 0);
        fb._depth && _attach(gl, gl.DEPTH_ATTACHMENT, fb._depth);
        fb._stencil && _attach(gl, gl.STENCIL_ATTACHMENT, fb._stencil);
        fb._depthStencil && _attach(gl, gl.DEPTH_STENCIL_ATTACHMENT, fb._depthStencil);
      };
      Device.prototype.setViewport = function setViewport(x, y, w, h) {
        if (this._vx !== x || this._vy !== y || this._vw !== w || this._vh !== h) {
          this._gl.viewport(x, y, w, h);
          this._vx = x;
          this._vy = y;
          this._vw = w;
          this._vh = h;
        }
      };
      Device.prototype.setScissor = function setScissor(x, y, w, h) {
        if (this._sx !== x || this._sy !== y || this._sw !== w || this._sh !== h) {
          this._gl.scissor(x, y, w, h);
          this._sx = x;
          this._sy = y;
          this._sw = w;
          this._sh = h;
        }
      };
      Device.prototype.clear = function clear(opts) {
        if (void 0 === opts.color && void 0 === opts.depth && void 0 === opts.stencil) return;
        var gl = this._gl;
        var flags = 0;
        if (void 0 !== opts.color) {
          flags |= gl.COLOR_BUFFER_BIT;
          gl.clearColor(opts.color[0], opts.color[1], opts.color[2], opts.color[3]);
        }
        if (void 0 !== opts.depth) {
          flags |= gl.DEPTH_BUFFER_BIT;
          gl.clearDepth(opts.depth);
          gl.enable(gl.DEPTH_TEST);
          gl.depthMask(true);
          gl.depthFunc(gl.ALWAYS);
        }
        if (void 0 !== opts.stencil) {
          flags |= gl.STENCIL_BUFFER_BIT;
          gl.clearStencil(opts.stencil);
        }
        gl.clear(flags);
        if (void 0 !== opts.depth) if (false === this._current.depthTest) gl.disable(gl.DEPTH_TEST); else {
          false === this._current.depthWrite && gl.depthMask(false);
          this._current.depthFunc !== _enums.enums.DS_FUNC_ALWAYS && gl.depthFunc(this._current.depthFunc);
        }
      };
      Device.prototype.enableBlend = function enableBlend() {
        this._next.blend = true;
      };
      Device.prototype.enableDepthTest = function enableDepthTest() {
        this._next.depthTest = true;
      };
      Device.prototype.enableDepthWrite = function enableDepthWrite() {
        this._next.depthWrite = true;
      };
      Device.prototype.setStencilTest = function setStencilTest(stencilTest) {
        this._next.stencilTest = stencilTest;
      };
      Device.prototype.setStencilFunc = function setStencilFunc(func, ref, mask) {
        this._next.stencilSep = false;
        this._next.stencilFuncFront = this._next.stencilFuncBack = func;
        this._next.stencilRefFront = this._next.stencilRefBack = ref;
        this._next.stencilMaskFront = this._next.stencilMaskBack = mask;
      };
      Device.prototype.setStencilFuncFront = function setStencilFuncFront(func, ref, mask) {
        this._next.stencilSep = true;
        this._next.stencilFuncFront = func;
        this._next.stencilRefFront = ref;
        this._next.stencilMaskFront = mask;
      };
      Device.prototype.setStencilFuncBack = function setStencilFuncBack(func, ref, mask) {
        this._next.stencilSep = true;
        this._next.stencilFuncBack = func;
        this._next.stencilRefBack = ref;
        this._next.stencilMaskBack = mask;
      };
      Device.prototype.setStencilOp = function setStencilOp(failOp, zFailOp, zPassOp, writeMask) {
        this._next.stencilFailOpFront = this._next.stencilFailOpBack = failOp;
        this._next.stencilZFailOpFront = this._next.stencilZFailOpBack = zFailOp;
        this._next.stencilZPassOpFront = this._next.stencilZPassOpBack = zPassOp;
        this._next.stencilWriteMaskFront = this._next.stencilWriteMaskBack = writeMask;
      };
      Device.prototype.setStencilOpFront = function setStencilOpFront(failOp, zFailOp, zPassOp, writeMask) {
        this._next.stencilSep = true;
        this._next.stencilFailOpFront = failOp;
        this._next.stencilZFailOpFront = zFailOp;
        this._next.stencilZPassOpFront = zPassOp;
        this._next.stencilWriteMaskFront = writeMask;
      };
      Device.prototype.setStencilOpBack = function setStencilOpBack(failOp, zFailOp, zPassOp, writeMask) {
        this._next.stencilSep = true;
        this._next.stencilFailOpBack = failOp;
        this._next.stencilZFailOpBack = zFailOp;
        this._next.stencilZPassOpBack = zPassOp;
        this._next.stencilWriteMaskBack = writeMask;
      };
      Device.prototype.setDepthFunc = function setDepthFunc(depthFunc) {
        this._next.depthFunc = depthFunc;
      };
      Device.prototype.setBlendColor32 = function setBlendColor32(rgba) {
        this._next.blendColor = rgba;
      };
      Device.prototype.setBlendColor = function setBlendColor(r, g, b, a) {
        this._next.blendColor = (255 * r << 24 | 255 * g << 16 | 255 * b << 8 | 255 * a) >>> 0;
      };
      Device.prototype.setBlendFunc = function setBlendFunc(src, dst) {
        this._next.blendSep = false;
        this._next.blendSrc = src;
        this._next.blendDst = dst;
      };
      Device.prototype.setBlendFuncSep = function setBlendFuncSep(src, dst, srcAlpha, dstAlpha) {
        this._next.blendSep = true;
        this._next.blendSrc = src;
        this._next.blendDst = dst;
        this._next.blendSrcAlpha = srcAlpha;
        this._next.blendDstAlpha = dstAlpha;
      };
      Device.prototype.setBlendEq = function setBlendEq(eq) {
        this._next.blendSep = false;
        this._next.blendEq = eq;
      };
      Device.prototype.setBlendEqSep = function setBlendEqSep(eq, alphaEq) {
        this._next.blendSep = true;
        this._next.blendEq = eq;
        this._next.blendAlphaEq = alphaEq;
      };
      Device.prototype.setCullMode = function setCullMode(mode) {
        this._next.cullMode = mode;
      };
      Device.prototype.setVertexBuffer = function setVertexBuffer(stream, buffer) {
        var start = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        this._next.vertexBuffers[stream] = buffer;
        this._next.vertexBufferOffsets[stream] = start;
        this._next.maxStream < stream && (this._next.maxStream = stream);
      };
      Device.prototype.setIndexBuffer = function setIndexBuffer(buffer) {
        this._next.indexBuffer = buffer;
      };
      Device.prototype.setProgram = function setProgram(program) {
        this._next.program = program;
      };
      Device.prototype.setTexture = function setTexture(name, texture, slot) {
        if (slot >= this._caps.maxTextureUnits) {
          console.warn("Can not set texture " + name + " at stage " + slot + ", max texture exceed: " + this._caps.maxTextureUnits);
          return;
        }
        this._next.textureUnits[slot] = texture;
        this.setUniform(name, slot);
        this._next.maxTextureSlot < slot && (this._next.maxTextureSlot = slot);
      };
      Device.prototype.setTextureArray = function setTextureArray(name, textures, slots) {
        var len = textures.length;
        if (len >= this._caps.maxTextureUnits) {
          console.warn("Can not set " + len + " textures for " + name + ", max texture exceed: " + this._caps.maxTextureUnits);
          return;
        }
        for (var i = 0; i < len; ++i) {
          var slot = slots[i];
          this._next.textureUnits[slot] = textures[i];
        }
        this.setUniform(name, slots);
      };
      Device.prototype.setUniform = function setUniform(name, value) {
        var uniform = this._uniforms[name];
        var sameType = false;
        var isArray = false, isFloat32Array = false, isInt32Array = false;
        do {
          if (!uniform) break;
          isFloat32Array = Array.isArray(value) || value instanceof Float32Array;
          isInt32Array = value instanceof Int32Array;
          isArray = isFloat32Array || isInt32Array;
          if (uniform.isArray !== isArray) break;
          if (uniform.isArray && uniform.value.length !== value.length) break;
          sameType = true;
        } while (false);
        if (sameType) {
          var oldValue = uniform.value;
          var dirty = false;
          if (uniform.isArray) {
            for (var i = 0, l = oldValue.length; i < l; i++) if (oldValue[i] !== value[i]) {
              dirty = true;
              oldValue[i] = value[i];
            }
          } else if (oldValue !== value) {
            dirty = true;
            uniform.value = value;
          }
          dirty && (uniform.dirty = true);
        } else {
          var newValue = value;
          isFloat32Array ? newValue = new Float32Array(value) : isInt32Array && (newValue = new Int32Array(value));
          uniform = {
            dirty: true,
            value: newValue,
            isArray: isArray
          };
        }
        this._uniforms[name] = uniform;
      };
      Device.prototype.setUniformDirectly = function setUniformDirectly(name, value) {
        var uniform = this._uniforms[name];
        uniform || (this._uniforms[name] = uniform = {});
        uniform.dirty = true;
        uniform.value = value;
      };
      Device.prototype.setPrimitiveType = function setPrimitiveType(type) {
        this._next.primitiveType = type;
      };
      Device.prototype.draw = function draw(base, count) {
        var gl = this._gl;
        var cur = this._current;
        var next = this._next;
        _commitBlendStates(gl, cur, next);
        _commitDepthStates(gl, cur, next);
        _commitStencilStates(gl, cur, next);
        _commitCullMode(gl, cur, next);
        _commitVertexBuffers(this, gl, cur, next);
        cur.indexBuffer !== next.indexBuffer && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, next.indexBuffer && -1 !== next.indexBuffer._glID ? next.indexBuffer._glID : null);
        var programDirty = false;
        if (cur.program !== next.program) {
          next.program._linked ? gl.useProgram(next.program._glID) : console.warn("Failed to use program: has not linked yet.");
          programDirty = true;
        }
        _commitTextures(gl, cur, next);
        for (var i = 0; i < next.program._uniforms.length; ++i) {
          var uniformInfo = next.program._uniforms[i];
          var uniform = this._uniforms[uniformInfo.name];
          if (!uniform) continue;
          if (!programDirty && !uniform.dirty) continue;
          uniform.dirty = false;
          var commitFunc = void 0 === uniformInfo.size ? _type2uniformCommit[uniformInfo.type] : _type2uniformArrayCommit[uniformInfo.type];
          if (!commitFunc) {
            console.warn("Can not find commit function for uniform " + uniformInfo.name);
            continue;
          }
          commitFunc(gl, uniformInfo.location, uniform.value);
        }
        count && (next.indexBuffer ? gl.drawElements(this._next.primitiveType, count, next.indexBuffer._format, base * next.indexBuffer._bytesPerIndex) : gl.drawArrays(this._next.primitiveType, base, count));
        this._stats.drawcalls += 1;
        cur.set(next);
        next.reset();
      };
      return Device;
    })();
    exports.default = Device;
    module.exports = exports["default"];
  }), {
    "./enums": 230,
    "./state": 237,
    "./texture-2d": 238,
    "./texture-cube": 239
  } ],
  230: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.attrTypeBytes = attrTypeBytes;
    exports.glFilter = glFilter;
    exports.glTextureFmt = glTextureFmt;
    var GL_NEAREST = 9728;
    var GL_LINEAR = 9729;
    var GL_NEAREST_MIPMAP_NEAREST = 9984;
    var GL_LINEAR_MIPMAP_NEAREST = 9985;
    var GL_NEAREST_MIPMAP_LINEAR = 9986;
    var GL_LINEAR_MIPMAP_LINEAR = 9987;
    var GL_UNSIGNED_BYTE = 5121;
    var GL_UNSIGNED_SHORT = 5123;
    var GL_UNSIGNED_INT = 5125;
    var GL_FLOAT = 5126;
    var GL_UNSIGNED_SHORT_5_6_5 = 33635;
    var GL_UNSIGNED_SHORT_4_4_4_4 = 32819;
    var GL_UNSIGNED_SHORT_5_5_5_1 = 32820;
    var GL_HALF_FLOAT_OES = 36193;
    var GL_DEPTH_COMPONENT = 6402;
    var GL_ALPHA = 6406;
    var GL_RGB = 6407;
    var GL_RGBA = 6408;
    var GL_LUMINANCE = 6409;
    var GL_LUMINANCE_ALPHA = 6410;
    var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 33776;
    var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777;
    var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778;
    var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779;
    var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840;
    var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841;
    var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842;
    var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843;
    var GL_COMPRESSED_RGB_ETC1_WEBGL = 36196;
    var GL_COMPRESSED_RGB8_ETC2 = 37492;
    var GL_COMPRESSED_RGBA8_ETC2_EAC = 37496;
    var _filterGL = [ [ GL_NEAREST, GL_NEAREST_MIPMAP_NEAREST, GL_NEAREST_MIPMAP_LINEAR ], [ GL_LINEAR, GL_LINEAR_MIPMAP_NEAREST, GL_LINEAR_MIPMAP_LINEAR ] ];
    var _textureFmtGL = [ {
      format: GL_RGB,
      internalFormat: GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
      pixelType: null
    }, {
      format: GL_RGBA,
      internalFormat: GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
      pixelType: null
    }, {
      format: GL_RGBA,
      internalFormat: GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
      pixelType: null
    }, {
      format: GL_RGBA,
      internalFormat: GL_COMPRESSED_RGBA_S3TC_DXT5_EXT,
      pixelType: null
    }, {
      format: GL_RGB,
      internalFormat: GL_COMPRESSED_RGB_ETC1_WEBGL,
      pixelType: null
    }, {
      format: GL_RGB,
      internalFormat: GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
      pixelType: null
    }, {
      format: GL_RGBA,
      internalFormat: GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,
      pixelType: null
    }, {
      format: GL_RGB,
      internalFormat: GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
      pixelType: null
    }, {
      format: GL_RGBA,
      internalFormat: GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
      pixelType: null
    }, {
      format: GL_ALPHA,
      internalFormat: GL_ALPHA,
      pixelType: GL_UNSIGNED_BYTE
    }, {
      format: GL_LUMINANCE,
      internalFormat: GL_LUMINANCE,
      pixelType: GL_UNSIGNED_BYTE
    }, {
      format: GL_LUMINANCE_ALPHA,
      internalFormat: GL_LUMINANCE_ALPHA,
      pixelType: GL_UNSIGNED_BYTE
    }, {
      format: GL_RGB,
      internalFormat: GL_RGB,
      pixelType: GL_UNSIGNED_SHORT_5_6_5
    }, {
      format: GL_RGBA,
      internalFormat: GL_RGBA,
      pixelType: GL_UNSIGNED_SHORT_5_5_5_1
    }, {
      format: GL_RGBA,
      internalFormat: GL_RGBA,
      pixelType: GL_UNSIGNED_SHORT_4_4_4_4
    }, {
      format: GL_RGB,
      internalFormat: GL_RGB,
      pixelType: GL_UNSIGNED_BYTE
    }, {
      format: GL_RGBA,
      internalFormat: GL_RGBA,
      pixelType: GL_UNSIGNED_BYTE
    }, {
      format: GL_RGB,
      internalFormat: GL_RGB,
      pixelType: GL_HALF_FLOAT_OES
    }, {
      format: GL_RGBA,
      internalFormat: GL_RGBA,
      pixelType: GL_HALF_FLOAT_OES
    }, {
      format: GL_RGB,
      internalFormat: GL_RGB,
      pixelType: GL_FLOAT
    }, {
      format: GL_RGBA,
      internalFormat: GL_RGBA,
      pixelType: GL_FLOAT
    }, {
      format: null,
      internalFormat: null,
      pixelType: null
    }, {
      format: null,
      internalFormat: null,
      pixelType: null
    }, {
      format: null,
      internalFormat: null,
      pixelType: null
    }, {
      format: null,
      internalFormat: null,
      pixelType: null
    }, {
      format: GL_DEPTH_COMPONENT,
      internalFormat: GL_DEPTH_COMPONENT,
      pixelType: GL_UNSIGNED_SHORT
    }, {
      format: GL_DEPTH_COMPONENT,
      internalFormat: GL_DEPTH_COMPONENT,
      pixelType: GL_UNSIGNED_INT
    }, {
      format: GL_DEPTH_COMPONENT,
      internalFormat: GL_DEPTH_COMPONENT,
      pixelType: GL_UNSIGNED_INT
    }, {
      format: GL_RGB,
      internalFormat: GL_COMPRESSED_RGB8_ETC2,
      pixelType: null
    }, {
      format: GL_RGBA,
      internalFormat: GL_COMPRESSED_RGBA8_ETC2_EAC,
      pixelType: null
    } ];
    var enums = exports.enums = {
      USAGE_STATIC: 35044,
      USAGE_DYNAMIC: 35048,
      USAGE_STREAM: 35040,
      INDEX_FMT_UINT8: 5121,
      INDEX_FMT_UINT16: 5123,
      INDEX_FMT_UINT32: 5125,
      ATTR_POSITION: "a_position",
      ATTR_NORMAL: "a_normal",
      ATTR_TANGENT: "a_tangent",
      ATTR_BITANGENT: "a_bitangent",
      ATTR_WEIGHTS: "a_weights",
      ATTR_JOINTS: "a_joints",
      ATTR_COLOR: "a_color",
      ATTR_COLOR0: "a_color0",
      ATTR_COLOR1: "a_color1",
      ATTR_UV: "a_uv",
      ATTR_UV0: "a_uv0",
      ATTR_UV1: "a_uv1",
      ATTR_UV2: "a_uv2",
      ATTR_UV3: "a_uv3",
      ATTR_UV4: "a_uv4",
      ATTR_UV5: "a_uv5",
      ATTR_UV6: "a_uv6",
      ATTR_UV7: "a_uv7",
      ATTR_TYPE_INT8: 5120,
      ATTR_TYPE_UINT8: 5121,
      ATTR_TYPE_INT16: 5122,
      ATTR_TYPE_UINT16: 5123,
      ATTR_TYPE_INT32: 5124,
      ATTR_TYPE_UINT32: 5125,
      ATTR_TYPE_FLOAT32: 5126,
      FILTER_NEAREST: 0,
      FILTER_LINEAR: 1,
      WRAP_REPEAT: 10497,
      WRAP_CLAMP: 33071,
      WRAP_MIRROR: 33648,
      TEXTURE_FMT_RGB_DXT1: 0,
      TEXTURE_FMT_RGBA_DXT1: 1,
      TEXTURE_FMT_RGBA_DXT3: 2,
      TEXTURE_FMT_RGBA_DXT5: 3,
      TEXTURE_FMT_RGB_ETC1: 4,
      TEXTURE_FMT_RGB_PVRTC_2BPPV1: 5,
      TEXTURE_FMT_RGBA_PVRTC_2BPPV1: 6,
      TEXTURE_FMT_RGB_PVRTC_4BPPV1: 7,
      TEXTURE_FMT_RGBA_PVRTC_4BPPV1: 8,
      TEXTURE_FMT_A8: 9,
      TEXTURE_FMT_L8: 10,
      TEXTURE_FMT_L8_A8: 11,
      TEXTURE_FMT_R5_G6_B5: 12,
      TEXTURE_FMT_R5_G5_B5_A1: 13,
      TEXTURE_FMT_R4_G4_B4_A4: 14,
      TEXTURE_FMT_RGB8: 15,
      TEXTURE_FMT_RGBA8: 16,
      TEXTURE_FMT_RGB16F: 17,
      TEXTURE_FMT_RGBA16F: 18,
      TEXTURE_FMT_RGB32F: 19,
      TEXTURE_FMT_RGBA32F: 20,
      TEXTURE_FMT_R32F: 21,
      TEXTURE_FMT_111110F: 22,
      TEXTURE_FMT_SRGB: 23,
      TEXTURE_FMT_SRGBA: 24,
      TEXTURE_FMT_D16: 25,
      TEXTURE_FMT_D32: 26,
      TEXTURE_FMT_D24S8: 27,
      TEXTURE_FMT_RGB_ETC2: 28,
      TEXTURE_FMT_RGBA_ETC2: 29,
      DS_FUNC_NEVER: 512,
      DS_FUNC_LESS: 513,
      DS_FUNC_EQUAL: 514,
      DS_FUNC_LEQUAL: 515,
      DS_FUNC_GREATER: 516,
      DS_FUNC_NOTEQUAL: 517,
      DS_FUNC_GEQUAL: 518,
      DS_FUNC_ALWAYS: 519,
      RB_FMT_RGBA4: 32854,
      RB_FMT_RGB5_A1: 32855,
      RB_FMT_RGB565: 36194,
      RB_FMT_D16: 33189,
      RB_FMT_S8: 36168,
      RB_FMT_D24S8: 34041,
      BLEND_FUNC_ADD: 32774,
      BLEND_FUNC_SUBTRACT: 32778,
      BLEND_FUNC_REVERSE_SUBTRACT: 32779,
      BLEND_ZERO: 0,
      BLEND_ONE: 1,
      BLEND_SRC_COLOR: 768,
      BLEND_ONE_MINUS_SRC_COLOR: 769,
      BLEND_DST_COLOR: 774,
      BLEND_ONE_MINUS_DST_COLOR: 775,
      BLEND_SRC_ALPHA: 770,
      BLEND_ONE_MINUS_SRC_ALPHA: 771,
      BLEND_DST_ALPHA: 772,
      BLEND_ONE_MINUS_DST_ALPHA: 773,
      BLEND_CONSTANT_COLOR: 32769,
      BLEND_ONE_MINUS_CONSTANT_COLOR: 32770,
      BLEND_CONSTANT_ALPHA: 32771,
      BLEND_ONE_MINUS_CONSTANT_ALPHA: 32772,
      BLEND_SRC_ALPHA_SATURATE: 776,
      STENCIL_DISABLE: 0,
      STENCIL_ENABLE: 1,
      STENCIL_INHERIT: 2,
      STENCIL_OP_KEEP: 7680,
      STENCIL_OP_ZERO: 0,
      STENCIL_OP_REPLACE: 7681,
      STENCIL_OP_INCR: 7682,
      STENCIL_OP_INCR_WRAP: 34055,
      STENCIL_OP_DECR: 7683,
      STENCIL_OP_DECR_WRAP: 34056,
      STENCIL_OP_INVERT: 5386,
      CULL_NONE: 0,
      CULL_FRONT: 1028,
      CULL_BACK: 1029,
      CULL_FRONT_AND_BACK: 1032,
      PT_POINTS: 0,
      PT_LINES: 1,
      PT_LINE_LOOP: 2,
      PT_LINE_STRIP: 3,
      PT_TRIANGLES: 4,
      PT_TRIANGLE_STRIP: 5,
      PT_TRIANGLE_FAN: 6
    };
    function attrTypeBytes(attrType) {
      if (attrType === enums.ATTR_TYPE_INT8) return 1;
      if (attrType === enums.ATTR_TYPE_UINT8) return 1;
      if (attrType === enums.ATTR_TYPE_INT16) return 2;
      if (attrType === enums.ATTR_TYPE_UINT16) return 2;
      if (attrType === enums.ATTR_TYPE_INT32) return 4;
      if (attrType === enums.ATTR_TYPE_UINT32) return 4;
      if (attrType === enums.ATTR_TYPE_FLOAT32) return 4;
      console.warn("Unknown ATTR_TYPE: " + attrType);
      return 0;
    }
    function glFilter(gl, filter) {
      var mipFilter = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -1;
      var result = _filterGL[filter][mipFilter + 1];
      if (void 0 === result) {
        console.warn("Unknown FILTER: " + filter);
        return -1 === mipFilter ? gl.LINEAR : gl.LINEAR_MIPMAP_LINEAR;
      }
      return result;
    }
    function glTextureFmt(fmt) {
      var result = _textureFmtGL[fmt];
      if (void 0 === result) {
        console.warn("Unknown TEXTURE_FMT: " + fmt);
        return _textureFmtGL[enums.TEXTURE_FMT_RGBA8];
      }
      return result;
    }
  }), {} ],
  231: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var FrameBuffer = (function() {
      function FrameBuffer(device, width, height, options) {
        _classCallCheck(this, FrameBuffer);
        this._device = device;
        this._width = width;
        this._height = height;
        this._colors = options.colors || [];
        this._depth = options.depth || null;
        this._stencil = options.stencil || null;
        this._depthStencil = options.depthStencil || null;
        this._glID = device._gl.createFramebuffer();
      }
      FrameBuffer.prototype.destroy = function destroy() {
        if (null === this._glID) {
          console.error("The frame-buffer already destroyed");
          return;
        }
        var gl = this._device._gl;
        gl.deleteFramebuffer(this._glID);
        this._glID = null;
      };
      return FrameBuffer;
    })();
    exports.default = FrameBuffer;
    module.exports = exports["default"];
  }), {} ],
  232: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          "value" in descriptor && (descriptor.writable = true);
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        protoProps && defineProperties(Constructor.prototype, protoProps);
        staticProps && defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _enums = require("./enums");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var IndexBuffer = (function() {
      function IndexBuffer(device, format, usage, data, numIndices) {
        _classCallCheck(this, IndexBuffer);
        this._device = device;
        this._format = format;
        this._usage = usage;
        this._numIndices = numIndices;
        this._bytesPerIndex = 0;
        format === _enums.enums.INDEX_FMT_UINT8 ? this._bytesPerIndex = 1 : format === _enums.enums.INDEX_FMT_UINT16 ? this._bytesPerIndex = 2 : format === _enums.enums.INDEX_FMT_UINT32 && (this._bytesPerIndex = 4);
        this._bytes = this._bytesPerIndex * numIndices;
        this._glID = device._gl.createBuffer();
        this.update(0, data);
        device._stats.ib += this._bytes;
      }
      IndexBuffer.prototype.destroy = function destroy() {
        if (-1 === this._glID) {
          console.error("The buffer already destroyed");
          return;
        }
        var gl = this._device._gl;
        gl.deleteBuffer(this._glID);
        this._device._stats.ib -= this.bytes;
        this._glID = -1;
      };
      IndexBuffer.prototype.update = function update(offset, data) {
        if (-1 === this._glID) {
          console.error("The buffer is destroyed");
          return;
        }
        if (data && data.byteLength + offset > this._bytes) {
          console.error("Failed to update data, bytes exceed.");
          return;
        }
        var gl = this._device._gl;
        var glUsage = this._usage;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._glID);
        data ? offset ? gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, offset, data) : gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, glUsage) : this._bytes ? gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._bytes, glUsage) : console.warn("bufferData should not submit 0 bytes data");
        this._device._restoreIndexBuffer();
      };
      _createClass(IndexBuffer, [ {
        key: "count",
        get: function get() {
          return this._numIndices;
        }
      } ]);
      return IndexBuffer;
    })();
    exports.default = IndexBuffer;
    module.exports = exports["default"];
  }), {
    "./enums": 230
  } ],
  233: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _enums = require("./enums");
    var _vertexFormat = require("./vertex-format");
    var _vertexFormat2 = _interopRequireDefault(_vertexFormat);
    var _indexBuffer = require("./index-buffer");
    var _indexBuffer2 = _interopRequireDefault(_indexBuffer);
    var _vertexBuffer = require("./vertex-buffer");
    var _vertexBuffer2 = _interopRequireDefault(_vertexBuffer);
    var _program = require("./program");
    var _program2 = _interopRequireDefault(_program);
    var _texture = require("./texture");
    var _texture2 = _interopRequireDefault(_texture);
    var _texture2d = require("./texture-2d");
    var _texture2d2 = _interopRequireDefault(_texture2d);
    var _textureCube = require("./texture-cube");
    var _textureCube2 = _interopRequireDefault(_textureCube);
    var _renderBuffer = require("./render-buffer");
    var _renderBuffer2 = _interopRequireDefault(_renderBuffer);
    var _frameBuffer = require("./frame-buffer");
    var _frameBuffer2 = _interopRequireDefault(_frameBuffer);
    var _device = require("./device");
    var _device2 = _interopRequireDefault(_device);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var gfx = {
      VertexFormat: _vertexFormat2.default,
      IndexBuffer: _indexBuffer2.default,
      VertexBuffer: _vertexBuffer2.default,
      Program: _program2.default,
      Texture: _texture2.default,
      Texture2D: _texture2d2.default,
      TextureCube: _textureCube2.default,
      RenderBuffer: _renderBuffer2.default,
      FrameBuffer: _frameBuffer2.default,
      Device: _device2.default,
      attrTypeBytes: _enums.attrTypeBytes,
      glFilter: _enums.glFilter,
      glTextureFmt: _enums.glTextureFmt
    };
    Object.assign(gfx, _enums.enums);
    exports.default = gfx;
    cc.gfx = gfx;
    module.exports = exports["default"];
  }), {
    "./device": 229,
    "./enums": 230,
    "./frame-buffer": 231,
    "./index-buffer": 232,
    "./program": 235,
    "./render-buffer": 236,
    "./texture": 240,
    "./texture-2d": 238,
    "./texture-cube": 239,
    "./vertex-buffer": 241,
    "./vertex-format": 242
  } ],
  234: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.isPow2 = isPow2;
    function isPow2(v) {
      return !(v & v - 1) && !!v;
    }
  }), {} ],
  235: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          "value" in descriptor && (descriptor.writable = true);
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        protoProps && defineProperties(Constructor.prototype, protoProps);
        staticProps && defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _genID = 0;
    function _parseError(out, type, errorLog) {
      errorLog.split("\n").forEach((function(msg) {
        if (msg.length < 5) return;
        var parts = /^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(msg);
        parts ? out.push({
          type: type,
          fileID: 0 | parts[1],
          line: 0 | parts[2],
          message: parts[3].trim()
        }) : msg.length > 0 && out.push({
          type: type,
          fileID: -1,
          line: 0,
          message: msg
        });
      }));
    }
    var Program = (function() {
      function Program(device, options) {
        _classCallCheck(this, Program);
        this._device = device;
        this._attributes = [];
        this._uniforms = [];
        this._samplers = [];
        this._errors = [];
        this._linked = false;
        this._vertSource = options.vert;
        this._fragSource = options.frag;
        this._glID = null;
        this._id = _genID++;
      }
      Program.prototype.link = function link() {
        if (this._linked) return;
        var gl = this._device._gl;
        var vertShader = _createShader(gl, gl.VERTEX_SHADER, this._vertSource);
        var fragShader = _createShader(gl, gl.FRAGMENT_SHADER, this._fragSource);
        var program = gl.createProgram();
        gl.attachShader(program, vertShader);
        gl.attachShader(program, fragShader);
        gl.linkProgram(program);
        var failed = false;
        var errors = this._errors;
        if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
          _parseError(errors, "vs", gl.getShaderInfoLog(vertShader));
          failed = true;
        }
        if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
          _parseError(errors, "fs", gl.getShaderInfoLog(fragShader));
          failed = true;
        }
        gl.deleteShader(vertShader);
        gl.deleteShader(fragShader);
        if (failed) return errors;
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          errors.push({
            info: "Failed to link shader program: " + gl.getProgramInfoLog(program)
          });
          return errors;
        }
        this._glID = program;
        var numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (var i = 0; i < numAttributes; ++i) {
          var info = gl.getActiveAttrib(program, i);
          var location = gl.getAttribLocation(program, info.name);
          this._attributes.push({
            name: info.name,
            location: location,
            type: info.type
          });
        }
        var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (var _i = 0; _i < numUniforms; ++_i) {
          var _info = gl.getActiveUniform(program, _i);
          var name = _info.name;
          var _location = gl.getUniformLocation(program, name);
          var isArray = "[0]" === name.substr(name.length - 3);
          isArray && (name = name.substr(0, name.length - 3));
          var uniform = {
            name: name,
            location: _location,
            type: _info.type,
            size: isArray ? _info.size : void 0
          };
          this._uniforms.push(uniform);
        }
        this._linked = true;
      };
      Program.prototype.destroy = function destroy() {
        var gl = this._device._gl;
        gl.deleteProgram(this._glID);
        this._linked = false;
        this._glID = null;
        this._attributes = [];
        this._uniforms = [];
        this._samplers = [];
      };
      _createClass(Program, [ {
        key: "id",
        get: function get() {
          return this._id;
        }
      } ]);
      return Program;
    })();
    exports.default = Program;
    function _createShader(gl, type, src) {
      var shader = gl.createShader(type);
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      return shader;
    }
    module.exports = exports["default"];
  }), {} ],
  236: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var RenderBuffer = (function() {
      function RenderBuffer(device, format, width, height) {
        _classCallCheck(this, RenderBuffer);
        this._device = device;
        this._format = format;
        this._glID = device._gl.createRenderbuffer();
        this.update(width, height);
      }
      RenderBuffer.prototype.update = function update(width, height) {
        this._width = width;
        this._height = height;
        var gl = this._device._gl;
        gl.bindRenderbuffer(gl.RENDERBUFFER, this._glID);
        gl.renderbufferStorage(gl.RENDERBUFFER, this._format, width, height);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      };
      RenderBuffer.prototype.destroy = function destroy() {
        if (null === this._glID) {
          console.error("The render-buffer already destroyed");
          return;
        }
        var gl = this._device._gl;
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.deleteRenderbuffer(this._glID);
        this._glID = null;
      };
      return RenderBuffer;
    })();
    exports.default = RenderBuffer;
    module.exports = exports["default"];
  }), {} ],
  237: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _enums = require("./enums");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _default = {
      blend: false,
      blendSep: false,
      blendColor: 4294967295,
      blendEq: _enums.enums.BLEND_FUNC_ADD,
      blendAlphaEq: _enums.enums.BLEND_FUNC_ADD,
      blendSrc: _enums.enums.BLEND_ONE,
      blendDst: _enums.enums.BLEND_ZERO,
      blendSrcAlpha: _enums.enums.BLEND_ONE,
      blendDstAlpha: _enums.enums.BLEND_ZERO,
      depthTest: false,
      depthWrite: false,
      depthFunc: _enums.enums.DS_FUNC_LESS,
      stencilTest: false,
      stencilSep: false,
      stencilFuncFront: _enums.enums.DS_FUNC_ALWAYS,
      stencilRefFront: 0,
      stencilMaskFront: 255,
      stencilFailOpFront: _enums.enums.STENCIL_OP_KEEP,
      stencilZFailOpFront: _enums.enums.STENCIL_OP_KEEP,
      stencilZPassOpFront: _enums.enums.STENCIL_OP_KEEP,
      stencilWriteMaskFront: 255,
      stencilFuncBack: _enums.enums.DS_FUNC_ALWAYS,
      stencilRefBack: 0,
      stencilMaskBack: 255,
      stencilFailOpBack: _enums.enums.STENCIL_OP_KEEP,
      stencilZFailOpBack: _enums.enums.STENCIL_OP_KEEP,
      stencilZPassOpBack: _enums.enums.STENCIL_OP_KEEP,
      stencilWriteMaskBack: 255,
      cullMode: _enums.enums.CULL_BACK,
      primitiveType: _enums.enums.PT_TRIANGLES,
      maxStream: -1,
      vertexBuffers: [],
      vertexBufferOffsets: [],
      indexBuffer: null,
      maxTextureSlot: -1,
      textureUnits: [],
      program: null
    };
    var State = (function() {
      function State(device) {
        _classCallCheck(this, State);
        this.vertexBuffers = new Array(device._caps.maxVertexStreams);
        this.vertexBufferOffsets = new Array(device._caps.maxVertexStreams);
        this.textureUnits = new Array(device._caps.maxTextureUnits);
        this.set(_default);
      }
      State.initDefault = function initDefault(device) {
        _default.vertexBuffers = new Array(device._caps.maxVertexStreams);
        _default.vertexBufferOffsets = new Array(device._caps.maxVertexStreams);
        _default.textureUnits = new Array(device._caps.maxTextureUnits);
      };
      State.prototype.reset = function reset() {
        this.set(_default);
      };
      State.prototype.set = function set(cpy) {
        this.blend = cpy.blend;
        this.blendSep = cpy.blendSep;
        this.blendColor = cpy.blendColor;
        this.blendEq = cpy.blendEq;
        this.blendAlphaEq = cpy.blendAlphaEq;
        this.blendSrc = cpy.blendSrc;
        this.blendDst = cpy.blendDst;
        this.blendSrcAlpha = cpy.blendSrcAlpha;
        this.blendDstAlpha = cpy.blendDstAlpha;
        this.depthTest = cpy.depthTest;
        this.depthWrite = cpy.depthWrite;
        this.depthFunc = cpy.depthFunc;
        this.stencilTest = cpy.stencilTest;
        this.stencilSep = cpy.stencilSep;
        this.stencilFuncFront = cpy.stencilFuncFront;
        this.stencilRefFront = cpy.stencilRefFront;
        this.stencilMaskFront = cpy.stencilMaskFront;
        this.stencilFailOpFront = cpy.stencilFailOpFront;
        this.stencilZFailOpFront = cpy.stencilZFailOpFront;
        this.stencilZPassOpFront = cpy.stencilZPassOpFront;
        this.stencilWriteMaskFront = cpy.stencilWriteMaskFront;
        this.stencilFuncBack = cpy.stencilFuncBack;
        this.stencilRefBack = cpy.stencilRefBack;
        this.stencilMaskBack = cpy.stencilMaskBack;
        this.stencilFailOpBack = cpy.stencilFailOpBack;
        this.stencilZFailOpBack = cpy.stencilZFailOpBack;
        this.stencilZPassOpBack = cpy.stencilZPassOpBack;
        this.stencilWriteMaskBack = cpy.stencilWriteMaskBack;
        this.cullMode = cpy.cullMode;
        this.primitiveType = cpy.primitiveType;
        this.maxStream = cpy.maxStream;
        for (var i = 0; i < cpy.vertexBuffers.length; ++i) this.vertexBuffers[i] = cpy.vertexBuffers[i];
        for (var _i = 0; _i < cpy.vertexBufferOffsets.length; ++_i) this.vertexBufferOffsets[_i] = cpy.vertexBufferOffsets[_i];
        this.indexBuffer = cpy.indexBuffer;
        this.maxTextureSlot = cpy.maxTextureSlot;
        for (var _i2 = 0; _i2 < cpy.textureUnits.length; ++_i2) this.textureUnits[_i2] = cpy.textureUnits[_i2];
        this.program = cpy.program;
      };
      return State;
    })();
    exports.default = State;
    module.exports = exports["default"];
  }), {
    "./enums": 230
  } ],
  238: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _texture = require("./texture");
    var _texture2 = _interopRequireDefault(_texture);
    var _enums = require("./enums");
    var _misc = require("./misc");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !call || "object" !== typeof call && "function" !== typeof call ? self : call;
    }
    function _inherits(subClass, superClass) {
      if ("function" !== typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
    }
    var ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;
    var Texture2D = (function(_Texture) {
      _inherits(Texture2D, _Texture);
      function Texture2D(device, options) {
        _classCallCheck(this, Texture2D);
        var _this = _possibleConstructorReturn(this, _Texture.call(this, device));
        var gl = _this._device._gl;
        _this._target = gl.TEXTURE_2D;
        _this._glID = gl.createTexture();
        options.images = options.images || [ null ];
        _this.update(options);
        return _this;
      }
      Texture2D.prototype.update = function update(options) {
        var gl = this._device._gl;
        var genMipmap = this._hasMipmap;
        if (options) {
          void 0 !== options.width && (this._width = options.width);
          void 0 !== options.height && (this._height = options.height);
          void 0 !== options.anisotropy && (this._anisotropy = options.anisotropy);
          void 0 !== options.minFilter && (this._minFilter = options.minFilter);
          void 0 !== options.magFilter && (this._magFilter = options.magFilter);
          void 0 !== options.mipFilter && (this._mipFilter = options.mipFilter);
          void 0 !== options.wrapS && (this._wrapS = options.wrapS);
          void 0 !== options.wrapT && (this._wrapT = options.wrapT);
          if (void 0 !== options.format) {
            this._format = options.format;
            this._compressed = this._format >= _enums.enums.TEXTURE_FMT_RGB_DXT1 && this._format <= _enums.enums.TEXTURE_FMT_RGBA_PVRTC_4BPPV1 || this._format >= _enums.enums.TEXTURE_FMT_RGB_ETC2 && this._format <= _enums.enums.TEXTURE_FMT_RGBA_ETC2;
          }
          if (void 0 !== options.mipmap) {
            this._hasMipmap = options.mipmap;
            genMipmap = options.mipmap;
          }
          var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
          var textureMaxSize = options.width && options.height ? Math.max(options.width, options.height) : 0;
          maxSize < textureMaxSize && console.warn("The current texture size " + textureMaxSize + " exceeds the maximum size [" + maxSize + "] supported on the device.");
          if (void 0 !== options.images && options.images.length > 1) {
            genMipmap = false;
            var maxLength = options.width > options.height ? options.width : options.height;
            maxLength >> options.images.length - 1 !== 1 && console.error("texture-2d mipmap is invalid, should have a 1x1 mipmap.");
          }
        }
        var pot = (0, _misc.isPow2)(this._width) && (0, _misc.isPow2)(this._height);
        pot || (genMipmap = false);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._glID);
        if (void 0 !== options.images && options.images.length > 0) {
          this._setMipmap(options.images, options.flipY, options.premultiplyAlpha);
          options.images.length > 1 && (this._hasMipmap = true);
        }
        if (genMipmap) {
          gl.hint(gl.GENERATE_MIPMAP_HINT, gl.NICEST);
          gl.generateMipmap(gl.TEXTURE_2D);
          this._hasMipmap = true;
        }
        this._setTexInfo();
        this._device._restoreTexture(0);
      };
      Texture2D.prototype.updateSubImage = function updateSubImage(options) {
        var gl = this._device._gl;
        var glFmt = (0, _enums.glTextureFmt)(this._format);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._glID);
        this._setSubImage(glFmt, options);
        this._device._restoreTexture(0);
      };
      Texture2D.prototype.updateImage = function updateImage(options) {
        var gl = this._device._gl;
        var glFmt = (0, _enums.glTextureFmt)(this._format);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._glID);
        this._setImage(glFmt, options);
        this._device._restoreTexture(0);
      };
      Texture2D.prototype._setSubImage = function _setSubImage(glFmt, options) {
        var gl = this._device._gl;
        var flipY = options.flipY;
        var premultiplyAlpha = options.premultiplyAlpha;
        var img = options.image;
        if (!img || ArrayBuffer.isView(img) || img instanceof ArrayBuffer) {
          void 0 === flipY ? gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false) : gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
          void 0 === premultiplyAlpha ? gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false) : gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
          this._compressed ? gl.compressedTexSubImage2D(gl.TEXTURE_2D, options.level, options.x, options.y, options.width, options.height, glFmt.format, img) : gl.texSubImage2D(gl.TEXTURE_2D, options.level, options.x, options.y, options.width, options.height, glFmt.format, glFmt.pixelType, img);
        } else {
          void 0 === flipY ? gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true) : gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
          void 0 === premultiplyAlpha ? gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false) : gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
          gl.texSubImage2D(gl.TEXTURE_2D, options.level, options.x, options.y, glFmt.format, glFmt.pixelType, img);
        }
      };
      Texture2D.prototype._setImage = function _setImage(glFmt, options) {
        var gl = this._device._gl;
        var flipY = options.flipY;
        var premultiplyAlpha = options.premultiplyAlpha;
        var img = options.image;
        if (!img || ArrayBuffer.isView(img) || img instanceof ArrayBuffer) {
          void 0 === flipY ? gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false) : gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
          void 0 === premultiplyAlpha ? gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false) : gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
          this._compressed ? gl.compressedTexImage2D(gl.TEXTURE_2D, options.level, glFmt.internalFormat, options.width, options.height, 0, img) : gl.texImage2D(gl.TEXTURE_2D, options.level, glFmt.internalFormat, options.width, options.height, 0, glFmt.format, glFmt.pixelType, img);
        } else {
          void 0 === flipY ? gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true) : gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
          void 0 === premultiplyAlpha ? gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false) : gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
          gl.texImage2D(gl.TEXTURE_2D, options.level, glFmt.internalFormat, glFmt.format, glFmt.pixelType, img);
        }
      };
      Texture2D.prototype._setMipmap = function _setMipmap(images, flipY, premultiplyAlpha) {
        var glFmt = (0, _enums.glTextureFmt)(this._format);
        var options = {
          width: this._width,
          height: this._height,
          flipY: flipY,
          premultiplyAlpha: premultiplyAlpha,
          level: 0,
          image: null
        };
        for (var i = 0; i < images.length; ++i) {
          options.level = i;
          options.width = this._width >> i;
          options.height = this._height >> i;
          options.image = images[i];
          this._setImage(glFmt, options);
        }
      };
      Texture2D.prototype._setTexInfo = function _setTexInfo() {
        var gl = this._device._gl;
        var pot = (0, _misc.isPow2)(this._width) && (0, _misc.isPow2)(this._height);
        if (!pot && (this._wrapS !== _enums.enums.WRAP_CLAMP || this._wrapT !== _enums.enums.WRAP_CLAMP)) {
          console.warn("WebGL1 doesn't support all wrap modes with NPOT textures");
          this._wrapS = _enums.enums.WRAP_CLAMP;
          this._wrapT = _enums.enums.WRAP_CLAMP;
        }
        var mipFilter = this._hasMipmap ? this._mipFilter : -1;
        if (!pot && -1 !== mipFilter) {
          console.warn("NPOT textures do not support mipmap filter");
          mipFilter = -1;
        }
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, (0, _enums.glFilter)(gl, this._minFilter, mipFilter));
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, (0, _enums.glFilter)(gl, this._magFilter, -1));
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT);
        var ext = this._device.ext("EXT_texture_filter_anisotropic");
        ext && gl.texParameteri(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, this._anisotropy);
      };
      return Texture2D;
    })(_texture2.default);
    exports.default = Texture2D;
    module.exports = exports["default"];
  }), {
    "./enums": 230,
    "./misc": 234,
    "./texture": 240
  } ],
  239: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _texture = require("./texture");
    var _texture2 = _interopRequireDefault(_texture);
    var _enums = require("./enums");
    var _misc = require("./misc");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !call || "object" !== typeof call && "function" !== typeof call ? self : call;
    }
    function _inherits(subClass, superClass) {
      if ("function" !== typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
    }
    var TextureCube = (function(_Texture) {
      _inherits(TextureCube, _Texture);
      function TextureCube(device, options) {
        _classCallCheck(this, TextureCube);
        var _this = _possibleConstructorReturn(this, _Texture.call(this, device));
        var gl = _this._device._gl;
        _this._target = gl.TEXTURE_CUBE_MAP;
        _this._glID = gl.createTexture();
        _this.update(options);
        return _this;
      }
      TextureCube.prototype.update = function update(options) {
        var gl = this._device._gl;
        var genMipmap = this._hasMipmap;
        if (options) {
          void 0 !== options.width && (this._width = options.width);
          void 0 !== options.height && (this._height = options.height);
          void 0 !== options.anisotropy && (this._anisotropy = options.anisotropy);
          void 0 !== options.minFilter && (this._minFilter = options.minFilter);
          void 0 !== options.magFilter && (this._magFilter = options.magFilter);
          void 0 !== options.mipFilter && (this._mipFilter = options.mipFilter);
          void 0 !== options.wrapS && (this._wrapS = options.wrapS);
          void 0 !== options.wrapT && (this._wrapT = options.wrapT);
          if (void 0 !== options.format) {
            this._format = options.format;
            this._compressed = this._format >= _enums.enums.TEXTURE_FMT_RGB_DXT1 && this._format <= _enums.enums.TEXTURE_FMT_RGBA_PVRTC_4BPPV1 || this._format >= _enums.enums.TEXTURE_FMT_RGB_ETC2 && this._format <= _enums.enums.TEXTURE_FMT_RGBA_ETC2;
          }
          if (void 0 !== options.mipmap) {
            this._hasMipmap = options.mipmap;
            genMipmap = options.mipmap;
          }
          if (void 0 !== options.images && options.images.length > 1) {
            genMipmap = false;
            options.width !== options.height && console.warn("texture-cube width and height should be identical.");
            options.width >> options.images.length - 1 !== 1 && console.error("texture-cube mipmap is invalid. please set mipmap as 1x1, 2x2, 4x4 ... nxn");
          }
        }
        var pot = (0, _misc.isPow2)(this._width) && (0, _misc.isPow2)(this._height);
        pot || (genMipmap = false);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._glID);
        if (void 0 !== options.images && options.images.length > 0) {
          this._setMipmap(options.images, options.flipY, options.premultiplyAlpha);
          options.images.length > 1 && (this._hasMipmap = true);
        }
        if (genMipmap) {
          gl.hint(gl.GENERATE_MIPMAP_HINT, gl.NICEST);
          gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
          this._hasMipmap = true;
        }
        this._setTexInfo();
        this._device._restoreTexture(0);
      };
      TextureCube.prototype.updateSubImage = function updateSubImage(options) {
        var gl = this._device._gl;
        var glFmt = (0, _enums.glTextureFmt)(this._format);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._glID);
        this._setSubImage(glFmt, options);
        this._device._restoreTexture(0);
      };
      TextureCube.prototype.updateImage = function updateImage(options) {
        var gl = this._device._gl;
        var glFmt = (0, _enums.glTextureFmt)(this._format);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._glID);
        this._setImage(glFmt, options);
        this._device._restoreTexture(0);
      };
      TextureCube.prototype._setSubImage = function _setSubImage(glFmt, options) {
        var gl = this._device._gl;
        var flipY = options.flipY;
        var premultiplyAlpha = options.premultiplyAlpha;
        var faceIndex = options.faceIndex;
        var img = options.image;
        void 0 === flipY ? gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false) : gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
        void 0 === premultiplyAlpha ? gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false) : gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
        !img || ArrayBuffer.isView(img) || img instanceof ArrayBuffer ? this._compressed ? gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, options.level, options.x, options.y, options.width, options.height, glFmt.format, img) : gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, options.level, options.x, options.y, options.width, options.height, glFmt.format, glFmt.pixelType, img) : gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, options.level, options.x, options.y, glFmt.format, glFmt.pixelType, img);
      };
      TextureCube.prototype._setImage = function _setImage(glFmt, options) {
        var gl = this._device._gl;
        var flipY = options.flipY;
        var premultiplyAlpha = options.premultiplyAlpha;
        var faceIndex = options.faceIndex;
        var img = options.image;
        void 0 === flipY ? gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false) : gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
        void 0 === premultiplyAlpha ? gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false) : gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
        !img || ArrayBuffer.isView(img) || img instanceof ArrayBuffer ? this._compressed ? gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, options.level, glFmt.internalFormat, options.width, options.height, 0, img) : gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, options.level, glFmt.internalFormat, options.width, options.height, 0, glFmt.format, glFmt.pixelType, img) : gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, options.level, glFmt.internalFormat, glFmt.format, glFmt.pixelType, img);
      };
      TextureCube.prototype._setMipmap = function _setMipmap(images, flipY, premultiplyAlpha) {
        var glFmt = (0, _enums.glTextureFmt)(this._format);
        var options = {
          width: this._width,
          height: this._height,
          faceIndex: 0,
          flipY: flipY,
          premultiplyAlpha: premultiplyAlpha,
          level: 0,
          image: null
        };
        for (var i = 0; i < images.length; ++i) {
          var levelImages = images[i];
          options.level = i;
          options.width = this._width >> i;
          options.height = this._height >> i;
          for (var face = 0; face < 6; ++face) {
            options.faceIndex = face;
            options.image = levelImages[face];
            this._setImage(glFmt, options);
          }
        }
      };
      TextureCube.prototype._setTexInfo = function _setTexInfo() {
        var gl = this._device._gl;
        var pot = (0, _misc.isPow2)(this._width) && (0, _misc.isPow2)(this._height);
        if (!pot && (this._wrapS !== _enums.enums.WRAP_CLAMP || this._wrapT !== _enums.enums.WRAP_CLAMP)) {
          console.warn("WebGL1 doesn't support all wrap modes with NPOT textures");
          this._wrapS = _enums.enums.WRAP_CLAMP;
          this._wrapT = _enums.enums.WRAP_CLAMP;
        }
        var mipFilter = this._hasMipmap ? this._mipFilter : -1;
        if (!pot && -1 !== mipFilter) {
          console.warn("NPOT textures do not support mipmap filter");
          mipFilter = -1;
        }
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, (0, _enums.glFilter)(gl, this._minFilter, mipFilter));
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, (0, _enums.glFilter)(gl, this._magFilter, -1));
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, this._wrapS);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, this._wrapT);
        var ext = this._device.ext("EXT_texture_filter_anisotropic");
        ext && gl.texParameteri(gl.TEXTURE_CUBE_MAP, ext.TEXTURE_MAX_ANISOTROPY_EXT, this._anisotropy);
      };
      return TextureCube;
    })(_texture2.default);
    exports.default = TextureCube;
    module.exports = exports["default"];
  }), {
    "./enums": 230,
    "./misc": 234,
    "./texture": 240
  } ],
  240: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _enums = require("./enums");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _nullWebGLTexture = null;
    var _textureID = 0;
    var Texture = (function() {
      function Texture(device) {
        _classCallCheck(this, Texture);
        this._device = device;
        this._width = 4;
        this._height = 4;
        this._hasMipmap = false;
        this._compressed = false;
        this._anisotropy = 1;
        this._minFilter = _enums.enums.FILTER_LINEAR;
        this._magFilter = _enums.enums.FILTER_LINEAR;
        this._mipFilter = _enums.enums.FILTER_LINEAR;
        this._wrapS = _enums.enums.WRAP_REPEAT;
        this._wrapT = _enums.enums.WRAP_REPEAT;
        this._format = _enums.enums.TEXTURE_FMT_RGBA8;
        this._target = -1;
        this._id = _textureID++;
      }
      Texture.prototype.destroy = function destroy() {
        if (this._glID === _nullWebGLTexture) {
          console.error("The texture already destroyed");
          return;
        }
        var gl = this._device._gl;
        gl.deleteTexture(this._glID);
        this._device._stats.tex -= this.bytes;
        this._glID = _nullWebGLTexture;
      };
      return Texture;
    })();
    exports.default = Texture;
    module.exports = exports["default"];
  }), {
    "./enums": 230
  } ],
  241: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          "value" in descriptor && (descriptor.writable = true);
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        protoProps && defineProperties(Constructor.prototype, protoProps);
        staticProps && defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _enums = require("./enums");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var VertexBuffer = (function() {
      function VertexBuffer(device, format, usage, data, numVertices) {
        _classCallCheck(this, VertexBuffer);
        this._device = device;
        this._format = format;
        this._usage = usage;
        this._numVertices = numVertices;
        this._bytes = this._format._bytes * numVertices;
        this._glID = device._gl.createBuffer();
        this.update(0, data);
        device._stats.vb += this._bytes;
      }
      VertexBuffer.prototype.destroy = function destroy() {
        if (-1 === this._glID) {
          console.error("The buffer already destroyed");
          return;
        }
        var gl = this._device._gl;
        gl.deleteBuffer(this._glID);
        this._device._stats.vb -= this.bytes;
        this._glID = -1;
      };
      VertexBuffer.prototype.update = function update(offset, data) {
        if (-1 === this._glID) {
          console.error("The buffer is destroyed");
          return;
        }
        if (data && data.byteLength + offset > this._bytes) {
          console.error("Failed to update data, bytes exceed.");
          return;
        }
        var gl = this._device._gl;
        var glUsage = this._usage;
        gl.bindBuffer(gl.ARRAY_BUFFER, this._glID);
        data ? offset ? gl.bufferSubData(gl.ARRAY_BUFFER, offset, data) : gl.bufferData(gl.ARRAY_BUFFER, data, glUsage) : this._bytes ? gl.bufferData(gl.ARRAY_BUFFER, this._bytes, glUsage) : console.warn("bufferData should not submit 0 bytes data");
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      };
      _createClass(VertexBuffer, [ {
        key: "count",
        get: function get() {
          return this._numVertices;
        }
      } ]);
      return VertexBuffer;
    })();
    exports.default = VertexBuffer;
    module.exports = exports["default"];
  }), {
    "./enums": 230
  } ],
  242: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _enums = require("./enums");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var VertexFormat = (function() {
      function VertexFormat(infos) {
        _classCallCheck(this, VertexFormat);
        this._attr2el = {};
        this._elements = [];
        this._bytes = 0;
        for (var i = 0, len = infos.length; i < len; ++i) {
          var info = infos[i];
          var el = {
            name: info.name,
            offset: this._bytes,
            stride: 0,
            stream: -1,
            type: info.type,
            num: info.num,
            normalize: void 0 !== info.normalize && info.normalize,
            bytes: info.num * (0, _enums.attrTypeBytes)(info.type)
          };
          this._attr2el[el.name] = el;
          this._elements.push(el);
          this._bytes += el.bytes;
        }
        for (var _i = 0, _len = this._elements.length; _i < _len; ++_i) {
          var _el = this._elements[_i];
          _el.stride = this._bytes;
        }
      }
      VertexFormat.prototype.element = function element(attrName) {
        return this._attr2el[attrName];
      };
      return VertexFormat;
    })();
    exports.default = VertexFormat;
    module.exports = exports["default"];
  }), {
    "./enums": 230
  } ],
  243: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var CircularPool = (function() {
      function CircularPool(fn, size) {
        _classCallCheck(this, CircularPool);
        this._cursor = 0;
        this._data = new Array(size);
        for (var i = 0; i < size; ++i) this._data[i] = fn();
      }
      CircularPool.prototype.request = function request() {
        var item = this._data[this._cursor];
        this._cursor = (this._cursor + 1) % this._data.length;
        return item;
      };
      return CircularPool;
    })();
    exports.default = CircularPool;
    module.exports = exports["default"];
  }), {} ],
  244: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          "value" in descriptor && (descriptor.writable = true);
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        protoProps && defineProperties(Constructor.prototype, protoProps);
        staticProps && defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _timsort = require("./timsort");
    var _timsort2 = _interopRequireDefault(_timsort);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var FixedArray = (function() {
      function FixedArray(size) {
        _classCallCheck(this, FixedArray);
        this._count = 0;
        this._data = new Array(size);
      }
      FixedArray.prototype._resize = function _resize(size) {
        if (size > this._data.length) for (var i = this._data.length; i < size; ++i) this._data[i] = void 0;
      };
      FixedArray.prototype.reset = function reset() {
        for (var i = 0; i < this._count; ++i) this._data[i] = void 0;
        this._count = 0;
      };
      FixedArray.prototype.push = function push(val) {
        this._count >= this._data.length && this._resize(2 * this._data.length);
        this._data[this._count] = val;
        ++this._count;
      };
      FixedArray.prototype.pop = function pop() {
        --this._count;
        this._count < 0 && (this._count = 0);
        var ret = this._data[this._count];
        this._data[this._count] = void 0;
        return ret;
      };
      FixedArray.prototype.fastRemove = function fastRemove(idx) {
        if (idx >= this._count || idx < 0) return;
        var last = this._count - 1;
        this._data[idx] = this._data[last];
        this._data[last] = void 0;
        this._count -= 1;
      };
      FixedArray.prototype.indexOf = function indexOf(val) {
        return this._data.indexOf(val);
      };
      FixedArray.prototype.sort = function sort(cmp) {
        return (0, _timsort2.default)(this._data, 0, this._count, cmp);
      };
      _createClass(FixedArray, [ {
        key: "length",
        get: function get() {
          return this._count;
        }
      }, {
        key: "data",
        get: function get() {
          return this._data;
        }
      } ]);
      return FixedArray;
    })();
    exports.default = FixedArray;
    module.exports = exports["default"];
  }), {
    "./timsort": 249
  } ],
  245: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _circularPool = require("./circular-pool");
    Object.defineProperty(exports, "CircularPool", {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_circularPool).default;
      }
    });
    var _fixedArray = require("./fixed-array");
    Object.defineProperty(exports, "FixedArray", {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_fixedArray).default;
      }
    });
    var _linkedArray = require("./linked-array");
    Object.defineProperty(exports, "LinkedArray", {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_linkedArray).default;
      }
    });
    var _pool = require("./pool");
    Object.defineProperty(exports, "Pool", {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_pool).default;
      }
    });
    var _recyclePool = require("./recycle-pool");
    Object.defineProperty(exports, "RecyclePool", {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_recyclePool).default;
      }
    });
    var _typedArrayPool = require("./typed-array-pool");
    Object.defineProperty(exports, "TypedArrayPool", {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_typedArrayPool).default;
      }
    });
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  }), {
    "./circular-pool": 243,
    "./fixed-array": 244,
    "./linked-array": 246,
    "./pool": 247,
    "./recycle-pool": 248,
    "./typed-array-pool": 250
  } ],
  246: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          "value" in descriptor && (descriptor.writable = true);
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        protoProps && defineProperties(Constructor.prototype, protoProps);
        staticProps && defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _pool = require("./pool");
    var _pool2 = _interopRequireDefault(_pool);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var LinkedArray = (function() {
      function LinkedArray(fn, size) {
        _classCallCheck(this, LinkedArray);
        this._fn = fn;
        this._count = 0;
        this._head = null;
        this._tail = null;
        this._pool = new _pool2.default(fn, size);
      }
      LinkedArray.prototype.add = function add() {
        var node = this._pool.alloc();
        if (this._tail) {
          this._tail._next = node;
          node._prev = this._tail;
        } else this._head = node;
        this._tail = node;
        this._count += 1;
        return node;
      };
      LinkedArray.prototype.remove = function remove(node) {
        node._prev ? node._prev._next = node._next : this._head = node._next;
        node._next ? node._next._prev = node._prev : this._tail = node._prev;
        node._next = null;
        node._prev = null;
        this._pool.free(node);
        this._count -= 1;
      };
      LinkedArray.prototype.forEach = function forEach(fn, binder) {
        var cursor = this._head;
        if (!cursor) return;
        binder && (fn = fn.bind(binder));
        var idx = 0;
        var next = cursor;
        while (cursor) {
          next = cursor._next;
          fn(cursor, idx, this);
          cursor = next;
          ++idx;
        }
      };
      _createClass(LinkedArray, [ {
        key: "head",
        get: function get() {
          return this._head;
        }
      }, {
        key: "tail",
        get: function get() {
          return this._tail;
        }
      }, {
        key: "length",
        get: function get() {
          return this._count;
        }
      } ]);
      return LinkedArray;
    })();
    exports.default = LinkedArray;
    module.exports = exports["default"];
  }), {
    "./pool": 247
  } ],
  247: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var Pool = (function() {
      function Pool(fn, size) {
        _classCallCheck(this, Pool);
        this._fn = fn;
        this._idx = size - 1;
        this._frees = new Array(size);
        for (var i = 0; i < size; ++i) this._frees[i] = fn();
      }
      Pool.prototype._expand = function _expand(size) {
        var old = this._frees;
        this._frees = new Array(size);
        var len = size - old.length;
        for (var i = 0; i < len; ++i) this._frees[i] = this._fn();
        for (var _i = len, j = 0; _i < size; ++_i, ++j) this._frees[_i] = old[j];
        this._idx += len;
      };
      Pool.prototype.alloc = function alloc() {
        this._idx < 0 && this._expand(Math.round(1.2 * this._frees.length) + 1);
        var ret = this._frees[this._idx];
        this._frees[this._idx] = null;
        --this._idx;
        return ret;
      };
      Pool.prototype.free = function free(obj) {
        ++this._idx;
        this._frees[this._idx] = obj;
      };
      return Pool;
    })();
    exports.default = Pool;
    module.exports = exports["default"];
  }), {} ],
  248: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          "value" in descriptor && (descriptor.writable = true);
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        protoProps && defineProperties(Constructor.prototype, protoProps);
        staticProps && defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _timsort = require("./timsort");
    var _timsort2 = _interopRequireDefault(_timsort);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var RecyclePool = (function() {
      function RecyclePool(fn, size) {
        _classCallCheck(this, RecyclePool);
        this._fn = fn;
        this._count = 0;
        this._data = new Array(size);
        for (var i = 0; i < size; ++i) this._data[i] = fn();
      }
      RecyclePool.prototype.reset = function reset() {
        this._count = 0;
      };
      RecyclePool.prototype.resize = function resize(size) {
        if (size > this._data.length) for (var i = this._data.length; i < size; ++i) this._data[i] = this._fn();
      };
      RecyclePool.prototype.add = function add() {
        this._count >= this._data.length && this.resize(2 * this._data.length);
        return this._data[this._count++];
      };
      RecyclePool.prototype.remove = function remove(idx) {
        if (idx >= this._count) return;
        var last = this._count - 1;
        var tmp = this._data[idx];
        this._data[idx] = this._data[last];
        this._data[last] = tmp;
        this._count -= 1;
      };
      RecyclePool.prototype.sort = function sort(cmp) {
        return (0, _timsort2.default)(this._data, 0, this._count, cmp);
      };
      _createClass(RecyclePool, [ {
        key: "length",
        get: function get() {
          return this._count;
        }
      }, {
        key: "data",
        get: function get() {
          return this._data;
        }
      } ]);
      return RecyclePool;
    })();
    exports.default = RecyclePool;
    module.exports = exports["default"];
  }), {
    "./timsort": 249
  } ],
  249: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = function(array, lo, hi, compare) {
      if (!Array.isArray(array)) throw new TypeError("Can only sort arrays");
      void 0 === lo && (lo = 0);
      void 0 === hi && (hi = array.length);
      void 0 === compare && (compare = alphabeticalCompare);
      var remaining = hi - lo;
      if (remaining < 2) return;
      var runLength = 0;
      if (remaining < DEFAULT_MIN_MERGE) {
        runLength = makeAscendingRun(array, lo, hi, compare);
        binaryInsertionSort(array, lo, hi, lo + runLength, compare);
        return;
      }
      var ts = new TimSort(array, compare);
      var minRun = minRunLength(remaining);
      do {
        runLength = makeAscendingRun(array, lo, hi, compare);
        if (runLength < minRun) {
          var force = remaining;
          force > minRun && (force = minRun);
          binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
          runLength = force;
        }
        ts.pushRun(lo, runLength);
        ts.mergeRuns();
        remaining -= runLength;
        lo += runLength;
      } while (0 !== remaining);
      ts.forceMergeRuns();
    };
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var DEFAULT_MIN_MERGE = 32;
    var DEFAULT_MIN_GALLOPING = 7;
    var DEFAULT_TMP_STORAGE_LENGTH = 256;
    var POWERS_OF_TEN = [ 1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9 ];
    function log10(x) {
      if (x < 1e5) {
        if (x < 100) return x < 10 ? 0 : 1;
        if (x < 1e4) return x < 1e3 ? 2 : 3;
        return 4;
      }
      if (x < 1e7) return x < 1e6 ? 5 : 6;
      if (x < 1e9) return x < 1e8 ? 7 : 8;
      return 9;
    }
    function alphabeticalCompare(a, b) {
      if (a === b) return 0;
      if (~~a === a && ~~b === b) {
        if (0 === a || 0 === b) return a < b ? -1 : 1;
        if (a < 0 || b < 0) {
          if (b >= 0) return -1;
          if (a >= 0) return 1;
          a = -a;
          b = -b;
        }
        var al = log10(a);
        var bl = log10(b);
        var t = 0;
        if (al < bl) {
          a *= POWERS_OF_TEN[bl - al - 1];
          b /= 10;
          t = -1;
        } else if (al > bl) {
          b *= POWERS_OF_TEN[al - bl - 1];
          a /= 10;
          t = 1;
        }
        if (a === b) return t;
        return a < b ? -1 : 1;
      }
      var aStr = String(a);
      var bStr = String(b);
      if (aStr === bStr) return 0;
      return aStr < bStr ? -1 : 1;
    }
    function minRunLength(n) {
      var r = 0;
      while (n >= DEFAULT_MIN_MERGE) {
        r |= 1 & n;
        n >>= 1;
      }
      return n + r;
    }
    function makeAscendingRun(array, lo, hi, compare) {
      var runHi = lo + 1;
      if (runHi === hi) return 1;
      if (compare(array[runHi++], array[lo]) < 0) {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) runHi++;
        reverseRun(array, lo, runHi);
      } else while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) runHi++;
      return runHi - lo;
    }
    function reverseRun(array, lo, hi) {
      hi--;
      while (lo < hi) {
        var t = array[lo];
        array[lo++] = array[hi];
        array[hi--] = t;
      }
    }
    function binaryInsertionSort(array, lo, hi, start, compare) {
      start === lo && start++;
      for (;start < hi; start++) {
        var pivot = array[start];
        var left = lo;
        var right = start;
        while (left < right) {
          var mid = left + right >>> 1;
          compare(pivot, array[mid]) < 0 ? right = mid : left = mid + 1;
        }
        var n = start - left;
        switch (n) {
         case 3:
          array[left + 3] = array[left + 2];

         case 2:
          array[left + 2] = array[left + 1];

         case 1:
          array[left + 1] = array[left];
          break;

         default:
          while (n > 0) {
            array[left + n] = array[left + n - 1];
            n--;
          }
        }
        array[left] = pivot;
      }
    }
    function gallopLeft(value, array, start, length, hint, compare) {
      var lastOffset = 0;
      var maxOffset = 0;
      var offset = 1;
      if (compare(value, array[start + hint]) > 0) {
        maxOffset = length - hint;
        while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
          lastOffset = offset;
          offset = 1 + (offset << 1);
          offset <= 0 && (offset = maxOffset);
        }
        offset > maxOffset && (offset = maxOffset);
        lastOffset += hint;
        offset += hint;
      } else {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
          lastOffset = offset;
          offset = 1 + (offset << 1);
          offset <= 0 && (offset = maxOffset);
        }
        offset > maxOffset && (offset = maxOffset);
        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      }
      lastOffset++;
      while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);
        compare(value, array[start + m]) > 0 ? lastOffset = m + 1 : offset = m;
      }
      return offset;
    }
    function gallopRight(value, array, start, length, hint, compare) {
      var lastOffset = 0;
      var maxOffset = 0;
      var offset = 1;
      if (compare(value, array[start + hint]) < 0) {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
          lastOffset = offset;
          offset = 1 + (offset << 1);
          offset <= 0 && (offset = maxOffset);
        }
        offset > maxOffset && (offset = maxOffset);
        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      } else {
        maxOffset = length - hint;
        while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
          lastOffset = offset;
          offset = 1 + (offset << 1);
          offset <= 0 && (offset = maxOffset);
        }
        offset > maxOffset && (offset = maxOffset);
        lastOffset += hint;
        offset += hint;
      }
      lastOffset++;
      while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);
        compare(value, array[start + m]) < 0 ? offset = m : lastOffset = m + 1;
      }
      return offset;
    }
    var TimSort = (function() {
      function TimSort(array, compare) {
        _classCallCheck(this, TimSort);
        this.array = array;
        this.compare = compare;
        this.minGallop = DEFAULT_MIN_GALLOPING;
        this.length = array.length;
        this.tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
        this.length < 2 * DEFAULT_TMP_STORAGE_LENGTH && (this.tmpStorageLength = this.length >>> 1);
        this.tmp = new Array(this.tmpStorageLength);
        this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40;
        this.runStart = new Array(this.stackLength);
        this.runLength = new Array(this.stackLength);
        this.stackSize = 0;
      }
      TimSort.prototype.pushRun = function pushRun(runStart, runLength) {
        this.runStart[this.stackSize] = runStart;
        this.runLength[this.stackSize] = runLength;
        this.stackSize += 1;
      };
      TimSort.prototype.mergeRuns = function mergeRuns() {
        while (this.stackSize > 1) {
          var n = this.stackSize - 2;
          if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) this.runLength[n - 1] < this.runLength[n + 1] && n--; else if (this.runLength[n] > this.runLength[n + 1]) break;
          this.mergeAt(n);
        }
      };
      TimSort.prototype.forceMergeRuns = function forceMergeRuns() {
        while (this.stackSize > 1) {
          var n = this.stackSize - 2;
          n > 0 && this.runLength[n - 1] < this.runLength[n + 1] && n--;
          this.mergeAt(n);
        }
      };
      TimSort.prototype.mergeAt = function mergeAt(i) {
        var compare = this.compare;
        var array = this.array;
        var start1 = this.runStart[i];
        var length1 = this.runLength[i];
        var start2 = this.runStart[i + 1];
        var length2 = this.runLength[i + 1];
        this.runLength[i] = length1 + length2;
        if (i === this.stackSize - 3) {
          this.runStart[i + 1] = this.runStart[i + 2];
          this.runLength[i + 1] = this.runLength[i + 2];
        }
        this.stackSize--;
        var k = gallopRight(array[start2], array, start1, length1, 0, compare);
        start1 += k;
        length1 -= k;
        if (0 === length1) return;
        length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
        if (0 === length2) return;
        length1 <= length2 ? this.mergeLow(start1, length1, start2, length2) : this.mergeHigh(start1, length1, start2, length2);
      };
      TimSort.prototype.mergeLow = function mergeLow(start1, length1, start2, length2) {
        var compare = this.compare;
        var array = this.array;
        var tmp = this.tmp;
        var i = 0;
        for (i = 0; i < length1; i++) tmp[i] = array[start1 + i];
        var cursor1 = 0;
        var cursor2 = start2;
        var dest = start1;
        array[dest++] = array[cursor2++];
        if (0 === --length2) {
          for (i = 0; i < length1; i++) array[dest + i] = tmp[cursor1 + i];
          return;
        }
        if (1 === length1) {
          for (i = 0; i < length2; i++) array[dest + i] = array[cursor2 + i];
          array[dest + length2] = tmp[cursor1];
          return;
        }
        var minGallop = this.minGallop;
        while (true) {
          var count1 = 0;
          var count2 = 0;
          var exit = false;
          do {
            if (compare(array[cursor2], tmp[cursor1]) < 0) {
              array[dest++] = array[cursor2++];
              count2++;
              count1 = 0;
              if (0 === --length2) {
                exit = true;
                break;
              }
            } else {
              array[dest++] = tmp[cursor1++];
              count1++;
              count2 = 0;
              if (1 === --length1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < minGallop);
          if (exit) break;
          do {
            count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
            if (0 !== count1) {
              for (i = 0; i < count1; i++) array[dest + i] = tmp[cursor1 + i];
              dest += count1;
              cursor1 += count1;
              length1 -= count1;
              if (length1 <= 1) {
                exit = true;
                break;
              }
            }
            array[dest++] = array[cursor2++];
            if (0 === --length2) {
              exit = true;
              break;
            }
            count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
            if (0 !== count2) {
              for (i = 0; i < count2; i++) array[dest + i] = array[cursor2 + i];
              dest += count2;
              cursor2 += count2;
              length2 -= count2;
              if (0 === length2) {
                exit = true;
                break;
              }
            }
            array[dest++] = tmp[cursor1++];
            if (1 === --length1) {
              exit = true;
              break;
            }
            minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
          if (exit) break;
          minGallop < 0 && (minGallop = 0);
          minGallop += 2;
        }
        this.minGallop = minGallop;
        minGallop < 1 && (this.minGallop = 1);
        if (1 === length1) {
          for (i = 0; i < length2; i++) array[dest + i] = array[cursor2 + i];
          array[dest + length2] = tmp[cursor1];
        } else {
          if (0 === length1) throw new Error("mergeLow preconditions were not respected");
          for (i = 0; i < length1; i++) array[dest + i] = tmp[cursor1 + i];
        }
      };
      TimSort.prototype.mergeHigh = function mergeHigh(start1, length1, start2, length2) {
        var compare = this.compare;
        var array = this.array;
        var tmp = this.tmp;
        var i = 0;
        for (i = 0; i < length2; i++) tmp[i] = array[start2 + i];
        var cursor1 = start1 + length1 - 1;
        var cursor2 = length2 - 1;
        var dest = start2 + length2 - 1;
        var customCursor = 0;
        var customDest = 0;
        array[dest--] = array[cursor1--];
        if (0 === --length1) {
          customCursor = dest - (length2 - 1);
          for (i = 0; i < length2; i++) array[customCursor + i] = tmp[i];
          return;
        }
        if (1 === length2) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = length1 - 1; i >= 0; i--) array[customDest + i] = array[customCursor + i];
          array[dest] = tmp[cursor2];
          return;
        }
        var minGallop = this.minGallop;
        while (true) {
          var count1 = 0;
          var count2 = 0;
          var exit = false;
          do {
            if (compare(tmp[cursor2], array[cursor1]) < 0) {
              array[dest--] = array[cursor1--];
              count1++;
              count2 = 0;
              if (0 === --length1) {
                exit = true;
                break;
              }
            } else {
              array[dest--] = tmp[cursor2--];
              count2++;
              count1 = 0;
              if (1 === --length2) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < minGallop);
          if (exit) break;
          do {
            count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
            if (0 !== count1) {
              dest -= count1;
              cursor1 -= count1;
              length1 -= count1;
              customDest = dest + 1;
              customCursor = cursor1 + 1;
              for (i = count1 - 1; i >= 0; i--) array[customDest + i] = array[customCursor + i];
              if (0 === length1) {
                exit = true;
                break;
              }
            }
            array[dest--] = tmp[cursor2--];
            if (1 === --length2) {
              exit = true;
              break;
            }
            count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
            if (0 !== count2) {
              dest -= count2;
              cursor2 -= count2;
              length2 -= count2;
              customDest = dest + 1;
              customCursor = cursor2 + 1;
              for (i = 0; i < count2; i++) array[customDest + i] = tmp[customCursor + i];
              if (length2 <= 1) {
                exit = true;
                break;
              }
            }
            array[dest--] = array[cursor1--];
            if (0 === --length1) {
              exit = true;
              break;
            }
            minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
          if (exit) break;
          minGallop < 0 && (minGallop = 0);
          minGallop += 2;
        }
        this.minGallop = minGallop;
        minGallop < 1 && (this.minGallop = 1);
        if (1 === length2) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = length1 - 1; i >= 0; i--) array[customDest + i] = array[customCursor + i];
          array[dest] = tmp[cursor2];
        } else {
          if (0 === length2) throw new Error("mergeHigh preconditions were not respected");
          customCursor = dest - (length2 - 1);
          for (i = 0; i < length2; i++) array[customCursor + i] = tmp[i];
        }
      };
      return TimSort;
    })();
    module.exports = exports["default"];
  }), {} ],
  250: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _bufferPools = Array(8);
    for (var i = 0; i < 8; ++i) _bufferPools[i] = [];
    function _nextPow16(v) {
      for (var _i = 16; _i <= 1 << 28; _i *= 16) if (v <= _i) return _i;
      return 0;
    }
    function _log2(v) {
      var r = void 0, shift = void 0;
      r = (v > 65535) << 4;
      v >>>= r;
      shift = (v > 255) << 3;
      v >>>= shift;
      r |= shift;
      shift = (v > 15) << 2;
      v >>>= shift;
      r |= shift;
      shift = (v > 3) << 1;
      v >>>= shift;
      r |= shift;
      return r | v >> 1;
    }
    function _alloc(n) {
      var sz = _nextPow16(n);
      var bin = _bufferPools[_log2(sz) >> 2];
      if (bin.length > 0) return bin.pop();
      return new ArrayBuffer(sz);
    }
    function _free(buf) {
      _bufferPools[_log2(buf.byteLength) >> 2].push(buf);
    }
    exports.default = {
      alloc_int8: function alloc_int8(n) {
        var result = new Int8Array(_alloc(n), 0, n);
        if (result.length !== n) return result.subarray(0, n);
        return result;
      },
      alloc_uint8: function alloc_uint8(n) {
        var result = new Uint8Array(_alloc(n), 0, n);
        if (result.length !== n) return result.subarray(0, n);
        return result;
      },
      alloc_int16: function alloc_int16(n) {
        var result = new Int16Array(_alloc(2 * n), 0, n);
        if (result.length !== n) return result.subarray(0, n);
        return result;
      },
      alloc_uint16: function alloc_uint16(n) {
        var result = new Uint16Array(_alloc(2 * n), 0, n);
        if (result.length !== n) return result.subarray(0, n);
        return result;
      },
      alloc_int32: function alloc_int32(n) {
        var result = new Int32Array(_alloc(4 * n), 0, n);
        if (result.length !== n) return result.subarray(0, n);
        return result;
      },
      alloc_uint32: function alloc_uint32(n) {
        var result = new Uint32Array(_alloc(4 * n), 0, n);
        if (result.length !== n) return result.subarray(0, n);
        return result;
      },
      alloc_float32: function alloc_float32(n) {
        var result = new Float32Array(_alloc(4 * n), 0, n);
        if (result.length !== n) return result.subarray(0, n);
        return result;
      },
      alloc_float64: function alloc_float64(n) {
        var result = new Float64Array(_alloc(8 * n), 0, n);
        if (result.length !== n) return result.subarray(0, n);
        return result;
      },
      alloc_dataview: function alloc_dataview(n) {
        var result = new DataView(_alloc(n), 0, n);
        if (result.length !== n) return result.subarray(0, n);
        return result;
      },
      free: function free(array) {
        _free(array.buffer);
      },
      reset: function reset() {
        var _bufferPools = Array(8);
        for (var _i2 = 0; _i2 < 8; ++_i2) _bufferPools[_i2] = [];
      }
    };
    module.exports = exports["default"];
  }), {} ],
  251: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var BaseRenderData = function BaseRenderData() {
      _classCallCheck(this, BaseRenderData);
      this.material = null;
      this.vertexCount = 0;
      this.indiceCount = 0;
    };
    exports.default = BaseRenderData;
    module.exports = exports["default"];
  }), {} ],
  252: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          "value" in descriptor && (descriptor.writable = true);
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        protoProps && defineProperties(Constructor.prototype, protoProps);
        staticProps && defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _baseRenderData = require("./base-render-data");
    var _baseRenderData2 = _interopRequireDefault(_baseRenderData);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !call || "object" !== typeof call && "function" !== typeof call ? self : call;
    }
    function _inherits(subClass, superClass) {
      if ("function" !== typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
    }
    var IARenderData = (function(_BaseRenderData) {
      _inherits(IARenderData, _BaseRenderData);
      function IARenderData() {
        _classCallCheck(this, IARenderData);
        var _this = _possibleConstructorReturn(this, _BaseRenderData.call(this));
        _this.ia = null;
        return _this;
      }
      _createClass(IARenderData, [ {
        key: "type",
        get: function get() {
          return IARenderData.type;
        }
      } ]);
      return IARenderData;
    })(_baseRenderData2.default);
    exports.default = IARenderData;
    IARenderData.type = "IARenderData";
    cc.IARenderData = IARenderData;
    module.exports = exports["default"];
  }), {
    "./base-render-data": 251
  } ],
  253: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          "value" in descriptor && (descriptor.writable = true);
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        protoProps && defineProperties(Constructor.prototype, protoProps);
        staticProps && defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _memop = require("../memop");
    var _baseRenderData = require("./base-render-data");
    var _baseRenderData2 = _interopRequireDefault(_baseRenderData);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !call || "object" !== typeof call && "function" !== typeof call ? self : call;
    }
    function _inherits(subClass, superClass) {
      if ("function" !== typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
    }
    var _pool;
    var _dataPool = new _memop.Pool(function() {
      return {
        x: 0,
        y: 0,
        z: 0,
        u: 0,
        v: 0,
        color: 0
      };
    }, 128);
    var RenderData = (function(_BaseRenderData) {
      _inherits(RenderData, _BaseRenderData);
      function RenderData() {
        _classCallCheck(this, RenderData);
        var _this = _possibleConstructorReturn(this, _BaseRenderData.call(this));
        _this._data = [];
        _this._indices = [];
        _this._pivotX = 0;
        _this._pivotY = 0;
        _this._width = 0;
        _this._height = 0;
        _this.uvDirty = true;
        _this.vertDirty = true;
        return _this;
      }
      RenderData.prototype.updateSizeNPivot = function updateSizeNPivot(width, height, pivotX, pivotY) {
        if (width !== this._width || height !== this._height || pivotX !== this._pivotX || pivotY !== this._pivotY) {
          this._width = width;
          this._height = height;
          this._pivotX = pivotX;
          this._pivotY = pivotY;
          this.vertDirty = true;
        }
      };
      RenderData.alloc = function alloc() {
        return _pool.alloc();
      };
      RenderData.free = function free(data) {
        if (data instanceof RenderData) {
          for (var i = data.length - 1; i > 0; i--) _dataPool.free(data._data[i]);
          data._data.length = 0;
          data._indices.length = 0;
          data.material = null;
          data.uvDirty = true;
          data.vertDirty = true;
          data.vertexCount = 0;
          data.indiceCount = 0;
          _pool.free(data);
        }
      };
      _createClass(RenderData, [ {
        key: "type",
        get: function get() {
          return RenderData.type;
        }
      }, {
        key: "dataLength",
        get: function get() {
          return this._data.length;
        },
        set: function set(length) {
          var data = this._data;
          if (data.length !== length) {
            for (var i = length; i < data.length; i++) _dataPool.free(data[i]);
            for (var _i = data.length; _i < length; _i++) data[_i] = _dataPool.alloc();
            data.length = length;
          }
        }
      } ]);
      return RenderData;
    })(_baseRenderData2.default);
    exports.default = RenderData;
    RenderData.type = "RenderData";
    _pool = new _memop.Pool(function() {
      return new RenderData();
    }, 32);
    module.exports = exports["default"];
  }), {
    "../memop": 245,
    "./base-render-data": 251
  } ],
  254: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _createClass = (function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          "value" in descriptor && (descriptor.writable = true);
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        protoProps && defineProperties(Constructor.prototype, protoProps);
        staticProps && defineProperties(Constructor, staticProps);
        return Constructor;
      };
    })();
    var _vmath = require("../../core/vmath");
    var _baseRenderer = require("../core/base-renderer");
    var _baseRenderer2 = _interopRequireDefault(_baseRenderer);
    var _enums = require("../enums");
    var _enums2 = _interopRequireDefault(_enums);
    var _memop = require("../memop");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !call || "object" !== typeof call && "function" !== typeof call ? self : call;
    }
    function _inherits(subClass, superClass) {
      if ("function" !== typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
    }
    var _a16_view = new Float32Array(16);
    var _a16_proj = new Float32Array(16);
    var _a16_viewProj = new Float32Array(16);
    var _a3_camPos = new Float32Array(3);
    var _a16_lightViewProj = new Float32Array(16);
    var _camPos = _vmath.vec3.create(0, 0, 0);
    var _camFwd = _vmath.vec3.create(0, 0, 0);
    var _v3_tmp1 = _vmath.vec3.create(0, 0, 0);
    var _float16_pool = new _memop.RecyclePool(function() {
      return new Float32Array(16);
    }, 8);
    var ForwardRenderer = (function(_BaseRenderer) {
      _inherits(ForwardRenderer, _BaseRenderer);
      function ForwardRenderer(device, builtin) {
        _classCallCheck(this, ForwardRenderer);
        var _this = _possibleConstructorReturn(this, _BaseRenderer.call(this, device, builtin));
        _this._directionalLights = [];
        _this._pointLights = [];
        _this._spotLights = [];
        _this._shadowLights = [];
        _this._sceneAmbient = new Float32Array([ 0, 0, 0 ]);
        _this._numLights = 0;
        _this._defines = {};
        _this._registerStage("shadowcast", _this._shadowStage.bind(_this));
        _this._registerStage("opaque", _this._opaqueStage.bind(_this));
        _this._registerStage("transparent", _this._transparentStage.bind(_this));
        return _this;
      }
      ForwardRenderer.prototype.render = function render(scene) {
        this.reset();
        this._updateLights(scene);
        var canvas = this._device._gl.canvas;
        for (var i = 0; i < scene._cameras.length; ++i) {
          var view = this._requestView();
          var width = canvas.width;
          var height = canvas.height;
          var camera = scene._cameras.data[i];
          camera.extractView(view, width, height);
        }
        this._viewPools.sort((function(a, b) {
          return a._priority - b._priority;
        }));
        for (var _i = 0; _i < this._viewPools.length; ++_i) {
          var _view = this._viewPools.data[_i];
          this._render(_view, scene);
        }
      };
      ForwardRenderer.prototype.renderCamera = function renderCamera(camera, scene) {
        this.reset();
        var canvas = this._device._gl.canvas;
        var width = canvas.width;
        var height = canvas.height;
        var view = this._requestView();
        camera.extractView(view, width, height);
        this._render(view, scene);
      };
      ForwardRenderer.prototype._updateLights = function _updateLights(scene) {
        this._directionalLights.length = 0;
        this._pointLights.length = 0;
        this._spotLights.length = 0;
        this._shadowLights.length = 0;
        var lights = scene._lights;
        for (var i = 0; i < lights.length; ++i) {
          var light = lights.data[i];
          light.update(this._device);
          if (light.shadowType !== _enums2.default.SHADOW_NONE) {
            this._shadowLights.push(light);
            var view = this._requestView();
            light.extractView(view, [ "shadowcast" ]);
          }
          light._type === _enums2.default.LIGHT_DIRECTIONAL ? this._directionalLights.push(light) : light._type === _enums2.default.LIGHT_POINT ? this._pointLights.push(light) : this._spotLights.push(light);
        }
        this._updateDefines();
        this._numLights = lights._count;
      };
      ForwardRenderer.prototype._updateDefines = function _updateDefines() {
        var defines = this._defines;
        defines._NUM_DIR_LIGHTS = Math.min(4, this._directionalLights.length);
        defines._NUM_POINT_LIGHTS = Math.min(4, this._pointLights.length);
        defines._NUM_SPOT_LIGHTS = Math.min(4, this._spotLights.length);
        defines._NUM_SHADOW_LIGHTS = Math.min(4, this._shadowLights.length);
      };
      ForwardRenderer.prototype._submitLightsUniforms = function _submitLightsUniforms() {
        var device = this._device;
        device.setUniform("cc_sceneAmbient", this._sceneAmbient);
        _float16_pool.reset();
        if (this._directionalLights.length > 0) {
          var directions = _float16_pool.add();
          var colors = _float16_pool.add();
          for (var i = 0; i < this._directionalLights.length; ++i) {
            var light = this._directionalLights[i];
            var index = 4 * i;
            directions.set(light._directionUniform, index);
            colors.set(light._colorUniform, index);
          }
          device.setUniform("cc_dirLightDirection", directions);
          device.setUniform("cc_dirLightColor", colors);
        }
        if (this._pointLights.length > 0) {
          var positionAndRanges = _float16_pool.add();
          var _colors = _float16_pool.add();
          for (var _i2 = 0; _i2 < this._pointLights.length; ++_i2) {
            var _light = this._pointLights[_i2];
            var _index = 4 * _i2;
            positionAndRanges.set(_light._positionUniform, _index);
            positionAndRanges[_index + 3] = _light._range;
            _colors.set(_light._colorUniform, _index);
          }
          device.setUniform("cc_pointLightPositionAndRange", positionAndRanges);
          device.setUniform("cc_pointLightColor", _colors);
        }
        if (this._spotLights.length > 0) {
          var _positionAndRanges = _float16_pool.add();
          var _directions = _float16_pool.add();
          var _colors2 = _float16_pool.add();
          for (var _i3 = 0; _i3 < this._spotLights.length; ++_i3) {
            var _light2 = this._spotLights[_i3];
            var _index2 = 4 * _i3;
            _positionAndRanges.set(_light2._positionUniform, _index2);
            _positionAndRanges[_index2 + 3] = _light2._range;
            _directions.set(_light2._directionUniform, _index2);
            _directions[_index2 + 3] = _light2._spotUniform[0];
            _colors2.set(_light2._colorUniform, _index2);
            _colors2[_index2 + 3] = _light2._spotUniform[1];
          }
          device.setUniform("cc_spotLightPositionAndRange", _positionAndRanges);
          device.setUniform("cc_spotLightDirection", _directions);
          device.setUniform("cc_spotLightColor", _colors2);
        }
      };
      ForwardRenderer.prototype._submitShadowStageUniforms = function _submitShadowStageUniforms(view) {
        var light = view._shadowLight;
        this._device.setUniform("cc_minDepth", light.shadowMinDepth);
        this._device.setUniform("cc_maxDepth", light.shadowMaxDepth);
        this._device.setUniform("cc_bias", light.shadowBias);
        this._device.setUniform("cc_depthScale", light.shadowDepthScale);
      };
      ForwardRenderer.prototype._submitOtherStagesUniforms = function _submitOtherStagesUniforms() {
        for (var index = 0; index < this._shadowLights.length; ++index) {
          var light = this._shadowLights[index];
          this._device.setUniform("cc_lightViewProjMatrix_" + index, _vmath.mat4.array(_a16_lightViewProj, light.viewProjMatrix));
          this._device.setUniform("cc_minDepth_" + index, light.shadowMinDepth);
          this._device.setUniform("cc_maxDepth_" + index, light.shadowMaxDepth);
          this._device.setUniform("cc_bias_" + index, light.shadowBias);
          this._device.setUniform("cc_depthScale_" + index, light.shadowDepthScale);
          this._device.setUniform("cc_darkness_" + index, light.shadowDarkness);
          this._device.setUniform("cc_frustumEdgeFalloff_" + index, light.frustumEdgeFalloff);
        }
      };
      ForwardRenderer.prototype._updateShaderDefines = function _updateShaderDefines(item) {
        item.defines.push(this._defines);
      };
      ForwardRenderer.prototype._sortItems = function _sortItems(items) {
        items.sort((function(a, b) {
          var techA = a.technique;
          var techB = b.technique;
          if (techA._layer !== techB._layer) return techA._layer - techB._layer;
          if (techA._passes.length !== techB._passes.length) return techA._passes.length - techB._passes.length;
          return a.sortKey - b.sortKey;
        }));
      };
      ForwardRenderer.prototype._shadowStage = function _shadowStage(view, items) {
        this._device.setUniform("cc_lightViewProjMatrix", _vmath.mat4.array(_a16_viewProj, view._matViewProj));
        this._submitShadowStageUniforms(view);
        for (var i = 0; i < items.length; ++i) {
          var item = items.data[i];
          if (this._programLib._getValueFromDefineList("_SHADOW_CASTING", item.defines)) {
            this._updateShaderDefines(item);
            this._draw(item);
          }
        }
      };
      ForwardRenderer.prototype._drawItems = function _drawItems(view, items) {
        var shadowLights = this._shadowLights;
        if (0 === shadowLights.length && 0 === this._numLights) for (var i = 0; i < items.length; ++i) {
          var item = items.data[i];
          this._draw(item);
        } else for (var _i4 = 0; _i4 < items.length; ++_i4) {
          var _item = items.data[_i4];
          for (var index = 0; index < shadowLights.length; ++index) {
            var light = shadowLights[index];
            this._device.setTexture("_shadowMap_" + index, light.shadowMap, this._allocTextureUnit());
          }
          this._updateShaderDefines(_item);
          this._draw(_item);
        }
      };
      ForwardRenderer.prototype._opaqueStage = function _opaqueStage(view, items) {
        view.getPosition(_camPos);
        this._device.setUniform("cc_matView", _vmath.mat4.array(_a16_view, view._matView));
        this._device.setUniform("cc_matpProj", _vmath.mat4.array(_a16_proj, view._matProj));
        this._device.setUniform("cc_matViewProj", _vmath.mat4.array(_a16_viewProj, view._matViewProj));
        this._device.setUniform("cc_cameraPos", _vmath.vec3.array(_a3_camPos, _camPos));
        this._submitLightsUniforms();
        this._submitOtherStagesUniforms();
        this._drawItems(view, items);
      };
      ForwardRenderer.prototype._transparentStage = function _transparentStage(view, items) {
        view.getPosition(_camPos);
        view.getForward(_camFwd);
        this._device.setUniform("cc_matView", _vmath.mat4.array(_a16_view, view._matView));
        this._device.setUniform("cc_matpProj", _vmath.mat4.array(_a16_proj, view._matProj));
        this._device.setUniform("cc_matViewProj", _vmath.mat4.array(_a16_viewProj, view._matViewProj));
        this._device.setUniform("cc_cameraPos", _vmath.vec3.array(_a3_camPos, _camPos));
        this._submitLightsUniforms();
        this._submitOtherStagesUniforms();
        for (var i = 0; i < items.length; ++i) {
          var item = items.data[i];
          item.node.getWorldPosition(_v3_tmp1);
          _vmath.vec3.sub(_v3_tmp1, _v3_tmp1, _camPos);
          item.sortKey = -_vmath.vec3.dot(_v3_tmp1, _camFwd);
        }
        this._sortItems(items);
        this._drawItems(view, items);
      };
      _createClass(ForwardRenderer, [ {
        key: "sceneAmbient",
        get: function get() {
          var ambient = this._sceneAmbient;
          return cc.color(255 * ambient.r, 255 * ambient.g, 255 * ambient.b, 255);
        },
        set: function set(val) {
          this._sceneAmbient[0] = val.r / 255;
          this._sceneAmbient[1] = val.g / 255;
          this._sceneAmbient[2] = val.b / 255;
        }
      } ]);
      return ForwardRenderer;
    })(_baseRenderer2.default);
    exports.default = ForwardRenderer;
    module.exports = exports["default"];
  }), {
    "../../core/vmath": 207,
    "../core/base-renderer": 221,
    "../enums": 228,
    "../memop": 245
  } ],
  255: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _vmath = require("../../core/vmath");
    var _geomUtils = require("../../core/geom-utils");
    var _geomUtils2 = _interopRequireDefault(_geomUtils);
    var _enums = require("../enums");
    var _enums2 = _interopRequireDefault(_enums);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var _tmp_v3 = _vmath.vec3.create();
    var _tmp2_v3 = _vmath.vec3.create();
    var _tmp_mat4 = _vmath.mat4.create();
    var _matView = _vmath.mat4.create();
    var _matProj = _vmath.mat4.create();
    var _matViewProj = _vmath.mat4.create();
    var _matInvViewProj = _vmath.mat4.create();
    var Camera = (function() {
      function Camera() {
        _classCallCheck(this, Camera);
        this._poolID = -1;
        this._node = null;
        this._projection = _enums2.default.PROJ_PERSPECTIVE;
        this._priority = 0;
        this._color = _vmath.color4.create(.2, .3, .47, 1);
        this._depth = 1;
        this._stencil = 0;
        this._clearFlags = _enums2.default.CLEAR_COLOR | _enums2.default.CLEAR_DEPTH;
        this._clearModel = null;
        this._stages = [];
        this._framebuffer = null;
        this._near = .01;
        this._far = 1e3;
        this._fov = Math.PI / 4;
        this._rect = {
          x: 0,
          y: 0,
          w: 1,
          h: 1
        };
        this._orthoHeight = 10;
        this._cullingMask = 4294967295;
      }
      Camera.prototype.getNode = function getNode() {
        return this._node;
      };
      Camera.prototype.setNode = function setNode(node) {
        this._node = node;
      };
      Camera.prototype.getType = function getType() {
        return this._projection;
      };
      Camera.prototype.setType = function setType(type) {
        this._projection = type;
      };
      Camera.prototype.getPriority = function getPriority() {
        return this._priority;
      };
      Camera.prototype.setPriority = function setPriority(priority) {
        this._priority = priority;
      };
      Camera.prototype.getOrthoHeight = function getOrthoHeight() {
        return this._orthoHeight;
      };
      Camera.prototype.setOrthoHeight = function setOrthoHeight(val) {
        this._orthoHeight = val;
      };
      Camera.prototype.getFov = function getFov() {
        return this._fov;
      };
      Camera.prototype.setFov = function setFov(fov) {
        this._fov = fov;
      };
      Camera.prototype.getNear = function getNear() {
        return this._near;
      };
      Camera.prototype.setNear = function setNear(near) {
        this._near = near;
      };
      Camera.prototype.getFar = function getFar() {
        return this._far;
      };
      Camera.prototype.setFar = function setFar(far) {
        this._far = far;
      };
      Camera.prototype.getColor = function getColor(out) {
        return _vmath.color4.copy(out, this._color);
      };
      Camera.prototype.setColor = function setColor(r, g, b, a) {
        _vmath.color4.set(this._color, r, g, b, a);
      };
      Camera.prototype.getDepth = function getDepth() {
        return this._depth;
      };
      Camera.prototype.setDepth = function setDepth(depth) {
        this._depth = depth;
      };
      Camera.prototype.getStencil = function getStencil() {
        return this._stencil;
      };
      Camera.prototype.setStencil = function setStencil(stencil) {
        this._stencil = stencil;
      };
      Camera.prototype.getClearFlags = function getClearFlags() {
        return this._clearFlags;
      };
      Camera.prototype.setClearFlags = function setClearFlags(flags) {
        this._clearFlags = flags;
      };
      Camera.prototype.getRect = function getRect(out) {
        out.x = this._rect.x;
        out.y = this._rect.y;
        out.w = this._rect.w;
        out.h = this._rect.h;
        return out;
      };
      Camera.prototype.setRect = function setRect(x, y, w, h) {
        this._rect.x = x;
        this._rect.y = y;
        this._rect.w = w;
        this._rect.h = h;
      };
      Camera.prototype.getStages = function getStages() {
        return this._stages;
      };
      Camera.prototype.setStages = function setStages(stages) {
        this._stages = stages;
      };
      Camera.prototype.getFramebuffer = function getFramebuffer() {
        return this._framebuffer;
      };
      Camera.prototype.setFramebuffer = function setFramebuffer(framebuffer) {
        this._framebuffer = framebuffer;
      };
      Camera.prototype._calcMatrices = function _calcMatrices(width, height) {
        this._node.getWorldRT(_matView);
        _vmath.mat4.invert(_matView, _matView);
        var aspect = width / height;
        if (this._projection === _enums2.default.PROJ_PERSPECTIVE) _vmath.mat4.perspective(_matProj, this._fov, aspect, this._near, this._far); else {
          var x = this._orthoHeight * aspect;
          var y = this._orthoHeight;
          _vmath.mat4.ortho(_matProj, -x, x, -y, y, this._near, this._far);
        }
        _vmath.mat4.mul(_matViewProj, _matProj, _matView);
        _vmath.mat4.invert(_matInvViewProj, _matViewProj);
      };
      Camera.prototype.extractView = function extractView(out, width, height) {
        if (this._framebuffer) {
          width = this._framebuffer._width;
          height = this._framebuffer._height;
        }
        out._priority = this._priority;
        out._rect.x = this._rect.x * width;
        out._rect.y = this._rect.y * height;
        out._rect.w = this._rect.w * width;
        out._rect.h = this._rect.h * height;
        this.getColor(out._color);
        out._depth = this._depth;
        out._stencil = this._stencil;
        out._clearFlags = this._clearFlags;
        out._clearModel = this._clearModel;
        out._stages = this._stages;
        out._framebuffer = this._framebuffer;
        this._calcMatrices(width, height);
        _vmath.mat4.copy(out._matView, _matView);
        _vmath.mat4.copy(out._matProj, _matProj);
        _vmath.mat4.copy(out._matViewProj, _matViewProj);
        _vmath.mat4.copy(out._matInvViewProj, _matInvViewProj);
        out._cullingMask = this._cullingMask;
      };
      Camera.prototype.screenPointToRay = function screenPointToRay(x, y, width, height, out) {
        if (!_geomUtils2.default) return out;
        out = out || _geomUtils2.default.Ray.create();
        this._calcMatrices(width, height);
        var cx = this._rect.x * width;
        var cy = this._rect.y * height;
        var cw = this._rect.w * width;
        var ch = this._rect.h * height;
        _vmath.vec3.set(_tmp2_v3, (x - cx) / cw * 2 - 1, (y - cy) / ch * 2 - 1, 1);
        _vmath.vec3.transformMat4(_tmp2_v3, _tmp2_v3, _matInvViewProj);
        if (this._projection === _enums2.default.PROJ_PERSPECTIVE) this._node.getWorldPosition(_tmp_v3); else {
          _vmath.vec3.set(_tmp_v3, (x - cx) / cw * 2 - 1, (y - cy) / ch * 2 - 1, -1);
          _vmath.vec3.transformMat4(_tmp_v3, _tmp_v3, _matInvViewProj);
        }
        return _geomUtils2.default.Ray.fromPoints(out, _tmp_v3, _tmp2_v3);
      };
      Camera.prototype.screenToWorld = function screenToWorld(out, screenPos, width, height) {
        this._calcMatrices(width, height);
        var cx = this._rect.x * width;
        var cy = this._rect.y * height;
        var cw = this._rect.w * width;
        var ch = this._rect.h * height;
        if (this._projection === _enums2.default.PROJ_PERSPECTIVE) {
          _vmath.vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, 1);
          _vmath.vec3.transformMat4(out, out, _matInvViewProj);
          this._node.getWorldPosition(_tmp_v3);
          _vmath.vec3.lerp(out, _tmp_v3, out, (0, _vmath.lerp)(this._near / this._far, 1, screenPos.z));
        } else {
          _vmath.vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, 2 * screenPos.z - 1);
          _vmath.vec3.transformMat4(out, out, _matInvViewProj);
        }
        return out;
      };
      Camera.prototype.worldToScreen = function worldToScreen(out, worldPos, width, height) {
        this._calcMatrices(width, height);
        var cx = this._rect.x * width;
        var cy = this._rect.y * height;
        var cw = this._rect.w * width;
        var ch = this._rect.h * height;
        _vmath.vec3.transformMat4(out, worldPos, _matViewProj);
        out.x = cx + .5 * (out.x + 1) * cw;
        out.y = cy + .5 * (out.y + 1) * ch;
        out.z = .5 * out.z + .5;
        return out;
      };
      Camera.prototype.worldMatrixToScreen = function worldMatrixToScreen(out, worldMatrix, width, height) {
        this._calcMatrices(width, height);
        _vmath.mat4.mul(out, _matViewProj, worldMatrix);
        var halfWidth = width / 2;
        var halfHeight = height / 2;
        _vmath.mat4.identity(_tmp_mat4);
        _vmath.mat4.translate(_tmp_mat4, _tmp_mat4, _vmath.vec3.set(_tmp_v3, halfWidth, halfHeight, 0));
        _vmath.mat4.scale(_tmp_mat4, _tmp_mat4, _vmath.vec3.set(_tmp_v3, halfWidth, halfHeight, 1));
        _vmath.mat4.mul(out, _tmp_mat4, out);
        return out;
      };
      return Camera;
    })();
    exports.default = Camera;
    module.exports = exports["default"];
  }), {
    "../../core/geom-utils": void 0,
    "../../core/vmath": 207,
    "../enums": 228
  } ],
  256: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var _geomUtils = require("../../core/geom-utils");
    var _geomUtils2 = _interopRequireDefault(_geomUtils);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var Model = (function() {
      function Model() {
        _classCallCheck(this, Model);
        this._type = "default";
        this._poolID = -1;
        this._node = null;
        this._inputAssembler = null;
        this._effect = null;
        this._viewID = -1;
        this._cameraID = -1;
        this._userKey = -1;
        this._castShadow = false;
        this._boundingShape = null;
        this._defines = [];
        this._uniforms = [];
      }
      Model.prototype._updateTransform = function _updateTransform() {
        if (!this._node._hasChanged || !this._boundingShape) return;
        this._node.updateWorldTransformFull();
        this._bsModelSpace.transform(this._node._mat, this._node._pos, this._node._rot, this._node._scale, this._boundingShape);
      };
      Model.prototype.createBoundingShape = function createBoundingShape(minPos, maxPos) {
        if (!_geomUtils2.default) return;
        if (!minPos || !maxPos) return;
        this._bsModelSpace = _geomUtils2.default.Aabb.fromPoints(_geomUtils2.default.Aabb.create(), minPos, maxPos);
        this._boundingShape = _geomUtils2.default.Aabb.clone(this._bsModelSpace);
      };
      Model.prototype.setNode = function setNode(node) {
        this._node = node;
      };
      Model.prototype.setInputAssembler = function setInputAssembler(ia) {
        this._inputAssembler = ia;
      };
      Model.prototype.setEffect = function setEffect(effect, customProperties) {
        this._effect = effect;
        var defines = this._defines;
        var uniforms = this._uniforms;
        defines.length = 0;
        uniforms.length = 0;
        if (effect) {
          defines.push(effect._defines);
          uniforms.push(effect._properties);
        }
        if (customProperties) {
          defines.push(customProperties._defines);
          uniforms.push(customProperties._properties);
        }
      };
      Model.prototype.setUserKey = function setUserKey(key) {
        this._userKey = key;
      };
      Model.prototype.extractDrawItem = function extractDrawItem(out) {
        out.model = this;
        out.node = this._node;
        out.ia = this._inputAssembler;
        out.effect = this._effect;
        out.defines = this._defines;
        out.dependencies = this._dependencies;
        out.uniforms = this._uniforms;
      };
      return Model;
    })();
    exports.default = Model;
    module.exports = exports["default"];
  }), {
    "../../core/geom-utils": void 0
  } ],
  257: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _memop = require("../memop");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
    }
    var Scene = (function() {
      function Scene(app) {
        _classCallCheck(this, Scene);
        this._lights = new _memop.FixedArray(16);
        this._models = new _memop.FixedArray(16);
        this._cameras = new _memop.FixedArray(16);
        this._debugCamera = null;
        this._app = app;
        this._views = [];
      }
      Scene.prototype._add = function _add(pool, item) {
        if (-1 !== item._poolID) return;
        pool.push(item);
        item._poolID = pool.length - 1;
      };
      Scene.prototype._remove = function _remove(pool, item) {
        if (-1 === item._poolID) return;
        pool.data[pool.length - 1]._poolID = item._poolID;
        pool.fastRemove(item._poolID);
        item._poolID = -1;
      };
      Scene.prototype.tick = function tick() {
        for (var i = 0; i < this._models.length; ++i) {
          var model = this._models.data[i];
          model._updateTransform();
        }
      };
      Scene.prototype.reset = function reset() {
        for (var i = 0; i < this._models.length; ++i) {
          var model = this._models.data[i];
          model._viewID = -1;
        }
      };
      Scene.prototype.setDebugCamera = function setDebugCamera(cam) {
        this._debugCamera = cam;
      };
      Scene.prototype.getCameraCount = function getCameraCount() {
        return this._cameras.length;
      };
      Scene.prototype.getCamera = function getCamera(idx) {
        return this._cameras.data[idx];
      };
      Scene.prototype.addCamera = function addCamera(camera) {
        this._add(this._cameras, camera);
      };
      Scene.prototype.removeCamera = function removeCamera(camera) {
        this._remove(this._cameras, camera);
      };
      Scene.prototype.getModelCount = function getModelCount() {
        return this._models.length;
      };
      Scene.prototype.getModel = function getModel(idx) {
        return this._models.data[idx];
      };
      Scene.prototype.addModel = function addModel(model) {
        this._add(this._models, model);
      };
      Scene.prototype.removeModel = function removeModel(model) {
        this._remove(this._models, model);
      };
      Scene.prototype.getLightCount = function getLightCount() {
        return this._lights.length;
      };
      Scene.prototype.getLight = function getLight(idx) {
        return this._lights.data[idx];
      };
      Scene.prototype.addLight = function addLight(light) {
        this._add(this._lights, light);
      };
      Scene.prototype.removeLight = function removeLight(light) {
        this._remove(this._lights, light);
      };
      Scene.prototype.addView = function addView(view) {
        -1 === this._views.indexOf(view) && this._views.push(view);
      };
      Scene.prototype.removeView = function removeView(view) {
        var idx = this._views.indexOf(view);
        -1 !== idx && this._views.splice(idx, 1);
      };
      return Scene;
    })();
    exports.default = Scene;
    module.exports = exports["default"];
  }), {
    "../memop": 245
  } ],
  258: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.ctor2enums = exports.enums2ctor = exports.ctor2default = void 0;
    var _ctor2default, _enums2ctor, _ctor2enums;
    var _enums = require("./enums");
    var _enums2 = _interopRequireDefault(_enums);
    var _valueTypes = require("../core/value-types");
    var _CCTexture2D = require("../core/assets/CCTexture2D");
    var _CCTexture2D2 = _interopRequireDefault(_CCTexture2D);
    var _texture2d = require("./gfx/texture-2d");
    var _texture2d2 = _interopRequireDefault(_texture2d);
    var _textureCube = require("./gfx/texture-cube");
    var _textureCube2 = _interopRequireDefault(_textureCube);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var CCObject = cc.Object;
    var ctor2default = exports.ctor2default = (_ctor2default = {}, _ctor2default[Number] = function(v) {
      return v || 0;
    }, _ctor2default[Boolean] = function(v) {
      return v || false;
    }, _ctor2default[_valueTypes.Vec2] = function(v) {
      return v ? cc.v2(v[0], v[1]) : cc.v2();
    }, _ctor2default[_valueTypes.Vec3] = function(v) {
      return v ? cc.v3(v[0], v[1], v[2]) : cc.v3();
    }, _ctor2default[_valueTypes.Vec4] = function(v) {
      return v ? cc.v4(v[0], v[1], v[2], v[3]) : cc.v4();
    }, _ctor2default[_valueTypes.Color] = function(v) {
      return v ? cc.color(255 * v[0], 255 * v[1], 255 * v[2], 255 * (v[3] || 1)) : cc.color();
    }, _ctor2default[_valueTypes.Mat4] = function(v) {
      return v ? cc.mat4(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9], v[10], v[11], v[12], v[13], v[14], v[15]) : cc.mat4();
    }, _ctor2default[_CCTexture2D2.default] = function() {
      return null;
    }, _ctor2default[CCObject] = function() {
      return null;
    }, _ctor2default);
    var enums2ctor = exports.enums2ctor = (_enums2ctor = {}, _enums2ctor[_enums2.default.PARAM_INT] = Number, 
    _enums2ctor[_enums2.default.PARAM_INT2] = _valueTypes.Vec2, _enums2ctor[_enums2.default.PARAM_INT3] = _valueTypes.Vec3, 
    _enums2ctor[_enums2.default.PARAM_INT4] = _valueTypes.Vec4, _enums2ctor[_enums2.default.PARAM_FLOAT] = Number, 
    _enums2ctor[_enums2.default.PARAM_FLOAT2] = _valueTypes.Vec2, _enums2ctor[_enums2.default.PARAM_FLOAT3] = _valueTypes.Vec3, 
    _enums2ctor[_enums2.default.PARAM_FLOAT4] = _valueTypes.Vec4, _enums2ctor[_enums2.default.PARAM_COLOR3] = _valueTypes.Color, 
    _enums2ctor[_enums2.default.PARAM_COLOR4] = _valueTypes.Color, _enums2ctor[_enums2.default.PARAM_MAT4] = _valueTypes.Mat4, 
    _enums2ctor[_enums2.default.PARAM_TEXTURE_2D] = _CCTexture2D2.default, _enums2ctor.number = Number, 
    _enums2ctor.boolean = Boolean, _enums2ctor.default = CCObject, _enums2ctor);
    var ctor2enums = exports.ctor2enums = (_ctor2enums = {}, _ctor2enums[Number] = _enums2.default.PARAM_FLOAT, 
    _ctor2enums[_valueTypes.Vec2] = _enums2.default.PARAM_FLOAT2, _ctor2enums[_valueTypes.Vec3] = _enums2.default.PARAM_FLOAT3, 
    _ctor2enums[_valueTypes.Vec4] = _enums2.default.PARAM_FLOAT4, _ctor2enums[_valueTypes.Color] = _enums2.default.PARAM_COLOR3, 
    _ctor2enums[_valueTypes.Color] = _enums2.default.PARAM_COLOR4, _ctor2enums[_valueTypes.Mat4] = _enums2.default.PARAM_MAT4, 
    _ctor2enums[_CCTexture2D2.default] = _enums2.default.PARAM_TEXTURE_2D, _ctor2enums[_texture2d2.default] = _enums2.default.PARAM_TEXTURE_2D, 
    _ctor2enums);
  }), {
    "../core/assets/CCTexture2D": 27,
    "../core/value-types": 196,
    "./enums": 228,
    "./gfx/texture-2d": 238,
    "./gfx/texture-cube": 239
  } ],
  259: [ (function(require, module, exports) {
    "use strict";
    var TiledMapAsset = cc.Class({
      name: "cc.TiledMapAsset",
      extends: cc.Asset,
      properties: {
        tmxXmlStr: "",
        textures: {
          default: [],
          type: [ cc.Texture2D ]
        },
        textureNames: [ cc.String ],
        tsxFiles: [ cc.TextAsset ],
        tsxFileNames: [ cc.String ]
      },
      statics: {
        preventDeferredLoadDependents: true
      },
      createNode: false
    });
    cc.TiledMapAsset = TiledMapAsset;
    module.exports = TiledMapAsset;
  }), {} ],
  260: [ (function(require, module, exports) {
    "use strict";
    require("./cocos2d/core");
    require("./cocos2d/animation");
    false;
    require("./cocos2d/particle");
    require("./cocos2d/tilemap");
    require("./cocos2d/videoplayer/CCVideoPlayer");
    require("./cocos2d/webview/CCWebView");
    require("./cocos2d/core/components/CCStudioComponent");
    require("./extensions/ccpool/CCNodePool");
    require("./cocos2d/actions");
    require("./extensions/spine");
    require("./extensions/dragonbones");
    true;
    require("./cocos2d/deprecated");
  }), {
    "./cocos2d/actions": void 0,
    "./cocos2d/animation": void 0,
    "./cocos2d/core": 80,
    "./cocos2d/core/components/CCStudioComponent": void 0,
    "./cocos2d/deprecated": 217,
    "./cocos2d/particle": void 0,
    "./cocos2d/particle/CCParticleAsset": 219,
    "./cocos2d/tilemap": void 0,
    "./cocos2d/tilemap/CCTiledMapAsset": 259,
    "./cocos2d/videoplayer/CCVideoPlayer": void 0,
    "./cocos2d/webview/CCWebView": void 0,
    "./extensions/ccpool/CCNodePool": 261,
    "./extensions/dragonbones": void 0,
    "./extensions/spine": void 0
  } ],
  261: [ (function(require, module, exports) {
    "use strict";
    cc.NodePool = function(poolHandlerComp) {
      this.poolHandlerComp = poolHandlerComp;
      this._pool = [];
    };
    cc.NodePool.prototype = {
      constructor: cc.NodePool,
      size: function size() {
        return this._pool.length;
      },
      clear: function clear() {
        var count = this._pool.length;
        for (var i = 0; i < count; ++i) this._pool[i].destroy();
        this._pool.length = 0;
      },
      put: function put(obj) {
        if (obj && -1 === this._pool.indexOf(obj)) {
          obj.removeFromParent(false);
          var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
          handler && handler.unuse && handler.unuse();
          this._pool.push(obj);
        }
      },
      get: function get() {
        var last = this._pool.length - 1;
        if (last < 0) return null;
        var obj = this._pool[last];
        this._pool.length = last;
        var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
        handler && handler.reuse && handler.reuse.apply(handler, arguments);
        return obj;
      }
    };
    module.exports = cc.NodePool;
  }), {} ],
  262: [ (function(require, module, exports) {
    "use strict";
    var _global = "undefined" === typeof window ? global : window;
    _global.cc = _global.cc || {};
    _global._cc = _global._cc || {};
    require("./predefine");
    require("./polyfill/string");
    require("./polyfill/misc");
    require("./polyfill/array");
    require("./polyfill/object");
    require("./polyfill/array-buffer");
    require("./polyfill/number");
    true;
    require("./polyfill/typescript");
    require("./cocos2d/core/predefine");
    true;
    require("./cocos2d");
    require("./extends");
    false;
    module.exports = _global.cc;
  }), {
    "./cocos2d": 218,
    "./cocos2d/core/predefine": 129,
    "./extends": 260,
    "./package": void 0,
    "./polyfill/array": 264,
    "./polyfill/array-buffer": 263,
    "./polyfill/misc": 265,
    "./polyfill/number": 266,
    "./polyfill/object": 267,
    "./polyfill/string": 268,
    "./polyfill/typescript": void 0,
    "./predefine": 269
  } ],
  263: [ (function(require, module, exports) {
    "use strict";
    if (!ArrayBuffer.isView) {
      var ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;
      ArrayBuffer.isView = function(view) {
        return view instanceof ArrayBufferView;
      };
    }
  }), {} ],
  264: [ (function(require, module, exports) {
    "use strict";
    Array.isArray || (Array.isArray = function(arg) {
      return "[object Array]" === Object.prototype.toString.call(arg);
    });
    Array.prototype.find || (Array.prototype.find = function(callback) {
      var length = this.length;
      for (var i = 0; i < length; i++) {
        var element = this[i];
        if (callback.call(this, element, i, this)) return element;
      }
      return;
    });
  }), {} ],
  265: [ (function(require, module, exports) {
    "use strict";
    Math.sign || (Math.sign = function(x) {
      x = +x;
      if (0 === x || isNaN(x)) return x;
      return x > 0 ? 1 : -1;
    });
    Math.log2 || (Math.log2 = function(x) {
      return Math.log(x) * Math.LOG2E;
    });
    Number.isInteger || (Number.isInteger = function(value) {
      return "number" === typeof value && isFinite(value) && Math.floor(value) === value;
    });
    if ((false, false) || !console.time) {
      var Timer = window.performance || Date;
      var _timerTable = Object.create(null);
      console.time = function(label) {
        _timerTable[label] = Timer.now();
      };
      console.timeEnd = function(label) {
        var startTime = _timerTable[label];
        var duration = Timer.now() - startTime;
        console.log(label + ": " + duration + "ms");
      };
    }
  }), {} ],
  266: [ (function(require, module, exports) {
    "use strict";
    Number.parseFloat = Number.parseFloat || parseFloat;
    Number.parseInt = Number.parseInt || parseInt;
  }), {} ],
  267: [ (function(require, module, exports) {
    "use strict";
    Object.assign || (Object.assign = function(target, source) {
      return cc.js.mixin(target, source);
    });
    Object.getOwnPropertyDescriptors || (Object.getOwnPropertyDescriptors = function(obj) {
      var descriptors = {};
      var ownKeys = Object.getOwnPropertyNames(obj);
      Object.getOwnPropertySymbols && (ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(obj)));
      for (var i = 0; i < ownKeys.length; ++i) {
        var key = ownKeys[i];
        descriptors[key] = Object.getOwnPropertyDescriptor(obj, key);
      }
      return descriptors;
    });
  }), {} ],
  268: [ (function(require, module, exports) {
    "use strict";
    String.prototype.startsWith || (String.prototype.startsWith = function(searchString, position) {
      position = position || 0;
      return this.lastIndexOf(searchString, position) === position;
    });
    String.prototype.endsWith || (String.prototype.endsWith = function(searchString, position) {
      ("undefined" === typeof position || position > this.length) && (position = this.length);
      position -= searchString.length;
      var lastIndex = this.indexOf(searchString, position);
      return -1 !== lastIndex && lastIndex === position;
    });
  }), {} ],
  269: [ (function(require, module, exports) {
    "use strict";
    var _global = "undefined" === typeof window ? global : window;
    function defineMacro(name, defaultValue) {
      "undefined" === typeof _global[name] && (_global[name] = defaultValue);
    }
    function defined(name) {
      return "object" === typeof _global[name];
    }
    defineMacro("CC_BUILD", false);
    true;
    _global.CC_BUILD = true;
    _global.CC_TEST = false;
    _global.CC_EDITOR = false;
    _global.CC_PREVIEW = false;
    _global.CC_DEV = false;
    _global.CC_DEBUG = true;
    _global.CC_JSB = false;
    _global.CC_WECHATGAMESUB = false;
    _global.CC_WECHATGAME = false;
    _global.CC_QQPLAY = false;
    _global.CC_RUNTIME = false;
    _global.CC_SUPPORT_JIT = true;
    false;
    var engineVersion = "2.1.2";
    _global["CocosEngine"] = cc.ENGINE_VERSION = engineVersion;
  }), {} ]
}, {}, [ 262 ]);